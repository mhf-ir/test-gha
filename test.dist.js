(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/* eslint-disable import/no-extraneous-dependencies */
require('@formatjs/intl-locale/polyfill');
require('@formatjs/intl-displaynames/polyfill');
require('@formatjs/intl-displaynames/locale-data/en');
require('@formatjs/intl-getcanonicallocales');

const { Locale } = require('../lib/Locale');
const { Environment } = require('../lib/Environment');
const { Calendar } = require('../lib/Calendar');

const YEAR_OFFSET = 100;

const START_DATE = new Date();

if (Environment.test() === false) {
  // eslint-disable-next-line no-alert, no-undef
  alert(`Your browser not support Intl well.`);
}

const FORMAT_TOKENS = [
  'a',
  'c',
  'ccc',
  'cccc',
  'ccccc',
  'd',
  'D',
  'dd',
  'DD',
  'DDD',
  'DDDD',
  'E',
  'EEE',
  'EEEE',
  'EEEEE',
  'f',
  'F',
  'ff',
  'FF',
  'fff',
  'FFF',
  'ffff',
  'FFFF',
  'G',
  'GG',
  'GGGGG',
  'h',
  'H',
  'hh',
  'HH',
  'kk',
  'kkkk',
  'L',
  'LL',
  'LLL',
  'LLLL',
  'LLLLL',
  'm',
  'M',
  'mm',
  'MM',
  'MMM',
  'MMMM',
  'MMMMM',
  'o',
  'ooo',
  'q',
  'qq',
  'S',
  's',
  'ss',
  'SSS',
  't',
  'T',
  'tt',
  'TT',
  'ttt',
  'TTT',
  'tttt',
  'TTTT',
  'u',
  'W',
  'WW',
  'X',
  'x',
  'y',
  'yy',
  'yyyy',
  'Z',
  'z',
  'ZZ',
  'ZZZ',
  'ZZZZ',
  'ZZZZZ',
];

// eslint-disable-next-line no-new, no-undef
new Vue({
  el: '#app',
  data: {
    locale: new Locale('en-US'),
    supportable: Environment.test(),
    formats: [],
    lang: '',
    country: '',
    calendar: '',
    year: 0,
    month: START_DATE,
    heads: [],
    weeks: [],
    years: [],
    monthList: [],
  },
  mounted() {
    this.date = START_DATE;

    this.locale = new Locale('en-US');
    this.lang = this.locale.getLanguageCode();
    this.country = this.locale.getCountryCode();
    this.calendar = this.locale.getCalendar();

    this.calendarObject = new Calendar(this.date, this.locale);
    this.heads = this.calendarObject.dayWeekList().heads;
    this.weeks = this.calendarObject.dayWeekList().weeks;
    this.years = this.calendarObject.yearList(YEAR_OFFSET);
    this.year = this.years.find((y) => y.selected).id;
    this.monthList = this.calendarObject.monthList();
    this.month = this.monthList.find((m) => m.selected).id;
  },
  computed: {},
  methods: {
    setInputDate() {
      this.drawCalendar();
    },
    drawCalendar() {
      this.calendarObject = new Calendar(this.date, this.locale);
      this.heads = this.calendarObject.dayWeekList().heads;
      this.weeks = this.calendarObject.dayWeekList().weeks;
      this.years = this.calendarObject.yearList(YEAR_OFFSET);
      this.year = this.years.find((y) => y.selected).id;
      this.monthList = this.calendarObject.monthList();
      this.month = this.monthList.find((m) => m.selected).id;
      const formats = [];
      FORMAT_TOKENS.forEach((token) => {
        formats.push({
          token,
          string: this.calendarObject.format(token, this.date),
        });
      });
      this.formats = formats;
    },

    changeLang() {
      this.locale = new Locale(this.lang);
      this.lang = this.locale.getLanguageCode();
      this.country = this.locale.getCountryCode();
      this.calendar = this.locale.getCalendar();

      if (this.locale.isRTL()) {
        // eslint-disable-next-line no-undef
        document.querySelector('html').setAttribute('dir', 'rtl');
      } else {
        // eslint-disable-next-line no-undef
        document.querySelector('html').setAttribute('dir', 'ltr');
      }

      this.drawCalendar();
    },
    changeCountry() {
      this.locale.setCountry(this.country);
      this.drawCalendar();
    },
    changeCalendar() {
      this.locale.setCalendar(this.calendar);
      this.drawCalendar();
    },
    yearChange() {
      this.calendarObject.yearJump(this.year);
      this.date = this.calendarObject.getDate();
      this.drawCalendar();
    },
    monthChange() {
      this.date = this.month;
      this.drawCalendar();
    },
    yearShift(next = true) {
      this.date = this.calendarObject.yearShift(next).getDate();
      this.drawCalendar();
    },
    monthShift(next = true) {
      this.date = this.calendarObject.monthShift(next).getDate();
      this.drawCalendar();
    },
    dayShift(next = true) {
      this.date = this.calendarObject.dayShift(next).getDate();
      this.drawCalendar();
    },
  },
});

},{"../lib/Calendar":2,"../lib/Environment":3,"../lib/Locale":4,"@formatjs/intl-displaynames/locale-data/en":73,"@formatjs/intl-displaynames/polyfill":74,"@formatjs/intl-getcanonicallocales":76,"@formatjs/intl-locale/polyfill":84}],2:[function(require,module,exports){
const luxon = require('luxon');

const { Locale } = require('./Locale');

const groupBy = (items, key) =>
  items.reduce(
    (result, item) => ({
      ...result,
      [item[key]]: [...(result[item[key]] || []), item],
    }),
    {},
  );

class Calendar {
  constructor(date = new Date(), locale = new Locale('en')) {
    this.setLocale(locale);
    this.setDate(date);
  }

  /**
   * @returns {import('./Locale').Locale}
   */
  getLocale() {
    return this.locale;
  }

  /**
   * @param {import('./Locale').Locale} locale
   * @returns {Calendar}
   */
  setLocale(locale) {
    this.locale = locale;
    return this;
  }

  /**
   * @returns {Date}
   */
  getDate() {
    return this.date;
  }

  /**
   * @param {Date} date
   * @returns {Calendar}
   */
  setDate(date) {
    this.date = date;
    return this;
  }

  /**
   * @param {String} format
   * @param {Date} date
   * @return {String}
   */
  format(format, date = this.date) {
    return luxon.DateTime.fromJSDate(date)
      .reconfigure({
        locale: this.locale.toString(),
        outputCalendar: this.locale.getCalendar(),
      })
      .toFormat(format);
  }

  /**
   * @param {String[]} tokens
   * @param {Date} date
   * @returns {Number[]}
   */
  tokenize(tokens, date = this.date) {
    return luxon.DateTime.fromJSDate(date)
      .reconfigure({
        outputCalendar: this.locale.getCalendar(),
        locale: 'en-US',
        numberingSystem: 'latn',
      })
      .toFormat(tokens.join(' '))
      .split(' ')
      .map((p) => parseInt(p, 10));
  }

  /**
   * @param {Number} length
   * @returns {{id: Number, selected: Boolean, title: String}[]}
   */
  yearList(length = 10) {
    const [currentYear] = this.tokenize(['yyyy'], this.date);
    const result = [];
    for (let i = -length; i <= length; i += 1) {
      const id = currentYear + i;
      if (id >= 0) {
        result.push({
          id,
          selected: id === currentYear,
          title: this.locale.numberFormat(id),
        });
      }
    }
    return result;
  }

  /**
   * @param {Number} dayOffset
   * @param {Number} wantedYear
   * @param {Number} currentMonth
   * @param {Number} currentDay
   * @returns {Date|null}
   */
  yearOffsetSeek(dayOffset, wantedYear, currentMonth, currentDay) {
    const dt = luxon.DateTime.fromJSDate(this.date).plus({ day: dayOffset });
    const [iterateYear, iterateMonth, iterateDay] = this.tokenize(
      ['yyyy', 'M', 'd'],
      dt.toJSDate(),
    );
    if (
      iterateYear === wantedYear &&
      iterateMonth === currentMonth &&
      iterateDay === currentDay
    ) {
      return dt.toJSDate();
    }
    return null;
  }

  /**
   * @param {Number} wantedYear
   * @returns {Calendar}
   */
  yearJump(wantedYear) {
    const [currentYear, currentMonth, currentDay] = this.tokenize(
      ['yyyy', 'M', 'd'],
      this.date,
    );

    if (wantedYear === currentYear) {
      return this.date;
    }

    const offset = Math.abs(currentYear - wantedYear) * 373;

    if (wantedYear > currentYear) {
      for (let i = 0; i <= offset; i += 1) {
        const date = this.yearOffsetSeek(
          i,
          wantedYear,
          currentMonth,
          currentDay,
        );
        if (date) {
          return this.setDate(date);
        }
      }
    } else {
      for (let i = offset; i >= 0; i -= 1) {
        const date = this.yearOffsetSeek(
          -i,
          wantedYear,
          currentMonth,
          currentDay,
        );
        if (date) {
          return this.setDate(date);
        }
      }
    }

    /* istanbul ignore next */
    return this;
  }

  /**
   * @param {Boolean} next
   * @return {Locale}
   */
  yearShift(next = true) {
    const [currentYear] = this.tokenize(['yyyy'], this.date);
    return this.yearJump(next ? currentYear + 1 : currentYear - 1);
  }

  /**
   * @returns {{id: Date, selected: Boolean, title: String, titleNumber: String, titleInt: Number}[]}
   */
  monthList() {
    const [currentYear, currentMonth, currentDay] = this.tokenize(
      ['yyyy', 'M', 'd'],
      this.date,
    );
    const result = [];
    for (let i = -397; i <= 397; i += 1) {
      const dt = luxon.DateTime.fromJSDate(this.date).plus({ day: i });
      const [iterateYear, , iterateDay] = this.tokenize(
        ['yyyy', 'M', 'd'],
        dt.toJSDate(),
      );
      if (iterateYear === currentYear && currentDay === iterateDay) {
        const [titleInt] = this.tokenize(['M'], dt.toJSDate());

        const date = dt.toJSDate();

        result.push({
          id: date,
          selected: titleInt === currentMonth,
          title: this.format('MMMM', dt.toJSDate()),
          titleNumber: this.format('M', dt.toJSDate()),
          titleInt,
        });
      }
    }
    return result;
  }

  /**
   * @param {Boolean} next
   * @return {Locale}
   */
  // eslint-disable-next-line sonarjs/cognitive-complexity
  monthShift(next = true) {
    const [currentYear, currentMonth, currentDay] = this.tokenize(
      ['yyyy', 'M', 'd'],
      this.date,
    );
    // const desireMonth = up ? currentYear
    for (let i = -38; i <= 38; i += 1) {
      const dt = luxon.DateTime.fromJSDate(this.date).plus({ day: i });
      const date = dt.toJSDate();
      const [iterateYear, iterateMonth, iterateDay] = this.tokenize(
        ['yyyy', 'M', 'd'],
        date,
      );
      if (iterateDay !== currentDay) {
        // eslint-disable-next-line no-continue
        continue;
      }
      if (next) {
        if (iterateYear > currentYear) {
          return this.setDate(date);
        }
        if (iterateMonth > currentMonth) {
          return this.setDate(date);
        }
      } else {
        if (iterateYear < currentYear) {
          return this.setDate(date);
        }
        if (iterateMonth < currentMonth) {
          return this.setDate(date);
        }
      }
    }
    return this;
  }

  /**
   * @param {Boolean} next
   * @return {Locale}
   */
  dayShift(next = true) {
    const dt = luxon.DateTime.fromJSDate(this.date).plus({
      day: next ? 1 : -1,
    });
    return this.setDate(dt.toJSDate());
  }

  /**
   * @returns {{id: Date, weekDay: Number, selected: Boolean, title: String, titleInt: Number}[]}
   */
  dayList() {
    const [currentYear, currentMonth, currentDay] = this.tokenize(
      ['yyyy', 'M', 'd'],
      this.date,
    );
    const result = [];
    for (let i = -38; i <= 38; i += 1) {
      const dt = luxon.DateTime.fromJSDate(this.date).plus({ day: i });
      const [iterateYear, iterateMonth, iterateDay] = this.tokenize(
        ['yyyy', 'M', 'd'],
        dt.toJSDate(),
      );
      if (iterateYear === currentYear && currentMonth === iterateMonth) {
        const [titleInt] = this.tokenize(['d'], dt.toJSDate());

        const date = dt.toJSDate();

        const utcDay = new Date(date.getTime());
        utcDay.setUTCHours(12, 0, 0, 0);

        const localeDate = [
          iterateYear,
          iterateMonth.toString().padStart(2, '0'),
          iterateDay.toString().padStart(2, '0'),
        ].join('-');
        const localeTime = [
          date.getHours().toString().padStart(2, '0'),
          date.getMinutes().toString().padStart(2, '0'),
          date.getSeconds().toString().padStart(2, '0'),
        ].join('-');

        result.push({
          id: date,
          utcDay,
          localeDateTime: `${localeDate} ${localeTime}`,
          weekDay: date.getDay(),
          weekEnd: this.locale.getWeekEnds().includes(date.getDay()),
          selected: titleInt === currentDay,
          title: this.format('d', dt.toJSDate()),
          titleInt,
        });
      }
    }
    return result;
  }

  dayWeekList() {
    const dayList = this.dayList();
    const days = [];
    const weekDays = this.locale.getWeekDays();
    const [weekStartDay] = weekDays;
    const weekNames = {};
    let weekNumber = 0;
    dayList.forEach((day) => {
      if (!weekNames[day.weekDay]) {
        weekNames[day.weekDay] = {
          long: this.format('EEE', day.id),
          narrow: this.format('EEEEE', day.id),
        };
      }

      if (day.weekDay === weekStartDay) {
        weekNumber += 1;
      }

      days.push({
        id: day.id,
        utcDay: day.utcDay,
        localeDateTime: day.localeDateTime,
        weekDay: day.weekDay,
        weekEnd: day.weekEnd,
        selected: day.selected,
        title: day.title,
        titleInt: day.titleInt,
        weekNumber,
      });
    });

    const result = {
      heads: [],
      weeks: [],
    };

    weekDays.forEach((n) => {
      result.heads.push(weekNames[n]);
    });

    const weeksDayList = groupBy(days, 'weekNumber');

    Object.values(weeksDayList).forEach((weeks) => {
      const week = [false, false, false, false, false, false, false];
      weeks.forEach((day) => {
        const weekDayIndex = weekDays.indexOf(day.id.getDay());
        week.splice(weekDayIndex, 1, {
          id: day.id,
          utcDay: day.utcDay,
          localeDateTime: day.localeDateTime,
          weekDay: day.weekDay,
          weekEnd: day.weekEnd,
          selected: day.selected,
          title: day.title,
          titleInt: day.titleInt,
          weekNumber,
        });
      });
      result.weeks.push(week);
    });

    return result;
  }
}

module.exports = { Calendar };

},{"./Locale":4,"luxon":87}],3:[function(require,module,exports){
class Environment {
  /**
   * @static
   * @returns {Boolean}
   */
  static test() {
    return (
      typeof Intl !== 'undefined' &&
      typeof Intl.Collator !== 'undefined' &&
      typeof Intl.DateTimeFormat !== 'undefined' &&
      typeof Intl.DateTimeFormat.prototype.formatToParts !== 'undefined' &&
      typeof Intl.DateTimeFormat.prototype.resolvedOptions !== 'undefined' &&
      typeof Intl.NumberFormat !== 'undefined' &&
      typeof Intl.PluralRules !== 'undefined' &&
      typeof Intl.DisplayNames !== 'undefined' &&
      typeof Intl.ListFormat !== 'undefined' &&
      typeof Intl.Locale !== 'undefined' &&
      typeof Intl.getCanonicalLocales !== 'undefined' &&
      typeof Intl.RelativeTimeFormat !== 'undefined' &&
      new Intl.DisplayNames('en-US', { type: 'region' }).of('IR') === 'Iran' &&
      new Intl.DisplayNames('en-US', { type: 'language' }).of('fa') ===
        'Persian'
    );
  }
}

module.exports = { Environment };

},{}],4:[function(require,module,exports){
const luxon = require('luxon');

const countries = require('./countries');
const languages = require('./languages');

/** @type {CalendarSystem[]} */
const SupportedCalendars = [
  'gregory',
  'persian',
  'islamicc',
  'islamic',
  'buddhist',
  'coptic',
  'ethioaa',
  'ethiopic',
  'hebrew',
  'indian',
  'japanese',
  'roc',
];

/**
 * @typedef {'buddhist'|'coptic'|'ethioaa'|'ethiopic'|'gregory'|'hebrew'|'indian'|'islamic'|'islamicc'|'japanese'|'persian'|'roc'} CalendarSystem
 * @typedef {'arab'|'arabext'|'bali'|'beng'|'deva'|'fullwide'|'gujr'|'guru'|'hanidec'|'khmr'|'knda'|'laoo'|'latn'|'limb'|'mlym'|'mong'|'mymr'|'orya'|'tamldec'|'telu'|'thai'|'tibt'} NumericSystemType
 * @typedef {'AC'|'AD'|'AE'|'AF'|'AG'|'AI'|'AL'|'AM'|'AO'|'AR'|'AS'|'AT'|'AU'|'AW'|'AX'|'AZ'|'BA'|'BB'|'BD'|'BE'|'BF'|'BG'|'BH'|'BI'|'BJ'|'BL'|'BM'|'BN'|'BO'|'BQ'|'BR'|'BS'|'BT'|'BW'|'BY'|'BZ'|'CA'|'CC'|'CD'|'CF'|'CG'|'CH'|'CI'|'CK'|'CL'|'CM'|'CN'|'CO'|'CR'|'CU'|'CV'|'CW'|'CX'|'CY'|'CZ'|'DE'|'DG'|'DJ'|'DK'|'DM'|'DO'|'DZ'|'EA'|'EC'|'EE'|'EG'|'EH'|'ER'|'ES'|'ET'|'FI'|'FJ'|'FK'|'FM'|'FO'|'FR'|'GA'|'GB'|'GD'|'GE'|'GF'|'GG'|'GH'|'GI'|'GL'|'GM'|'GN'|'GP'|'GQ'|'GR'|'GT'|'GU'|'GW'|'GY'|'HK'|'HN'|'HR'|'HT'|'HU'|'IC'|'ID'|'IE'|'IL'|'IM'|'IN'|'IO'|'IQ'|'IR'|'IS'|'IT'|'JE'|'JM'|'JO'|'JP'|'KE'|'KG'|'KH'|'KI'|'KM'|'KN'|'KP'|'KR'|'KW'|'KY'|'KZ'|'LA'|'LB'|'LC'|'LI'|'LK'|'LR'|'LS'|'LT'|'LU'|'LV'|'LY'|'MA'|'MC'|'MD'|'ME'|'MF'|'MG'|'MH'|'MK'|'ML'|'MM'|'MN'|'MO'|'MP'|'MQ'|'MR'|'MS'|'MT'|'MU'|'MV'|'MW'|'MX'|'MY'|'MZ'|'NA'|'NC'|'NE'|'NF'|'NG'|'NI'|'NL'|'NO'|'NP'|'NR'|'NU'|'NZ'|'OM'|'PA'|'PE'|'PF'|'PG'|'PH'|'PK'|'PL'|'PM'|'PN'|'PR'|'PS'|'PT'|'PW'|'PY'|'QA'|'RE'|'RO'|'RS'|'RU'|'RW'|'SA'|'SB'|'SC'|'SD'|'SE'|'SG'|'SH'|'SI'|'SJ'|'SK'|'SL'|'SM'|'SN'|'SO'|'SR'|'SS'|'ST'|'SV'|'SX'|'SY'|'SZ'|'TA'|'TC'|'TD'|'TF'|'TG'|'TH'|'TJ'|'TK'|'TL'|'TM'|'TN'|'TO'|'TR'|'TT'|'TV'|'TW'|'TZ'|'UA'|'UG'|'UM'|'US'|'UY'|'UZ'|'VA'|'VC'|'VE'|'VG'|'VI'|'VN'|'VU'|'WF'|'WS'|'XK'|'YE'|'YT'|'ZA'|'ZM'|'ZW'} CountryISOCode
 * @typedef {'aa'|'af'|'ar'|'az'|'be'|'bg'|'bi'|'bm'|'bn'|'bs'|'ca'|'cs'|'da'|'de'|'dv'|'dz'|'el'|'en'|'es'|'et'|'fa'|'fi'|'fo'|'fr'|'gn'|'ha'|'he'|'hi'|'hr'|'ht'|'hu'|'hy'|'id'|'is'|'it'|'ja'|'ka'|'kl'|'km'|'ko'|'ky'|'lo'|'lt'|'lv'|'mg'|'mk'|'mn'|'ms'|'mt'|'my'|'nb'|'ne'|'nl'|'pl'|'pt'|'rn'|'ro'|'ru'|'rw'|'si'|'sk'|'sl'|'sm'|'sn'|'so'|'sq'|'sr'|'st'|'sv'|'sw'|'tg'|'th'|'ti'|'tk'|'to'|'tr'|'ur'|'uz'|'vi'|'wo'|'zh'} LanguageISOCode
 */

class Locale {
  /**
   * @param {String} formatted
   * @param {String} ident
   * @returns {String}
   */
  static calendarName(formatted, ident) {
    const camelCase = ident.charAt(0).toUpperCase() + ident.slice(1);
    if (formatted.match(/^ERA/) || formatted === 'null') {
      return camelCase;
    }
    if (ident === 'islamicc') {
      return `${formatted}(c)`;
    }
    return formatted;
  }

  /**
   * @param {String} locale
   */
  constructor(locale) {
    const iLocale = new Intl.Locale(Intl.getCanonicalLocales(locale));
    const country = iLocale.maximize().region;
    this.language = iLocale.maximize().language;
    this.setCountry(country);
    this.numberingSystem = new Intl.NumberFormat(
      this.toString(),
    ).resolvedOptions().numberingSystem;
  }

  /**
   * @returns {String}
   */
  toString() {
    return `${this.language}-${this.country}`;
  }

  /**
   * @returns {LanguageISOCode}
   */
  getLanguageCode() {
    return this.language;
  }

  /**
   * @returns {CountryISOCode}
   */
  getCountryCode() {
    return this.country;
  }

  /**
   * @returns {String}
   */
  getCountryFlag() {
    return this.flag;
  }

  /**
   * @returns {Calendar}
   */
  getCalendar() {
    return this.calendar;
  }

  /**
   * @returns {Boolean}
   */
  isRTL(lang = this.language) {
    return ['ar', 'dv', 'fa', 'he', 'ps', 'ur', 'yi'].includes(lang);
  }

  /**
   * @returns {NumericSystem}
   */
  getNumberingSystem() {
    return this.numberingSystem;
  }

  /**
   * @param {Number} number
   * @param {Intl.NumberFormatOptions} options
   * @returns {String}
   */
  numberFormat(
    number,
    options = {
      useGrouping: false,
    },
  ) {
    const formatter = new Intl.NumberFormat(this.toString(), options);
    return formatter.format(number);
  }

  /**
   * @param {Date} date1
   * @param {Date} date2
   * @param {Intl.RelativeTimeFormatOptions} options
   * @returns {String}
   */
  relativeTimeString(
    date1,
    date2 = new Date(),
    options = {
      style: 'narrow',
    },
  ) {
    const formatter = new Intl.RelativeTimeFormat(this.language, options);
    const diff = date1 - date2;
    const diffAbs = Math.abs(diff);
    const x = diff > 0 ? 1 : -1;

    const matrix = {
      year: 31536000000,
      month: 2592000000,
      day: 86400000,
      hour: 3600000,
      minute: 60000,
      second: 1000,
    };

    let output = '';

    Object.keys(matrix).forEach((unit) => {
      const interval = matrix[unit];
      if (output === '' && diffAbs > interval) {
        output = formatter.format(x * Math.round(diffAbs / interval), unit);
      }
    });

    return output;
  }

  /**
   * @param {CountryISOCode} country
   * @returns {Locale}
   */
  setCountry(country) {
    this.weekdays = [1, 2, 3, 4, 5, 6, 0];
    this.weekends = [6, 0];
    this.flag = 'ğŸ‡¿ğŸ‡¿';
    this.calendar = 'gregory';

    if (countries[country]) {
      this.flag = countries[country].f;

      if (countries[country].wd) {
        this.weekdays = countries[country].wd;
      }

      if (countries[country].we) {
        this.weekends = countries[country].we;
      }

      if (countries[country].c) {
        this.calendar = countries[country].c;
      }
    }

    this.country = country;

    return this;
  }

  /**
   * @param {CalendarSystem} calendar
   * @returns {Locale}
   */
  setCalendar(calendar) {
    this.calendar = calendar;
    return this;
  }

  /**
   * @returns {Number[]}
   */
  getWeekDays() {
    return this.weekdays;
  }

  /**
   * @returns {Number[]}
   */
  getWeekEnds() {
    return this.weekends;
  }

  /**
   * @return {{ id: CountryISOCode, selected: Boolean, defaultLanguage: LanguageISOCode, flag: String, title: String, titleNative: String }[]}
   */
  getCountryList() {
    const result = [];
    Object.keys(countries).forEach((code) => {
      const data = countries[code];
      const title = new Intl.DisplayNames([this.language], {
        type: 'region',
      });
      const titleNative = new Intl.DisplayNames([data.l], { type: 'region' });

      result.push({
        id: code,
        selected: this.country === code,
        defaultLanguage: code.l,
        flag: data.f,
        title: title.of(code),
        titleNative: titleNative.of(code),
      });
    });
    return result;
  }

  /**
   * @return {{id: LanguageISOCode, selected: Boolean, rtl: Boolean, title: String, titleNative: String}[]}
   */
  getLanguageList() {
    const result = [];
    languages.forEach((code) => {
      const title = new Intl.DisplayNames([this.language], {
        type: 'language',
      });
      const titleNative = new Intl.DisplayNames([code], { type: 'language' });

      result.push({
        id: code,
        selected: this.language === code,
        rtl: this.isRTL(code),
        title: title.of(code),
        titleNative: titleNative.of(code),
      });
    });
    return result;
  }

  /**
   * @return {{id: Calendar, selected: Boolean, long: String, short: String}[]}
   */
  getCalendarList() {
    return SupportedCalendars.map((ident) => {
      const d = luxon.DateTime.local().reconfigure({
        locale: this.language,
        outputCalendar: ident,
      });
      return {
        id: ident,
        selected: this.calendar === ident,
        title: this.constructor.calendarName(d.toFormat('GG'), ident),
        titleShort: this.constructor.calendarName(d.toFormat('G'), ident),
      };
    });
  }
}

module.exports = { Locale, SupportedCalendars };

},{"./countries":5,"./languages":6,"luxon":87}],5:[function(require,module,exports){
module.exports = {
  AC: { f: 'ğŸ‡¦ğŸ‡¨', l: 'en' },
  AD: { f: 'ğŸ‡¦ğŸ‡©', l: 'ca' },
  AE: { f: 'ğŸ‡¦ğŸ‡ª', l: 'ar', wd: [6, 0, 1, 2, 3, 4, 5], we: [5, 6] },
  AF: { f: 'ğŸ‡¦ğŸ‡«', l: 'fa', c: 'persian', wd: [6, 0, 1, 2, 3, 4, 5], we: [4, 5] },
  AG: { f: 'ğŸ‡¦ğŸ‡¬', l: 'en', wd: [0, 1, 2, 3, 4, 5, 6] },
  AI: { f: 'ğŸ‡¦ğŸ‡®', l: 'en' },
  AL: { f: 'ğŸ‡¦ğŸ‡±', l: 'sq' },
  AM: { f: 'ğŸ‡¦ğŸ‡²', l: 'hy' },
  AO: { f: 'ğŸ‡¦ğŸ‡´', l: 'pt' },
  AR: { f: 'ğŸ‡¦ğŸ‡·', l: 'es' },
  AS: { f: 'ğŸ‡¦ğŸ‡¸', l: 'en', wd: [0, 1, 2, 3, 4, 5, 6] },
  AT: { f: 'ğŸ‡¦ğŸ‡¹', l: 'de' },
  AU: { f: 'ğŸ‡¦ğŸ‡º', l: 'en', wd: [0, 1, 2, 3, 4, 5, 6] },
  AW: { f: 'ğŸ‡¦ğŸ‡¼', l: 'nl' },
  AX: { f: 'ğŸ‡¦ğŸ‡½', l: 'sv' },
  AZ: { f: 'ğŸ‡¦ğŸ‡¿', l: 'az' },
  BA: { f: 'ğŸ‡§ğŸ‡¦', l: 'bs' },
  BB: { f: 'ğŸ‡§ğŸ‡§', l: 'en' },
  BD: { f: 'ğŸ‡§ğŸ‡©', l: 'bn', wd: [0, 1, 2, 3, 4, 5, 6] },
  BE: { f: 'ğŸ‡§ğŸ‡ª', l: 'en' },
  BF: { f: 'ğŸ‡§ğŸ‡«', l: 'fr' },
  BG: { f: 'ğŸ‡§ğŸ‡¬', l: 'bg' },
  BH: { f: 'ğŸ‡§ğŸ‡­', l: 'ar', wd: [6, 0, 1, 2, 3, 4, 5], we: [5, 6] },
  BI: { f: 'ğŸ‡§ğŸ‡®', l: 'rn' },
  BJ: { f: 'ğŸ‡§ğŸ‡¯', l: 'fr' },
  BL: { f: 'ğŸ‡§ğŸ‡±', l: 'fr' },
  BM: { f: 'ğŸ‡§ğŸ‡²', l: 'en' },
  BN: { f: 'ğŸ‡§ğŸ‡³', l: 'ms' },
  BO: { f: 'ğŸ‡§ğŸ‡´', l: 'es' },
  BQ: { f: 'ğŸ‡§ğŸ‡¶', l: 'nl' },
  BR: { f: 'ğŸ‡§ğŸ‡·', l: 'pt', wd: [0, 1, 2, 3, 4, 5, 6] },
  BS: { f: 'ğŸ‡§ğŸ‡¸', l: 'en', wd: [0, 1, 2, 3, 4, 5, 6] },
  BT: { f: 'ğŸ‡§ğŸ‡¹', l: 'dz', wd: [0, 1, 2, 3, 4, 5, 6] },
  BW: { f: 'ğŸ‡§ğŸ‡¼', l: 'en', wd: [0, 1, 2, 3, 4, 5, 6] },
  BY: { f: 'ğŸ‡§ğŸ‡¾', l: 'be' },
  BZ: { f: 'ğŸ‡§ğŸ‡¿', l: 'en', wd: [0, 1, 2, 3, 4, 5, 6] },
  CA: { f: 'ğŸ‡¨ğŸ‡¦', l: 'en', wd: [0, 1, 2, 3, 4, 5, 6] },
  CC: { f: 'ğŸ‡¨ğŸ‡¨', l: 'en' },
  CD: { f: 'ğŸ‡¨ğŸ‡©', l: 'fr' },
  CF: { f: 'ğŸ‡¨ğŸ‡«', l: 'fr' },
  CG: { f: 'ğŸ‡¨ğŸ‡¬', l: 'fr' },
  CH: { f: 'ğŸ‡¨ğŸ‡­', l: 'de' },
  CI: { f: 'ğŸ‡¨ğŸ‡®', l: 'fr' },
  CK: { f: 'ğŸ‡¨ğŸ‡°', l: 'en' },
  CL: { f: 'ğŸ‡¨ğŸ‡±', l: 'es' },
  CM: { f: 'ğŸ‡¨ğŸ‡²', l: 'fr' },
  CN: { f: 'ğŸ‡¨ğŸ‡³', l: 'zh', wd: [0, 1, 2, 3, 4, 5, 6] },
  CO: { f: 'ğŸ‡¨ğŸ‡´', l: 'es', wd: [0, 1, 2, 3, 4, 5, 6] },
  CR: { f: 'ğŸ‡¨ğŸ‡·', l: 'es' },
  CU: { f: 'ğŸ‡¨ğŸ‡º', l: 'es' },
  CV: { f: 'ğŸ‡¨ğŸ‡»', l: 'pt' },
  CW: { f: 'ğŸ‡¨ğŸ‡¼', l: 'nl' },
  CX: { f: 'ğŸ‡¨ğŸ‡½', l: 'en' },
  CY: { f: 'ğŸ‡¨ğŸ‡¾', l: 'el' },
  CZ: { f: 'ğŸ‡¨ğŸ‡¿', l: 'cs' },
  DE: { f: 'ğŸ‡©ğŸ‡ª', l: 'de' },
  DG: { f: 'ğŸ‡©ğŸ‡¬', l: 'en' },
  DJ: { f: 'ğŸ‡©ğŸ‡¯', l: 'aa', wd: [6, 0, 1, 2, 3, 4, 5] },
  DK: { f: 'ğŸ‡©ğŸ‡°', l: 'da' },
  DM: { f: 'ğŸ‡©ğŸ‡²', l: 'en', wd: [0, 1, 2, 3, 4, 5, 6] },
  DO: { f: 'ğŸ‡©ğŸ‡´', l: 'es', wd: [0, 1, 2, 3, 4, 5, 6] },
  DZ: { f: 'ğŸ‡©ğŸ‡¿', l: 'ar', wd: [6, 0, 1, 2, 3, 4, 5], we: [5, 6] },
  EA: { f: 'ğŸ‡ªğŸ‡¦', l: 'es' },
  EC: { f: 'ğŸ‡ªğŸ‡¨', l: 'es' },
  EE: { f: 'ğŸ‡ªğŸ‡ª', l: 'et' },
  EG: { f: 'ğŸ‡ªğŸ‡¬', l: 'ar', wd: [6, 0, 1, 2, 3, 4, 5], we: [5, 6] },
  EH: { f: 'ğŸ‡ªğŸ‡­', l: 'ar' },
  ER: { f: 'ğŸ‡ªğŸ‡·', l: 'ti' },
  ES: { f: 'ğŸ‡ªğŸ‡¸', l: 'es' },
  ET: { f: 'ğŸ‡ªğŸ‡¹', l: 'en', wd: [0, 1, 2, 3, 4, 5, 6] },
  FI: { f: 'ğŸ‡«ğŸ‡®', l: 'fi' },
  FJ: { f: 'ğŸ‡«ğŸ‡¯', l: 'en' },
  FK: { f: 'ğŸ‡«ğŸ‡°', l: 'en' },
  FM: { f: 'ğŸ‡«ğŸ‡²', l: 'en' },
  FO: { f: 'ğŸ‡«ğŸ‡´', l: 'fo' },
  FR: { f: 'ğŸ‡«ğŸ‡·', l: 'fr' },
  GA: { f: 'ğŸ‡¬ğŸ‡¦', l: 'fr' },
  GB: { f: 'ğŸ‡¬ğŸ‡§', l: 'en' },
  GD: { f: 'ğŸ‡¬ğŸ‡©', l: 'en' },
  GE: { f: 'ğŸ‡¬ğŸ‡ª', l: 'ka' },
  GF: { f: 'ğŸ‡¬ğŸ‡«', l: 'fr' },
  GG: { f: 'ğŸ‡¬ğŸ‡¬', l: 'en' },
  GH: { f: 'ğŸ‡¬ğŸ‡­', l: 'en' },
  GI: { f: 'ğŸ‡¬ğŸ‡®', l: 'en' },
  GL: { f: 'ğŸ‡¬ğŸ‡±', l: 'kl' },
  GM: { f: 'ğŸ‡¬ğŸ‡²', l: 'en' },
  GN: { f: 'ğŸ‡¬ğŸ‡³', l: 'fr' },
  GP: { f: 'ğŸ‡¬ğŸ‡µ', l: 'fr' },
  GQ: { f: 'ğŸ‡¬ğŸ‡¶', l: 'es' },
  GR: { f: 'ğŸ‡¬ğŸ‡·', l: 'el' },
  GT: { f: 'ğŸ‡¬ğŸ‡¹', l: 'es', wd: [0, 1, 2, 3, 4, 5, 6] },
  GU: { f: 'ğŸ‡¬ğŸ‡º', l: 'en', wd: [0, 1, 2, 3, 4, 5, 6] },
  GW: { f: 'ğŸ‡¬ğŸ‡¼', l: 'pt' },
  GY: { f: 'ğŸ‡¬ğŸ‡¾', l: 'en' },
  HK: { f: 'ğŸ‡­ğŸ‡°', l: 'zh', wd: [0, 1, 2, 3, 4, 5, 6] },
  HN: { f: 'ğŸ‡­ğŸ‡³', l: 'es', wd: [0, 1, 2, 3, 4, 5, 6] },
  HR: { f: 'ğŸ‡­ğŸ‡·', l: 'hr' },
  HT: { f: 'ğŸ‡­ğŸ‡¹', l: 'ht' },
  HU: { f: 'ğŸ‡­ğŸ‡º', l: 'hu' },
  IC: { f: 'ğŸ‡®ğŸ‡¨', l: 'es' },
  ID: { f: 'ğŸ‡®ğŸ‡©', l: 'id', wd: [0, 1, 2, 3, 4, 5, 6] },
  IE: { f: 'ğŸ‡®ğŸ‡ª', l: 'en' },
  IL: { f: 'ğŸ‡®ğŸ‡±', l: 'he', wd: [0, 1, 2, 3, 4, 5, 6], we: [5, 6] },
  IM: { f: 'ğŸ‡®ğŸ‡²', l: 'en' },
  IN: { f: 'ğŸ‡®ğŸ‡³', l: 'hi', wd: [0, 1, 2, 3, 4, 5, 6], we: [0] },
  IO: { f: 'ğŸ‡®ğŸ‡´', l: 'en' },
  IQ: { f: 'ğŸ‡®ğŸ‡¶', l: 'ar', wd: [6, 0, 1, 2, 3, 4, 5], we: [5, 6] },
  IR: { f: 'ğŸ‡®ğŸ‡·', l: 'fa', c: 'persian', wd: [6, 0, 1, 2, 3, 4, 5], we: [5] },
  IS: { f: 'ğŸ‡®ğŸ‡¸', l: 'is' },
  IT: { f: 'ğŸ‡®ğŸ‡¹', l: 'it' },
  JE: { f: 'ğŸ‡¯ğŸ‡ª', l: 'en' },
  JM: { f: 'ğŸ‡¯ğŸ‡²', l: 'en', wd: [0, 1, 2, 3, 4, 5, 6] },
  JO: { f: 'ğŸ‡¯ğŸ‡´', l: 'ar', wd: [6, 0, 1, 2, 3, 4, 5], we: [5, 6] },
  JP: { f: 'ğŸ‡¯ğŸ‡µ', l: 'ja', wd: [0, 1, 2, 3, 4, 5, 6] },
  KE: { f: 'ğŸ‡°ğŸ‡ª', l: 'sw', wd: [0, 1, 2, 3, 4, 5, 6] },
  KG: { f: 'ğŸ‡°ğŸ‡¬', l: 'ky' },
  KH: { f: 'ğŸ‡°ğŸ‡­', l: 'km', wd: [0, 1, 2, 3, 4, 5, 6] },
  KI: { f: 'ğŸ‡°ğŸ‡®', l: 'en' },
  KM: { f: 'ğŸ‡°ğŸ‡²', l: 'ar' },
  KN: { f: 'ğŸ‡°ğŸ‡³', l: 'en' },
  KP: { f: 'ğŸ‡°ğŸ‡µ', l: 'ko' },
  KR: { f: 'ğŸ‡°ğŸ‡·', l: 'ko', wd: [0, 1, 2, 3, 4, 5, 6] },
  KW: { f: 'ğŸ‡°ğŸ‡¼', l: 'ar', wd: [6, 0, 1, 2, 3, 4, 5], we: [5, 6] },
  KY: { f: 'ğŸ‡°ğŸ‡¾', l: 'en' },
  KZ: { f: 'ğŸ‡°ğŸ‡¿', l: 'ru' },
  LA: { f: 'ğŸ‡±ğŸ‡¦', l: 'lo', wd: [0, 1, 2, 3, 4, 5, 6] },
  LB: { f: 'ğŸ‡±ğŸ‡§', l: 'ar' },
  LC: { f: 'ğŸ‡±ğŸ‡¨', l: 'en' },
  LI: { f: 'ğŸ‡±ğŸ‡®', l: 'de' },
  LK: { f: 'ğŸ‡±ğŸ‡°', l: 'si' },
  LR: { f: 'ğŸ‡±ğŸ‡·', l: 'en' },
  LS: { f: 'ğŸ‡±ğŸ‡¸', l: 'st' },
  LT: { f: 'ğŸ‡±ğŸ‡¹', l: 'lt' },
  LU: { f: 'ğŸ‡±ğŸ‡º', l: 'fr' },
  LV: { f: 'ğŸ‡±ğŸ‡»', l: 'lv' },
  LY: { f: 'ğŸ‡±ğŸ‡¾', l: 'ar', wd: [6, 0, 1, 2, 3, 4, 5], we: [5, 6] },
  MA: { f: 'ğŸ‡²ğŸ‡¦', l: 'fr' },
  MC: { f: 'ğŸ‡²ğŸ‡¨', l: 'fr' },
  MD: { f: 'ğŸ‡²ğŸ‡©', l: 'ro' },
  ME: { f: 'ğŸ‡²ğŸ‡ª', l: 'sq' },
  MF: { f: 'ğŸ‡²ğŸ‡«', l: 'fr' },
  MG: { f: 'ğŸ‡²ğŸ‡¬', l: 'mg' },
  MH: { f: 'ğŸ‡²ğŸ‡­', l: 'en', wd: [0, 1, 2, 3, 4, 5, 6] },
  MK: { f: 'ğŸ‡²ğŸ‡°', l: 'mk' },
  ML: { f: 'ğŸ‡²ğŸ‡±', l: 'bm' },
  MM: { f: 'ğŸ‡²ğŸ‡²', l: 'my', wd: [0, 1, 2, 3, 4, 5, 6] },
  MN: { f: 'ğŸ‡²ğŸ‡³', l: 'mn' },
  MO: { f: 'ğŸ‡²ğŸ‡´', l: 'zh', wd: [0, 1, 2, 3, 4, 5, 6] },
  MP: { f: 'ğŸ‡²ğŸ‡µ', l: 'en' },
  MQ: { f: 'ğŸ‡²ğŸ‡¶', l: 'fr' },
  MR: { f: 'ğŸ‡²ğŸ‡·', l: 'ar' },
  MS: { f: 'ğŸ‡²ğŸ‡¸', l: 'en' },
  MT: { f: 'ğŸ‡²ğŸ‡¹', l: 'mt', wd: [0, 1, 2, 3, 4, 5, 6] },
  MU: { f: 'ğŸ‡²ğŸ‡º', l: 'en' },
  MV: { f: 'ğŸ‡²ğŸ‡»', l: 'dv', wd: [5, 6, 0, 1, 2, 3, 4] },
  MW: { f: 'ğŸ‡²ğŸ‡¼', l: 'en' },
  MX: { f: 'ğŸ‡²ğŸ‡½', l: 'es', wd: [0, 1, 2, 3, 4, 5, 6] },
  MY: { f: 'ğŸ‡²ğŸ‡¾', l: 'ms' },
  MZ: { f: 'ğŸ‡²ğŸ‡¿', l: 'pt', wd: [0, 1, 2, 3, 4, 5, 6] },
  NA: { f: 'ğŸ‡³ğŸ‡¦', l: 'af' },
  NC: { f: 'ğŸ‡³ğŸ‡¨', l: 'fr' },
  NE: { f: 'ğŸ‡³ğŸ‡ª', l: 'ha' },
  NF: { f: 'ğŸ‡³ğŸ‡«', l: 'en' },
  NG: { f: 'ğŸ‡³ğŸ‡¬', l: 'en' },
  NI: { f: 'ğŸ‡³ğŸ‡®', l: 'es', wd: [0, 1, 2, 3, 4, 5, 6] },
  NL: { f: 'ğŸ‡³ğŸ‡±', l: 'nl' },
  NO: { f: 'ğŸ‡³ğŸ‡´', l: 'nb' },
  NP: { f: 'ğŸ‡³ğŸ‡µ', l: 'ne', wd: [0, 1, 2, 3, 4, 5, 6] },
  NR: { f: 'ğŸ‡³ğŸ‡·', l: 'en' },
  NU: { f: 'ğŸ‡³ğŸ‡º', l: 'en' },
  NZ: { f: 'ğŸ‡³ğŸ‡¿', l: 'en' },
  OM: { f: 'ğŸ‡´ğŸ‡²', l: 'ar', wd: [6, 0, 1, 2, 3, 4, 5], we: [5, 6] },
  PA: { f: 'ğŸ‡µğŸ‡¦', l: 'es', wd: [0, 1, 2, 3, 4, 5, 6] },
  PE: { f: 'ğŸ‡µğŸ‡ª', l: 'es', wd: [0, 1, 2, 3, 4, 5, 6] },
  PF: { f: 'ğŸ‡µğŸ‡«', l: 'fr' },
  PG: { f: 'ğŸ‡µğŸ‡¬', l: 'en' },
  PH: { f: 'ğŸ‡µğŸ‡­', l: 'en', wd: [0, 1, 2, 3, 4, 5, 6] },
  PK: { f: 'ğŸ‡µğŸ‡°', l: 'ur', wd: [0, 1, 2, 3, 4, 5, 6] },
  PL: { f: 'ğŸ‡µğŸ‡±', l: 'pl' },
  PM: { f: 'ğŸ‡µğŸ‡²', l: 'fr' },
  PN: { f: 'ğŸ‡µğŸ‡³', l: 'en' },
  PR: { f: 'ğŸ‡µğŸ‡·', l: 'en', wd: [0, 1, 2, 3, 4, 5, 6] },
  PS: { f: 'ğŸ‡µğŸ‡¸', l: 'ar' },
  PT: { f: 'ğŸ‡µğŸ‡¹', l: 'pt', wd: [0, 1, 2, 3, 4, 5, 6] },
  PW: { f: 'ğŸ‡µğŸ‡¼', l: 'en' },
  PY: { f: 'ğŸ‡µğŸ‡¾', l: 'gn', wd: [0, 1, 2, 3, 4, 5, 6] },
  QA: { f: 'ğŸ‡¶ğŸ‡¦', l: 'ar', wd: [6, 0, 1, 2, 3, 4, 5], we: [5, 6] },
  RE: { f: 'ğŸ‡·ğŸ‡ª', l: 'fr' },
  RO: { f: 'ğŸ‡·ğŸ‡´', l: 'ro' },
  RS: { f: 'ğŸ‡·ğŸ‡¸', l: 'sr' },
  RU: { f: 'ğŸ‡·ğŸ‡º', l: 'ru' },
  RW: { f: 'ğŸ‡·ğŸ‡¼', l: 'rw' },
  SA: { f: 'ğŸ‡¸ğŸ‡¦', l: 'ar', c: 'islamic', wd: [0, 1, 2, 3, 4, 5, 6], we: [5, 6] },
  SB: { f: 'ğŸ‡¸ğŸ‡§', l: 'en' },
  SC: { f: 'ğŸ‡¸ğŸ‡¨', l: 'fr' },
  SD: { f: 'ğŸ‡¸ğŸ‡©', l: 'ar', wd: [6, 0, 1, 2, 3, 4, 5], we: [5, 6] },
  SE: { f: 'ğŸ‡¸ğŸ‡ª', l: 'sv' },
  SG: { f: 'ğŸ‡¸ğŸ‡¬', l: 'en', wd: [0, 1, 2, 3, 4, 5, 6] },
  SH: { f: 'ğŸ‡¸ğŸ‡­', l: 'en' },
  SI: { f: 'ğŸ‡¸ğŸ‡®', l: 'sl' },
  SJ: { f: 'ğŸ‡¸ğŸ‡¯', l: 'nb' },
  SK: { f: 'ğŸ‡¸ğŸ‡°', l: 'sk' },
  SL: { f: 'ğŸ‡¸ğŸ‡±', l: 'en' },
  SM: { f: 'ğŸ‡¸ğŸ‡²', l: 'it' },
  SN: { f: 'ğŸ‡¸ğŸ‡³', l: 'wo' },
  SO: { f: 'ğŸ‡¸ğŸ‡´', l: 'so' },
  SR: { f: 'ğŸ‡¸ğŸ‡·', l: 'nl' },
  SS: { f: 'ğŸ‡¸ğŸ‡¸', l: 'ar' },
  ST: { f: 'ğŸ‡¸ğŸ‡¹', l: 'pt' },
  SV: { f: 'ğŸ‡¸ğŸ‡»', l: 'es', wd: [0, 1, 2, 3, 4, 5, 6] },
  SX: { f: 'ğŸ‡¸ğŸ‡½', l: 'en' },
  SY: { f: 'ğŸ‡¸ğŸ‡¾', l: 'ar', wd: [6, 0, 1, 2, 3, 4, 5], we: [5, 6] },
  SZ: { f: 'ğŸ‡¸ğŸ‡¿', l: 'en' },
  TA: { f: 'ğŸ‡¹ğŸ‡¦', l: 'en' },
  TC: { f: 'ğŸ‡¹ğŸ‡¨', l: 'en' },
  TD: { f: 'ğŸ‡¹ğŸ‡©', l: 'fr' },
  TF: { f: 'ğŸ‡¹ğŸ‡«', l: 'fr' },
  TG: { f: 'ğŸ‡¹ğŸ‡¬', l: 'fr' },
  TH: { f: 'ğŸ‡¹ğŸ‡­', l: 'th', c: 'buddhist', wd: [0, 1, 2, 3, 4, 5, 6] },
  TJ: { f: 'ğŸ‡¹ğŸ‡¯', l: 'tg' },
  TK: { f: 'ğŸ‡¹ğŸ‡°', l: 'en' },
  TL: { f: 'ğŸ‡¹ğŸ‡±', l: 'pt' },
  TM: { f: 'ğŸ‡¹ğŸ‡²', l: 'tk' },
  TN: { f: 'ğŸ‡¹ğŸ‡³', l: 'ar' },
  TO: { f: 'ğŸ‡¹ğŸ‡´', l: 'to' },
  TR: { f: 'ğŸ‡¹ğŸ‡·', l: 'tr' },
  TT: { f: 'ğŸ‡¹ğŸ‡¹', l: 'en', wd: [0, 1, 2, 3, 4, 5, 6] },
  TV: { f: 'ğŸ‡¹ğŸ‡»', l: 'en' },
  TW: { f: 'ğŸ‡¹ğŸ‡¼', l: 'zh', wd: [0, 1, 2, 3, 4, 5, 6] },
  TZ: { f: 'ğŸ‡¹ğŸ‡¿', l: 'sw' },
  UA: { f: 'ğŸ‡ºğŸ‡¦', l: 'ru' },
  UG: { f: 'ğŸ‡ºğŸ‡¬', l: 'sw', we: [0] },
  UM: { f: 'ğŸ‡ºğŸ‡²', l: 'en', wd: [0, 1, 2, 3, 4, 5, 6] },
  US: { f: 'ğŸ‡ºğŸ‡¸', l: 'en', wd: [0, 1, 2, 3, 4, 5, 6] },
  UY: { f: 'ğŸ‡ºğŸ‡¾', l: 'es' },
  UZ: { f: 'ğŸ‡ºğŸ‡¿', l: 'uz' },
  VA: { f: 'ğŸ‡»ğŸ‡¦', l: 'it' },
  VC: { f: 'ğŸ‡»ğŸ‡¨', l: 'en' },
  VE: { f: 'ğŸ‡»ğŸ‡ª', l: 'es', wd: [0, 1, 2, 3, 4, 5, 6] },
  VG: { f: 'ğŸ‡»ğŸ‡¬', l: 'en' },
  VI: { f: 'ğŸ‡»ğŸ‡®', l: 'en', wd: [0, 1, 2, 3, 4, 5, 6] },
  VN: { f: 'ğŸ‡»ğŸ‡³', l: 'vi' },
  VU: { f: 'ğŸ‡»ğŸ‡º', l: 'bi' },
  WF: { f: 'ğŸ‡¼ğŸ‡«', l: 'fr' },
  WS: { f: 'ğŸ‡¼ğŸ‡¸', l: 'sm', wd: [0, 1, 2, 3, 4, 5, 6] },
  XK: { f: 'ğŸ‡½ğŸ‡°', l: 'sq' },
  YE: { f: 'ğŸ‡¾ğŸ‡ª', l: 'ar', wd: [0, 1, 2, 3, 4, 5, 6], we: [5, 6] },
  YT: { f: 'ğŸ‡¾ğŸ‡¹', l: 'fr' },
  ZA: { f: 'ğŸ‡¿ğŸ‡¦', l: 'en', wd: [0, 1, 2, 3, 4, 5, 6] },
  ZM: { f: 'ğŸ‡¿ğŸ‡²', l: 'en' },
  ZW: { f: 'ğŸ‡¿ğŸ‡¼', l: 'sn', wd: [0, 1, 2, 3, 4, 5, 6] },
};

},{}],6:[function(require,module,exports){
module.exports = [
  'aa',
  'af',
  'ar',
  'az',
  'be',
  'bg',
  'bi',
  'bm',
  'bn',
  'bs',
  'ca',
  'cs',
  'da',
  'de',
  'dv',
  'dz',
  'el',
  'en',
  'es',
  'et',
  'fa',
  'fi',
  'fo',
  'fr',
  'gn',
  'ha',
  'he',
  'hi',
  'hr',
  'ht',
  'hu',
  'hy',
  'id',
  'is',
  'it',
  'ja',
  'ka',
  'kl',
  'km',
  'ko',
  'ky',
  'lo',
  'lt',
  'lv',
  'mg',
  'mk',
  'mn',
  'ms',
  'mt',
  'my',
  'nb',
  'ne',
  'nl',
  'pl',
  'pt',
  'rn',
  'ro',
  'ru',
  'rw',
  'si',
  'sk',
  'sl',
  'sm',
  'sn',
  'so',
  'sq',
  'sr',
  'st',
  'sv',
  'sw',
  'tg',
  'th',
  'ti',
  'tk',
  'to',
  'tr',
  'ur',
  'uz',
  'vi',
  'wo',
  'zh',
];

},{}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecFromTime = exports.MinFromTime = exports.HourFromTime = exports.DateFromTime = exports.MonthFromTime = exports.InLeapYear = exports.DayWithinYear = exports.DaysInYear = exports.YearFromTime = exports.TimeFromYear = exports.DayFromYear = exports.WeekDay = exports.Day = exports.Type = exports.HasOwnProperty = exports.ArrayCreate = exports.SameValue = exports.ToObject = exports.TimeClip = exports.ToNumber = exports.ToString = void 0;
/**
 * https://tc39.es/ecma262/#sec-tostring
 */
function ToString(o) {
    // Only symbol is irregular...
    if (typeof o === 'symbol') {
        throw TypeError('Cannot convert a Symbol value to a string');
    }
    return String(o);
}
exports.ToString = ToString;
/**
 * https://tc39.es/ecma262/#sec-tonumber
 * @param val
 */
function ToNumber(val) {
    if (val === undefined) {
        return NaN;
    }
    if (val === null) {
        return +0;
    }
    if (typeof val === 'boolean') {
        return val ? 1 : +0;
    }
    if (typeof val === 'number') {
        return val;
    }
    if (typeof val === 'symbol' || typeof val === 'bigint') {
        throw new TypeError('Cannot convert symbol/bigint to number');
    }
    return Number(val);
}
exports.ToNumber = ToNumber;
/**
 * https://tc39.es/ecma262/#sec-tointeger
 * @param n
 */
function ToInteger(n) {
    var number = ToNumber(n);
    if (isNaN(number) || SameValue(number, -0)) {
        return 0;
    }
    if (isFinite(number)) {
        return number;
    }
    var integer = Math.floor(Math.abs(number));
    if (number < 0) {
        integer = -integer;
    }
    if (SameValue(integer, -0)) {
        return 0;
    }
    return integer;
}
/**
 * https://tc39.es/ecma262/#sec-timeclip
 * @param time
 */
function TimeClip(time) {
    if (!isFinite(time)) {
        return NaN;
    }
    if (Math.abs(time) > 8.64 * 1e16) {
        return NaN;
    }
    return ToInteger(time);
}
exports.TimeClip = TimeClip;
/**
 * https://tc39.es/ecma262/#sec-toobject
 * @param arg
 */
function ToObject(arg) {
    if (arg == null) {
        throw new TypeError('undefined/null cannot be converted to object');
    }
    return Object(arg);
}
exports.ToObject = ToObject;
/**
 * https://www.ecma-international.org/ecma-262/11.0/index.html#sec-samevalue
 * @param x
 * @param y
 */
function SameValue(x, y) {
    if (Object.is) {
        return Object.is(x, y);
    }
    // SameValue algorithm
    if (x === y) {
        // Steps 1-5, 7-10
        // Steps 6.b-6.e: +0 != -0
        return x !== 0 || 1 / x === 1 / y;
    }
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
}
exports.SameValue = SameValue;
/**
 * https://www.ecma-international.org/ecma-262/11.0/index.html#sec-arraycreate
 * @param len
 */
function ArrayCreate(len) {
    return new Array(len);
}
exports.ArrayCreate = ArrayCreate;
/**
 * https://www.ecma-international.org/ecma-262/11.0/index.html#sec-hasownproperty
 * @param o
 * @param prop
 */
function HasOwnProperty(o, prop) {
    return Object.prototype.hasOwnProperty.call(o, prop);
}
exports.HasOwnProperty = HasOwnProperty;
/**
 * https://www.ecma-international.org/ecma-262/11.0/index.html#sec-type
 * @param x
 */
function Type(x) {
    if (x === null) {
        return 'Null';
    }
    if (typeof x === 'undefined') {
        return 'Undefined';
    }
    if (typeof x === 'function' || typeof x === 'object') {
        return 'Object';
    }
    if (typeof x === 'number') {
        return 'Number';
    }
    if (typeof x === 'boolean') {
        return 'Boolean';
    }
    if (typeof x === 'string') {
        return 'String';
    }
    if (typeof x === 'symbol') {
        return 'Symbol';
    }
    if (typeof x === 'bigint') {
        return 'BigInt';
    }
}
exports.Type = Type;
var MS_PER_DAY = 86400000;
/**
 * https://www.ecma-international.org/ecma-262/11.0/index.html#eqn-modulo
 * @param x
 * @param y
 * @return k of the same sign as y
 */
function mod(x, y) {
    return x - Math.floor(x / y) * y;
}
/**
 * https://tc39.es/ecma262/#eqn-Day
 * @param t
 */
function Day(t) {
    return Math.floor(t / MS_PER_DAY);
}
exports.Day = Day;
/**
 * https://tc39.es/ecma262/#sec-week-day
 * @param t
 */
function WeekDay(t) {
    return mod(Day(t) + 4, 7);
}
exports.WeekDay = WeekDay;
/**
 * https://tc39.es/ecma262/#sec-year-number
 * @param y
 */
function DayFromYear(y) {
    return (365 * (y - 1970) +
        Math.floor((y - 1969) / 4) -
        Math.floor((y - 1901) / 100) +
        Math.floor((y - 1601) / 400));
}
exports.DayFromYear = DayFromYear;
/**
 * https://tc39.es/ecma262/#sec-year-number
 * @param y
 */
function TimeFromYear(y) {
    return MS_PER_DAY * DayFromYear(y);
}
exports.TimeFromYear = TimeFromYear;
/**
 * https://tc39.es/ecma262/#sec-year-number
 * @param t
 */
function YearFromTime(t) {
    var min = Math.ceil(t / MS_PER_DAY / 366);
    var y = min;
    while (TimeFromYear(y) <= t) {
        y++;
    }
    return y - 1;
}
exports.YearFromTime = YearFromTime;
function DaysInYear(y) {
    if (y % 4 !== 0) {
        return 365;
    }
    if (y % 100 !== 0) {
        return 366;
    }
    if (y % 400 !== 0) {
        return 365;
    }
    return 366;
}
exports.DaysInYear = DaysInYear;
function DayWithinYear(t) {
    return Day(t) - DayFromYear(YearFromTime(t));
}
exports.DayWithinYear = DayWithinYear;
function InLeapYear(t) {
    return DaysInYear(YearFromTime(t)) === 365 ? 0 : 1;
}
exports.InLeapYear = InLeapYear;
/**
 * https://tc39.es/ecma262/#sec-month-number
 * @param t
 */
function MonthFromTime(t) {
    var dwy = DayWithinYear(t);
    var leap = InLeapYear(t);
    if (dwy >= 0 && dwy < 31) {
        return 0;
    }
    if (dwy < 59 + leap) {
        return 1;
    }
    if (dwy < 90 + leap) {
        return 2;
    }
    if (dwy < 120 + leap) {
        return 3;
    }
    if (dwy < 151 + leap) {
        return 4;
    }
    if (dwy < 181 + leap) {
        return 5;
    }
    if (dwy < 212 + leap) {
        return 6;
    }
    if (dwy < 243 + leap) {
        return 7;
    }
    if (dwy < 273 + leap) {
        return 8;
    }
    if (dwy < 304 + leap) {
        return 9;
    }
    if (dwy < 334 + leap) {
        return 10;
    }
    if (dwy < 365 + leap) {
        return 11;
    }
    throw new Error('Invalid time');
}
exports.MonthFromTime = MonthFromTime;
function DateFromTime(t) {
    var dwy = DayWithinYear(t);
    var mft = MonthFromTime(t);
    var leap = InLeapYear(t);
    if (mft === 0) {
        return dwy + 1;
    }
    if (mft === 1) {
        return dwy - 30;
    }
    if (mft === 2) {
        return dwy - 58 - leap;
    }
    if (mft === 3) {
        return dwy - 89 - leap;
    }
    if (mft === 4) {
        return dwy - 119 - leap;
    }
    if (mft === 5) {
        return dwy - 150 - leap;
    }
    if (mft === 6) {
        return dwy - 180 - leap;
    }
    if (mft === 7) {
        return dwy - 211 - leap;
    }
    if (mft === 8) {
        return dwy - 242 - leap;
    }
    if (mft === 9) {
        return dwy - 272 - leap;
    }
    if (mft === 10) {
        return dwy - 303 - leap;
    }
    if (mft === 11) {
        return dwy - 333 - leap;
    }
    throw new Error('Invalid time');
}
exports.DateFromTime = DateFromTime;
var HOURS_PER_DAY = 24;
var MINUTES_PER_HOUR = 60;
var SECONDS_PER_MINUTE = 60;
var MS_PER_SECOND = 1e3;
var MS_PER_MINUTE = MS_PER_SECOND * SECONDS_PER_MINUTE;
var MS_PER_HOUR = MS_PER_MINUTE * MINUTES_PER_HOUR;
function HourFromTime(t) {
    return mod(Math.floor(t / MS_PER_HOUR), HOURS_PER_DAY);
}
exports.HourFromTime = HourFromTime;
function MinFromTime(t) {
    return mod(Math.floor(t / MS_PER_MINUTE), MINUTES_PER_HOUR);
}
exports.MinFromTime = MinFromTime;
function SecFromTime(t) {
    return mod(Math.floor(t / MS_PER_SECOND), SECONDS_PER_MINUTE);
}
exports.SecFromTime = SecFromTime;

},{}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BestAvailableLocale = void 0;
/**
 * https://tc39.es/ecma402/#sec-bestavailablelocale
 * @param availableLocales
 * @param locale
 */
function BestAvailableLocale(availableLocales, locale) {
    var candidate = locale;
    while (true) {
        if (availableLocales.has(candidate)) {
            return candidate;
        }
        var pos = candidate.lastIndexOf('-');
        if (!~pos) {
            return undefined;
        }
        if (pos >= 2 && candidate[pos - 2] === '-') {
            pos -= 2;
        }
        candidate = candidate.slice(0, pos);
    }
}
exports.BestAvailableLocale = BestAvailableLocale;

},{}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BestFitMatcher = void 0;
var BestAvailableLocale_1 = require("./BestAvailableLocale");
var utils_1 = require("./utils");
/**
 * https://tc39.es/ecma402/#sec-bestfitmatcher
 * @param availableLocales
 * @param requestedLocales
 * @param getDefaultLocale
 */
function BestFitMatcher(availableLocales, requestedLocales, getDefaultLocale) {
    var minimizedAvailableLocaleMap = {};
    var minimizedAvailableLocales = new Set();
    availableLocales.forEach(function (locale) {
        var minimizedLocale = new Intl.Locale(locale)
            .minimize()
            .toString();
        minimizedAvailableLocaleMap[minimizedLocale] = locale;
        minimizedAvailableLocales.add(minimizedLocale);
    });
    var foundLocale;
    for (var _i = 0, requestedLocales_1 = requestedLocales; _i < requestedLocales_1.length; _i++) {
        var l = requestedLocales_1[_i];
        if (foundLocale) {
            break;
        }
        var noExtensionLocale = l.replace(utils_1.UNICODE_EXTENSION_SEQUENCE_REGEX, '');
        if (availableLocales.has(noExtensionLocale)) {
            foundLocale = noExtensionLocale;
            break;
        }
        if (minimizedAvailableLocales.has(noExtensionLocale)) {
            foundLocale = minimizedAvailableLocaleMap[noExtensionLocale];
            break;
        }
        var locale = new Intl.Locale(noExtensionLocale);
        var maximizedRequestedLocale = locale.maximize().toString();
        var minimizedRequestedLocale = locale.minimize().toString();
        // Check minimized locale
        if (minimizedAvailableLocales.has(minimizedRequestedLocale)) {
            foundLocale = minimizedAvailableLocaleMap[minimizedRequestedLocale];
            break;
        }
        // Lookup algo on maximized locale
        foundLocale = BestAvailableLocale_1.BestAvailableLocale(minimizedAvailableLocales, maximizedRequestedLocale);
    }
    return {
        locale: foundLocale || getDefaultLocale(),
    };
}
exports.BestFitMatcher = BestFitMatcher;

},{"./BestAvailableLocale":8,"./utils":71}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CanonicalizeLocaleList = void 0;
/**
 * http://ecma-international.org/ecma-402/7.0/index.html#sec-canonicalizelocalelist
 * @param locales
 */
function CanonicalizeLocaleList(locales) {
    // TODO
    return Intl.getCanonicalLocales(locales);
}
exports.CanonicalizeLocaleList = CanonicalizeLocaleList;

},{}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CanonicalizeTimeZoneName = void 0;
/**
 * https://tc39.es/ecma402/#sec-canonicalizetimezonename
 * @param tz
 */
function CanonicalizeTimeZoneName(tz, _a) {
    var tzData = _a.tzData, uppercaseLinks = _a.uppercaseLinks;
    var uppercasedTz = tz.toUpperCase();
    var uppercasedZones = Object.keys(tzData).reduce(function (all, z) {
        all[z.toUpperCase()] = z;
        return all;
    }, {});
    var ianaTimeZone = uppercaseLinks[uppercasedTz] || uppercasedZones[uppercasedTz];
    if (ianaTimeZone === 'Etc/UTC' || ianaTimeZone === 'Etc/GMT') {
        return 'UTC';
    }
    return ianaTimeZone;
}
exports.CanonicalizeTimeZoneName = CanonicalizeTimeZoneName;

},{}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasicFormatMatcher = void 0;
var tslib_1 = require("tslib");
var utils_1 = require("../utils");
var utils_2 = require("./utils");
/**
 * https://tc39.es/ecma402/#sec-basicformatmatcher
 * @param options
 * @param formats
 */
function BasicFormatMatcher(options, formats) {
    var bestScore = -Infinity;
    var bestFormat = formats[0];
    utils_1.invariant(Array.isArray(formats), 'formats should be a list of things');
    for (var _i = 0, formats_1 = formats; _i < formats_1.length; _i++) {
        var format = formats_1[_i];
        var score = 0;
        for (var _a = 0, DATE_TIME_PROPS_1 = utils_2.DATE_TIME_PROPS; _a < DATE_TIME_PROPS_1.length; _a++) {
            var prop = DATE_TIME_PROPS_1[_a];
            var optionsProp = options[prop];
            var formatProp = format[prop];
            if (optionsProp === undefined && formatProp !== undefined) {
                score -= utils_2.additionPenalty;
            }
            else if (optionsProp !== undefined && formatProp === undefined) {
                score -= utils_2.removalPenalty;
            }
            else if (optionsProp !== formatProp) {
                var values = ['2-digit', 'numeric', 'narrow', 'short', 'long'];
                var optionsPropIndex = values.indexOf(optionsProp);
                var formatPropIndex = values.indexOf(formatProp);
                var delta = Math.max(-2, Math.min(formatPropIndex - optionsPropIndex, 2));
                if (delta === 2) {
                    score -= utils_2.longMorePenalty;
                }
                else if (delta === 1) {
                    score -= utils_2.shortMorePenalty;
                }
                else if (delta === -1) {
                    score -= utils_2.shortLessPenalty;
                }
                else if (delta === -2) {
                    score -= utils_2.longLessPenalty;
                }
            }
        }
        if (score > bestScore) {
            bestScore = score;
            bestFormat = format;
        }
    }
    return tslib_1.__assign({}, bestFormat);
}
exports.BasicFormatMatcher = BasicFormatMatcher;

},{"../utils":71,"./utils":26,"tslib":88}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BestFitFormatMatcher = exports.bestFitFormatMatcherScore = void 0;
var tslib_1 = require("tslib");
var utils_1 = require("../utils");
var utils_2 = require("./utils");
var skeleton_1 = require("./skeleton");
function isNumericType(t) {
    return t === 'numeric' || t === '2-digit';
}
/**
 * Credit: https://github.com/andyearnshaw/Intl.js/blob/0958dc1ad8153f1056653ea22b8208f0df289a4e/src/12.datetimeformat.js#L611
 * with some modifications
 * @param options
 * @param format
 */
function bestFitFormatMatcherScore(options, format) {
    var score = 0;
    if (options.hour12 && !format.hour12) {
        score -= utils_2.removalPenalty;
    }
    else if (!options.hour12 && format.hour12) {
        score -= utils_2.additionPenalty;
    }
    for (var _i = 0, DATE_TIME_PROPS_1 = utils_2.DATE_TIME_PROPS; _i < DATE_TIME_PROPS_1.length; _i++) {
        var prop = DATE_TIME_PROPS_1[_i];
        var optionsProp = options[prop];
        var formatProp = format[prop];
        if (optionsProp === undefined && formatProp !== undefined) {
            score -= utils_2.additionPenalty;
        }
        else if (optionsProp !== undefined && formatProp === undefined) {
            score -= utils_2.removalPenalty;
        }
        else if (optionsProp !== formatProp) {
            // extra penalty for numeric vs non-numeric
            if (isNumericType(optionsProp) !==
                isNumericType(formatProp)) {
                score -= utils_2.differentNumericTypePenalty;
            }
            else {
                var values = ['2-digit', 'numeric', 'narrow', 'short', 'long'];
                var optionsPropIndex = values.indexOf(optionsProp);
                var formatPropIndex = values.indexOf(formatProp);
                var delta = Math.max(-2, Math.min(formatPropIndex - optionsPropIndex, 2));
                if (delta === 2) {
                    score -= utils_2.longMorePenalty;
                }
                else if (delta === 1) {
                    score -= utils_2.shortMorePenalty;
                }
                else if (delta === -1) {
                    score -= utils_2.shortLessPenalty;
                }
                else if (delta === -2) {
                    score -= utils_2.longLessPenalty;
                }
            }
        }
    }
    return score;
}
exports.bestFitFormatMatcherScore = bestFitFormatMatcherScore;
/**
 * https://tc39.es/ecma402/#sec-bestfitformatmatcher
 * Just alias to basic for now
 * @param options
 * @param formats
 * @param implDetails Implementation details
 */
function BestFitFormatMatcher(options, formats) {
    var bestScore = -Infinity;
    var bestFormat = formats[0];
    utils_1.invariant(Array.isArray(formats), 'formats should be a list of things');
    for (var _i = 0, formats_1 = formats; _i < formats_1.length; _i++) {
        var format = formats_1[_i];
        var score = bestFitFormatMatcherScore(options, format);
        if (score > bestScore) {
            bestScore = score;
            bestFormat = format;
        }
    }
    var skeletonFormat = tslib_1.__assign({}, bestFormat);
    var patternFormat = { rawPattern: bestFormat.rawPattern };
    skeleton_1.processDateTimePattern(bestFormat.rawPattern, patternFormat);
    // Kinda following https://github.com/unicode-org/icu/blob/dd50e38f459d84e9bf1b0c618be8483d318458ad/icu4j/main/classes/core/src/com/ibm/icu/text/DateTimePatternGenerator.java
    // Method adjustFieldTypes
    for (var prop in skeletonFormat) {
        var skeletonValue = skeletonFormat[prop];
        var patternValue = patternFormat[prop];
        var requestedValue = options[prop];
        // Don't mess with minute/second or we can get in the situation of
        // 7:0:0 which is weird
        if (prop === 'minute' || prop === 'second') {
            continue;
        }
        // Nothing to do here
        if (!requestedValue) {
            continue;
        }
        // https://unicode.org/reports/tr35/tr35-dates.html#Matching_Skeletons
        // Looks like we should not convert numeric to alphabetic but the other way
        // around is ok
        if (isNumericType(patternValue) &&
            !isNumericType(requestedValue)) {
            continue;
        }
        if (skeletonValue === requestedValue) {
            continue;
        }
        patternFormat[prop] = requestedValue;
    }
    // Copy those over
    patternFormat.pattern = skeletonFormat.pattern;
    patternFormat.pattern12 = skeletonFormat.pattern12;
    patternFormat.skeleton = skeletonFormat.skeleton;
    patternFormat.rangePatterns = skeletonFormat.rangePatterns;
    patternFormat.rangePatterns12 = skeletonFormat.rangePatterns12;
    return patternFormat;
}
exports.BestFitFormatMatcher = BestFitFormatMatcher;

},{"../utils":71,"./skeleton":25,"./utils":26,"tslib":88}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DateTimeStyleFormat = void 0;
var utils_1 = require("../utils");
function DateTimeStyleFormat(dateStyle, timeStyle, dataLocaleData) {
    var dateFormat, timeFormat;
    if (timeStyle !== undefined) {
        utils_1.invariant(timeStyle === 'full' ||
            timeStyle === 'long' ||
            timeStyle === 'medium' ||
            timeStyle === 'short', 'invalid timeStyle');
        timeFormat = dataLocaleData.timeFormat[timeStyle];
    }
    if (dateStyle !== undefined) {
        utils_1.invariant(dateStyle === 'full' ||
            dateStyle === 'long' ||
            dateStyle === 'medium' ||
            dateStyle === 'short', 'invalid dateStyle');
        dateFormat = dataLocaleData.dateFormat[dateStyle];
    }
    if (dateStyle !== undefined && timeStyle !== undefined) {
        var format = {};
        for (var field in dateFormat) {
            if (field !== 'pattern') {
                // @ts-ignore
                format[field] = dateFormat[field];
            }
        }
        for (var field in timeFormat) {
            if (field !== 'pattern' && field !== 'pattern12') {
                // @ts-ignore
                format[field] = timeFormat[field];
            }
        }
        var connector = dataLocaleData.dateTimeFormat[dateStyle];
        var pattern = connector
            .replace('{0}', timeFormat.pattern)
            .replace('{1}', dateFormat.pattern);
        format.pattern = pattern;
        if ('pattern12' in timeFormat) {
            var pattern12 = connector
                .replace('{0}', timeFormat.pattern12)
                .replace('{1}', dateFormat.pattern);
            format.pattern12 = pattern12;
        }
        return format;
    }
    if (timeStyle !== undefined) {
        return timeFormat;
    }
    utils_1.invariant(dateStyle !== undefined, 'dateStyle should not be undefined');
    return dateFormat;
}
exports.DateTimeStyleFormat = DateTimeStyleFormat;

},{"../utils":71}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FormatDateTime = void 0;
var PartitionDateTimePattern_1 = require("./PartitionDateTimePattern");
/**
 * https://tc39.es/ecma402/#sec-formatdatetime
 * @param dtf DateTimeFormat
 * @param x
 */
function FormatDateTime(dtf, x, implDetails) {
    var parts = PartitionDateTimePattern_1.PartitionDateTimePattern(dtf, x, implDetails);
    var result = '';
    for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
        var part = parts_1[_i];
        result += part.value;
    }
    return result;
}
exports.FormatDateTime = FormatDateTime;

},{"./PartitionDateTimePattern":21}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FormatDateTimePattern = void 0;
var utils_1 = require("./utils");
var ToLocalTime_1 = require("./ToLocalTime");
var _262_1 = require("../262");
function pad(n) {
    if (n < 10) {
        return "0" + n;
    }
    return String(n);
}
function offsetToGmtString(gmtFormat, hourFormat, offsetInMs, style) {
    var offsetInMinutes = Math.floor(offsetInMs / 60000);
    var mins = Math.abs(offsetInMinutes) % 60;
    var hours = Math.floor(Math.abs(offsetInMinutes) / 60);
    var _a = hourFormat.split(';'), positivePattern = _a[0], negativePattern = _a[1];
    var offsetStr = '';
    var pattern = offsetInMs < 0 ? negativePattern : positivePattern;
    if (style === 'long') {
        offsetStr = pattern
            .replace('HH', pad(hours))
            .replace('H', String(hours))
            .replace('mm', pad(mins))
            .replace('m', String(mins));
    }
    else if (mins || hours) {
        if (!mins) {
            pattern = pattern.replace(/:?m+/, '');
        }
        offsetStr = pattern
            .replace(/H+/, String(hours))
            .replace(/m+/, String(mins));
    }
    return gmtFormat.replace('{0}', offsetStr);
}
/**
 * https://tc39.es/ecma402/#sec-partitiondatetimepattern
 * @param dtf
 * @param x
 */
function FormatDateTimePattern(dtf, patternParts, x, _a) {
    var getInternalSlots = _a.getInternalSlots, localeData = _a.localeData, getDefaultTimeZone = _a.getDefaultTimeZone, tzData = _a.tzData;
    x = _262_1.TimeClip(x);
    /** IMPL START */
    var internalSlots = getInternalSlots(dtf);
    var dataLocale = internalSlots.dataLocale;
    var dataLocaleData = localeData[dataLocale];
    /** IMPL END */
    var locale = internalSlots.locale;
    var nfOptions = Object.create(null);
    nfOptions.useGrouping = false;
    var nf = new Intl.NumberFormat(locale, nfOptions);
    var nf2Options = Object.create(null);
    nf2Options.minimumIntegerDigits = 2;
    nf2Options.useGrouping = false;
    var nf2 = new Intl.NumberFormat(locale, nf2Options);
    var tm = ToLocalTime_1.ToLocalTime(x, 
    // @ts-ignore
    internalSlots.calendar, internalSlots.timeZone, { tzData: tzData });
    var result = [];
    for (var _i = 0, patternParts_1 = patternParts; _i < patternParts_1.length; _i++) {
        var patternPart = patternParts_1[_i];
        var p = patternPart.type;
        if (p === 'literal') {
            result.push({
                type: 'literal',
                value: patternPart.value,
            });
        }
        else if (utils_1.DATE_TIME_PROPS.indexOf(p) > -1) {
            var fv = '';
            var f = internalSlots[p];
            // @ts-ignore
            var v = tm[p];
            if (p === 'year' && v <= 0) {
                v = 1 - v;
            }
            if (p === 'month') {
                v++;
            }
            var hourCycle = internalSlots.hourCycle;
            if (p === 'hour' && (hourCycle === 'h11' || hourCycle === 'h12')) {
                v = v % 12;
                if (v === 0 && hourCycle === 'h12') {
                    v = 12;
                }
            }
            if (p === 'hour' && hourCycle === 'h24') {
                if (v === 0) {
                    v = 24;
                }
            }
            if (f === 'numeric') {
                fv = nf.format(v);
            }
            else if (f === '2-digit') {
                fv = nf2.format(v);
                if (fv.length > 2) {
                    fv = fv.slice(fv.length - 2, fv.length);
                }
            }
            else if (f === 'narrow' || f === 'short' || f === 'long') {
                if (p === 'era') {
                    fv = dataLocaleData[p][f][v];
                }
                else if (p === 'timeZoneName') {
                    var timeZoneName = dataLocaleData.timeZoneName, gmtFormat = dataLocaleData.gmtFormat, hourFormat = dataLocaleData.hourFormat;
                    var timeZone = internalSlots.timeZone || getDefaultTimeZone();
                    var timeZoneData = timeZoneName[timeZone];
                    if (timeZoneData && timeZoneData[f]) {
                        fv = timeZoneData[f][+tm.inDST];
                    }
                    else {
                        // Fallback to gmtFormat
                        fv = offsetToGmtString(gmtFormat, hourFormat, tm.timeZoneOffset, f);
                    }
                }
                else if (p === 'month') {
                    fv = dataLocaleData.month[f][v - 1];
                }
                else {
                    fv = dataLocaleData[p][f][v];
                }
            }
            result.push({
                type: p,
                value: fv,
            });
        }
        else if (p === 'ampm') {
            var v = tm.hour;
            var fv = void 0;
            if (v > 11) {
                fv = dataLocaleData.pm;
            }
            else {
                fv = dataLocaleData.am;
            }
            result.push({
                type: 'dayPeriod',
                value: fv,
            });
        }
        else if (p === 'relatedYear') {
            var v = tm.relatedYear;
            // @ts-ignore
            var fv = nf.format(v);
            result.push({
                // @ts-ignore TODO: Fix TS type
                type: 'relatedYear',
                value: fv,
            });
        }
        else if (p === 'yearName') {
            var v = tm.yearName;
            // @ts-ignore
            var fv = nf.format(v);
            result.push({
                // @ts-ignore TODO: Fix TS type
                type: 'yearName',
                value: fv,
            });
        }
    }
    return result;
}
exports.FormatDateTimePattern = FormatDateTimePattern;

},{"../262":7,"./ToLocalTime":24,"./utils":26}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FormatDateTimeRange = void 0;
var PartitionDateTimeRangePattern_1 = require("./PartitionDateTimeRangePattern");
function FormatDateTimeRange(dtf, x, y, implDetails) {
    var parts = PartitionDateTimeRangePattern_1.PartitionDateTimeRangePattern(dtf, x, y, implDetails);
    var result = '';
    for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
        var part = parts_1[_i];
        result += part.value;
    }
    return result;
}
exports.FormatDateTimeRange = FormatDateTimeRange;

},{"./PartitionDateTimeRangePattern":22}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FormatDateTimeRangeToParts = void 0;
var PartitionDateTimeRangePattern_1 = require("./PartitionDateTimeRangePattern");
function FormatDateTimeRangeToParts(dtf, x, y, implDetails) {
    var parts = PartitionDateTimeRangePattern_1.PartitionDateTimeRangePattern(dtf, x, y, implDetails);
    var result = new Array(0);
    for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
        var part = parts_1[_i];
        result.push({
            type: part.type,
            value: part.value,
            source: part.source,
        });
    }
    return result;
}
exports.FormatDateTimeRangeToParts = FormatDateTimeRangeToParts;

},{"./PartitionDateTimeRangePattern":22}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FormatDateTimeToParts = void 0;
var PartitionDateTimePattern_1 = require("./PartitionDateTimePattern");
var _262_1 = require("../262");
/**
 * https://tc39.es/ecma402/#sec-formatdatetimetoparts
 *
 * @param dtf
 * @param x
 * @param implDetails
 */
function FormatDateTimeToParts(dtf, x, implDetails) {
    var parts = PartitionDateTimePattern_1.PartitionDateTimePattern(dtf, x, implDetails);
    var result = _262_1.ArrayCreate(0);
    for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
        var part = parts_1[_i];
        result.push({
            type: part.type,
            value: part.value,
        });
    }
    return result;
}
exports.FormatDateTimeToParts = FormatDateTimeToParts;

},{"../262":7,"./PartitionDateTimePattern":21}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InitializeDateTimeFormat = void 0;
var CanonicalizeLocaleList_1 = require("../CanonicalizeLocaleList");
var ToDateTimeOptions_1 = require("./ToDateTimeOptions");
var GetOption_1 = require("../GetOption");
var ResolveLocale_1 = require("../ResolveLocale");
var IsValidTimeZoneName_1 = require("../IsValidTimeZoneName");
var CanonicalizeTimeZoneName_1 = require("../CanonicalizeTimeZoneName");
var BasicFormatMatcher_1 = require("./BasicFormatMatcher");
var BestFitFormatMatcher_1 = require("./BestFitFormatMatcher");
var utils_1 = require("../utils");
var utils_2 = require("./utils");
var DateTimeStyleFormat_1 = require("./DateTimeStyleFormat");
function isTimeRelated(opt) {
    for (var _i = 0, _a = ['hour', 'minute', 'second']; _i < _a.length; _i++) {
        var prop = _a[_i];
        var value = opt[prop];
        if (value !== undefined) {
            return true;
        }
    }
    return false;
}
function resolveHourCycle(hc, hcDefault, hour12) {
    if (hc == null) {
        hc = hcDefault;
    }
    if (hour12 !== undefined) {
        if (hour12) {
            if (hcDefault === 'h11' || hcDefault === 'h23') {
                hc = 'h11';
            }
            else {
                hc = 'h12';
            }
        }
        else {
            utils_1.invariant(!hour12, 'hour12 must not be set');
            if (hcDefault === 'h11' || hcDefault === 'h23') {
                hc = 'h23';
            }
            else {
                hc = 'h24';
            }
        }
    }
    return hc;
}
var TYPE_REGEX = /^[a-z0-9]{3,8}$/i;
/**
 * https://tc39.es/ecma402/#sec-initializedatetimeformat
 * @param dtf DateTimeFormat
 * @param locales locales
 * @param opts options
 */
function InitializeDateTimeFormat(dtf, locales, opts, _a) {
    var getInternalSlots = _a.getInternalSlots, availableLocales = _a.availableLocales, localeData = _a.localeData, getDefaultLocale = _a.getDefaultLocale, getDefaultTimeZone = _a.getDefaultTimeZone, relevantExtensionKeys = _a.relevantExtensionKeys, tzData = _a.tzData, uppercaseLinks = _a.uppercaseLinks;
    // @ts-ignore
    var requestedLocales = CanonicalizeLocaleList_1.CanonicalizeLocaleList(locales);
    var options = ToDateTimeOptions_1.ToDateTimeOptions(opts, 'any', 'date');
    var opt = Object.create(null);
    var matcher = GetOption_1.GetOption(options, 'localeMatcher', 'string', ['lookup', 'best fit'], 'best fit');
    opt.localeMatcher = matcher;
    var calendar = GetOption_1.GetOption(options, 'calendar', 'string', undefined, undefined);
    if (calendar !== undefined && !TYPE_REGEX.test(calendar)) {
        throw new RangeError('Malformed calendar');
    }
    var internalSlots = getInternalSlots(dtf);
    opt.ca = calendar;
    var numberingSystem = GetOption_1.GetOption(options, 'numberingSystem', 'string', undefined, undefined);
    if (numberingSystem !== undefined && !TYPE_REGEX.test(numberingSystem)) {
        throw new RangeError('Malformed numbering system');
    }
    opt.nu = numberingSystem;
    var hour12 = GetOption_1.GetOption(options, 'hour12', 'boolean', undefined, undefined);
    var hourCycle = GetOption_1.GetOption(options, 'hourCycle', 'string', ['h11', 'h12', 'h23', 'h24'], undefined);
    if (hour12 !== undefined) {
        // @ts-ignore
        hourCycle = null;
    }
    opt.hc = hourCycle;
    var r = ResolveLocale_1.ResolveLocale(availableLocales, requestedLocales, opt, relevantExtensionKeys, localeData, getDefaultLocale);
    internalSlots.locale = r.locale;
    calendar = r.ca;
    internalSlots.calendar = calendar;
    internalSlots.hourCycle = r.hc;
    internalSlots.numberingSystem = r.nu;
    var dataLocale = r.dataLocale;
    internalSlots.dataLocale = dataLocale;
    var timeZone = options.timeZone;
    if (timeZone !== undefined) {
        timeZone = String(timeZone);
        if (!IsValidTimeZoneName_1.IsValidTimeZoneName(timeZone, { tzData: tzData, uppercaseLinks: uppercaseLinks })) {
            throw new RangeError('Invalid timeZoneName');
        }
        timeZone = CanonicalizeTimeZoneName_1.CanonicalizeTimeZoneName(timeZone, { tzData: tzData, uppercaseLinks: uppercaseLinks });
    }
    else {
        timeZone = getDefaultTimeZone();
    }
    internalSlots.timeZone = timeZone;
    opt = Object.create(null);
    opt.weekday = GetOption_1.GetOption(options, 'weekday', 'string', ['narrow', 'short', 'long'], undefined);
    opt.era = GetOption_1.GetOption(options, 'era', 'string', ['narrow', 'short', 'long'], undefined);
    opt.year = GetOption_1.GetOption(options, 'year', 'string', ['2-digit', 'numeric'], undefined);
    opt.month = GetOption_1.GetOption(options, 'month', 'string', ['2-digit', 'numeric', 'narrow', 'short', 'long'], undefined);
    opt.day = GetOption_1.GetOption(options, 'day', 'string', ['2-digit', 'numeric'], undefined);
    opt.hour = GetOption_1.GetOption(options, 'hour', 'string', ['2-digit', 'numeric'], undefined);
    opt.minute = GetOption_1.GetOption(options, 'minute', 'string', ['2-digit', 'numeric'], undefined);
    opt.second = GetOption_1.GetOption(options, 'second', 'string', ['2-digit', 'numeric'], undefined);
    opt.timeZoneName = GetOption_1.GetOption(options, 'timeZoneName', 'string', ['short', 'long'], undefined);
    var dataLocaleData = localeData[dataLocale];
    utils_1.invariant(!!dataLocaleData, "Missing locale data for " + dataLocale);
    var formats = dataLocaleData.formats[calendar];
    // UNSPECCED: IMPLEMENTATION DETAILS
    if (!formats) {
        throw new RangeError("Calendar \"" + calendar + "\" is not supported. Try setting \"calendar\" to 1 of the following: " + Object.keys(dataLocaleData.formats).join(', '));
    }
    matcher = GetOption_1.GetOption(options, 'formatMatcher', 'string', ['basic', 'best fit'], 'best fit');
    var dateStyle = GetOption_1.GetOption(options, 'dateStyle', 'string', ['full', 'long', 'medium', 'short'], undefined);
    internalSlots.dateStyle = dateStyle;
    var timeStyle = GetOption_1.GetOption(options, 'timeStyle', 'string', ['full', 'long', 'medium', 'short'], undefined);
    internalSlots.timeStyle = timeStyle;
    var bestFormat;
    if (dateStyle === undefined && timeStyle === undefined) {
        if (matcher === 'basic') {
            bestFormat = BasicFormatMatcher_1.BasicFormatMatcher(opt, formats);
        }
        else {
            // IMPL DETAILS START
            if (isTimeRelated(opt)) {
                var hc = resolveHourCycle(internalSlots.hourCycle, dataLocaleData.hourCycle, hour12);
                opt.hour12 = hc === 'h11' || hc === 'h12';
            }
            // IMPL DETAILS END
            bestFormat = BestFitFormatMatcher_1.BestFitFormatMatcher(opt, formats);
        }
    }
    else {
        for (var _i = 0, DATE_TIME_PROPS_1 = utils_2.DATE_TIME_PROPS; _i < DATE_TIME_PROPS_1.length; _i++) {
            var prop = DATE_TIME_PROPS_1[_i];
            var p = opt[prop];
            if (p !== undefined) {
                throw new TypeError("Intl.DateTimeFormat can't set option " + prop + " when " + (dateStyle ? 'dateStyle' : 'timeStyle') + " is used");
            }
        }
        bestFormat = DateTimeStyleFormat_1.DateTimeStyleFormat(dateStyle, timeStyle, dataLocaleData);
    }
    // IMPL DETAIL START
    // For debugging
    internalSlots.format = bestFormat;
    // IMPL DETAIL END
    for (var prop in opt) {
        var p = bestFormat[prop];
        if (p !== undefined) {
            internalSlots[prop] = p;
        }
    }
    var pattern;
    var rangePatterns;
    if (internalSlots.hour !== undefined) {
        var hc = resolveHourCycle(internalSlots.hourCycle, dataLocaleData.hourCycle, hour12);
        internalSlots.hourCycle = hc;
        if (hc === 'h11' || hc === 'h12') {
            pattern = bestFormat.pattern12;
            rangePatterns = bestFormat.rangePatterns12;
        }
        else {
            pattern = bestFormat.pattern;
            rangePatterns = bestFormat.rangePatterns;
        }
    }
    else {
        // @ts-ignore
        internalSlots.hourCycle = undefined;
        pattern = bestFormat.pattern;
        rangePatterns = bestFormat.rangePatterns;
    }
    internalSlots.pattern = pattern;
    internalSlots.rangePatterns = rangePatterns;
    return dtf;
}
exports.InitializeDateTimeFormat = InitializeDateTimeFormat;

},{"../CanonicalizeLocaleList":10,"../CanonicalizeTimeZoneName":11,"../GetOption":30,"../IsValidTimeZoneName":32,"../ResolveLocale":60,"../utils":71,"./BasicFormatMatcher":12,"./BestFitFormatMatcher":13,"./DateTimeStyleFormat":14,"./ToDateTimeOptions":23,"./utils":26}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PartitionDateTimePattern = void 0;
var _262_1 = require("../262");
var FormatDateTimePattern_1 = require("./FormatDateTimePattern");
var PartitionPattern_1 = require("../PartitionPattern");
/**
 * https://tc39.es/ecma402/#sec-partitiondatetimepattern
 * @param dtf
 * @param x
 */
function PartitionDateTimePattern(dtf, x, implDetails) {
    x = _262_1.TimeClip(x);
    if (isNaN(x)) {
        throw new RangeError('invalid time');
    }
    /** IMPL START */
    var getInternalSlots = implDetails.getInternalSlots;
    var internalSlots = getInternalSlots(dtf);
    /** IMPL END */
    var pattern = internalSlots.pattern;
    return FormatDateTimePattern_1.FormatDateTimePattern(dtf, PartitionPattern_1.PartitionPattern(pattern), x, implDetails);
}
exports.PartitionDateTimePattern = PartitionDateTimePattern;

},{"../262":7,"../PartitionPattern":50,"./FormatDateTimePattern":16}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PartitionDateTimeRangePattern = void 0;
var _262_1 = require("../262");
var ToLocalTime_1 = require("./ToLocalTime");
var FormatDateTimePattern_1 = require("./FormatDateTimePattern");
var PartitionPattern_1 = require("../PartitionPattern");
var TABLE_2_FIELDS = [
    'era',
    'year',
    'month',
    'day',
    'ampm',
    'hour',
    'minute',
    'second',
];
function PartitionDateTimeRangePattern(dtf, x, y, implDetails) {
    x = _262_1.TimeClip(x);
    if (isNaN(x)) {
        throw new RangeError('Invalid start time');
    }
    y = _262_1.TimeClip(y);
    if (isNaN(y)) {
        throw new RangeError('Invalid end time');
    }
    /** IMPL START */
    var getInternalSlots = implDetails.getInternalSlots, tzData = implDetails.tzData;
    var internalSlots = getInternalSlots(dtf);
    /** IMPL END */
    var tm1 = ToLocalTime_1.ToLocalTime(x, 
    // @ts-ignore
    internalSlots.calendar, internalSlots.timeZone, { tzData: tzData });
    var tm2 = ToLocalTime_1.ToLocalTime(y, 
    // @ts-ignore
    internalSlots.calendar, internalSlots.timeZone, { tzData: tzData });
    var pattern = internalSlots.pattern, rangePatterns = internalSlots.rangePatterns;
    var rangePattern;
    var dateFieldsPracticallyEqual = true;
    var patternContainsLargerDateField = false;
    for (var _i = 0, TABLE_2_FIELDS_1 = TABLE_2_FIELDS; _i < TABLE_2_FIELDS_1.length; _i++) {
        var fieldName = TABLE_2_FIELDS_1[_i];
        if (dateFieldsPracticallyEqual && !patternContainsLargerDateField) {
            if (fieldName === 'ampm') {
                var rp = rangePatterns.ampm;
                if (rangePattern !== undefined && rp === undefined) {
                    patternContainsLargerDateField = true;
                }
                else {
                    var v1 = tm1.hour;
                    var v2 = tm2.hour;
                    if ((v1 > 11 && v2 < 11) || (v1 < 11 && v2 > 11)) {
                        dateFieldsPracticallyEqual = false;
                    }
                    rangePattern = rp;
                }
            }
            else {
                var rp = rangePatterns[fieldName];
                if (rangePattern !== undefined && rp === undefined) {
                    patternContainsLargerDateField = true;
                }
                else {
                    var v1 = tm1[fieldName];
                    var v2 = tm2[fieldName];
                    if (!_262_1.SameValue(v1, v2)) {
                        dateFieldsPracticallyEqual = false;
                    }
                    rangePattern = rp;
                }
            }
        }
    }
    if (dateFieldsPracticallyEqual) {
        var result_2 = FormatDateTimePattern_1.FormatDateTimePattern(dtf, PartitionPattern_1.PartitionPattern(pattern), x, implDetails);
        for (var _a = 0, result_1 = result_2; _a < result_1.length; _a++) {
            var r = result_1[_a];
            r.source = "shared" /* shared */;
        }
        return result_2;
    }
    var result = [];
    if (rangePattern === undefined) {
        rangePattern = rangePatterns.default;
        /** IMPL DETAILS */
        // Now we have to replace {0} & {1} with actual pattern
        for (var _b = 0, _c = rangePattern.patternParts; _b < _c.length; _b++) {
            var patternPart = _c[_b];
            if (patternPart.pattern === '{0}' || patternPart.pattern === '{1}') {
                patternPart.pattern = pattern;
            }
        }
    }
    for (var _d = 0, _e = rangePattern.patternParts; _d < _e.length; _d++) {
        var rangePatternPart = _e[_d];
        var source = rangePatternPart.source, pattern_1 = rangePatternPart.pattern;
        var z = void 0;
        if (source === "startRange" /* startRange */ ||
            source === "shared" /* shared */) {
            z = x;
        }
        else {
            z = y;
        }
        var patternParts = PartitionPattern_1.PartitionPattern(pattern_1);
        var partResult = FormatDateTimePattern_1.FormatDateTimePattern(dtf, patternParts, z, implDetails);
        for (var _f = 0, partResult_1 = partResult; _f < partResult_1.length; _f++) {
            var r = partResult_1[_f];
            r.source = source;
        }
        result = result.concat(partResult);
    }
    return result;
}
exports.PartitionDateTimeRangePattern = PartitionDateTimeRangePattern;

},{"../262":7,"../PartitionPattern":50,"./FormatDateTimePattern":16,"./ToLocalTime":24}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToDateTimeOptions = void 0;
var _262_1 = require("../262");
/**
 * https://tc39.es/ecma402/#sec-todatetimeoptions
 * @param options
 * @param required
 * @param defaults
 */
function ToDateTimeOptions(options, required, defaults) {
    if (options === undefined) {
        options = null;
    }
    else {
        options = _262_1.ToObject(options);
    }
    options = Object.create(options);
    var needDefaults = true;
    if (required === 'date' || required === 'any') {
        for (var _i = 0, _a = ['weekday', 'year', 'month', 'day']; _i < _a.length; _i++) {
            var prop = _a[_i];
            var value = options[prop];
            if (value !== undefined) {
                needDefaults = false;
            }
        }
    }
    if (required === 'time' || required === 'any') {
        for (var _b = 0, _c = ['hour', 'minute', 'second']; _b < _c.length; _b++) {
            var prop = _c[_b];
            var value = options[prop];
            if (value !== undefined) {
                needDefaults = false;
            }
        }
    }
    if (options.dateStyle !== undefined || options.timeStyle !== undefined) {
        needDefaults = false;
    }
    if (required === 'date' && options.timeStyle) {
        throw new TypeError('Intl.DateTimeFormat date was required but timeStyle was included');
    }
    if (required === 'time' && options.dateStyle) {
        throw new TypeError('Intl.DateTimeFormat time was required but dateStyle was included');
    }
    if (needDefaults && (defaults === 'date' || defaults === 'all')) {
        for (var _d = 0, _e = ['year', 'month', 'day']; _d < _e.length; _d++) {
            var prop = _e[_d];
            options[prop] = 'numeric';
        }
    }
    if (needDefaults && (defaults === 'time' || defaults === 'all')) {
        for (var _f = 0, _g = ['hour', 'minute', 'second']; _f < _g.length; _f++) {
            var prop = _g[_f];
            options[prop] = 'numeric';
        }
    }
    return options;
}
exports.ToDateTimeOptions = ToDateTimeOptions;

},{"../262":7}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToLocalTime = void 0;
var utils_1 = require("../utils");
var _262_1 = require("../262");
function getApplicableZoneData(t, timeZone, tzData) {
    var _a;
    var zoneData = tzData[timeZone];
    // We don't have data for this so just say it's UTC
    if (!zoneData) {
        return [0, false];
    }
    var i = 0;
    var offset = 0;
    var dst = false;
    for (; i <= zoneData.length; i++) {
        if (i === zoneData.length || zoneData[i][0] * 1e3 > t) {
            _a = zoneData[i - 1], offset = _a[2], dst = _a[3];
            break;
        }
    }
    return [offset * 1e3, dst];
}
/**
 * https://tc39.es/ecma402/#sec-tolocaltime
 * @param t
 * @param calendar
 * @param timeZone
 */
function ToLocalTime(t, calendar, timeZone, _a) {
    var tzData = _a.tzData;
    utils_1.invariant(_262_1.Type(t) === 'Number', 'invalid time');
    utils_1.invariant(calendar === 'gregory', 'We only support Gregory calendar right now');
    var _b = getApplicableZoneData(t, timeZone, tzData), timeZoneOffset = _b[0], inDST = _b[1];
    var tz = t + timeZoneOffset;
    var year = _262_1.YearFromTime(tz);
    return {
        weekday: _262_1.WeekDay(tz),
        era: year < 0 ? 'BC' : 'AD',
        year: year,
        relatedYear: undefined,
        yearName: undefined,
        month: _262_1.MonthFromTime(tz),
        day: _262_1.DateFromTime(tz),
        hour: _262_1.HourFromTime(tz),
        minute: _262_1.MinFromTime(tz),
        second: _262_1.SecFromTime(tz),
        inDST: inDST,
        // IMPORTANT: Not in spec
        timeZoneOffset: timeZoneOffset,
    };
}
exports.ToLocalTime = ToLocalTime;

},{"../262":7,"../utils":71}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.splitRangePattern = exports.splitFallbackRangePattern = exports.parseDateTimeSkeleton = exports.processDateTimePattern = void 0;
var tslib_1 = require("tslib");
/**
 * https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * Credit: https://github.com/caridy/intl-datetimeformat-pattern/blob/master/index.js
 * with some tweaks
 */
var DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
// trim patterns after transformations
var expPatternTrimmer = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
function matchSkeletonPattern(match, result) {
    var len = match.length;
    switch (match[0]) {
        // Era
        case 'G':
            result.era = len === 4 ? 'long' : len === 5 ? 'narrow' : 'short';
            return '{era}';
        // Year
        case 'y':
        case 'Y':
        case 'u':
        case 'U':
        case 'r':
            result.year = len === 2 ? '2-digit' : 'numeric';
            return '{year}';
        // Quarter
        case 'q':
        case 'Q':
            throw new RangeError('`w/Q` (quarter) patterns are not supported');
        // Month
        case 'M':
        case 'L':
            result.month = ['numeric', '2-digit', 'short', 'long', 'narrow'][len - 1];
            return '{month}';
        // Week
        case 'w':
        case 'W':
            throw new RangeError('`w/W` (week of year) patterns are not supported');
        case 'd':
            result.day = ['numeric', '2-digit'][len - 1];
            return '{day}';
        case 'D':
        case 'F':
        case 'g':
            result.day = 'numeric';
            return '{day}';
        // Weekday
        case 'E':
            result.weekday = len === 4 ? 'long' : len === 5 ? 'narrow' : 'short';
            return '{weekday}';
        case 'e':
            result.weekday = [
                'numeric',
                '2-digit',
                'short',
                'long',
                'narrow',
                'short',
            ][len - 1];
            return '{weekday}';
        case 'c':
            result.weekday = [
                'numeric',
                undefined,
                'short',
                'long',
                'narrow',
                'short',
            ][len - 1];
            return '{weekday}';
        // Period
        case 'a': // AM, PM
        case 'b': // am, pm, noon, midnight
        case 'B': // flexible day periods
            result.hour12 = true;
            return '{ampm}';
        // Hour
        case 'h':
            result.hour = ['numeric', '2-digit'][len - 1];
            result.hour12 = true;
            return '{hour}';
        case 'H':
            result.hour = ['numeric', '2-digit'][len - 1];
            return '{hour}';
        case 'K':
            result.hour = ['numeric', '2-digit'][len - 1];
            result.hour12 = true;
            return '{hour}';
        case 'k':
            result.hour = ['numeric', '2-digit'][len - 1];
            return '{hour}';
        case 'j':
        case 'J':
        case 'C':
            throw new RangeError('`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead');
        // Minute
        case 'm':
            result.minute = ['numeric', '2-digit'][len - 1];
            return '{minute}';
        // Second
        case 's':
            result.second = ['numeric', '2-digit'][len - 1];
            return '{second}';
        case 'S':
        case 'A':
            result.second = 'numeric';
            return '{second}';
        // Zone
        case 'z': // 1..3, 4: specific non-location format
        case 'Z': // 1..3, 4, 5: The ISO8601 varios formats
        case 'O': // 1, 4: miliseconds in day short, long
        case 'v': // 1, 4: generic non-location format
        case 'V': // 1, 2, 3, 4: time zone ID or city
        case 'X': // 1, 2, 3, 4: The ISO8601 varios formats
        case 'x': // 1, 2, 3, 4: The ISO8601 varios formats
            result.timeZoneName = len < 4 ? 'short' : 'long';
            return '{timeZoneName}';
    }
    return '';
}
function skeletonTokenToTable2(c) {
    switch (c) {
        // Era
        case 'G':
            return 'era';
        // Year
        case 'y':
        case 'Y':
        case 'u':
        case 'U':
        case 'r':
            return 'year';
        // Month
        case 'M':
        case 'L':
            return 'month';
        // Day
        case 'd':
        case 'D':
        case 'F':
        case 'g':
            return 'day';
        // Period
        case 'a': // AM, PM
        case 'b': // am, pm, noon, midnight
        case 'B': // flexible day periods
            return 'ampm';
        // Hour
        case 'h':
        case 'H':
        case 'K':
        case 'k':
            return 'hour';
        // Minute
        case 'm':
            return 'minute';
        // Second
        case 's':
        case 'S':
        case 'A':
            return 'second';
        default:
            throw new RangeError('Invalid range pattern token');
    }
}
function processDateTimePattern(pattern, result) {
    var literals = [];
    // Use skeleton to populate result, but use mapped pattern to populate pattern
    var pattern12 = pattern
        // Double apostrophe
        .replace(/'{2}/g, '{apostrophe}')
        // Apostrophe-escaped
        .replace(/'(.*?)'/g, function (_, literal) {
        literals.push(literal);
        return "$$" + (literals.length - 1) + "$$";
    })
        .replace(DATE_TIME_REGEX, function (m) { return matchSkeletonPattern(m, result || {}); });
    //Restore literals
    if (literals.length) {
        pattern12 = pattern12
            .replace(/\$\$(\d+)\$\$/g, function (_, i) {
            return literals[+i];
        })
            .replace(/\{apostrophe\}/g, "'");
    }
    // Handle apostrophe-escaped things
    return [
        pattern12
            .replace(/([\s\uFEFF\xA0])\{ampm\}([\s\uFEFF\xA0])/, '$1')
            .replace('{ampm}', '')
            .replace(expPatternTrimmer, ''),
        pattern12,
    ];
}
exports.processDateTimePattern = processDateTimePattern;
/**
 * Parse Date time skeleton into Intl.DateTimeFormatOptions
 * Ref: https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * @public
 * @param skeleton skeleton string
 */
function parseDateTimeSkeleton(skeleton, rawPattern, rangePatterns, intervalFormatFallback) {
    if (rawPattern === void 0) { rawPattern = skeleton; }
    var result = {
        pattern: '',
        pattern12: '',
        skeleton: skeleton,
        rawPattern: rawPattern,
        rangePatterns: {},
        rangePatterns12: {},
    };
    if (rangePatterns) {
        for (var k in rangePatterns) {
            var key = skeletonTokenToTable2(k);
            var rawPattern_1 = rangePatterns[k];
            var intervalResult = {
                patternParts: [],
            };
            var _a = processDateTimePattern(rawPattern_1, intervalResult), pattern_1 = _a[0], pattern12_1 = _a[1];
            result.rangePatterns[key] = tslib_1.__assign(tslib_1.__assign({}, intervalResult), { patternParts: splitRangePattern(pattern_1) });
            result.rangePatterns12[key] = tslib_1.__assign(tslib_1.__assign({}, intervalResult), { patternParts: splitRangePattern(pattern12_1) });
        }
    }
    else if (intervalFormatFallback) {
        var patternParts = splitFallbackRangePattern(intervalFormatFallback);
        result.rangePatterns.default = {
            patternParts: patternParts,
        };
        result.rangePatterns12.default = {
            patternParts: patternParts,
        };
    }
    // Process skeleton
    skeleton.replace(DATE_TIME_REGEX, function (m) { return matchSkeletonPattern(m, result); });
    var _b = processDateTimePattern(rawPattern), pattern = _b[0], pattern12 = _b[1];
    result.pattern = pattern;
    result.pattern12 = pattern12;
    return result;
}
exports.parseDateTimeSkeleton = parseDateTimeSkeleton;
function splitFallbackRangePattern(pattern) {
    var parts = pattern.split(/(\{[0|1]\})/g).filter(Boolean);
    return parts.map(function (pattern) {
        switch (pattern) {
            case '{0}':
                return {
                    source: "startRange" /* startRange */,
                    pattern: pattern,
                };
            case '{1}':
                return {
                    source: "endRange" /* endRange */,
                    pattern: pattern,
                };
            default:
                return {
                    source: "shared" /* shared */,
                    pattern: pattern,
                };
        }
    });
}
exports.splitFallbackRangePattern = splitFallbackRangePattern;
function splitRangePattern(pattern) {
    var PART_REGEX = /\{(.*?)\}/g;
    // Map of part and index within the string
    var parts = {};
    var match;
    var splitIndex = 0;
    while ((match = PART_REGEX.exec(pattern))) {
        if (!(match[0] in parts)) {
            parts[match[0]] = match.index;
        }
        else {
            splitIndex = match.index;
            break;
        }
    }
    if (!splitIndex) {
        return [
            {
                source: "startRange" /* startRange */,
                pattern: pattern,
            },
        ];
    }
    return [
        {
            source: "startRange" /* startRange */,
            pattern: pattern.slice(0, splitIndex),
        },
        {
            source: "endRange" /* endRange */,
            pattern: pattern.slice(splitIndex),
        },
    ];
}
exports.splitRangePattern = splitRangePattern;

},{"tslib":88}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shortMorePenalty = exports.shortLessPenalty = exports.longMorePenalty = exports.longLessPenalty = exports.differentNumericTypePenalty = exports.additionPenalty = exports.removalPenalty = exports.DATE_TIME_PROPS = void 0;
exports.DATE_TIME_PROPS = [
    'weekday',
    'era',
    'year',
    'month',
    'day',
    'hour',
    'minute',
    'second',
    'timeZoneName',
];
exports.removalPenalty = 120;
exports.additionPenalty = 20;
exports.differentNumericTypePenalty = 15;
exports.longLessPenalty = 8;
exports.longMorePenalty = 6;
exports.shortLessPenalty = 6;
exports.shortMorePenalty = 3;

},{}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultNumberOption = void 0;
/**
 * https://tc39.es/ecma402/#sec-defaultnumberoption
 * @param val
 * @param min
 * @param max
 * @param fallback
 */
function DefaultNumberOption(val, min, max, fallback) {
    if (val !== undefined) {
        val = Number(val);
        if (isNaN(val) || val < min || val > max) {
            throw new RangeError(val + " is outside of range [" + min + ", " + max + "]");
        }
        return Math.floor(val);
    }
    return fallback;
}
exports.DefaultNumberOption = DefaultNumberOption;

},{}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CanonicalCodeForDisplayNames = void 0;
var CanonicalizeLocaleList_1 = require("../CanonicalizeLocaleList");
var utils_1 = require("../utils");
var IsWellFormedCurrencyCode_1 = require("../IsWellFormedCurrencyCode");
var UNICODE_REGION_SUBTAG_REGEX = /^([a-z]{2}|[0-9]{3})$/i;
var ALPHA_4 = /^[a-z]{4}$/i;
function isUnicodeRegionSubtag(region) {
    return UNICODE_REGION_SUBTAG_REGEX.test(region);
}
function isUnicodeScriptSubtag(script) {
    return ALPHA_4.test(script);
}
function CanonicalCodeForDisplayNames(type, code) {
    if (type === 'language') {
        return CanonicalizeLocaleList_1.CanonicalizeLocaleList([code])[0];
    }
    if (type === 'region') {
        if (!isUnicodeRegionSubtag(code)) {
            throw RangeError('invalid region');
        }
        return code.toUpperCase();
    }
    if (type === 'script') {
        if (!isUnicodeScriptSubtag(code)) {
            throw RangeError('invalid script');
        }
        return "" + code[0].toUpperCase() + code.slice(1);
    }
    utils_1.invariant(type === 'currency', 'invalid type');
    if (!IsWellFormedCurrencyCode_1.IsWellFormedCurrencyCode(code)) {
        throw RangeError('invalid currency');
    }
    return code.toUpperCase();
}
exports.CanonicalCodeForDisplayNames = CanonicalCodeForDisplayNames;

},{"../CanonicalizeLocaleList":10,"../IsWellFormedCurrencyCode":33,"../utils":71}],29:[function(require,module,exports){
"use strict";
/**
 * https://tc39.es/ecma402/#sec-getnumberoption
 * @param options
 * @param property
 * @param min
 * @param max
 * @param fallback
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetNumberOption = void 0;
var DefaultNumberOption_1 = require("./DefaultNumberOption");
function GetNumberOption(options, property, minimum, maximum, fallback) {
    var val = options[property];
    return DefaultNumberOption_1.DefaultNumberOption(val, minimum, maximum, fallback);
}
exports.GetNumberOption = GetNumberOption;

},{"./DefaultNumberOption":27}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetOption = void 0;
var _262_1 = require("./262");
/**
 * https://tc39.es/ecma402/#sec-getoption
 * @param opts
 * @param prop
 * @param type
 * @param values
 * @param fallback
 */
function GetOption(opts, prop, type, values, fallback) {
    // const descriptor = Object.getOwnPropertyDescriptor(opts, prop);
    var value = opts[prop];
    if (value !== undefined) {
        if (type !== 'boolean' && type !== 'string') {
            throw new TypeError('invalid type');
        }
        if (type === 'boolean') {
            value = Boolean(value);
        }
        if (type === 'string') {
            value = _262_1.ToString(value);
        }
        if (values !== undefined && !values.filter(function (val) { return val == value; }).length) {
            throw new RangeError(value + " is not within " + values.join(', '));
        }
        return value;
    }
    return fallback;
}
exports.GetOption = GetOption;

},{"./262":7}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IsSanctionedSimpleUnitIdentifier = exports.SIMPLE_UNITS = exports.removeUnitNamespace = exports.SANCTIONED_UNITS = void 0;
/**
 * https://tc39.es/ecma402/#table-sanctioned-simple-unit-identifiers
 */
exports.SANCTIONED_UNITS = [
    'angle-degree',
    'area-acre',
    'area-hectare',
    'concentr-percent',
    'digital-bit',
    'digital-byte',
    'digital-gigabit',
    'digital-gigabyte',
    'digital-kilobit',
    'digital-kilobyte',
    'digital-megabit',
    'digital-megabyte',
    'digital-petabyte',
    'digital-terabit',
    'digital-terabyte',
    'duration-day',
    'duration-hour',
    'duration-millisecond',
    'duration-minute',
    'duration-month',
    'duration-second',
    'duration-week',
    'duration-year',
    'length-centimeter',
    'length-foot',
    'length-inch',
    'length-kilometer',
    'length-meter',
    'length-mile-scandinavian',
    'length-mile',
    'length-millimeter',
    'length-yard',
    'mass-gram',
    'mass-kilogram',
    'mass-ounce',
    'mass-pound',
    'mass-stone',
    'temperature-celsius',
    'temperature-fahrenheit',
    'volume-fluid-ounce',
    'volume-gallon',
    'volume-liter',
    'volume-milliliter',
];
// In CLDR, the unit name always follows the form `namespace-unit` pattern.
// For example: `digital-bit` instead of `bit`. This function removes the namespace prefix.
function removeUnitNamespace(unit) {
    return unit.slice(unit.indexOf('-') + 1);
}
exports.removeUnitNamespace = removeUnitNamespace;
/**
 * https://tc39.es/ecma402/#table-sanctioned-simple-unit-identifiers
 */
exports.SIMPLE_UNITS = exports.SANCTIONED_UNITS.map(removeUnitNamespace);
/**
 * https://tc39.es/ecma402/#sec-issanctionedsimpleunitidentifier
 */
function IsSanctionedSimpleUnitIdentifier(unitIdentifier) {
    return exports.SIMPLE_UNITS.indexOf(unitIdentifier) > -1;
}
exports.IsSanctionedSimpleUnitIdentifier = IsSanctionedSimpleUnitIdentifier;

},{}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IsValidTimeZoneName = void 0;
/**
 * https://tc39.es/ecma402/#sec-isvalidtimezonename
 * @param tz
 * @param implDetails implementation details
 */
function IsValidTimeZoneName(tz, _a) {
    var tzData = _a.tzData, uppercaseLinks = _a.uppercaseLinks;
    var uppercasedTz = tz.toUpperCase();
    var zoneNames = new Set();
    Object.keys(tzData)
        .map(function (z) { return z.toUpperCase(); })
        .forEach(function (z) { return zoneNames.add(z); });
    return zoneNames.has(uppercasedTz) || uppercasedTz in uppercaseLinks;
}
exports.IsValidTimeZoneName = IsValidTimeZoneName;

},{}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IsWellFormedCurrencyCode = void 0;
/**
 * This follows https://tc39.es/ecma402/#sec-case-sensitivity-and-case-mapping
 * @param str string to convert
 */
function toUpperCase(str) {
    return str.replace(/([a-z])/g, function (_, c) { return c.toUpperCase(); });
}
var NOT_A_Z_REGEX = /[^A-Z]/;
/**
 * https://tc39.es/ecma402/#sec-iswellformedcurrencycode
 */
function IsWellFormedCurrencyCode(currency) {
    currency = toUpperCase(currency);
    if (currency.length !== 3) {
        return false;
    }
    if (NOT_A_Z_REGEX.test(currency)) {
        return false;
    }
    return true;
}
exports.IsWellFormedCurrencyCode = IsWellFormedCurrencyCode;

},{}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IsWellFormedUnitIdentifier = void 0;
var IsSanctionedSimpleUnitIdentifier_1 = require("./IsSanctionedSimpleUnitIdentifier");
/**
 * This follows https://tc39.es/ecma402/#sec-case-sensitivity-and-case-mapping
 * @param str string to convert
 */
function toLowerCase(str) {
    return str.replace(/([A-Z])/g, function (_, c) { return c.toLowerCase(); });
}
/**
 * https://tc39.es/ecma402/#sec-iswellformedunitidentifier
 * @param unit
 */
function IsWellFormedUnitIdentifier(unit) {
    unit = toLowerCase(unit);
    if (IsSanctionedSimpleUnitIdentifier_1.IsSanctionedSimpleUnitIdentifier(unit)) {
        return true;
    }
    var units = unit.split('-per-');
    if (units.length !== 2) {
        return false;
    }
    var numerator = units[0], denominator = units[1];
    if (!IsSanctionedSimpleUnitIdentifier_1.IsSanctionedSimpleUnitIdentifier(numerator) ||
        !IsSanctionedSimpleUnitIdentifier_1.IsSanctionedSimpleUnitIdentifier(denominator)) {
        return false;
    }
    return true;
}
exports.IsWellFormedUnitIdentifier = IsWellFormedUnitIdentifier;

},{"./IsSanctionedSimpleUnitIdentifier":31}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LookupMatcher = void 0;
var utils_1 = require("./utils");
var BestAvailableLocale_1 = require("./BestAvailableLocale");
/**
 * https://tc39.es/ecma402/#sec-lookupmatcher
 * @param availableLocales
 * @param requestedLocales
 * @param getDefaultLocale
 */
function LookupMatcher(availableLocales, requestedLocales, getDefaultLocale) {
    var result = { locale: '' };
    for (var _i = 0, requestedLocales_1 = requestedLocales; _i < requestedLocales_1.length; _i++) {
        var locale = requestedLocales_1[_i];
        var noExtensionLocale = locale.replace(utils_1.UNICODE_EXTENSION_SEQUENCE_REGEX, '');
        var availableLocale = BestAvailableLocale_1.BestAvailableLocale(availableLocales, noExtensionLocale);
        if (availableLocale) {
            result.locale = availableLocale;
            if (locale !== noExtensionLocale) {
                result.extension = locale.slice(noExtensionLocale.length + 1, locale.length);
            }
            return result;
        }
    }
    result.locale = getDefaultLocale();
    return result;
}
exports.LookupMatcher = LookupMatcher;

},{"./BestAvailableLocale":8,"./utils":71}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LookupSupportedLocales = void 0;
var utils_1 = require("./utils");
var BestAvailableLocale_1 = require("./BestAvailableLocale");
/**
 * https://tc39.es/ecma402/#sec-lookupsupportedlocales
 * @param availableLocales
 * @param requestedLocales
 */
function LookupSupportedLocales(availableLocales, requestedLocales) {
    var subset = [];
    for (var _i = 0, requestedLocales_1 = requestedLocales; _i < requestedLocales_1.length; _i++) {
        var locale = requestedLocales_1[_i];
        var noExtensionLocale = locale.replace(utils_1.UNICODE_EXTENSION_SEQUENCE_REGEX, '');
        var availableLocale = BestAvailableLocale_1.BestAvailableLocale(availableLocales, noExtensionLocale);
        if (availableLocale) {
            subset.push(availableLocale);
        }
    }
    return subset;
}
exports.LookupSupportedLocales = LookupSupportedLocales;

},{"./BestAvailableLocale":8,"./utils":71}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComputeExponent = void 0;
var utils_1 = require("../utils");
var ComputeExponentForMagnitude_1 = require("./ComputeExponentForMagnitude");
var FormatNumericToString_1 = require("./FormatNumericToString");
/**
 * The abstract operation ComputeExponent computes an exponent (power of ten) by which to scale x
 * according to the number formatting settings. It handles cases such as 999 rounding up to 1000,
 * requiring a different exponent.
 *
 * NOT IN SPEC: it returns [exponent, magnitude].
 */
function ComputeExponent(numberFormat, x, _a) {
    var getInternalSlots = _a.getInternalSlots;
    if (x === 0) {
        return [0, 0];
    }
    if (x < 0) {
        x = -x;
    }
    var magnitude = utils_1.getMagnitude(x);
    var exponent = ComputeExponentForMagnitude_1.ComputeExponentForMagnitude(numberFormat, magnitude, {
        getInternalSlots: getInternalSlots,
    });
    // Preserve more precision by doing multiplication when exponent is negative.
    x = exponent < 0 ? x * Math.pow(10, -exponent) : x / Math.pow(10, exponent);
    var formatNumberResult = FormatNumericToString_1.FormatNumericToString(getInternalSlots(numberFormat), x);
    if (formatNumberResult.roundedNumber === 0) {
        return [exponent, magnitude];
    }
    var newMagnitude = utils_1.getMagnitude(formatNumberResult.roundedNumber);
    if (newMagnitude === magnitude - exponent) {
        return [exponent, magnitude];
    }
    return [
        ComputeExponentForMagnitude_1.ComputeExponentForMagnitude(numberFormat, magnitude + 1, {
            getInternalSlots: getInternalSlots,
        }),
        magnitude + 1,
    ];
}
exports.ComputeExponent = ComputeExponent;

},{"../utils":71,"./ComputeExponentForMagnitude":38,"./FormatNumericToString":41}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComputeExponentForMagnitude = void 0;
/**
 * The abstract operation ComputeExponentForMagnitude computes an exponent by which to scale a
 * number of the given magnitude (power of ten of the most significant digit) according to the
 * locale and the desired notation (scientific, engineering, or compact).
 */
function ComputeExponentForMagnitude(numberFormat, magnitude, _a) {
    var getInternalSlots = _a.getInternalSlots;
    var internalSlots = getInternalSlots(numberFormat);
    var notation = internalSlots.notation, dataLocaleData = internalSlots.dataLocaleData, numberingSystem = internalSlots.numberingSystem;
    switch (notation) {
        case 'standard':
            return 0;
        case 'scientific':
            return magnitude;
        case 'engineering':
            return Math.floor(magnitude / 3) * 3;
        default: {
            // Let exponent be an implementation- and locale-dependent (ILD) integer by which to scale a
            // number of the given magnitude in compact notation for the current locale.
            var compactDisplay = internalSlots.compactDisplay, style = internalSlots.style, currencyDisplay = internalSlots.currencyDisplay;
            var thresholdMap = void 0;
            if (style === 'currency' && currencyDisplay !== 'name') {
                var currency = dataLocaleData.numbers.currency[numberingSystem] ||
                    dataLocaleData.numbers.currency[dataLocaleData.numbers.nu[0]];
                thresholdMap = currency.short;
            }
            else {
                var decimal = dataLocaleData.numbers.decimal[numberingSystem] ||
                    dataLocaleData.numbers.decimal[dataLocaleData.numbers.nu[0]];
                thresholdMap = compactDisplay === 'long' ? decimal.long : decimal.short;
            }
            if (!thresholdMap) {
                return 0;
            }
            var num = String(Math.pow(10, magnitude));
            var thresholds = Object.keys(thresholdMap); // TODO: this can be pre-processed
            if (num < thresholds[0]) {
                return 0;
            }
            if (num > thresholds[thresholds.length - 1]) {
                return thresholds[thresholds.length - 1].length - 1;
            }
            var i = thresholds.indexOf(num);
            if (i === -1) {
                return 0;
            }
            // See https://unicode.org/reports/tr35/tr35-numbers.html#Compact_Number_Formats
            // Special handling if the pattern is precisely `0`.
            var magnitudeKey = thresholds[i];
            // TODO: do we need to handle plural here?
            var compactPattern = thresholdMap[magnitudeKey].other;
            if (compactPattern === '0') {
                return 0;
            }
            // Example: in zh-TW, `10000000` maps to `0000è¬`. So we need to return 8 - 4 = 4 here.
            return (magnitudeKey.length -
                thresholdMap[magnitudeKey].other.match(/0+/)[0].length);
        }
    }
}
exports.ComputeExponentForMagnitude = ComputeExponentForMagnitude;

},{}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CurrencyDigits = void 0;
var _262_1 = require("../262");
/**
 * https://tc39.es/ecma402/#sec-currencydigits
 */
function CurrencyDigits(c, _a) {
    var currencyDigitsData = _a.currencyDigitsData;
    return _262_1.HasOwnProperty(currencyDigitsData, c)
        ? currencyDigitsData[c]
        : 2;
}
exports.CurrencyDigits = CurrencyDigits;

},{"../262":7}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FormatNumericToParts = void 0;
var PartitionNumberPattern_1 = require("./PartitionNumberPattern");
var _262_1 = require("../262");
function FormatNumericToParts(nf, x, implDetails) {
    var parts = PartitionNumberPattern_1.PartitionNumberPattern(nf, x, implDetails);
    var result = _262_1.ArrayCreate(0);
    for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
        var part = parts_1[_i];
        result.push({
            type: part.type,
            value: part.value,
        });
    }
    return result;
}
exports.FormatNumericToParts = FormatNumericToParts;

},{"../262":7,"./PartitionNumberPattern":43}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FormatNumericToString = void 0;
var _262_1 = require("../262");
var ToRawPrecision_1 = require("./ToRawPrecision");
var utils_1 = require("../utils");
var ToRawFixed_1 = require("./ToRawFixed");
/**
 * https://tc39.es/ecma402/#sec-formatnumberstring
 */
function FormatNumericToString(intlObject, x) {
    var isNegative = x < 0 || _262_1.SameValue(x, -0);
    if (isNegative) {
        x = -x;
    }
    var result;
    var rourndingType = intlObject.roundingType;
    switch (rourndingType) {
        case 'significantDigits':
            result = ToRawPrecision_1.ToRawPrecision(x, intlObject.minimumSignificantDigits, intlObject.maximumSignificantDigits);
            break;
        case 'fractionDigits':
            result = ToRawFixed_1.ToRawFixed(x, intlObject.minimumFractionDigits, intlObject.maximumFractionDigits);
            break;
        default:
            result = ToRawPrecision_1.ToRawPrecision(x, 1, 2);
            if (result.integerDigitsCount > 1) {
                result = ToRawFixed_1.ToRawFixed(x, 0, 0);
            }
            break;
    }
    x = result.roundedNumber;
    var string = result.formattedString;
    var int = result.integerDigitsCount;
    var minInteger = intlObject.minimumIntegerDigits;
    if (int < minInteger) {
        var forwardZeros = utils_1.repeat('0', minInteger - int);
        string = forwardZeros + string;
    }
    if (isNegative) {
        x = -x;
    }
    return { roundedNumber: x, formattedString: string };
}
exports.FormatNumericToString = FormatNumericToString;

},{"../262":7,"../utils":71,"./ToRawFixed":46,"./ToRawPrecision":47}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InitializeNumberFormat = void 0;
var CanonicalizeLocaleList_1 = require("../CanonicalizeLocaleList");
var _262_1 = require("../262");
var GetOption_1 = require("../GetOption");
var ResolveLocale_1 = require("../ResolveLocale");
var SetNumberFormatUnitOptions_1 = require("./SetNumberFormatUnitOptions");
var CurrencyDigits_1 = require("./CurrencyDigits");
var SetNumberFormatDigitOptions_1 = require("./SetNumberFormatDigitOptions");
var utils_1 = require("../utils");
/**
 * https://tc39.es/ecma402/#sec-initializenumberformat
 */
function InitializeNumberFormat(nf, locales, opts, _a) {
    var getInternalSlots = _a.getInternalSlots, localeData = _a.localeData, availableLocales = _a.availableLocales, numberingSystemNames = _a.numberingSystemNames, getDefaultLocale = _a.getDefaultLocale, currencyDigitsData = _a.currencyDigitsData;
    // @ts-ignore
    var requestedLocales = CanonicalizeLocaleList_1.CanonicalizeLocaleList(locales);
    var options = opts === undefined ? Object.create(null) : _262_1.ToObject(opts);
    var opt = Object.create(null);
    var matcher = GetOption_1.GetOption(options, 'localeMatcher', 'string', ['lookup', 'best fit'], 'best fit');
    opt.localeMatcher = matcher;
    var numberingSystem = GetOption_1.GetOption(options, 'numberingSystem', 'string', undefined, undefined);
    if (numberingSystem !== undefined &&
        numberingSystemNames.indexOf(numberingSystem) < 0) {
        // 8.a. If numberingSystem does not match the Unicode Locale Identifier type nonterminal,
        // throw a RangeError exception.
        throw RangeError("Invalid numberingSystems: " + numberingSystem);
    }
    opt.nu = numberingSystem;
    var r = ResolveLocale_1.ResolveLocale(availableLocales, requestedLocales, opt, 
    // [[RelevantExtensionKeys]] slot, which is a constant
    ['nu'], localeData, getDefaultLocale);
    var dataLocaleData = localeData[r.dataLocale];
    utils_1.invariant(!!dataLocaleData, "Missing locale data for " + r.dataLocale);
    var internalSlots = getInternalSlots(nf);
    internalSlots.locale = r.locale;
    internalSlots.dataLocale = r.dataLocale;
    internalSlots.numberingSystem = r.nu;
    internalSlots.dataLocaleData = dataLocaleData;
    SetNumberFormatUnitOptions_1.SetNumberFormatUnitOptions(nf, options, { getInternalSlots: getInternalSlots });
    var style = internalSlots.style;
    var mnfdDefault;
    var mxfdDefault;
    if (style === 'currency') {
        var currency = internalSlots.currency;
        var cDigits = CurrencyDigits_1.CurrencyDigits(currency, { currencyDigitsData: currencyDigitsData });
        mnfdDefault = cDigits;
        mxfdDefault = cDigits;
    }
    else {
        mnfdDefault = 0;
        mxfdDefault = style === 'percent' ? 0 : 3;
    }
    var notation = GetOption_1.GetOption(options, 'notation', 'string', ['standard', 'scientific', 'engineering', 'compact'], 'standard');
    internalSlots.notation = notation;
    SetNumberFormatDigitOptions_1.SetNumberFormatDigitOptions(internalSlots, options, mnfdDefault, mxfdDefault, notation);
    var compactDisplay = GetOption_1.GetOption(options, 'compactDisplay', 'string', ['short', 'long'], 'short');
    if (notation === 'compact') {
        internalSlots.compactDisplay = compactDisplay;
    }
    var useGrouping = GetOption_1.GetOption(options, 'useGrouping', 'boolean', undefined, true);
    internalSlots.useGrouping = useGrouping;
    var signDisplay = GetOption_1.GetOption(options, 'signDisplay', 'string', ['auto', 'never', 'always', 'exceptZero'], 'auto');
    internalSlots.signDisplay = signDisplay;
    return nf;
}
exports.InitializeNumberFormat = InitializeNumberFormat;

},{"../262":7,"../CanonicalizeLocaleList":10,"../GetOption":30,"../ResolveLocale":60,"../utils":71,"./CurrencyDigits":39,"./SetNumberFormatDigitOptions":44,"./SetNumberFormatUnitOptions":45}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PartitionNumberPattern = void 0;
var tslib_1 = require("tslib");
var FormatNumericToString_1 = require("./FormatNumericToString");
var _262_1 = require("../262");
var ComputeExponent_1 = require("./ComputeExponent");
var format_to_parts_1 = tslib_1.__importDefault(require("./format_to_parts"));
/**
 * https://tc39.es/ecma402/#sec-formatnumberstring
 */
function PartitionNumberPattern(numberFormat, x, _a) {
    var _b;
    var getInternalSlots = _a.getInternalSlots;
    var internalSlots = getInternalSlots(numberFormat);
    var pl = internalSlots.pl, dataLocaleData = internalSlots.dataLocaleData, numberingSystem = internalSlots.numberingSystem;
    var symbols = dataLocaleData.numbers.symbols[numberingSystem] ||
        dataLocaleData.numbers.symbols[dataLocaleData.numbers.nu[0]];
    var magnitude = 0;
    var exponent = 0;
    var n;
    if (isNaN(x)) {
        n = symbols.nan;
    }
    else if (!isFinite(x)) {
        n = symbols.infinity;
    }
    else {
        if (internalSlots.style === 'percent') {
            x *= 100;
        }
        _b = ComputeExponent_1.ComputeExponent(numberFormat, x, {
            getInternalSlots: getInternalSlots,
        }), exponent = _b[0], magnitude = _b[1];
        // Preserve more precision by doing multiplication when exponent is negative.
        x = exponent < 0 ? x * Math.pow(10, -exponent) : x / Math.pow(10, exponent);
        var formatNumberResult = FormatNumericToString_1.FormatNumericToString(internalSlots, x);
        n = formatNumberResult.formattedString;
        x = formatNumberResult.roundedNumber;
    }
    // Based on https://tc39.es/ecma402/#sec-getnumberformatpattern
    // We need to do this before `x` is rounded.
    var sign;
    var signDisplay = internalSlots.signDisplay;
    switch (signDisplay) {
        case 'never':
            sign = 0;
            break;
        case 'auto':
            if (_262_1.SameValue(x, 0) || x > 0 || isNaN(x)) {
                sign = 0;
            }
            else {
                sign = -1;
            }
            break;
        case 'always':
            if (_262_1.SameValue(x, 0) || x > 0 || isNaN(x)) {
                sign = 1;
            }
            else {
                sign = -1;
            }
            break;
        default:
            // x === 0 -> x is 0 or x is -0
            if (x === 0 || isNaN(x)) {
                sign = 0;
            }
            else if (x > 0) {
                sign = 1;
            }
            else {
                sign = -1;
            }
    }
    return format_to_parts_1.default({ roundedNumber: x, formattedString: n, exponent: exponent, magnitude: magnitude, sign: sign }, internalSlots.dataLocaleData, pl, internalSlots);
}
exports.PartitionNumberPattern = PartitionNumberPattern;

},{"../262":7,"./ComputeExponent":37,"./FormatNumericToString":41,"./format_to_parts":49,"tslib":88}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SetNumberFormatDigitOptions = void 0;
var GetNumberOption_1 = require("../GetNumberOption");
var DefaultNumberOption_1 = require("../DefaultNumberOption");
/**
 * https://tc39.es/ecma402/#sec-setnfdigitoptions
 */
function SetNumberFormatDigitOptions(internalSlots, opts, mnfdDefault, mxfdDefault, notation) {
    var mnid = GetNumberOption_1.GetNumberOption(opts, 'minimumIntegerDigits', 1, 21, 1);
    var mnfd = opts.minimumFractionDigits;
    var mxfd = opts.maximumFractionDigits;
    var mnsd = opts.minimumSignificantDigits;
    var mxsd = opts.maximumSignificantDigits;
    internalSlots.minimumIntegerDigits = mnid;
    if (mnsd !== undefined || mxsd !== undefined) {
        internalSlots.roundingType = 'significantDigits';
        mnsd = DefaultNumberOption_1.DefaultNumberOption(mnsd, 1, 21, 1);
        mxsd = DefaultNumberOption_1.DefaultNumberOption(mxsd, mnsd, 21, 21);
        internalSlots.minimumSignificantDigits = mnsd;
        internalSlots.maximumSignificantDigits = mxsd;
    }
    else if (mnfd !== undefined || mxfd !== undefined) {
        internalSlots.roundingType = 'fractionDigits';
        mnfd = DefaultNumberOption_1.DefaultNumberOption(mnfd, 0, 20, mnfdDefault);
        var mxfdActualDefault = Math.max(mnfd, mxfdDefault);
        mxfd = DefaultNumberOption_1.DefaultNumberOption(mxfd, mnfd, 20, mxfdActualDefault);
        internalSlots.minimumFractionDigits = mnfd;
        internalSlots.maximumFractionDigits = mxfd;
    }
    else if (notation === 'compact') {
        internalSlots.roundingType = 'compactRounding';
    }
    else {
        internalSlots.roundingType = 'fractionDigits';
        internalSlots.minimumFractionDigits = mnfdDefault;
        internalSlots.maximumFractionDigits = mxfdDefault;
    }
}
exports.SetNumberFormatDigitOptions = SetNumberFormatDigitOptions;

},{"../DefaultNumberOption":27,"../GetNumberOption":29}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SetNumberFormatUnitOptions = void 0;
var GetOption_1 = require("../GetOption");
var IsWellFormedCurrencyCode_1 = require("../IsWellFormedCurrencyCode");
var IsWellFormedUnitIdentifier_1 = require("../IsWellFormedUnitIdentifier");
/**
 * https://tc39.es/ecma402/#sec-setnumberformatunitoptions
 */
function SetNumberFormatUnitOptions(nf, options, _a) {
    if (options === void 0) { options = Object.create(null); }
    var getInternalSlots = _a.getInternalSlots;
    var internalSlots = getInternalSlots(nf);
    var style = GetOption_1.GetOption(options, 'style', 'string', ['decimal', 'percent', 'currency', 'unit'], 'decimal');
    internalSlots.style = style;
    var currency = GetOption_1.GetOption(options, 'currency', 'string', undefined, undefined);
    if (currency !== undefined && !IsWellFormedCurrencyCode_1.IsWellFormedCurrencyCode(currency)) {
        throw RangeError('Malformed currency code');
    }
    if (style === 'currency' && currency === undefined) {
        throw TypeError('currency cannot be undefined');
    }
    var currencyDisplay = GetOption_1.GetOption(options, 'currencyDisplay', 'string', ['code', 'symbol', 'narrowSymbol', 'name'], 'symbol');
    var currencySign = GetOption_1.GetOption(options, 'currencySign', 'string', ['standard', 'accounting'], 'standard');
    var unit = GetOption_1.GetOption(options, 'unit', 'string', undefined, undefined);
    if (unit !== undefined && !IsWellFormedUnitIdentifier_1.IsWellFormedUnitIdentifier(unit)) {
        throw RangeError('Invalid unit argument for Intl.NumberFormat()');
    }
    if (style === 'unit' && unit === undefined) {
        throw TypeError('unit cannot be undefined');
    }
    var unitDisplay = GetOption_1.GetOption(options, 'unitDisplay', 'string', ['short', 'narrow', 'long'], 'short');
    if (style === 'currency') {
        internalSlots.currency = currency.toUpperCase();
        internalSlots.currencyDisplay = currencyDisplay;
        internalSlots.currencySign = currencySign;
    }
    if (style === 'unit') {
        internalSlots.unit = unit;
        internalSlots.unitDisplay = unitDisplay;
    }
}
exports.SetNumberFormatUnitOptions = SetNumberFormatUnitOptions;

},{"../GetOption":30,"../IsWellFormedCurrencyCode":33,"../IsWellFormedUnitIdentifier":34}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToRawFixed = void 0;
var utils_1 = require("../utils");
/**
 * TODO: dedup with intl-pluralrules and support BigInt
 * https://tc39.es/ecma402/#sec-torawfixed
 * @param x a finite non-negative Number or BigInt
 * @param minFraction and integer between 0 and 20
 * @param maxFraction and integer between 0 and 20
 */
function ToRawFixed(x, minFraction, maxFraction) {
    var f = maxFraction;
    var n = Math.round(x * Math.pow(10, f));
    var xFinal = n / Math.pow(10, f);
    // n is a positive integer, but it is possible to be greater than 1e21.
    // In such case we will go the slow path.
    // See also: https://tc39.es/ecma262/#sec-numeric-types-number-tostring
    var m;
    if (n < 1e21) {
        m = n.toString();
    }
    else {
        m = n.toString();
        var _a = m.split('e'), mantissa = _a[0], exponent = _a[1];
        m = mantissa.replace('.', '');
        m = m + utils_1.repeat('0', Math.max(+exponent - m.length + 1, 0));
    }
    var int;
    if (f !== 0) {
        var k = m.length;
        if (k <= f) {
            var z = utils_1.repeat('0', f + 1 - k);
            m = z + m;
            k = f + 1;
        }
        var a = m.slice(0, k - f);
        var b = m.slice(k - f);
        m = a + "." + b;
        int = a.length;
    }
    else {
        int = m.length;
    }
    var cut = maxFraction - minFraction;
    while (cut > 0 && m[m.length - 1] === '0') {
        m = m.slice(0, -1);
        cut--;
    }
    if (m[m.length - 1] === '.') {
        m = m.slice(0, -1);
    }
    return { formattedString: m, roundedNumber: xFinal, integerDigitsCount: int };
}
exports.ToRawFixed = ToRawFixed;

},{"../utils":71}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToRawPrecision = void 0;
var utils_1 = require("../utils");
function ToRawPrecision(x, minPrecision, maxPrecision) {
    var p = maxPrecision;
    var m;
    var e;
    var xFinal;
    if (x === 0) {
        m = utils_1.repeat('0', p);
        e = 0;
        xFinal = 0;
    }
    else {
        var xToString = x.toString();
        // If xToString is formatted as scientific notation, the number is either very small or very
        // large. If the precision of the formatted string is lower that requested max precision, we
        // should still infer them from the formatted string, otherwise the formatted result might have
        // precision loss (e.g. 1e41 will not have 0 in every trailing digits).
        var xToStringExponentIndex = xToString.indexOf('e');
        var _a = xToString.split('e'), xToStringMantissa = _a[0], xToStringExponent = _a[1];
        var xToStringMantissaWithoutDecimalPoint = xToStringMantissa.replace('.', '');
        if (xToStringExponentIndex >= 0 &&
            xToStringMantissaWithoutDecimalPoint.length <= p) {
            e = +xToStringExponent;
            m =
                xToStringMantissaWithoutDecimalPoint +
                    utils_1.repeat('0', p - xToStringMantissaWithoutDecimalPoint.length);
            xFinal = x;
        }
        else {
            e = utils_1.getMagnitude(x);
            var decimalPlaceOffset = e - p + 1;
            // n is the integer containing the required precision digits. To derive the formatted string,
            // we will adjust its decimal place in the logic below.
            var n = Math.round(adjustDecimalPlace(x, decimalPlaceOffset));
            // The rounding caused the change of magnitude, so we should increment `e` by 1.
            if (adjustDecimalPlace(n, p - 1) >= 10) {
                e = e + 1;
                // Divide n by 10 to swallow one precision.
                n = Math.floor(n / 10);
            }
            m = n.toString();
            // Equivalent of n * 10 ** (e - p + 1)
            xFinal = adjustDecimalPlace(n, p - 1 - e);
        }
    }
    var int;
    if (e >= p - 1) {
        m = m + utils_1.repeat('0', e - p + 1);
        int = e + 1;
    }
    else if (e >= 0) {
        m = m.slice(0, e + 1) + "." + m.slice(e + 1);
        int = e + 1;
    }
    else {
        m = "0." + utils_1.repeat('0', -e - 1) + m;
        int = 1;
    }
    if (m.indexOf('.') >= 0 && maxPrecision > minPrecision) {
        var cut = maxPrecision - minPrecision;
        while (cut > 0 && m[m.length - 1] === '0') {
            m = m.slice(0, -1);
            cut--;
        }
        if (m[m.length - 1] === '.') {
            m = m.slice(0, -1);
        }
    }
    return { formattedString: m, roundedNumber: xFinal, integerDigitsCount: int };
    // x / (10 ** magnitude), but try to preserve as much floating point precision as possible.
    function adjustDecimalPlace(x, magnitude) {
        return magnitude < 0 ? x * Math.pow(10, -magnitude) : x / Math.pow(10, magnitude);
    }
}
exports.ToRawPrecision = ToRawPrecision;

},{"../utils":71}],48:[function(require,module,exports){
module.exports={ "adlm": ["ğ¥", "ğ¥‘", "ğ¥’", "ğ¥“", "ğ¥”", "ğ¥•", "ğ¥–", "ğ¥—", "ğ¥˜", "ğ¥™"], "ahom": ["ğ‘œ°", "ğ‘œ±", "ğ‘œ²", "ğ‘œ³", "ğ‘œ´", "ğ‘œµ", "ğ‘œ¶", "ğ‘œ·", "ğ‘œ¸", "ğ‘œ¹"], "arab": ["Ù ", "Ù¡", "Ù¢", "Ù£", "Ù¤", "Ù¥", "Ù¦", "Ù§", "Ù¨", "Ù©"], "arabext": ["Û°", "Û±", "Û²", "Û³", "Û´", "Ûµ", "Û¶", "Û·", "Û¸", "Û¹"], "bali": ["á­", "á­‘", "á­’", "á­“", "á­”", "á­•", "á­–", "á­—", "á­˜", "á­™"], "beng": ["à§¦", "à§§", "à§¨", "à§©", "à§ª", "à§«", "à§¬", "à§­", "à§®", "à§¯"], "bhks": ["ğ‘±", "ğ‘±‘", "ğ‘±’", "ğ‘±“", "ğ‘±”", "ğ‘±•", "ğ‘±–", "ğ‘±—", "ğ‘±˜", "ğ‘±™"], "brah": ["ğ‘¦", "ğ‘§", "ğ‘¨", "ğ‘©", "ğ‘ª", "ğ‘«", "ğ‘¬", "ğ‘­", "ğ‘®", "ğ‘¯"], "cakm": ["ğ‘„¶", "ğ‘„·", "ğ‘„¸", "ğ‘„¹", "ğ‘„º", "ğ‘„»", "ğ‘„¼", "ğ‘„½", "ğ‘„¾", "ğ‘„¿"], "cham": ["ê©", "ê©‘", "ê©’", "ê©“", "ê©”", "ê©•", "ê©–", "ê©—", "ê©˜", "ê©™"], "deva": ["à¥¦", "à¥§", "à¥¨", "à¥©", "à¥ª", "à¥«", "à¥¬", "à¥­", "à¥®", "à¥¯"], "diak": ["ğ‘¥", "ğ‘¥‘", "ğ‘¥’", "ğ‘¥“", "ğ‘¥”", "ğ‘¥•", "ğ‘¥–", "ğ‘¥—", "ğ‘¥˜", "ğ‘¥™"], "fullwide": ["ï¼", "ï¼‘", "ï¼’", "ï¼“", "ï¼”", "ï¼•", "ï¼–", "ï¼—", "ï¼˜", "ï¼™"], "gong": ["ğ‘¶ ", "ğ‘¶¡", "ğ‘¶¢", "ğ‘¶£", "ğ‘¶¤", "ğ‘¶¥", "ğ‘¶¦", "ğ‘¶§", "ğ‘¶¨", "ğ‘¶©"], "gonm": ["ğ‘µ", "ğ‘µ‘", "ğ‘µ’", "ğ‘µ“", "ğ‘µ”", "ğ‘µ•", "ğ‘µ–", "ğ‘µ—", "ğ‘µ˜", "ğ‘µ™"], "gujr": ["à«¦", "à«§", "à«¨", "à«©", "à«ª", "à««", "à«¬", "à«­", "à«®", "à«¯"], "guru": ["à©¦", "à©§", "à©¨", "à©©", "à©ª", "à©«", "à©¬", "à©­", "à©®", "à©¯"], "hanidec": ["ã€‡", "ä¸€", "äºŒ", "ä¸‰", "å››", "äº”", "å…­", "ä¸ƒ", "å…«", "ä¹"], "hmng": ["ğ–­", "ğ–­‘", "ğ–­’", "ğ–­“", "ğ–­”", "ğ–­•", "ğ–­–", "ğ–­—", "ğ–­˜", "ğ–­™"], "hmnp": ["ğ…€", "ğ…", "ğ…‚", "ğ…ƒ", "ğ…„", "ğ……", "ğ…†", "ğ…‡", "ğ…ˆ", "ğ…‰"], "java": ["ê§", "ê§‘", "ê§’", "ê§“", "ê§”", "ê§•", "ê§–", "ê§—", "ê§˜", "ê§™"], "kali": ["ê¤€", "ê¤", "ê¤‚", "ê¤ƒ", "ê¤„", "ê¤…", "ê¤†", "ê¤‡", "ê¤ˆ", "ê¤‰"], "khmr": ["áŸ ", "áŸ¡", "áŸ¢", "áŸ£", "áŸ¤", "áŸ¥", "áŸ¦", "áŸ§", "áŸ¨", "áŸ©"], "knda": ["à³¦", "à³§", "à³¨", "à³©", "à³ª", "à³«", "à³¬", "à³­", "à³®", "à³¯"], "lana": ["áª€", "áª", "áª‚", "áªƒ", "áª„", "áª…", "áª†", "áª‡", "áªˆ", "áª‰"], "lanatham": ["áª", "áª‘", "áª’", "áª“", "áª”", "áª•", "áª–", "áª—", "áª˜", "áª™"], "laoo": ["à»", "à»‘", "à»’", "à»“", "à»”", "à»•", "à»–", "à»—", "à»˜", "à»™"], "lepc": ["áª", "áª‘", "áª’", "áª“", "áª”", "áª•", "áª–", "áª—", "áª˜", "áª™"], "limb": ["á¥†", "á¥‡", "á¥ˆ", "á¥‰", "á¥Š", "á¥‹", "á¥Œ", "á¥", "á¥", "á¥"], "mathbold": ["ğŸ", "ğŸ", "ğŸ", "ğŸ‘", "ğŸ’", "ğŸ“", "ğŸ”", "ğŸ•", "ğŸ–", "ğŸ—"], "mathdbl": ["ğŸ˜", "ğŸ™", "ğŸš", "ğŸ›", "ğŸœ", "ğŸ", "ğŸ", "ğŸŸ", "ğŸ ", "ğŸ¡"], "mathmono": ["ğŸ¶", "ğŸ·", "ğŸ¸", "ğŸ¹", "ğŸº", "ğŸ»", "ğŸ¼", "ğŸ½", "ğŸ¾", "ğŸ¿"], "mathsanb": ["ğŸ¬", "ğŸ­", "ğŸ®", "ğŸ¯", "ğŸ°", "ğŸ±", "ğŸ²", "ğŸ³", "ğŸ´", "ğŸµ"], "mathsans": ["ğŸ¢", "ğŸ£", "ğŸ¤", "ğŸ¥", "ğŸ¦", "ğŸ§", "ğŸ¨", "ğŸ©", "ğŸª", "ğŸ«"], "mlym": ["àµ¦", "àµ§", "àµ¨", "àµ©", "àµª", "àµ«", "àµ¬", "àµ­", "àµ®", "àµ¯"], "modi": ["ğ‘™", "ğ‘™‘", "ğ‘™’", "ğ‘™“", "ğ‘™”", "ğ‘™•", "ğ‘™–", "ğ‘™—", "ğ‘™˜", "ğ‘™™"], "mong": ["á ", "á ‘", "á ’", "á “", "á ”", "á •", "á –", "á —", "á ˜", "á ™"], "mroo": ["ğ–© ", "ğ–©¡", "ğ–©¢", "ğ–©£", "ğ–©¤", "ğ–©¥", "ğ–©¦", "ğ–©§", "ğ–©¨", "ğ–©©"], "mtei": ["ê¯°", "ê¯±", "ê¯²", "ê¯³", "ê¯´", "ê¯µ", "ê¯¶", "ê¯·", "ê¯¸", "ê¯¹"], "mymr": ["á€", "á", "á‚", "áƒ", "á„", "á…", "á†", "á‡", "áˆ", "á‰"], "mymrshan": ["á‚", "á‚‘", "á‚’", "á‚“", "á‚”", "á‚•", "á‚–", "á‚—", "á‚˜", "á‚™"], "mymrtlng": ["ê§°", "ê§±", "ê§²", "ê§³", "ê§´", "ê§µ", "ê§¶", "ê§·", "ê§¸", "ê§¹"], "newa": ["ğ‘‘", "ğ‘‘‘", "ğ‘‘’", "ğ‘‘“", "ğ‘‘”", "ğ‘‘•", "ğ‘‘–", "ğ‘‘—", "ğ‘‘˜", "ğ‘‘™"], "nkoo": ["ß€", "ß", "ß‚", "ßƒ", "ß„", "ß…", "ß†", "ß‡", "ßˆ", "ß‰"], "olck": ["á±", "á±‘", "á±’", "á±“", "á±”", "á±•", "á±–", "á±—", "á±˜", "á±™"], "orya": ["à­¦", "à­§", "à­¨", "à­©", "à­ª", "à­«", "à­¬", "à­­", "à­®", "à­¯"], "osma": ["ğ’ ", "ğ’¡", "ğ’¢", "ğ’£", "ğ’¤", "ğ’¥", "ğ’¦", "ğ’§", "ğ’¨", "ğ’©"], "rohg": ["ğ´°", "ğ´±", "ğ´²", "ğ´³", "ğ´´", "ğ´µ", "ğ´¶", "ğ´·", "ğ´¸", "ğ´¹"], "saur": ["ê£", "ê£‘", "ê£’", "ê£“", "ê£”", "ê£•", "ê£–", "ê£—", "ê£˜", "ê£™"], "segment": ["ğŸ¯°", "ğŸ¯±", "ğŸ¯²", "ğŸ¯³", "ğŸ¯´", "ğŸ¯µ", "ğŸ¯¶", "ğŸ¯·", "ğŸ¯¸", "ğŸ¯¹"], "shrd": ["ğ‘‡", "ğ‘‡‘", "ğ‘‡’", "ğ‘‡“", "ğ‘‡”", "ğ‘‡•", "ğ‘‡–", "ğ‘‡—", "ğ‘‡˜", "ğ‘‡™"], "sind": ["ğ‘‹°", "ğ‘‹±", "ğ‘‹²", "ğ‘‹³", "ğ‘‹´", "ğ‘‹µ", "ğ‘‹¶", "ğ‘‹·", "ğ‘‹¸", "ğ‘‹¹"], "sinh": ["à·¦", "à·§", "à·¨", "à·©", "à·ª", "à·«", "à·¬", "à·­", "à·®", "à·¯"], "sora": ["ğ‘ƒ°", "ğ‘ƒ±", "ğ‘ƒ²", "ğ‘ƒ³", "ğ‘ƒ´", "ğ‘ƒµ", "ğ‘ƒ¶", "ğ‘ƒ·", "ğ‘ƒ¸", "ğ‘ƒ¹"], "sund": ["á®°", "á®±", "á®²", "á®³", "á®´", "á®µ", "á®¶", "á®·", "á®¸", "á®¹"], "takr": ["ğ‘›€", "ğ‘›", "ğ‘›‚", "ğ‘›ƒ", "ğ‘›„", "ğ‘›…", "ğ‘›†", "ğ‘›‡", "ğ‘›ˆ", "ğ‘›‰"], "talu": ["á§", "á§‘", "á§’", "á§“", "á§”", "á§•", "á§–", "á§—", "á§˜", "á§™"], "tamldec": ["à¯¦", "à¯§", "à¯¨", "à¯©", "à¯ª", "à¯«", "à¯¬", "à¯­", "à¯®", "à¯¯"], "telu": ["à±¦", "à±§", "à±¨", "à±©", "à±ª", "à±«", "à±¬", "à±­", "à±®", "à±¯"], "thai": ["à¹", "à¹‘", "à¹’", "à¹“", "à¹”", "à¹•", "à¹–", "à¹—", "à¹˜", "à¹™"], "tibt": ["à¼ ", "à¼¡", "à¼¢", "à¼£", "à¼¤", "à¼¥", "à¼¦", "à¼§", "à¼¨", "à¼©"], "tirh": ["ğ‘“", "ğ‘“‘", "ğ‘“’", "ğ‘““", "ğ‘“”", "ğ‘“•", "ğ‘“–", "ğ‘“—", "ğ‘“˜", "ğ‘“™"], "vaii": ["á˜ ", "á˜¡", "á˜¢", "á˜£", "á˜¤", "á˜¥", "á˜¦", "á˜§", "á˜¨", "á˜©"], "wara": ["ğ‘£ ", "ğ‘£¡", "ğ‘£¢", "ğ‘££", "ğ‘£¤", "ğ‘£¥", "ğ‘£¦", "ğ‘£§", "ğ‘£¨", "ğ‘£©"], "wcho": ["ğ‹°", "ğ‹±", "ğ‹²", "ğ‹³", "ğ‹´", "ğ‹µ", "ğ‹¶", "ğ‹·", "ğ‹¸", "ğ‹¹"] }

},{}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ToRawFixed_1 = require("./ToRawFixed");
var digitMapping = tslib_1.__importStar(require("./digit-mapping.json"));
// This is from: unicode-12.1.0/General_Category/Symbol/regex.js
// IE11 does not support unicode flag, otherwise this is just /\p{S}/u.
var S_UNICODE_REGEX = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20BF\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B98-\u2BFF\u2CE5-\u2CEA\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uFB29\uFBB2-\uFBC1\uFDFC\uFDFD\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9B\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD10-\uDD6C\uDD70-\uDDAC\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED5\uDEE0-\uDEEC\uDEF0-\uDEFA\uDF00-\uDF73\uDF80-\uDFD8\uDFE0-\uDFEB]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD00-\uDD0B\uDD0D-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDE53\uDE60-\uDE6D\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95]/;
// /^\p{S}/u
var CARET_S_UNICODE_REGEX = new RegExp("^" + S_UNICODE_REGEX.source);
// /\p{S}$/u
var S_DOLLAR_UNICODE_REGEX = new RegExp(S_UNICODE_REGEX.source + "$");
var CLDR_NUMBER_PATTERN = /[#0](?:[\.,][#0]+)*/g;
function formatToParts(numberResult, data, pl, options) {
    var sign = numberResult.sign, exponent = numberResult.exponent, magnitude = numberResult.magnitude;
    var notation = options.notation, style = options.style, numberingSystem = options.numberingSystem;
    var defaultNumberingSystem = data.numbers.nu[0];
    // #region Part 1: partition and interpolate the CLDR number pattern.
    // ----------------------------------------------------------
    var compactNumberPattern = null;
    if (notation === 'compact' && magnitude) {
        compactNumberPattern = getCompactDisplayPattern(numberResult, pl, data, style, options.compactDisplay, options.currencyDisplay, numberingSystem);
    }
    // This is used multiple times
    var nonNameCurrencyPart;
    if (style === 'currency' && options.currencyDisplay !== 'name') {
        var byCurrencyDisplay = data.currencies[options.currency];
        if (byCurrencyDisplay) {
            switch (options.currencyDisplay) {
                case 'code':
                    nonNameCurrencyPart = options.currency;
                    break;
                case 'symbol':
                    nonNameCurrencyPart = byCurrencyDisplay.symbol;
                    break;
                default:
                    nonNameCurrencyPart = byCurrencyDisplay.narrow;
                    break;
            }
        }
        else {
            // Fallback for unknown currency
            nonNameCurrencyPart = options.currency;
        }
    }
    var numberPattern;
    if (!compactNumberPattern) {
        // Note: if the style is unit, or is currency and the currency display is name,
        // its unit parts will be interpolated in part 2. So here we can fallback to decimal.
        if (style === 'decimal' ||
            style === 'unit' ||
            (style === 'currency' && options.currencyDisplay === 'name')) {
            // Shortcut for decimal
            var decimalData = data.numbers.decimal[numberingSystem] ||
                data.numbers.decimal[defaultNumberingSystem];
            numberPattern = getPatternForSign(decimalData.standard, sign);
        }
        else if (style === 'currency') {
            var currencyData = data.numbers.currency[numberingSystem] ||
                data.numbers.currency[defaultNumberingSystem];
            // We replace number pattern part with `0` for easier postprocessing.
            numberPattern = getPatternForSign(currencyData[options.currencySign], sign);
        }
        else {
            // percent
            var percentPattern = data.numbers.percent[numberingSystem] ||
                data.numbers.percent[defaultNumberingSystem];
            numberPattern = getPatternForSign(percentPattern, sign);
        }
    }
    else {
        numberPattern = compactNumberPattern;
    }
    // Extract the decimal number pattern string. It looks like "#,##0,00", which will later be
    // used to infer decimal group sizes.
    var decimalNumberPattern = CLDR_NUMBER_PATTERN.exec(numberPattern)[0];
    // Now we start to substitute patterns
    // 1. replace strings like `0` and `#,##0.00` with `{0}`
    // 2. unquote characters (invariant: the quoted characters does not contain the special tokens)
    numberPattern = numberPattern
        .replace(CLDR_NUMBER_PATTERN, '{0}')
        .replace(/'(.)'/g, '$1');
    // Handle currency spacing (both compact and non-compact).
    if (style === 'currency' && options.currencyDisplay !== 'name') {
        var currencyData = data.numbers.currency[numberingSystem] ||
            data.numbers.currency[defaultNumberingSystem];
        // See `currencySpacing` substitution rule in TR-35.
        // Here we always assume the currencyMatch is "[:^S:]" and surroundingMatch is "[:digit:]".
        //
        // Example 1: for pattern "#,##0.00Â¤" with symbol "US$", we replace "Â¤" with the symbol,
        // but insert an extra non-break space before the symbol, because "[:^S:]" matches "U" in
        // "US$" and "[:digit:]" matches the latn numbering system digits.
        //
        // Example 2: for pattern "Â¤#,##0.00" with symbol "US$", there is no spacing between symbol
        // and number, because `$` does not match "[:^S:]".
        //
        // Implementation note: here we do the best effort to infer the insertion.
        // We also assume that `beforeInsertBetween` and `afterInsertBetween` will never be `;`.
        var afterCurrency = currencyData.currencySpacing.afterInsertBetween;
        if (afterCurrency && !S_DOLLAR_UNICODE_REGEX.test(nonNameCurrencyPart)) {
            numberPattern = numberPattern.replace('Â¤{0}', "\u00A4" + afterCurrency + "{0}");
        }
        var beforeCurrency = currencyData.currencySpacing.beforeInsertBetween;
        if (beforeCurrency && !CARET_S_UNICODE_REGEX.test(nonNameCurrencyPart)) {
            numberPattern = numberPattern.replace('{0}Â¤', "{0}" + beforeCurrency + "\u00A4");
        }
    }
    // The following tokens are special: `{0}`, `Â¤`, `%`, `-`, `+`, `{c:...}.
    var numberPatternParts = numberPattern.split(/({c:[^}]+}|\{0\}|[Â¤%\-\+])/g);
    var numberParts = [];
    var symbols = data.numbers.symbols[numberingSystem] ||
        data.numbers.symbols[defaultNumberingSystem];
    for (var _i = 0, numberPatternParts_1 = numberPatternParts; _i < numberPatternParts_1.length; _i++) {
        var part = numberPatternParts_1[_i];
        if (!part) {
            continue;
        }
        switch (part) {
            case '{0}': {
                // We only need to handle scientific and engineering notation here.
                numberParts.push.apply(numberParts, paritionNumberIntoParts(symbols, numberResult, notation, exponent, numberingSystem, 
                // If compact number pattern exists, do not insert group separators.
                !compactNumberPattern && options.useGrouping, decimalNumberPattern));
                break;
            }
            case '-':
                numberParts.push({ type: 'minusSign', value: symbols.minusSign });
                break;
            case '+':
                numberParts.push({ type: 'plusSign', value: symbols.plusSign });
                break;
            case '%':
                numberParts.push({ type: 'percentSign', value: symbols.percentSign });
                break;
            case 'Â¤':
                // Computed above when handling currency spacing.
                numberParts.push({ type: 'currency', value: nonNameCurrencyPart });
                break;
            default:
                if (/^\{c:/.test(part)) {
                    numberParts.push({
                        type: 'compact',
                        value: part.substring(3, part.length - 1),
                    });
                }
                else {
                    // literal
                    numberParts.push({ type: 'literal', value: part });
                }
                break;
        }
    }
    // #endregion
    // #region Part 2: interpolate unit pattern if necessary.
    // ----------------------------------------------
    switch (style) {
        case 'currency': {
            // `currencyDisplay: 'name'` has similar pattern handling as units.
            if (options.currencyDisplay === 'name') {
                var unitPattern = (data.numbers.currency[numberingSystem] ||
                    data.numbers.currency[defaultNumberingSystem]).unitPattern;
                // Select plural
                var unitName = void 0;
                var currencyNameData = data.currencies[options.currency];
                if (currencyNameData) {
                    unitName = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), currencyNameData.displayName);
                }
                else {
                    // Fallback for unknown currency
                    unitName = options.currency;
                }
                // Do {0} and {1} substitution
                var unitPatternParts = unitPattern.split(/(\{[01]\})/g);
                var result = [];
                for (var _a = 0, unitPatternParts_1 = unitPatternParts; _a < unitPatternParts_1.length; _a++) {
                    var part = unitPatternParts_1[_a];
                    switch (part) {
                        case '{0}':
                            result.push.apply(result, numberParts);
                            break;
                        case '{1}':
                            result.push({ type: 'currency', value: unitName });
                            break;
                        default:
                            if (part) {
                                result.push({ type: 'literal', value: part });
                            }
                            break;
                    }
                }
                return result;
            }
            else {
                return numberParts;
            }
        }
        case 'unit': {
            var unit = options.unit, unitDisplay = options.unitDisplay;
            var unitData = data.units.simple[unit];
            var unitPattern = void 0;
            if (unitData) {
                // Simple unit pattern
                unitPattern = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), data.units.simple[unit][unitDisplay]);
            }
            else {
                // See: http://unicode.org/reports/tr35/tr35-general.html#perUnitPatterns
                // If cannot find unit in the simple pattern, it must be "per" compound pattern.
                // Implementation note: we are not following TR-35 here because we need to format to parts!
                var _b = unit.split('-per-'), numeratorUnit = _b[0], denominatorUnit = _b[1];
                unitData = data.units.simple[numeratorUnit];
                var numeratorUnitPattern = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), data.units.simple[numeratorUnit][unitDisplay]);
                var perUnitPattern = data.units.simple[denominatorUnit].perUnit[unitDisplay];
                if (perUnitPattern) {
                    // perUnitPattern exists, combine it with numeratorUnitPattern
                    unitPattern = perUnitPattern.replace('{0}', numeratorUnitPattern);
                }
                else {
                    // get compoundUnit pattern (e.g. "{0} per {1}"), repalce {0} with numerator pattern and {1} with
                    // the denominator pattern in singular form.
                    var perPattern = data.units.compound.per[unitDisplay];
                    var denominatorPattern = selectPlural(pl, 1, data.units.simple[denominatorUnit][unitDisplay]);
                    unitPattern = unitPattern = perPattern
                        .replace('{0}', numeratorUnitPattern)
                        .replace('{1}', denominatorPattern.replace('{0}', ''));
                }
            }
            var result = [];
            // We need spacing around "{0}" because they are not treated as "unit" parts, but "literal".
            for (var _c = 0, _d = unitPattern.split(/(\s*\{0\}\s*)/); _c < _d.length; _c++) {
                var part = _d[_c];
                var interpolateMatch = /^(\s*)\{0\}(\s*)$/.exec(part);
                if (interpolateMatch) {
                    // Space before "{0}"
                    if (interpolateMatch[1]) {
                        result.push({ type: 'literal', value: interpolateMatch[1] });
                    }
                    // "{0}" itself
                    result.push.apply(result, numberParts);
                    // Space after "{0}"
                    if (interpolateMatch[2]) {
                        result.push({ type: 'literal', value: interpolateMatch[2] });
                    }
                }
                else if (part) {
                    result.push({ type: 'unit', value: part });
                }
            }
            return result;
        }
        default:
            return numberParts;
    }
    // #endregion
}
exports.default = formatToParts;
// A subset of https://tc39.es/ecma402/#sec-partitionnotationsubpattern
// Plus the exponent parts handling.
function paritionNumberIntoParts(symbols, numberResult, notation, exponent, numberingSystem, useGrouping, 
/**
 * This is the decimal number pattern without signs or symbols.
 * It is used to infer the group size when `useGrouping` is true.
 *
 * A typical value looks like "#,##0.00" (primary group size is 3).
 * Some locales like Hindi has secondary group size of 2 (e.g. "#,##,##0.00").
 */
decimalNumberPattern) {
    var result = [];
    // eslint-disable-next-line prefer-const
    var n = numberResult.formattedString, x = numberResult.roundedNumber;
    if (isNaN(x)) {
        return [{ type: 'nan', value: n }];
    }
    else if (!isFinite(x)) {
        return [{ type: 'infinity', value: n }];
    }
    var digitReplacementTable = digitMapping[numberingSystem];
    if (digitReplacementTable) {
        n = n.replace(/\d/g, function (digit) { return digitReplacementTable[+digit] || digit; });
    }
    // TODO: Else use an implementation dependent algorithm to map n to the appropriate
    // representation of n in the given numbering system.
    var decimalSepIndex = n.indexOf('.');
    var integer;
    var fraction;
    if (decimalSepIndex > 0) {
        integer = n.slice(0, decimalSepIndex);
        fraction = n.slice(decimalSepIndex + 1);
    }
    else {
        integer = n;
    }
    // #region Grouping integer digits
    // The weird compact and x >= 10000 check is to ensure consistency with Node.js and Chrome.
    // Note that `de` does not have compact form for thousands, but Node.js does not insert grouping separator
    // unless the rounded number is greater than 10000:
    //   NumberFormat('de', {notation: 'compact', compactDisplay: 'short'}).format(1234) //=> "1234"
    //   NumberFormat('de').format(1234) //=> "1.234"
    if (useGrouping && (notation !== 'compact' || x >= 10000)) {
        var groupSepSymbol = symbols.group;
        var groups = [];
        // > There may be two different grouping sizes: The primary grouping size used for the least
        // > significant integer group, and the secondary grouping size used for more significant groups.
        // > If a pattern contains multiple grouping separators, the interval between the last one and the
        // > end of the integer defines the primary grouping size, and the interval between the last two
        // > defines the secondary grouping size. All others are ignored.
        var integerNumberPattern = decimalNumberPattern.split('.')[0];
        var patternGroups = integerNumberPattern.split(',');
        var primaryGroupingSize = 3;
        var secondaryGroupingSize = 3;
        if (patternGroups.length > 1) {
            primaryGroupingSize = patternGroups[patternGroups.length - 1].length;
        }
        if (patternGroups.length > 2) {
            secondaryGroupingSize = patternGroups[patternGroups.length - 2].length;
        }
        var i = integer.length - primaryGroupingSize;
        if (i > 0) {
            // Slice the least significant integer group
            groups.push(integer.slice(i, i + primaryGroupingSize));
            // Then iteratively push the more signicant groups
            // TODO: handle surrogate pairs in some numbering system digits
            for (i -= secondaryGroupingSize; i > 0; i -= secondaryGroupingSize) {
                groups.push(integer.slice(i, i + secondaryGroupingSize));
            }
            groups.push(integer.slice(0, i + secondaryGroupingSize));
        }
        else {
            groups.push(integer);
        }
        while (groups.length > 0) {
            var integerGroup = groups.pop();
            result.push({ type: 'integer', value: integerGroup });
            if (groups.length > 0) {
                result.push({ type: 'group', value: groupSepSymbol });
            }
        }
    }
    else {
        result.push({ type: 'integer', value: integer });
    }
    // #endregion
    if (fraction !== undefined) {
        result.push({ type: 'decimal', value: symbols.decimal }, { type: 'fraction', value: fraction });
    }
    if ((notation === 'scientific' || notation === 'engineering') &&
        isFinite(x)) {
        result.push({ type: 'exponentSeparator', value: symbols.exponential });
        if (exponent < 0) {
            result.push({ type: 'exponentMinusSign', value: symbols.minusSign });
            exponent = -exponent;
        }
        var exponentResult = ToRawFixed_1.ToRawFixed(exponent, 0, 0);
        result.push({
            type: 'exponentInteger',
            value: exponentResult.formattedString,
        });
    }
    return result;
}
function getPatternForSign(pattern, sign) {
    if (pattern.indexOf(';') < 0) {
        pattern = pattern + ";-" + pattern;
    }
    var _a = pattern.split(';'), zeroPattern = _a[0], negativePattern = _a[1];
    switch (sign) {
        case 0:
            return zeroPattern;
        case -1:
            return negativePattern;
        default:
            return negativePattern.indexOf('-') >= 0
                ? negativePattern.replace(/-/g, '+')
                : "+" + zeroPattern;
    }
}
// Find the CLDR pattern for compact notation based on the magnitude of data and style.
//
// Example return value: "Â¤Â {c:laki}000;Â¤{c:laki}Â -0" (`sw` locale):
// - Notice the `{c:...}` token that wraps the compact literal.
// - The consecutive zeros are normalized to single zero to match CLDR_NUMBER_PATTERN.
//
// Returning null means the compact display pattern cannot be found.
function getCompactDisplayPattern(numberResult, pl, data, style, compactDisplay, currencyDisplay, numberingSystem) {
    var _a;
    var roundedNumber = numberResult.roundedNumber, sign = numberResult.sign, magnitude = numberResult.magnitude;
    var magnitudeKey = String(Math.pow(10, magnitude));
    var defaultNumberingSystem = data.numbers.nu[0];
    var pattern;
    if (style === 'currency' && currencyDisplay !== 'name') {
        var byNumberingSystem = data.numbers.currency;
        var currencyData = byNumberingSystem[numberingSystem] ||
            byNumberingSystem[defaultNumberingSystem];
        // NOTE: compact notation ignores currencySign!
        var compactPluralRules = (_a = currencyData.short) === null || _a === void 0 ? void 0 : _a[magnitudeKey];
        if (!compactPluralRules) {
            return null;
        }
        pattern = selectPlural(pl, roundedNumber, compactPluralRules);
    }
    else {
        var byNumberingSystem = data.numbers.decimal;
        var byCompactDisplay = byNumberingSystem[numberingSystem] ||
            byNumberingSystem[defaultNumberingSystem];
        var compactPlaralRule = byCompactDisplay[compactDisplay][magnitudeKey];
        if (!compactPlaralRule) {
            return null;
        }
        pattern = selectPlural(pl, roundedNumber, compactPlaralRule);
    }
    // See https://unicode.org/reports/tr35/tr35-numbers.html#Compact_Number_Formats
    // > If the value is precisely â€œ0â€, either explicit or defaulted, then the normal number format
    // > pattern for that sort of object is supplied.
    if (pattern === '0') {
        return null;
    }
    pattern = getPatternForSign(pattern, sign)
        // Extract compact literal from the pattern
        .replace(/([^\s;\-\+\dÂ¤]+)/g, '{c:$1}')
        // We replace one or more zeros with a single zero so it matches `CLDR_NUMBER_PATTERN`.
        .replace(/0+/, '0');
    return pattern;
}
function selectPlural(pl, x, rules) {
    return rules[pl.select(x)] || rules.other;
}

},{"./ToRawFixed":46,"./digit-mapping.json":48,"tslib":88}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PartitionPattern = void 0;
var utils_1 = require("./utils");
/**
 * https://tc39.es/ecma402/#sec-partitionpattern
 * @param pattern
 */
function PartitionPattern(pattern) {
    var result = [];
    var beginIndex = pattern.indexOf('{');
    var endIndex = 0;
    var nextIndex = 0;
    var length = pattern.length;
    while (beginIndex < pattern.length && beginIndex > -1) {
        endIndex = pattern.indexOf('}', beginIndex);
        utils_1.invariant(endIndex > beginIndex, "Invalid pattern " + pattern);
        if (beginIndex > nextIndex) {
            result.push({
                type: 'literal',
                value: pattern.substring(nextIndex, beginIndex),
            });
        }
        result.push({
            type: pattern.substring(beginIndex + 1, endIndex),
            value: undefined,
        });
        nextIndex = endIndex + 1;
        beginIndex = pattern.indexOf('{', nextIndex);
    }
    if (nextIndex < length) {
        result.push({
            type: 'literal',
            value: pattern.substring(nextIndex, length),
        });
    }
    return result;
}
exports.PartitionPattern = PartitionPattern;

},{"./utils":71}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetOperands = void 0;
var utils_1 = require("../utils");
var _262_1 = require("../262");
/**
 * http://ecma-international.org/ecma-402/7.0/index.html#sec-getoperands
 * @param s
 */
function GetOperands(s) {
    utils_1.invariant(typeof s === 'string', "GetOperands should have been called with a string");
    var n = _262_1.ToNumber(s);
    utils_1.invariant(isFinite(n), 'n should be finite');
    var dp = s.indexOf('.');
    var iv;
    var f;
    var v;
    var fv = '';
    if (dp === -1) {
        iv = n;
        f = 0;
        v = 0;
    }
    else {
        iv = s.slice(0, dp);
        fv = s.slice(dp, s.length);
        f = _262_1.ToNumber(fv);
        v = fv.length;
    }
    var i = Math.abs(_262_1.ToNumber(iv));
    var w;
    var t;
    if (f !== 0) {
        var ft = fv.replace(/0+$/, '');
        w = ft.length;
        t = _262_1.ToNumber(ft);
    }
    else {
        w = 0;
        t = 0;
    }
    return {
        Number: n,
        IntegerDigits: i,
        NumberOfFractionDigits: v,
        NumberOfFractionDigitsWithoutTrailing: w,
        FractionDigits: f,
        FractionDigitsWithoutTrailing: t,
    };
}
exports.GetOperands = GetOperands;

},{"../262":7,"../utils":71}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InitializePluralRules = void 0;
var CanonicalizeLocaleList_1 = require("../CanonicalizeLocaleList");
var _262_1 = require("../262");
var GetOption_1 = require("../GetOption");
var SetNumberFormatDigitOptions_1 = require("../NumberFormat/SetNumberFormatDigitOptions");
var ResolveLocale_1 = require("../ResolveLocale");
function InitializePluralRules(pl, locales, options, _a) {
    var availableLocales = _a.availableLocales, relevantExtensionKeys = _a.relevantExtensionKeys, localeData = _a.localeData, getDefaultLocale = _a.getDefaultLocale, getInternalSlots = _a.getInternalSlots;
    var requestedLocales = CanonicalizeLocaleList_1.CanonicalizeLocaleList(locales);
    var opt = Object.create(null);
    var opts = options === undefined ? Object.create(null) : _262_1.ToObject(options);
    var internalSlots = getInternalSlots(pl);
    internalSlots.initializedPluralRules = true;
    var matcher = GetOption_1.GetOption(opts, 'localeMatcher', 'string', ['best fit', 'lookup'], 'best fit');
    opt.localeMatcher = matcher;
    internalSlots.type = GetOption_1.GetOption(opts, 'type', 'string', ['cardinal', 'ordinal'], 'cardinal');
    SetNumberFormatDigitOptions_1.SetNumberFormatDigitOptions(internalSlots, opts, 0, 3, 'standard');
    var r = ResolveLocale_1.ResolveLocale(availableLocales, requestedLocales, opt, relevantExtensionKeys, localeData, getDefaultLocale);
    internalSlots.locale = r.locale;
    return pl;
}
exports.InitializePluralRules = InitializePluralRules;

},{"../262":7,"../CanonicalizeLocaleList":10,"../GetOption":30,"../NumberFormat/SetNumberFormatDigitOptions":44,"../ResolveLocale":60}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResolvePlural = void 0;
var utils_1 = require("../utils");
var _262_1 = require("../262");
var FormatNumericToString_1 = require("../NumberFormat/FormatNumericToString");
var GetOperands_1 = require("./GetOperands");
/**
 * http://ecma-international.org/ecma-402/7.0/index.html#sec-resolveplural
 * @param pl
 * @param n
 * @param PluralRuleSelect Has to pass in bc it's implementation-specific
 */
function ResolvePlural(pl, n, _a) {
    var getInternalSlots = _a.getInternalSlots, PluralRuleSelect = _a.PluralRuleSelect;
    var internalSlots = getInternalSlots(pl);
    utils_1.invariant(_262_1.Type(internalSlots) === 'Object', 'pl has to be an object');
    utils_1.invariant('initializedPluralRules' in internalSlots, 'pluralrules must be initialized');
    utils_1.invariant(_262_1.Type(n) === 'Number', 'n must be a number');
    if (!isFinite(n)) {
        return 'other';
    }
    var locale = internalSlots.locale, type = internalSlots.type;
    var res = FormatNumericToString_1.FormatNumericToString(internalSlots, n);
    var s = res.formattedString;
    var operands = GetOperands_1.GetOperands(s);
    return PluralRuleSelect(locale, type, n, operands);
}
exports.ResolvePlural = ResolvePlural;

},{"../262":7,"../NumberFormat/FormatNumericToString":41,"../utils":71,"./GetOperands":51}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FormatRelativeTime = void 0;
var PartitionRelativeTimePattern_1 = require("./PartitionRelativeTimePattern");
function FormatRelativeTime(rtf, value, unit, implDetails) {
    var parts = PartitionRelativeTimePattern_1.PartitionRelativeTimePattern(rtf, value, unit, implDetails);
    var result = '';
    for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
        var part = parts_1[_i];
        result += part.value;
    }
    return result;
}
exports.FormatRelativeTime = FormatRelativeTime;

},{"./PartitionRelativeTimePattern":58}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FormatRelativeTimeToParts = void 0;
var PartitionRelativeTimePattern_1 = require("./PartitionRelativeTimePattern");
var _262_1 = require("../262");
function FormatRelativeTimeToParts(rtf, value, unit, implDetails) {
    var parts = PartitionRelativeTimePattern_1.PartitionRelativeTimePattern(rtf, value, unit, implDetails);
    var result = _262_1.ArrayCreate(0);
    for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
        var part = parts_1[_i];
        var o = {
            type: part.type,
            value: part.value,
        };
        if ('unit' in part) {
            o.unit = part.unit;
        }
        result.push(o);
    }
    return result;
}
exports.FormatRelativeTimeToParts = FormatRelativeTimeToParts;

},{"../262":7,"./PartitionRelativeTimePattern":58}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InitializeRelativeTimeFormat = void 0;
var CanonicalizeLocaleList_1 = require("../CanonicalizeLocaleList");
var _262_1 = require("../262");
var GetOption_1 = require("../GetOption");
var ResolveLocale_1 = require("../ResolveLocale");
var utils_1 = require("../utils");
var NUMBERING_SYSTEM_REGEX = /^[a-z0-9]{3,8}(-[a-z0-9]{3,8})*$/i;
function InitializeRelativeTimeFormat(rtf, locales, options, _a) {
    var getInternalSlots = _a.getInternalSlots, availableLocales = _a.availableLocales, relevantExtensionKeys = _a.relevantExtensionKeys, localeData = _a.localeData, getDefaultLocale = _a.getDefaultLocale;
    var internalSlots = getInternalSlots(rtf);
    internalSlots.initializedRelativeTimeFormat = true;
    var requestedLocales = CanonicalizeLocaleList_1.CanonicalizeLocaleList(locales);
    var opt = Object.create(null);
    var opts = options === undefined ? Object.create(null) : _262_1.ToObject(options);
    var matcher = GetOption_1.GetOption(opts, 'localeMatcher', 'string', ['best fit', 'lookup'], 'best fit');
    opt.localeMatcher = matcher;
    var numberingSystem = GetOption_1.GetOption(opts, 'numberingSystem', 'string', undefined, undefined);
    if (numberingSystem !== undefined) {
        if (!NUMBERING_SYSTEM_REGEX.test(numberingSystem)) {
            throw new RangeError("Invalid numbering system " + numberingSystem);
        }
    }
    opt.nu = numberingSystem;
    var r = ResolveLocale_1.ResolveLocale(availableLocales, requestedLocales, opt, relevantExtensionKeys, localeData, getDefaultLocale);
    var locale = r.locale, nu = r.nu;
    internalSlots.locale = locale;
    internalSlots.style = GetOption_1.GetOption(opts, 'style', 'string', ['long', 'narrow', 'short'], 'long');
    internalSlots.numeric = GetOption_1.GetOption(opts, 'numeric', 'string', ['always', 'auto'], 'always');
    var fields = localeData[r.dataLocale];
    utils_1.invariant(!!fields, "Missing locale data for " + r.dataLocale);
    internalSlots.fields = fields;
    internalSlots.numberFormat = new Intl.NumberFormat(locales);
    internalSlots.pluralRules = new Intl.PluralRules(locales);
    internalSlots.numberingSystem = nu;
    return rtf;
}
exports.InitializeRelativeTimeFormat = InitializeRelativeTimeFormat;

},{"../262":7,"../CanonicalizeLocaleList":10,"../GetOption":30,"../ResolveLocale":60,"../utils":71}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MakePartsList = void 0;
var PartitionPattern_1 = require("../PartitionPattern");
var utils_1 = require("../utils");
function MakePartsList(pattern, unit, parts) {
    var patternParts = PartitionPattern_1.PartitionPattern(pattern);
    var result = [];
    for (var _i = 0, patternParts_1 = patternParts; _i < patternParts_1.length; _i++) {
        var patternPart = patternParts_1[_i];
        if (patternPart.type === 'literal') {
            result.push({
                type: 'literal',
                value: patternPart.value,
            });
        }
        else {
            utils_1.invariant(patternPart.type === '0', "Malformed pattern " + pattern);
            for (var _a = 0, parts_1 = parts; _a < parts_1.length; _a++) {
                var part = parts_1[_a];
                result.push({
                    type: part.type,
                    value: part.value,
                    unit: unit,
                });
            }
        }
    }
    return result;
}
exports.MakePartsList = MakePartsList;

},{"../PartitionPattern":50,"../utils":71}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PartitionRelativeTimePattern = void 0;
var utils_1 = require("../utils");
var SingularRelativeTimeUnit_1 = require("./SingularRelativeTimeUnit");
var MakePartsList_1 = require("./MakePartsList");
var _262_1 = require("../262");
function PartitionRelativeTimePattern(rtf, value, unit, _a) {
    var getInternalSlots = _a.getInternalSlots;
    utils_1.invariant(_262_1.Type(value) === 'Number', "value must be number, instead got " + typeof value, TypeError);
    utils_1.invariant(_262_1.Type(unit) === 'String', "unit must be number, instead got " + typeof value, TypeError);
    if (isNaN(value) || !isFinite(value)) {
        throw new RangeError("Invalid value " + value);
    }
    var resolvedUnit = SingularRelativeTimeUnit_1.SingularRelativeTimeUnit(unit);
    var _b = getInternalSlots(rtf), fields = _b.fields, style = _b.style, numeric = _b.numeric, pluralRules = _b.pluralRules, numberFormat = _b.numberFormat;
    var entry = resolvedUnit;
    if (style === 'short') {
        entry = resolvedUnit + "-short";
    }
    else if (style === 'narrow') {
        entry = resolvedUnit + "-narrow";
    }
    if (!(entry in fields)) {
        entry = resolvedUnit;
    }
    var patterns = fields[entry];
    if (numeric === 'auto') {
        if (_262_1.ToString(value) in patterns) {
            return [
                {
                    type: 'literal',
                    value: patterns[_262_1.ToString(value)],
                },
            ];
        }
    }
    var tl = 'future';
    if (_262_1.SameValue(value, -0) || value < 0) {
        tl = 'past';
    }
    var po = patterns[tl];
    var fv = typeof numberFormat.formatToParts === 'function'
        ? numberFormat.formatToParts(Math.abs(value))
        : // TODO: If formatToParts is not supported, we assume the whole formatted
            // number is a part
            [
                {
                    type: 'literal',
                    value: numberFormat.format(Math.abs(value)),
                    unit: unit,
                },
            ];
    var pr = pluralRules.select(value);
    var pattern = po[pr];
    return MakePartsList_1.MakePartsList(pattern, resolvedUnit, fv);
}
exports.PartitionRelativeTimePattern = PartitionRelativeTimePattern;

},{"../262":7,"../utils":71,"./MakePartsList":57,"./SingularRelativeTimeUnit":59}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SingularRelativeTimeUnit = void 0;
var utils_1 = require("../utils");
var _262_1 = require("../262");
/**
 * https://tc39.es/proposal-intl-relative-time/#sec-singularrelativetimeunit
 * @param unit
 */
function SingularRelativeTimeUnit(unit) {
    utils_1.invariant(_262_1.Type(unit) === 'String', 'unit must be a string');
    if (unit === 'seconds')
        return 'second';
    if (unit === 'minutes')
        return 'minute';
    if (unit === 'hours')
        return 'hour';
    if (unit === 'days')
        return 'day';
    if (unit === 'weeks')
        return 'week';
    if (unit === 'months')
        return 'month';
    if (unit === 'quarters')
        return 'quarter';
    if (unit === 'years')
        return 'year';
    if (unit !== 'second' &&
        unit !== 'minute' &&
        unit !== 'hour' &&
        unit !== 'day' &&
        unit !== 'week' &&
        unit !== 'month' &&
        unit !== 'quarter' &&
        unit !== 'year') {
        throw new RangeError('invalid unit');
    }
    return unit;
}
exports.SingularRelativeTimeUnit = SingularRelativeTimeUnit;

},{"../262":7,"../utils":71}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResolveLocale = void 0;
var LookupMatcher_1 = require("./LookupMatcher");
var BestFitMatcher_1 = require("./BestFitMatcher");
var utils_1 = require("./utils");
var UnicodeExtensionValue_1 = require("./UnicodeExtensionValue");
/**
 * https://tc39.es/ecma402/#sec-resolvelocale
 */
function ResolveLocale(availableLocales, requestedLocales, options, relevantExtensionKeys, localeData, getDefaultLocale) {
    var matcher = options.localeMatcher;
    var r;
    if (matcher === 'lookup') {
        r = LookupMatcher_1.LookupMatcher(availableLocales, requestedLocales, getDefaultLocale);
    }
    else {
        r = BestFitMatcher_1.BestFitMatcher(availableLocales, requestedLocales, getDefaultLocale);
    }
    var foundLocale = r.locale;
    var result = { locale: '', dataLocale: foundLocale };
    var supportedExtension = '-u';
    for (var _i = 0, relevantExtensionKeys_1 = relevantExtensionKeys; _i < relevantExtensionKeys_1.length; _i++) {
        var key = relevantExtensionKeys_1[_i];
        utils_1.invariant(foundLocale in localeData, "Missing locale data for " + foundLocale);
        var foundLocaleData = localeData[foundLocale];
        utils_1.invariant(typeof foundLocaleData === 'object' && foundLocaleData !== null, "locale data " + key + " must be an object");
        var keyLocaleData = foundLocaleData[key];
        utils_1.invariant(Array.isArray(keyLocaleData), "keyLocaleData for " + key + " must be an array");
        var value = keyLocaleData[0];
        utils_1.invariant(typeof value === 'string' || value === null, "value must be string or null but got " + typeof value + " in key " + key);
        var supportedExtensionAddition = '';
        if (r.extension) {
            var requestedValue = UnicodeExtensionValue_1.UnicodeExtensionValue(r.extension, key);
            if (requestedValue !== undefined) {
                if (requestedValue !== '') {
                    if (~keyLocaleData.indexOf(requestedValue)) {
                        value = requestedValue;
                        supportedExtensionAddition = "-" + key + "-" + value;
                    }
                }
                else if (~requestedValue.indexOf('true')) {
                    value = 'true';
                    supportedExtensionAddition = "-" + key;
                }
            }
        }
        if (key in options) {
            var optionsValue = options[key];
            utils_1.invariant(typeof optionsValue === 'string' ||
                typeof optionsValue === 'undefined' ||
                optionsValue === null, 'optionsValue must be String, Undefined or Null');
            if (~keyLocaleData.indexOf(optionsValue)) {
                if (optionsValue !== value) {
                    value = optionsValue;
                    supportedExtensionAddition = '';
                }
            }
        }
        result[key] = value;
        supportedExtension += supportedExtensionAddition;
    }
    if (supportedExtension.length > 2) {
        var privateIndex = foundLocale.indexOf('-x-');
        if (privateIndex === -1) {
            foundLocale = foundLocale + supportedExtension;
        }
        else {
            var preExtension = foundLocale.slice(0, privateIndex);
            var postExtension = foundLocale.slice(privateIndex, foundLocale.length);
            foundLocale = preExtension + supportedExtension + postExtension;
        }
        foundLocale = Intl.getCanonicalLocales(foundLocale)[0];
    }
    result.locale = foundLocale;
    return result;
}
exports.ResolveLocale = ResolveLocale;

},{"./BestFitMatcher":9,"./LookupMatcher":35,"./UnicodeExtensionValue":62,"./utils":71}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SupportedLocales = void 0;
var _262_1 = require("./262");
var GetOption_1 = require("./GetOption");
var LookupSupportedLocales_1 = require("./LookupSupportedLocales");
/**
 * https://tc39.es/ecma402/#sec-supportedlocales
 * @param availableLocales
 * @param requestedLocales
 * @param options
 */
function SupportedLocales(availableLocales, requestedLocales, options) {
    var matcher = 'best fit';
    if (options !== undefined) {
        options = _262_1.ToObject(options);
        matcher = GetOption_1.GetOption(options, 'localeMatcher', 'string', ['lookup', 'best fit'], 'best fit');
    }
    if (matcher === 'best fit') {
        return LookupSupportedLocales_1.LookupSupportedLocales(availableLocales, requestedLocales);
    }
    return LookupSupportedLocales_1.LookupSupportedLocales(availableLocales, requestedLocales);
}
exports.SupportedLocales = SupportedLocales;

},{"./262":7,"./GetOption":30,"./LookupSupportedLocales":36}],62:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnicodeExtensionValue = void 0;
var utils_1 = require("./utils");
/**
 * https://tc39.es/ecma402/#sec-unicodeextensionvalue
 * @param extension
 * @param key
 */
function UnicodeExtensionValue(extension, key) {
    utils_1.invariant(key.length === 2, 'key must have 2 elements');
    var size = extension.length;
    var searchValue = "-" + key + "-";
    var pos = extension.indexOf(searchValue);
    if (pos !== -1) {
        var start = pos + 4;
        var end = start;
        var k = start;
        var done = false;
        while (!done) {
            var e = extension.indexOf('-', k);
            var len = void 0;
            if (e === -1) {
                len = size - k;
            }
            else {
                len = e - k;
            }
            if (len === 2) {
                done = true;
            }
            else if (e === -1) {
                end = size;
                done = true;
            }
            else {
                end = e;
                k = e + 1;
            }
        }
        return extension.slice(start, end);
    }
    searchValue = "-" + key;
    pos = extension.indexOf(searchValue);
    if (pos !== -1 && pos + 3 === size) {
        return '';
    }
    return undefined;
}
exports.UnicodeExtensionValue = UnicodeExtensionValue;

},{"./utils":71}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isMissingLocaleDataError = void 0;
var tslib_1 = require("tslib");
var MissingLocaleDataError = /** @class */ (function (_super) {
    tslib_1.__extends(MissingLocaleDataError, _super);
    function MissingLocaleDataError() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'MISSING_LOCALE_DATA';
        return _this;
    }
    return MissingLocaleDataError;
}(Error));
function isMissingLocaleDataError(e) {
    return e.type === 'MISSING_LOCALE_DATA';
}
exports.isMissingLocaleDataError = isMissingLocaleDataError;

},{"tslib":88}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.invariant = exports.isMissingLocaleDataError = exports.defineProperty = exports.getMagnitude = exports.setMultiInternalSlots = exports.setInternalSlot = exports.isLiteralPart = exports.getMultiInternalSlots = exports.getInternalSlot = exports.parseDateTimeSkeleton = exports.DATE_TIME_PROPS = exports._formatToParts = exports.BestFitFormatMatcher = void 0;
var tslib_1 = require("tslib");
var BestFitFormatMatcher_1 = require("./DateTimeFormat/BestFitFormatMatcher");
Object.defineProperty(exports, "BestFitFormatMatcher", { enumerable: true, get: function () { return BestFitFormatMatcher_1.BestFitFormatMatcher; } });
tslib_1.__exportStar(require("./CanonicalizeLocaleList"), exports);
tslib_1.__exportStar(require("./CanonicalizeTimeZoneName"), exports);
tslib_1.__exportStar(require("./DateTimeFormat/BasicFormatMatcher"), exports);
tslib_1.__exportStar(require("./DateTimeFormat/DateTimeStyleFormat"), exports);
tslib_1.__exportStar(require("./DateTimeFormat/FormatDateTime"), exports);
tslib_1.__exportStar(require("./DateTimeFormat/FormatDateTimeRange"), exports);
tslib_1.__exportStar(require("./DateTimeFormat/FormatDateTimeRangeToParts"), exports);
tslib_1.__exportStar(require("./DateTimeFormat/FormatDateTimeToParts"), exports);
tslib_1.__exportStar(require("./DateTimeFormat/InitializeDateTimeFormat"), exports);
tslib_1.__exportStar(require("./DateTimeFormat/PartitionDateTimePattern"), exports);
tslib_1.__exportStar(require("./DateTimeFormat/ToDateTimeOptions"), exports);
tslib_1.__exportStar(require("./DisplayNames/CanonicalCodeForDisplayNames"), exports);
tslib_1.__exportStar(require("./GetNumberOption"), exports);
tslib_1.__exportStar(require("./GetOption"), exports);
tslib_1.__exportStar(require("./IsSanctionedSimpleUnitIdentifier"), exports);
tslib_1.__exportStar(require("./IsValidTimeZoneName"), exports);
tslib_1.__exportStar(require("./IsWellFormedCurrencyCode"), exports);
tslib_1.__exportStar(require("./IsWellFormedUnitIdentifier"), exports);
tslib_1.__exportStar(require("./NumberFormat/ComputeExponent"), exports);
tslib_1.__exportStar(require("./NumberFormat/ComputeExponentForMagnitude"), exports);
tslib_1.__exportStar(require("./NumberFormat/CurrencyDigits"), exports);
tslib_1.__exportStar(require("./NumberFormat/FormatNumericToParts"), exports);
tslib_1.__exportStar(require("./NumberFormat/FormatNumericToString"), exports);
tslib_1.__exportStar(require("./NumberFormat/InitializeNumberFormat"), exports);
tslib_1.__exportStar(require("./NumberFormat/PartitionNumberPattern"), exports);
tslib_1.__exportStar(require("./NumberFormat/SetNumberFormatDigitOptions"), exports);
tslib_1.__exportStar(require("./NumberFormat/SetNumberFormatUnitOptions"), exports);
tslib_1.__exportStar(require("./NumberFormat/ToRawFixed"), exports);
tslib_1.__exportStar(require("./NumberFormat/ToRawPrecision"), exports);
tslib_1.__exportStar(require("./PartitionPattern"), exports);
tslib_1.__exportStar(require("./PluralRules/GetOperands"), exports);
tslib_1.__exportStar(require("./PluralRules/InitializePluralRules"), exports);
tslib_1.__exportStar(require("./PluralRules/ResolvePlural"), exports);
tslib_1.__exportStar(require("./RelativeTimeFormat/FormatRelativeTime"), exports);
tslib_1.__exportStar(require("./RelativeTimeFormat/FormatRelativeTimeToParts"), exports);
tslib_1.__exportStar(require("./RelativeTimeFormat/InitializeRelativeTimeFormat"), exports);
tslib_1.__exportStar(require("./RelativeTimeFormat/MakePartsList"), exports);
tslib_1.__exportStar(require("./RelativeTimeFormat/PartitionRelativeTimePattern"), exports);
tslib_1.__exportStar(require("./RelativeTimeFormat/SingularRelativeTimeUnit"), exports);
tslib_1.__exportStar(require("./ResolveLocale"), exports);
tslib_1.__exportStar(require("./SupportedLocales"), exports);
var format_to_parts_1 = require("./NumberFormat/format_to_parts");
Object.defineProperty(exports, "_formatToParts", { enumerable: true, get: function () { return tslib_1.__importDefault(format_to_parts_1).default; } });
var utils_1 = require("./DateTimeFormat/utils");
Object.defineProperty(exports, "DATE_TIME_PROPS", { enumerable: true, get: function () { return utils_1.DATE_TIME_PROPS; } });
var skeleton_1 = require("./DateTimeFormat/skeleton");
Object.defineProperty(exports, "parseDateTimeSkeleton", { enumerable: true, get: function () { return skeleton_1.parseDateTimeSkeleton; } });
var utils_2 = require("./utils");
Object.defineProperty(exports, "getInternalSlot", { enumerable: true, get: function () { return utils_2.getInternalSlot; } });
Object.defineProperty(exports, "getMultiInternalSlots", { enumerable: true, get: function () { return utils_2.getMultiInternalSlots; } });
Object.defineProperty(exports, "isLiteralPart", { enumerable: true, get: function () { return utils_2.isLiteralPart; } });
Object.defineProperty(exports, "setInternalSlot", { enumerable: true, get: function () { return utils_2.setInternalSlot; } });
Object.defineProperty(exports, "setMultiInternalSlots", { enumerable: true, get: function () { return utils_2.setMultiInternalSlots; } });
Object.defineProperty(exports, "getMagnitude", { enumerable: true, get: function () { return utils_2.getMagnitude; } });
Object.defineProperty(exports, "defineProperty", { enumerable: true, get: function () { return utils_2.defineProperty; } });
var data_1 = require("./data");
Object.defineProperty(exports, "isMissingLocaleDataError", { enumerable: true, get: function () { return data_1.isMissingLocaleDataError; } });
tslib_1.__exportStar(require("./types/relative-time"), exports);
tslib_1.__exportStar(require("./types/date-time"), exports);
tslib_1.__exportStar(require("./types/list"), exports);
tslib_1.__exportStar(require("./types/plural-rules"), exports);
tslib_1.__exportStar(require("./types/number"), exports);
tslib_1.__exportStar(require("./types/displaynames"), exports);
var utils_3 = require("./utils");
Object.defineProperty(exports, "invariant", { enumerable: true, get: function () { return utils_3.invariant; } });
tslib_1.__exportStar(require("./262"), exports);

},{"./262":7,"./CanonicalizeLocaleList":10,"./CanonicalizeTimeZoneName":11,"./DateTimeFormat/BasicFormatMatcher":12,"./DateTimeFormat/BestFitFormatMatcher":13,"./DateTimeFormat/DateTimeStyleFormat":14,"./DateTimeFormat/FormatDateTime":15,"./DateTimeFormat/FormatDateTimeRange":17,"./DateTimeFormat/FormatDateTimeRangeToParts":18,"./DateTimeFormat/FormatDateTimeToParts":19,"./DateTimeFormat/InitializeDateTimeFormat":20,"./DateTimeFormat/PartitionDateTimePattern":21,"./DateTimeFormat/ToDateTimeOptions":23,"./DateTimeFormat/skeleton":25,"./DateTimeFormat/utils":26,"./DisplayNames/CanonicalCodeForDisplayNames":28,"./GetNumberOption":29,"./GetOption":30,"./IsSanctionedSimpleUnitIdentifier":31,"./IsValidTimeZoneName":32,"./IsWellFormedCurrencyCode":33,"./IsWellFormedUnitIdentifier":34,"./NumberFormat/ComputeExponent":37,"./NumberFormat/ComputeExponentForMagnitude":38,"./NumberFormat/CurrencyDigits":39,"./NumberFormat/FormatNumericToParts":40,"./NumberFormat/FormatNumericToString":41,"./NumberFormat/InitializeNumberFormat":42,"./NumberFormat/PartitionNumberPattern":43,"./NumberFormat/SetNumberFormatDigitOptions":44,"./NumberFormat/SetNumberFormatUnitOptions":45,"./NumberFormat/ToRawFixed":46,"./NumberFormat/ToRawPrecision":47,"./NumberFormat/format_to_parts":49,"./PartitionPattern":50,"./PluralRules/GetOperands":51,"./PluralRules/InitializePluralRules":52,"./PluralRules/ResolvePlural":53,"./RelativeTimeFormat/FormatRelativeTime":54,"./RelativeTimeFormat/FormatRelativeTimeToParts":55,"./RelativeTimeFormat/InitializeRelativeTimeFormat":56,"./RelativeTimeFormat/MakePartsList":57,"./RelativeTimeFormat/PartitionRelativeTimePattern":58,"./RelativeTimeFormat/SingularRelativeTimeUnit":59,"./ResolveLocale":60,"./SupportedLocales":61,"./data":63,"./types/date-time":65,"./types/displaynames":66,"./types/list":67,"./types/number":68,"./types/plural-rules":69,"./types/relative-time":70,"./utils":71,"tslib":88}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RangePatternType = void 0;
var RangePatternType;
(function (RangePatternType) {
    RangePatternType["startRange"] = "startRange";
    RangePatternType["shared"] = "shared";
    RangePatternType["endRange"] = "endRange";
})(RangePatternType = exports.RangePatternType || (exports.RangePatternType = {}));

},{}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],67:[function(require,module,exports){
arguments[4][66][0].apply(exports,arguments)
},{"dup":66}],68:[function(require,module,exports){
arguments[4][66][0].apply(exports,arguments)
},{"dup":66}],69:[function(require,module,exports){
arguments[4][66][0].apply(exports,arguments)
},{"dup":66}],70:[function(require,module,exports){
arguments[4][66][0].apply(exports,arguments)
},{"dup":66}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.invariant = exports.UNICODE_EXTENSION_SEQUENCE_REGEX = exports.defineProperty = exports.isLiteralPart = exports.getMultiInternalSlots = exports.getInternalSlot = exports.setMultiInternalSlots = exports.setInternalSlot = exports.repeat = exports.getMagnitude = void 0;
/**
 * Cannot do Math.log(x) / Math.log(10) bc if IEEE floating point issue
 * @param x number
 */
function getMagnitude(x) {
    // Cannot count string length via Number.toString because it may use scientific notation
    // for very small or very large numbers.
    return Math.floor(Math.log(x) * Math.LOG10E);
}
exports.getMagnitude = getMagnitude;
function repeat(s, times) {
    if (typeof s.repeat === 'function') {
        return s.repeat(times);
    }
    var arr = new Array(times);
    for (var i = 0; i < arr.length; i++) {
        arr[i] = s;
    }
    return arr.join('');
}
exports.repeat = repeat;
function setInternalSlot(map, pl, field, value) {
    if (!map.get(pl)) {
        map.set(pl, Object.create(null));
    }
    var slots = map.get(pl);
    slots[field] = value;
}
exports.setInternalSlot = setInternalSlot;
function setMultiInternalSlots(map, pl, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var k = _a[_i];
        setInternalSlot(map, pl, k, props[k]);
    }
}
exports.setMultiInternalSlots = setMultiInternalSlots;
function getInternalSlot(map, pl, field) {
    return getMultiInternalSlots(map, pl, field)[field];
}
exports.getInternalSlot = getInternalSlot;
function getMultiInternalSlots(map, pl) {
    var fields = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        fields[_i - 2] = arguments[_i];
    }
    var slots = map.get(pl);
    if (!slots) {
        throw new TypeError(pl + " InternalSlot has not been initialized");
    }
    return fields.reduce(function (all, f) {
        all[f] = slots[f];
        return all;
    }, Object.create(null));
}
exports.getMultiInternalSlots = getMultiInternalSlots;
function isLiteralPart(patternPart) {
    return patternPart.type === 'literal';
}
exports.isLiteralPart = isLiteralPart;
/*
  17 ECMAScript Standard Built-in Objects:
    Every built-in Function object, including constructors, that is not
    identified as an anonymous function has a name property whose value
    is a String.

    Unless otherwise specified, the name property of a built-in Function
    object, if it exists, has the attributes { [[Writable]]: false,
    [[Enumerable]]: false, [[Configurable]]: true }.
*/
function defineProperty(target, name, _a) {
    var value = _a.value;
    Object.defineProperty(target, name, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: value,
    });
}
exports.defineProperty = defineProperty;
exports.UNICODE_EXTENSION_SEQUENCE_REGEX = /-u(?:-[0-9a-z]{2,8})+/gi;
function invariant(condition, message, Err) {
    if (Err === void 0) { Err = Error; }
    if (!condition) {
        throw new Err(message);
    }
}
exports.invariant = invariant;

},{}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DisplayNames = void 0;
var tslib_1 = require("tslib");
var ecma402_abstract_1 = require("@formatjs/ecma402-abstract");
var DisplayNames = /** @class */ (function () {
    function DisplayNames(locales, options) {
        var _newTarget = this.constructor;
        if (_newTarget === undefined) {
            throw TypeError("Constructor Intl.DisplayNames requires 'new'");
        }
        var requestedLocales = ecma402_abstract_1.CanonicalizeLocaleList(locales);
        options = ecma402_abstract_1.ToObject(options);
        var opt = Object.create(null);
        var localeData = DisplayNames.localeData;
        var matcher = ecma402_abstract_1.GetOption(options, 'localeMatcher', 'string', ['lookup', 'best fit'], 'best fit');
        opt.localeMatcher = matcher;
        var r = ecma402_abstract_1.ResolveLocale(DisplayNames.availableLocales, requestedLocales, opt, [], // there is no relevantExtensionKeys
        DisplayNames.localeData, DisplayNames.getDefaultLocale);
        var style = ecma402_abstract_1.GetOption(options, 'style', 'string', ['narrow', 'short', 'long'], 'long');
        setSlot(this, 'style', style);
        var type = ecma402_abstract_1.GetOption(options, 'type', 'string', ['language', 'currency', 'region', 'script'], undefined);
        if (type === undefined) {
            throw TypeError("Intl.DisplayNames constructor requires \"type\" option");
        }
        setSlot(this, 'type', type);
        var fallback = ecma402_abstract_1.GetOption(options, 'fallback', 'string', ['code', 'none'], 'code');
        setSlot(this, 'fallback', fallback);
        setSlot(this, 'locale', r.locale);
        var dataLocale = r.dataLocale;
        var dataLocaleData = localeData[dataLocale];
        ecma402_abstract_1.invariant(!!dataLocaleData, "Missing locale data for " + dataLocale);
        setSlot(this, 'localeData', dataLocaleData);
        ecma402_abstract_1.invariant(dataLocaleData !== undefined, "locale data for " + r.locale + " does not exist.");
        var types = dataLocaleData.types;
        ecma402_abstract_1.invariant(typeof types === 'object' && types != null, 'invalid types data');
        var typeFields = types[type];
        ecma402_abstract_1.invariant(typeof typeFields === 'object' && typeFields != null, 'invalid typeFields data');
        var styleFields = typeFields[style];
        ecma402_abstract_1.invariant(typeof styleFields === 'object' && styleFields != null, 'invalid styleFields data');
        setSlot(this, 'fields', styleFields);
    }
    DisplayNames.supportedLocalesOf = function (locales, options) {
        return ecma402_abstract_1.SupportedLocales(DisplayNames.availableLocales, ecma402_abstract_1.CanonicalizeLocaleList(locales), options);
    };
    DisplayNames.__addLocaleData = function () {
        var data = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            data[_i] = arguments[_i];
        }
        for (var _a = 0, data_1 = data; _a < data_1.length; _a++) {
            var _b = data_1[_a], d = _b.data, locale = _b.locale;
            var minimizedLocale = new Intl.Locale(locale)
                .minimize()
                .toString();
            DisplayNames.localeData[locale] = DisplayNames.localeData[minimizedLocale] = d;
            DisplayNames.availableLocales.add(minimizedLocale);
            DisplayNames.availableLocales.add(locale);
            if (!DisplayNames.__defaultLocale) {
                DisplayNames.__defaultLocale = minimizedLocale;
            }
        }
    };
    DisplayNames.prototype.of = function (code) {
        checkReceiver(this, 'of');
        var type = getSlot(this, 'type');
        var codeAsString = ecma402_abstract_1.ToString(code);
        if (!isValidCodeForDisplayNames(type, codeAsString)) {
            throw RangeError('invalid code for Intl.DisplayNames.prototype.of');
        }
        var _a = ecma402_abstract_1.getMultiInternalSlots(__INTERNAL_SLOT_MAP__, this, 'localeData', 'style', 'fallback'), localeData = _a.localeData, style = _a.style, fallback = _a.fallback;
        // Canonicalize the case.
        var canonicalCode;
        // This is only used to store extracted language region.
        var regionSubTag;
        switch (type) {
            // Normalize the locale id and remove the region.
            case 'language': {
                canonicalCode = ecma402_abstract_1.CanonicalizeLocaleList(codeAsString)[0];
                var regionMatch = /-([a-z]{2}|\d{3})\b/i.exec(canonicalCode);
                if (regionMatch) {
                    // Remove region subtag
                    canonicalCode =
                        canonicalCode.substring(0, regionMatch.index) +
                            canonicalCode.substring(regionMatch.index + regionMatch[0].length);
                    regionSubTag = regionMatch[1];
                }
                break;
            }
            // currency code should be all upper-case.
            case 'currency':
                canonicalCode = codeAsString.toUpperCase();
                break;
            // script code should be title case
            case 'script':
                canonicalCode =
                    codeAsString[0] + codeAsString.substring(1).toLowerCase();
                break;
            // region shold be all upper-case
            case 'region':
                canonicalCode = codeAsString.toUpperCase();
                break;
        }
        var typesData = localeData.types[type];
        // If the style of choice does not exist, fallback to "long".
        var name = typesData[style][canonicalCode] || typesData.long[canonicalCode];
        if (name !== undefined) {
            // If there is a region subtag in the language id, use locale pattern to interpolate the region
            if (regionSubTag) {
                // Retrieve region display names
                var regionsData = localeData.types.region;
                var regionDisplayName = regionsData[style][regionSubTag] || regionsData.long[regionSubTag];
                if (regionDisplayName || fallback === 'code') {
                    // Interpolate into locale-specific pattern.
                    var pattern = localeData.patterns.locale;
                    return pattern
                        .replace('{0}', name)
                        .replace('{1}', regionDisplayName || regionSubTag);
                }
            }
            else {
                return name;
            }
        }
        if (fallback === 'code') {
            return codeAsString;
        }
    };
    DisplayNames.prototype.resolvedOptions = function () {
        checkReceiver(this, 'resolvedOptions');
        return tslib_1.__assign({}, ecma402_abstract_1.getMultiInternalSlots(__INTERNAL_SLOT_MAP__, this, 'locale', 'style', 'type', 'fallback'));
    };
    DisplayNames.getDefaultLocale = function () {
        return DisplayNames.__defaultLocale;
    };
    DisplayNames.localeData = {};
    DisplayNames.availableLocales = new Set();
    DisplayNames.__defaultLocale = '';
    DisplayNames.polyfilled = true;
    return DisplayNames;
}());
exports.DisplayNames = DisplayNames;
// https://tc39.es/proposal-intl-displaynames/#sec-isvalidcodefordisplaynames
function isValidCodeForDisplayNames(type, code) {
    switch (type) {
        case 'language':
            // subset of unicode_language_id
            // languageCode ["-" scriptCode] ["-" regionCode] *("-" variant)
            // where:
            // - languageCode is either a two letters ISO 639-1 language code or a three letters ISO 639-2 language code.
            // - scriptCode is should be an ISO-15924 four letters script code
            // - regionCode is either an ISO-3166 two letters region code, or a three digits UN M49 Geographic Regions.
            return /^[a-z]{2,3}(-[a-z]{4})?(-([a-z]{2}|\d{3}))?(-([a-z\d]{5,8}|\d[a-z\d]{3}))*$/i.test(code);
        case 'region':
            // unicode_region_subtag
            return /^([a-z]{2}|\d{3})$/i.test(code);
        case 'script':
            // unicode_script_subtag
            return /^[a-z]{4}$/i.test(code);
        case 'currency':
            return ecma402_abstract_1.IsWellFormedCurrencyCode(code);
    }
}
try {
    // IE11 does not have Symbol
    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
        Object.defineProperty(DisplayNames.prototype, Symbol.toStringTag, {
            value: 'Intl.DisplayNames',
            configurable: true,
            enumerable: false,
            writable: false,
        });
    }
    Object.defineProperty(DisplayNames, 'length', {
        value: 2,
        writable: false,
        enumerable: false,
        configurable: true,
    });
}
catch (e) {
    // Make test 262 compliant
}
var __INTERNAL_SLOT_MAP__ = new WeakMap();
function getSlot(instance, key) {
    return ecma402_abstract_1.getInternalSlot(__INTERNAL_SLOT_MAP__, instance, key);
}
function setSlot(instance, key, value) {
    ecma402_abstract_1.setInternalSlot(__INTERNAL_SLOT_MAP__, instance, key, value);
}
function checkReceiver(receiver, methodName) {
    if (!(receiver instanceof DisplayNames)) {
        throw TypeError("Method Intl.DisplayNames.prototype." + methodName + " called on incompatible receiver");
    }
}

},{"@formatjs/ecma402-abstract":64,"tslib":88}],73:[function(require,module,exports){
/* @generated */
// prettier-ignore
if (Intl.DisplayNames && typeof Intl.DisplayNames.__addLocaleData === 'function') {
  Intl.DisplayNames.__addLocaleData({"data":{"types":{"language":{"long":{"aa":"Afar","ab":"Abkhazian","ace":"Achinese","ach":"Acoli","ada":"Adangme","ady":"Adyghe","ae":"Avestan","aeb":"Tunisian Arabic","af":"Afrikaans","afh":"Afrihili","agq":"Aghem","ain":"Ainu","ak":"Akan","akk":"Akkadian","akz":"Alabama","ale":"Aleut","aln":"Gheg Albanian","alt":"Southern Altai","am":"Amharic","an":"Aragonese","ang":"Old English","anp":"Angika","ar":"Arabic","ar-001":"Modern Standard Arabic","arc":"Aramaic","arn":"Mapuche","aro":"Araona","arp":"Arapaho","arq":"Algerian Arabic","ars":"Najdi Arabic","arw":"Arawak","ary":"Moroccan Arabic","arz":"Egyptian Arabic","as":"Assamese","asa":"Asu","ase":"American Sign Language","ast":"Asturian","av":"Avaric","avk":"Kotava","awa":"Awadhi","ay":"Aymara","az":"Azerbaijani","ba":"Bashkir","bal":"Baluchi","ban":"Balinese","bar":"Bavarian","bas":"Basaa","bax":"Bamun","bbc":"Batak Toba","bbj":"Ghomala","be":"Belarusian","bej":"Beja","bem":"Bemba","bew":"Betawi","bez":"Bena","bfd":"Bafut","bfq":"Badaga","bg":"Bulgarian","bgn":"Western Balochi","bho":"Bhojpuri","bi":"Bislama","bik":"Bikol","bin":"Bini","bjn":"Banjar","bkm":"Kom","bla":"Siksika","bm":"Bambara","bn":"Bangla","bo":"Tibetan","bpy":"Bishnupriya","bqi":"Bakhtiari","br":"Breton","bra":"Braj","brh":"Brahui","brx":"Bodo","bs":"Bosnian","bss":"Akoose","bua":"Buriat","bug":"Buginese","bum":"Bulu","byn":"Blin","byv":"Medumba","ca":"Catalan","cad":"Caddo","car":"Carib","cay":"Cayuga","cch":"Atsam","ccp":"Chakma","ce":"Chechen","ceb":"Cebuano","cgg":"Chiga","ch":"Chamorro","chb":"Chibcha","chg":"Chagatai","chk":"Chuukese","chm":"Mari","chn":"Chinook Jargon","cho":"Choctaw","chp":"Chipewyan","chr":"Cherokee","chy":"Cheyenne","cic":"Chickasaw","ckb":"Central Kurdish","co":"Corsican","cop":"Coptic","cps":"Capiznon","cr":"Cree","crh":"Crimean Turkish","crs":"Seselwa Creole French","cs":"Czech","csb":"Kashubian","cu":"Church Slavic","cv":"Chuvash","cy":"Welsh","da":"Danish","dak":"Dakota","dar":"Dargwa","dav":"Taita","de":"German","de-AT":"Austrian German","de-CH":"Swiss High German","del":"Delaware","den":"Slave","dgr":"Dogrib","din":"Dinka","dje":"Zarma","doi":"Dogri","dsb":"Lower Sorbian","dtp":"Central Dusun","dua":"Duala","dum":"Middle Dutch","dv":"Divehi","dyo":"Jola-Fonyi","dyu":"Dyula","dz":"Dzongkha","dzg":"Dazaga","ebu":"Embu","ee":"Ewe","efi":"Efik","egl":"Emilian","egy":"Ancient Egyptian","eka":"Ekajuk","el":"Greek","elx":"Elamite","en":"English","en-AU":"Australian English","en-CA":"Canadian English","en-GB":"British English","en-US":"American English","enm":"Middle English","eo":"Esperanto","es":"Spanish","es-419":"Latin American Spanish","es-ES":"European Spanish","es-MX":"Mexican Spanish","esu":"Central Yupik","et":"Estonian","eu":"Basque","ewo":"Ewondo","ext":"Extremaduran","fa":"Persian","fa-AF":"Dari","fan":"Fang","fat":"Fanti","ff":"Fulah","fi":"Finnish","fil":"Filipino","fit":"Tornedalen Finnish","fj":"Fijian","fo":"Faroese","fon":"Fon","fr":"French","fr-CA":"Canadian French","fr-CH":"Swiss French","frc":"Cajun French","frm":"Middle French","fro":"Old French","frp":"Arpitan","frr":"Northern Frisian","frs":"Eastern Frisian","fur":"Friulian","fy":"Western Frisian","ga":"Irish","gaa":"Ga","gag":"Gagauz","gan":"Gan Chinese","gay":"Gayo","gba":"Gbaya","gbz":"Zoroastrian Dari","gd":"Scottish Gaelic","gez":"Geez","gil":"Gilbertese","gl":"Galician","glk":"Gilaki","gmh":"Middle High German","gn":"Guarani","goh":"Old High German","gom":"Goan Konkani","gon":"Gondi","gor":"Gorontalo","got":"Gothic","grb":"Grebo","grc":"Ancient Greek","gsw":"Swiss German","gu":"Gujarati","guc":"Wayuu","gur":"Frafra","guz":"Gusii","gv":"Manx","gwi":"GwichÊ¼in","ha":"Hausa","hai":"Haida","hak":"Hakka Chinese","haw":"Hawaiian","he":"Hebrew","hi":"Hindi","hif":"Fiji Hindi","hil":"Hiligaynon","hit":"Hittite","hmn":"Hmong","ho":"Hiri Motu","hr":"Croatian","hsb":"Upper Sorbian","hsn":"Xiang Chinese","ht":"Haitian Creole","hu":"Hungarian","hup":"Hupa","hy":"Armenian","hz":"Herero","ia":"Interlingua","iba":"Iban","ibb":"Ibibio","id":"Indonesian","ie":"Interlingue","ig":"Igbo","ii":"Sichuan Yi","ik":"Inupiaq","ilo":"Iloko","inh":"Ingush","io":"Ido","is":"Icelandic","it":"Italian","iu":"Inuktitut","izh":"Ingrian","ja":"Japanese","jam":"Jamaican Creole English","jbo":"Lojban","jgo":"Ngomba","jmc":"Machame","jpr":"Judeo-Persian","jrb":"Judeo-Arabic","jut":"Jutish","jv":"Javanese","ka":"Georgian","kaa":"Kara-Kalpak","kab":"Kabyle","kac":"Kachin","kaj":"Jju","kam":"Kamba","kaw":"Kawi","kbd":"Kabardian","kbl":"Kanembu","kcg":"Tyap","kde":"Makonde","kea":"Kabuverdianu","ken":"Kenyang","kfo":"Koro","kg":"Kongo","kgp":"Kaingang","kha":"Khasi","kho":"Khotanese","khq":"Koyra Chiini","khw":"Khowar","ki":"Kikuyu","kiu":"Kirmanjki","kj":"Kuanyama","kk":"Kazakh","kkj":"Kako","kl":"Kalaallisut","kln":"Kalenjin","km":"Khmer","kmb":"Kimbundu","kn":"Kannada","ko":"Korean","koi":"Komi-Permyak","kok":"Konkani","kos":"Kosraean","kpe":"Kpelle","kr":"Kanuri","krc":"Karachay-Balkar","kri":"Krio","krj":"Kinaray-a","krl":"Karelian","kru":"Kurukh","ks":"Kashmiri","ksb":"Shambala","ksf":"Bafia","ksh":"Colognian","ku":"Kurdish","kum":"Kumyk","kut":"Kutenai","kv":"Komi","kw":"Cornish","ky":"Kyrgyz","la":"Latin","lad":"Ladino","lag":"Langi","lah":"Lahnda","lam":"Lamba","lb":"Luxembourgish","lez":"Lezghian","lfn":"Lingua Franca Nova","lg":"Ganda","li":"Limburgish","lij":"Ligurian","liv":"Livonian","lkt":"Lakota","lmo":"Lombard","ln":"Lingala","lo":"Lao","lol":"Mongo","lou":"Louisiana Creole","loz":"Lozi","lrc":"Northern Luri","lt":"Lithuanian","ltg":"Latgalian","lu":"Luba-Katanga","lua":"Luba-Lulua","lui":"Luiseno","lun":"Lunda","luo":"Luo","lus":"Mizo","luy":"Luyia","lv":"Latvian","lzh":"Literary Chinese","lzz":"Laz","mad":"Madurese","maf":"Mafa","mag":"Magahi","mai":"Maithili","mak":"Makasar","man":"Mandingo","mas":"Masai","mde":"Maba","mdf":"Moksha","mdr":"Mandar","men":"Mende","mer":"Meru","mfe":"Morisyen","mg":"Malagasy","mga":"Middle Irish","mgh":"Makhuwa-Meetto","mgo":"MetaÊ¼","mh":"Marshallese","mi":"Maori","mic":"Mi'kmaq","min":"Minangkabau","mk":"Macedonian","ml":"Malayalam","mn":"Mongolian","mnc":"Manchu","mni":"Manipuri","moh":"Mohawk","mos":"Mossi","mr":"Marathi","mrj":"Western Mari","ms":"Malay","mt":"Maltese","mua":"Mundang","mul":"Multiple languages","mus":"Muscogee","mwl":"Mirandese","mwr":"Marwari","mwv":"Mentawai","my":"Burmese","mye":"Myene","myv":"Erzya","mzn":"Mazanderani","na":"Nauru","nan":"Min Nan Chinese","nap":"Neapolitan","naq":"Nama","nb":"Norwegian BokmÃ¥l","nd":"North Ndebele","nds":"Low German","nds-NL":"Low Saxon","ne":"Nepali","new":"Newari","ng":"Ndonga","nia":"Nias","niu":"Niuean","njo":"Ao Naga","nl":"Dutch","nl-BE":"Flemish","nmg":"Kwasio","nn":"Norwegian Nynorsk","nnh":"Ngiemboon","no":"Norwegian","nog":"Nogai","non":"Old Norse","nov":"Novial","nqo":"Nâ€™Ko","nr":"South Ndebele","nso":"Northern Sotho","nus":"Nuer","nv":"Navajo","nwc":"Classical Newari","ny":"Nyanja","nym":"Nyamwezi","nyn":"Nyankole","nyo":"Nyoro","nzi":"Nzima","oc":"Occitan","oj":"Ojibwa","om":"Oromo","or":"Odia","os":"Ossetic","osa":"Osage","ota":"Ottoman Turkish","pa":"Punjabi","pag":"Pangasinan","pal":"Pahlavi","pam":"Pampanga","pap":"Papiamento","pau":"Palauan","pcd":"Picard","pcm":"Nigerian Pidgin","pdc":"Pennsylvania German","pdt":"Plautdietsch","peo":"Old Persian","pfl":"Palatine German","phn":"Phoenician","pi":"Pali","pl":"Polish","pms":"Piedmontese","pnt":"Pontic","pon":"Pohnpeian","prg":"Prussian","pro":"Old ProvenÃ§al","ps":"Pashto","pt":"Portuguese","pt-BR":"Brazilian Portuguese","pt-PT":"European Portuguese","qu":"Quechua","quc":"KÊ¼icheÊ¼","qug":"Chimborazo Highland Quichua","raj":"Rajasthani","rap":"Rapanui","rar":"Rarotongan","rgn":"Romagnol","rif":"Riffian","rm":"Romansh","rn":"Rundi","ro":"Romanian","ro-MD":"Moldavian","rof":"Rombo","rom":"Romany","root":"Root","rtm":"Rotuman","ru":"Russian","rue":"Rusyn","rug":"Roviana","rup":"Aromanian","rw":"Kinyarwanda","rwk":"Rwa","sa":"Sanskrit","sad":"Sandawe","sah":"Sakha","sam":"Samaritan Aramaic","saq":"Samburu","sas":"Sasak","sat":"Santali","saz":"Saurashtra","sba":"Ngambay","sbp":"Sangu","sc":"Sardinian","scn":"Sicilian","sco":"Scots","sd":"Sindhi","sdc":"Sassarese Sardinian","sdh":"Southern Kurdish","se":"Northern Sami","see":"Seneca","seh":"Sena","sei":"Seri","sel":"Selkup","ses":"Koyraboro Senni","sg":"Sango","sga":"Old Irish","sgs":"Samogitian","sh":"Serbo-Croatian","shi":"Tachelhit","shn":"Shan","shu":"Chadian Arabic","si":"Sinhala","sid":"Sidamo","sk":"Slovak","sl":"Slovenian","sli":"Lower Silesian","sly":"Selayar","sm":"Samoan","sma":"Southern Sami","smj":"Lule Sami","smn":"Inari Sami","sms":"Skolt Sami","sn":"Shona","snk":"Soninke","so":"Somali","sog":"Sogdien","sq":"Albanian","sr":"Serbian","sr-ME":"Montenegrin","srn":"Sranan Tongo","srr":"Serer","ss":"Swati","ssy":"Saho","st":"Southern Sotho","stq":"Saterland Frisian","su":"Sundanese","suk":"Sukuma","sus":"Susu","sux":"Sumerian","sv":"Swedish","sw":"Swahili","sw-CD":"Congo Swahili","swb":"Comorian","syc":"Classical Syriac","syr":"Syriac","szl":"Silesian","ta":"Tamil","tcy":"Tulu","te":"Telugu","tem":"Timne","teo":"Teso","ter":"Tereno","tet":"Tetum","tg":"Tajik","th":"Thai","ti":"Tigrinya","tig":"Tigre","tiv":"Tiv","tk":"Turkmen","tkl":"Tokelau","tkr":"Tsakhur","tl":"Tagalog","tlh":"Klingon","tli":"Tlingit","tly":"Talysh","tmh":"Tamashek","tn":"Tswana","to":"Tongan","tog":"Nyasa Tonga","tpi":"Tok Pisin","tr":"Turkish","tru":"Turoyo","trv":"Taroko","ts":"Tsonga","tsd":"Tsakonian","tsi":"Tsimshian","tt":"Tatar","ttt":"Muslim Tat","tum":"Tumbuka","tvl":"Tuvalu","tw":"Twi","twq":"Tasawaq","ty":"Tahitian","tyv":"Tuvinian","tzm":"Central Atlas Tamazight","udm":"Udmurt","ug":"Uyghur","uga":"Ugaritic","uk":"Ukrainian","umb":"Umbundu","und":"Unknown language","ur":"Urdu","uz":"Uzbek","vai":"Vai","ve":"Venda","vec":"Venetian","vep":"Veps","vi":"Vietnamese","vls":"West Flemish","vmf":"Main-Franconian","vo":"VolapÃ¼k","vot":"Votic","vro":"VÃµro","vun":"Vunjo","wa":"Walloon","wae":"Walser","wal":"Wolaytta","war":"Waray","was":"Washo","wbp":"Warlpiri","wo":"Wolof","wuu":"Wu Chinese","xal":"Kalmyk","xh":"Xhosa","xmf":"Mingrelian","xog":"Soga","yao":"Yao","yap":"Yapese","yav":"Yangben","ybb":"Yemba","yi":"Yiddish","yo":"Yoruba","yrl":"Nheengatu","yue":"Cantonese","za":"Zhuang","zap":"Zapotec","zbl":"Blissymbols","zea":"Zeelandic","zen":"Zenaga","zgh":"Standard Moroccan Tamazight","zh":"Chinese","zh-Hans":"Simplified Chinese","zh-Hant":"Traditional Chinese","zu":"Zulu","zun":"Zuni","zxx":"No linguistic content","zza":"Zaza"},"short":{"az":"Azeri","en-GB":"UK English","en-US":"US English"},"narrow":{}},"region":{"long":{"142":"Asia","143":"Central Asia","145":"Western Asia","150":"Europe","151":"Eastern Europe","154":"Northern Europe","155":"Western Europe","202":"Sub-Saharan Africa","419":"Latin America","001":"World","002":"Africa","003":"North America","005":"South America","009":"Oceania","011":"Western Africa","013":"Central America","014":"Eastern Africa","015":"Northern Africa","017":"Middle Africa","018":"Southern Africa","019":"Americas","021":"Northern America","029":"Caribbean","030":"Eastern Asia","034":"Southern Asia","035":"Southeast Asia","039":"Southern Europe","053":"Australasia","054":"Melanesia","057":"Micronesian Region","061":"Polynesia","AC":"Ascension Island","AD":"Andorra","AE":"United Arab Emirates","AF":"Afghanistan","AG":"Antigua & Barbuda","AI":"Anguilla","AL":"Albania","AM":"Armenia","AO":"Angola","AQ":"Antarctica","AR":"Argentina","AS":"American Samoa","AT":"Austria","AU":"Australia","AW":"Aruba","AX":"Ã…land Islands","AZ":"Azerbaijan","BA":"Bosnia & Herzegovina","BB":"Barbados","BD":"Bangladesh","BE":"Belgium","BF":"Burkina Faso","BG":"Bulgaria","BH":"Bahrain","BI":"Burundi","BJ":"Benin","BL":"St. BarthÃ©lemy","BM":"Bermuda","BN":"Brunei","BO":"Bolivia","BQ":"Caribbean Netherlands","BR":"Brazil","BS":"Bahamas","BT":"Bhutan","BV":"Bouvet Island","BW":"Botswana","BY":"Belarus","BZ":"Belize","CA":"Canada","CC":"Cocos (Keeling) Islands","CD":"Congo - Kinshasa","CF":"Central African Republic","CG":"Congo - Brazzaville","CH":"Switzerland","CI":"CÃ´te dâ€™Ivoire","CK":"Cook Islands","CL":"Chile","CM":"Cameroon","CN":"China","CO":"Colombia","CP":"Clipperton Island","CR":"Costa Rica","CU":"Cuba","CV":"Cape Verde","CW":"CuraÃ§ao","CX":"Christmas Island","CY":"Cyprus","CZ":"Czechia","DE":"Germany","DG":"Diego Garcia","DJ":"Djibouti","DK":"Denmark","DM":"Dominica","DO":"Dominican Republic","DZ":"Algeria","EA":"Ceuta & Melilla","EC":"Ecuador","EE":"Estonia","EG":"Egypt","EH":"Western Sahara","ER":"Eritrea","ES":"Spain","ET":"Ethiopia","EU":"European Union","EZ":"Eurozone","FI":"Finland","FJ":"Fiji","FK":"Falkland Islands","FM":"Micronesia","FO":"Faroe Islands","FR":"France","GA":"Gabon","GB":"United Kingdom","GD":"Grenada","GE":"Georgia","GF":"French Guiana","GG":"Guernsey","GH":"Ghana","GI":"Gibraltar","GL":"Greenland","GM":"Gambia","GN":"Guinea","GP":"Guadeloupe","GQ":"Equatorial Guinea","GR":"Greece","GS":"South Georgia & South Sandwich Islands","GT":"Guatemala","GU":"Guam","GW":"Guinea-Bissau","GY":"Guyana","HK":"Hong Kong SAR China","HM":"Heard & McDonald Islands","HN":"Honduras","HR":"Croatia","HT":"Haiti","HU":"Hungary","IC":"Canary Islands","ID":"Indonesia","IE":"Ireland","IL":"Israel","IM":"Isle of Man","IN":"India","IO":"British Indian Ocean Territory","IQ":"Iraq","IR":"Iran","IS":"Iceland","IT":"Italy","JE":"Jersey","JM":"Jamaica","JO":"Jordan","JP":"Japan","KE":"Kenya","KG":"Kyrgyzstan","KH":"Cambodia","KI":"Kiribati","KM":"Comoros","KN":"St. Kitts & Nevis","KP":"North Korea","KR":"South Korea","KW":"Kuwait","KY":"Cayman Islands","KZ":"Kazakhstan","LA":"Laos","LB":"Lebanon","LC":"St. Lucia","LI":"Liechtenstein","LK":"Sri Lanka","LR":"Liberia","LS":"Lesotho","LT":"Lithuania","LU":"Luxembourg","LV":"Latvia","LY":"Libya","MA":"Morocco","MC":"Monaco","MD":"Moldova","ME":"Montenegro","MF":"St. Martin","MG":"Madagascar","MH":"Marshall Islands","MK":"North Macedonia","ML":"Mali","MM":"Myanmar (Burma)","MN":"Mongolia","MO":"Macao SAR China","MP":"Northern Mariana Islands","MQ":"Martinique","MR":"Mauritania","MS":"Montserrat","MT":"Malta","MU":"Mauritius","MV":"Maldives","MW":"Malawi","MX":"Mexico","MY":"Malaysia","MZ":"Mozambique","NA":"Namibia","NC":"New Caledonia","NE":"Niger","NF":"Norfolk Island","NG":"Nigeria","NI":"Nicaragua","NL":"Netherlands","NO":"Norway","NP":"Nepal","NR":"Nauru","NU":"Niue","NZ":"New Zealand","OM":"Oman","PA":"Panama","PE":"Peru","PF":"French Polynesia","PG":"Papua New Guinea","PH":"Philippines","PK":"Pakistan","PL":"Poland","PM":"St. Pierre & Miquelon","PN":"Pitcairn Islands","PR":"Puerto Rico","PS":"Palestinian Territories","PT":"Portugal","PW":"Palau","PY":"Paraguay","QA":"Qatar","QO":"Outlying Oceania","RE":"RÃ©union","RO":"Romania","RS":"Serbia","RU":"Russia","RW":"Rwanda","SA":"Saudi Arabia","SB":"Solomon Islands","SC":"Seychelles","SD":"Sudan","SE":"Sweden","SG":"Singapore","SH":"St. Helena","SI":"Slovenia","SJ":"Svalbard & Jan Mayen","SK":"Slovakia","SL":"Sierra Leone","SM":"San Marino","SN":"Senegal","SO":"Somalia","SR":"Suriname","SS":"South Sudan","ST":"SÃ£o TomÃ© & PrÃ­ncipe","SV":"El Salvador","SX":"Sint Maarten","SY":"Syria","SZ":"Eswatini","TA":"Tristan da Cunha","TC":"Turks & Caicos Islands","TD":"Chad","TF":"French Southern Territories","TG":"Togo","TH":"Thailand","TJ":"Tajikistan","TK":"Tokelau","TL":"Timor-Leste","TM":"Turkmenistan","TN":"Tunisia","TO":"Tonga","TR":"Turkey","TT":"Trinidad & Tobago","TV":"Tuvalu","TW":"Taiwan","TZ":"Tanzania","UA":"Ukraine","UG":"Uganda","UM":"U.S. Outlying Islands","UN":"United Nations","US":"United States","UY":"Uruguay","UZ":"Uzbekistan","VA":"Vatican City","VC":"St. Vincent & Grenadines","VE":"Venezuela","VG":"British Virgin Islands","VI":"U.S. Virgin Islands","VN":"Vietnam","VU":"Vanuatu","WF":"Wallis & Futuna","WS":"Samoa","XA":"Pseudo-Accents","XB":"Pseudo-Bidi","XK":"Kosovo","YE":"Yemen","YT":"Mayotte","ZA":"South Africa","ZM":"Zambia","ZW":"Zimbabwe","ZZ":"Unknown Region"},"short":{"BA":"Bosnia","GB":"UK","HK":"Hong Kong","MM":"Myanmar","MO":"Macao","PS":"Palestine","UN":"UN","US":"US"},"narrow":{}},"script":{"long":{"Adlm":"Adlam","Afak":"Afaka","Aghb":"Caucasian Albanian","Ahom":"Ahom","Arab":"Arabic","Aran":"Nastaliq","Armi":"Imperial Aramaic","Armn":"Armenian","Avst":"Avestan","Bali":"Balinese","Bamu":"Bamum","Bass":"Bassa Vah","Batk":"Batak","Beng":"Bangla","Bhks":"Bhaiksuki","Blis":"Blissymbols","Bopo":"Bopomofo","Brah":"Brahmi","Brai":"Braille","Bugi":"Buginese","Buhd":"Buhid","Cakm":"Chakma","Cans":"Unified Canadian Aboriginal Syllabics","Cari":"Carian","Cham":"Cham","Cher":"Cherokee","Chrs":"Chorasmian","Cirt":"Cirth","Copt":"Coptic","Cprt":"Cypriot","Cyrl":"Cyrillic","Cyrs":"Old Church Slavonic Cyrillic","Deva":"Devanagari","Diak":"Dives Akuru","Dogr":"Dogra","Dsrt":"Deseret","Dupl":"Duployan shorthand","Egyd":"Egyptian demotic","Egyh":"Egyptian hieratic","Egyp":"Egyptian hieroglyphs","Elba":"Elbasan","Elym":"Elymaic","Ethi":"Ethiopic","Geok":"Georgian Khutsuri","Geor":"Georgian","Glag":"Glagolitic","Gong":"Gunjala Gondi","Gonm":"Masaram Gondi","Goth":"Gothic","Gran":"Grantha","Grek":"Greek","Gujr":"Gujarati","Guru":"Gurmukhi","Hanb":"Han with Bopomofo","Hang":"Hangul","Hani":"Han","Hano":"Hanunoo","Hans":"Simplified","Hant":"Traditional","Hatr":"Hatran","Hebr":"Hebrew","Hira":"Hiragana","Hluw":"Anatolian Hieroglyphs","Hmng":"Pahawh Hmong","Hmnp":"Nyiakeng Puachue Hmong","Hrkt":"Japanese syllabaries","Hung":"Old Hungarian","Inds":"Indus","Ital":"Old Italic","Jamo":"Jamo","Java":"Javanese","Jpan":"Japanese","Jurc":"Jurchen","Kali":"Kayah Li","Kana":"Katakana","Khar":"Kharoshthi","Khmr":"Khmer","Khoj":"Khojki","Kits":"Khitan small script","Knda":"Kannada","Kore":"Korean","Kpel":"Kpelle","Kthi":"Kaithi","Lana":"Lanna","Laoo":"Lao","Latf":"Fraktur Latin","Latg":"Gaelic Latin","Latn":"Latin","Lepc":"Lepcha","Limb":"Limbu","Lina":"Linear A","Linb":"Linear B","Lisu":"Fraser","Loma":"Loma","Lyci":"Lycian","Lydi":"Lydian","Mahj":"Mahajani","Maka":"Makasar","Mand":"Mandaean","Mani":"Manichaean","Marc":"Marchen","Maya":"Mayan hieroglyphs","Medf":"Medefaidrin","Mend":"Mende","Merc":"Meroitic Cursive","Mero":"Meroitic","Mlym":"Malayalam","Modi":"Modi","Mong":"Mongolian","Moon":"Moon","Mroo":"Mro","Mtei":"Meitei Mayek","Mult":"Multani","Mymr":"Myanmar","Nand":"Nandinagari","Narb":"Old North Arabian","Nbat":"Nabataean","Newa":"Newa","Nkgb":"Naxi Geba","Nkoo":"Nâ€™Ko","Nshu":"NÃ¼shu","Ogam":"Ogham","Olck":"Ol Chiki","Orkh":"Orkhon","Orya":"Odia","Osge":"Osage","Osma":"Osmanya","Palm":"Palmyrene","Pauc":"Pau Cin Hau","Perm":"Old Permic","Phag":"Phags-pa","Phli":"Inscriptional Pahlavi","Phlp":"Psalter Pahlavi","Phlv":"Book Pahlavi","Phnx":"Phoenician","Plrd":"Pollard Phonetic","Prti":"Inscriptional Parthian","Qaag":"Zawgyi","Rjng":"Rejang","Rohg":"Hanifi Rohingya","Roro":"Rongorongo","Runr":"Runic","Samr":"Samaritan","Sara":"Sarati","Sarb":"Old South Arabian","Saur":"Saurashtra","Sgnw":"SignWriting","Shaw":"Shavian","Shrd":"Sharada","Sidd":"Siddham","Sind":"Khudawadi","Sinh":"Sinhala","Sogd":"Sogdian","Sogo":"Old Sogdian","Sora":"Sora Sompeng","Soyo":"Soyombo","Sund":"Sundanese","Sylo":"Syloti Nagri","Syrc":"Syriac","Syre":"Estrangelo Syriac","Syrj":"Western Syriac","Syrn":"Eastern Syriac","Tagb":"Tagbanwa","Takr":"Takri","Tale":"Tai Le","Talu":"New Tai Lue","Taml":"Tamil","Tang":"Tangut","Tavt":"Tai Viet","Telu":"Telugu","Teng":"Tengwar","Tfng":"Tifinagh","Tglg":"Tagalog","Thaa":"Thaana","Thai":"Thai","Tibt":"Tibetan","Tirh":"Tirhuta","Ugar":"Ugaritic","Vaii":"Vai","Visp":"Visible Speech","Wara":"Varang Kshiti","Wcho":"Wancho","Wole":"Woleai","Xpeo":"Old Persian","Xsux":"Sumero-Akkadian Cuneiform","Yezi":"Yezidi","Yiii":"Yi","Zanb":"Zanabazar Square","Zinh":"Inherited","Zmth":"Mathematical Notation","Zsye":"Emoji","Zsym":"Symbols","Zxxx":"Unwritten","Zyyy":"Common","Zzzz":"Unknown Script"},"short":{"Cans":"UCAS","Xsux":"S-A Cuneiform"},"narrow":{}},"currency":{"long":{"ADP":"Andorran Peseta","AED":"United Arab Emirates Dirham","AFA":"Afghan Afghani (1927â€“2002)","AFN":"Afghan Afghani","ALK":"Albanian Lek (1946â€“1965)","ALL":"Albanian Lek","AMD":"Armenian Dram","ANG":"Netherlands Antillean Guilder","AOA":"Angolan Kwanza","AOK":"Angolan Kwanza (1977â€“1991)","AON":"Angolan New Kwanza (1990â€“2000)","AOR":"Angolan Readjusted Kwanza (1995â€“1999)","ARA":"Argentine Austral","ARL":"Argentine Peso Ley (1970â€“1983)","ARM":"Argentine Peso (1881â€“1970)","ARP":"Argentine Peso (1983â€“1985)","ARS":"Argentine Peso","ATS":"Austrian Schilling","AUD":"Australian Dollar","AWG":"Aruban Florin","AZM":"Azerbaijani Manat (1993â€“2006)","AZN":"Azerbaijani Manat","BAD":"Bosnia-Herzegovina Dinar (1992â€“1994)","BAM":"Bosnia-Herzegovina Convertible Mark","BAN":"Bosnia-Herzegovina New Dinar (1994â€“1997)","BBD":"Barbadian Dollar","BDT":"Bangladeshi Taka","BEC":"Belgian Franc (convertible)","BEF":"Belgian Franc","BEL":"Belgian Franc (financial)","BGL":"Bulgarian Hard Lev","BGM":"Bulgarian Socialist Lev","BGN":"Bulgarian Lev","BGO":"Bulgarian Lev (1879â€“1952)","BHD":"Bahraini Dinar","BIF":"Burundian Franc","BMD":"Bermudan Dollar","BND":"Brunei Dollar","BOB":"Bolivian Boliviano","BOL":"Bolivian Boliviano (1863â€“1963)","BOP":"Bolivian Peso","BOV":"Bolivian Mvdol","BRB":"Brazilian New Cruzeiro (1967â€“1986)","BRC":"Brazilian Cruzado (1986â€“1989)","BRE":"Brazilian Cruzeiro (1990â€“1993)","BRL":"Brazilian Real","BRN":"Brazilian New Cruzado (1989â€“1990)","BRR":"Brazilian Cruzeiro (1993â€“1994)","BRZ":"Brazilian Cruzeiro (1942â€“1967)","BSD":"Bahamian Dollar","BTN":"Bhutanese Ngultrum","BUK":"Burmese Kyat","BWP":"Botswanan Pula","BYB":"Belarusian Ruble (1994â€“1999)","BYN":"Belarusian Ruble","BYR":"Belarusian Ruble (2000â€“2016)","BZD":"Belize Dollar","CAD":"Canadian Dollar","CDF":"Congolese Franc","CHE":"WIR Euro","CHF":"Swiss Franc","CHW":"WIR Franc","CLE":"Chilean Escudo","CLF":"Chilean Unit of Account (UF)","CLP":"Chilean Peso","CNH":"Chinese Yuan (offshore)","CNX":"Chinese Peopleâ€™s Bank Dollar","CNY":"Chinese Yuan","COP":"Colombian Peso","COU":"Colombian Real Value Unit","CRC":"Costa Rican ColÃ³n","CSD":"Serbian Dinar (2002â€“2006)","CSK":"Czechoslovak Hard Koruna","CUC":"Cuban Convertible Peso","CUP":"Cuban Peso","CVE":"Cape Verdean Escudo","CYP":"Cypriot Pound","CZK":"Czech Koruna","DDM":"East German Mark","DEM":"German Mark","DJF":"Djiboutian Franc","DKK":"Danish Krone","DOP":"Dominican Peso","DZD":"Algerian Dinar","ECS":"Ecuadorian Sucre","ECV":"Ecuadorian Unit of Constant Value","EEK":"Estonian Kroon","EGP":"Egyptian Pound","ERN":"Eritrean Nakfa","ESA":"Spanish Peseta (A account)","ESB":"Spanish Peseta (convertible account)","ESP":"Spanish Peseta","ETB":"Ethiopian Birr","EUR":"Euro","FIM":"Finnish Markka","FJD":"Fijian Dollar","FKP":"Falkland Islands Pound","FRF":"French Franc","GBP":"British Pound","GEK":"Georgian Kupon Larit","GEL":"Georgian Lari","GHC":"Ghanaian Cedi (1979â€“2007)","GHS":"Ghanaian Cedi","GIP":"Gibraltar Pound","GMD":"Gambian Dalasi","GNF":"Guinean Franc","GNS":"Guinean Syli","GQE":"Equatorial Guinean Ekwele","GRD":"Greek Drachma","GTQ":"Guatemalan Quetzal","GWE":"Portuguese Guinea Escudo","GWP":"Guinea-Bissau Peso","GYD":"Guyanaese Dollar","HKD":"Hong Kong Dollar","HNL":"Honduran Lempira","HRD":"Croatian Dinar","HRK":"Croatian Kuna","HTG":"Haitian Gourde","HUF":"Hungarian Forint","IDR":"Indonesian Rupiah","IEP":"Irish Pound","ILP":"Israeli Pound","ILR":"Israeli Shekel (1980â€“1985)","ILS":"Israeli New Shekel","INR":"Indian Rupee","IQD":"Iraqi Dinar","IRR":"Iranian Rial","ISJ":"Icelandic KrÃ³na (1918â€“1981)","ISK":"Icelandic KrÃ³na","ITL":"Italian Lira","JMD":"Jamaican Dollar","JOD":"Jordanian Dinar","JPY":"Japanese Yen","KES":"Kenyan Shilling","KGS":"Kyrgystani Som","KHR":"Cambodian Riel","KMF":"Comorian Franc","KPW":"North Korean Won","KRH":"South Korean Hwan (1953â€“1962)","KRO":"South Korean Won (1945â€“1953)","KRW":"South Korean Won","KWD":"Kuwaiti Dinar","KYD":"Cayman Islands Dollar","KZT":"Kazakhstani Tenge","LAK":"Laotian Kip","LBP":"Lebanese Pound","LKR":"Sri Lankan Rupee","LRD":"Liberian Dollar","LSL":"Lesotho Loti","LTL":"Lithuanian Litas","LTT":"Lithuanian Talonas","LUC":"Luxembourgian Convertible Franc","LUF":"Luxembourgian Franc","LUL":"Luxembourg Financial Franc","LVL":"Latvian Lats","LVR":"Latvian Ruble","LYD":"Libyan Dinar","MAD":"Moroccan Dirham","MAF":"Moroccan Franc","MCF":"Monegasque Franc","MDC":"Moldovan Cupon","MDL":"Moldovan Leu","MGA":"Malagasy Ariary","MGF":"Malagasy Franc","MKD":"Macedonian Denar","MKN":"Macedonian Denar (1992â€“1993)","MLF":"Malian Franc","MMK":"Myanmar Kyat","MNT":"Mongolian Tugrik","MOP":"Macanese Pataca","MRO":"Mauritanian Ouguiya (1973â€“2017)","MRU":"Mauritanian Ouguiya","MTL":"Maltese Lira","MTP":"Maltese Pound","MUR":"Mauritian Rupee","MVP":"Maldivian Rupee (1947â€“1981)","MVR":"Maldivian Rufiyaa","MWK":"Malawian Kwacha","MXN":"Mexican Peso","MXP":"Mexican Silver Peso (1861â€“1992)","MXV":"Mexican Investment Unit","MYR":"Malaysian Ringgit","MZE":"Mozambican Escudo","MZM":"Mozambican Metical (1980â€“2006)","MZN":"Mozambican Metical","NAD":"Namibian Dollar","NGN":"Nigerian Naira","NIC":"Nicaraguan CÃ³rdoba (1988â€“1991)","NIO":"Nicaraguan CÃ³rdoba","NLG":"Dutch Guilder","NOK":"Norwegian Krone","NPR":"Nepalese Rupee","NZD":"New Zealand Dollar","OMR":"Omani Rial","PAB":"Panamanian Balboa","PEI":"Peruvian Inti","PEN":"Peruvian Sol","PES":"Peruvian Sol (1863â€“1965)","PGK":"Papua New Guinean Kina","PHP":"Philippine Piso","PKR":"Pakistani Rupee","PLN":"Polish Zloty","PLZ":"Polish Zloty (1950â€“1995)","PTE":"Portuguese Escudo","PYG":"Paraguayan Guarani","QAR":"Qatari Rial","RHD":"Rhodesian Dollar","ROL":"Romanian Leu (1952â€“2006)","RON":"Romanian Leu","RSD":"Serbian Dinar","RUB":"Russian Ruble","RUR":"Russian Ruble (1991â€“1998)","RWF":"Rwandan Franc","SAR":"Saudi Riyal","SBD":"Solomon Islands Dollar","SCR":"Seychellois Rupee","SDD":"Sudanese Dinar (1992â€“2007)","SDG":"Sudanese Pound","SDP":"Sudanese Pound (1957â€“1998)","SEK":"Swedish Krona","SGD":"Singapore Dollar","SHP":"St. Helena Pound","SIT":"Slovenian Tolar","SKK":"Slovak Koruna","SLL":"Sierra Leonean Leone","SOS":"Somali Shilling","SRD":"Surinamese Dollar","SRG":"Surinamese Guilder","SSP":"South Sudanese Pound","STD":"SÃ£o TomÃ© & PrÃ­ncipe Dobra (1977â€“2017)","STN":"SÃ£o TomÃ© & PrÃ­ncipe Dobra","SUR":"Soviet Rouble","SVC":"Salvadoran ColÃ³n","SYP":"Syrian Pound","SZL":"Swazi Lilangeni","THB":"Thai Baht","TJR":"Tajikistani Ruble","TJS":"Tajikistani Somoni","TMM":"Turkmenistani Manat (1993â€“2009)","TMT":"Turkmenistani Manat","TND":"Tunisian Dinar","TOP":"Tongan PaÊ»anga","TPE":"Timorese Escudo","TRL":"Turkish Lira (1922â€“2005)","TRY":"Turkish Lira","TTD":"Trinidad & Tobago Dollar","TWD":"New Taiwan Dollar","TZS":"Tanzanian Shilling","UAH":"Ukrainian Hryvnia","UAK":"Ukrainian Karbovanets","UGS":"Ugandan Shilling (1966â€“1987)","UGX":"Ugandan Shilling","USD":"US Dollar","USN":"US Dollar (Next day)","USS":"US Dollar (Same day)","UYI":"Uruguayan Peso (Indexed Units)","UYP":"Uruguayan Peso (1975â€“1993)","UYU":"Uruguayan Peso","UYW":"Uruguayan Nominal Wage Index Unit","UZS":"Uzbekistani Som","VEB":"Venezuelan BolÃ­var (1871â€“2008)","VEF":"Venezuelan BolÃ­var (2008â€“2018)","VES":"Venezuelan BolÃ­var","VND":"Vietnamese Dong","VNN":"Vietnamese Dong (1978â€“1985)","VUV":"Vanuatu Vatu","WST":"Samoan Tala","XAF":"Central African CFA Franc","XAG":"Silver","XAU":"Gold","XBA":"European Composite Unit","XBB":"European Monetary Unit","XBC":"European Unit of Account (XBC)","XBD":"European Unit of Account (XBD)","XCD":"East Caribbean Dollar","XDR":"Special Drawing Rights","XEU":"European Currency Unit","XFO":"French Gold Franc","XFU":"French UIC-Franc","XOF":"West African CFA Franc","XPD":"Palladium","XPF":"CFP Franc","XPT":"Platinum","XRE":"RINET Funds","XSU":"Sucre","XTS":"Testing Currency Code","XUA":"ADB Unit of Account","XXX":"Unknown Currency","YDD":"Yemeni Dinar","YER":"Yemeni Rial","YUD":"Yugoslavian Hard Dinar (1966â€“1990)","YUM":"Yugoslavian New Dinar (1994â€“2002)","YUN":"Yugoslavian Convertible Dinar (1990â€“1992)","YUR":"Yugoslavian Reformed Dinar (1992â€“1993)","ZAL":"South African Rand (financial)","ZAR":"South African Rand","ZMK":"Zambian Kwacha (1968â€“2012)","ZMW":"Zambian Kwacha","ZRN":"Zairean New Zaire (1993â€“1998)","ZRZ":"Zairean Zaire (1971â€“1993)","ZWD":"Zimbabwean Dollar (1980â€“2008)","ZWL":"Zimbabwean Dollar (2009)","ZWR":"Zimbabwean Dollar (2008)"},"short":{},"narrow":{}}},"patterns":{"locale":"{0} ({1})"}},"locale":"en"}
)
}
},{}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
var should_polyfill_1 = require("./should-polyfill");
if (should_polyfill_1.shouldPolyfill()) {
    Object.defineProperty(Intl, 'DisplayNames', {
        value: _1.DisplayNames,
        enumerable: false,
        writable: true,
        configurable: true,
    });
}

},{"./":72,"./should-polyfill":75}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shouldPolyfill = void 0;
/**
 * https://bugs.chromium.org/p/chromium/issues/detail?id=1097432
 */
function hasMissingICUBug() {
    if (Intl.DisplayNames) {
        var regionNames = new Intl.DisplayNames(['en'], {
            type: 'region',
        });
        return regionNames.of('CA') === 'CA';
    }
    return false;
}
function shouldPolyfill() {
    return !Intl.DisplayNames || hasMissingICUBug();
}
exports.shouldPolyfill = shouldPolyfill;

},{}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isUnicodeLanguageSubtag = exports.isUnicodeScriptSubtag = exports.isUnicodeRegionSubtag = exports.isStructurallyValidLanguageTag = exports.parseUnicodeLanguageId = exports.parseUnicodeLocaleId = exports.getCanonicalLocales = void 0;
var tslib_1 = require("tslib");
var parser_1 = require("./src/parser");
var emitter_1 = require("./src/emitter");
var canonicalizer_1 = require("./src/canonicalizer");
/**
 * https://tc39.es/ecma402/#sec-canonicalizelocalelist
 * @param locales
 */
function CanonicalizeLocaleList(locales) {
    if (locales === undefined) {
        return [];
    }
    var seen = [];
    if (typeof locales === 'string') {
        locales = [locales];
    }
    for (var _i = 0, locales_1 = locales; _i < locales_1.length; _i++) {
        var locale = locales_1[_i];
        var canonicalizedTag = emitter_1.emitUnicodeLocaleId(canonicalizer_1.canonicalizeUnicodeLocaleId(parser_1.parseUnicodeLocaleId(locale)));
        if (seen.indexOf(canonicalizedTag) < 0) {
            seen.push(canonicalizedTag);
        }
    }
    return seen;
}
function getCanonicalLocales(locales) {
    return CanonicalizeLocaleList(locales);
}
exports.getCanonicalLocales = getCanonicalLocales;
var parser_2 = require("./src/parser");
Object.defineProperty(exports, "parseUnicodeLocaleId", { enumerable: true, get: function () { return parser_2.parseUnicodeLocaleId; } });
Object.defineProperty(exports, "parseUnicodeLanguageId", { enumerable: true, get: function () { return parser_2.parseUnicodeLanguageId; } });
Object.defineProperty(exports, "isStructurallyValidLanguageTag", { enumerable: true, get: function () { return parser_2.isStructurallyValidLanguageTag; } });
Object.defineProperty(exports, "isUnicodeRegionSubtag", { enumerable: true, get: function () { return parser_2.isUnicodeRegionSubtag; } });
Object.defineProperty(exports, "isUnicodeScriptSubtag", { enumerable: true, get: function () { return parser_2.isUnicodeScriptSubtag; } });
Object.defineProperty(exports, "isUnicodeLanguageSubtag", { enumerable: true, get: function () { return parser_2.isUnicodeLanguageSubtag; } });
tslib_1.__exportStar(require("./src/types"), exports);
tslib_1.__exportStar(require("./src/emitter"), exports);

},{"./src/canonicalizer":77,"./src/emitter":79,"./src/parser":80,"./src/types":81,"tslib":88}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.canonicalizeUnicodeLocaleId = exports.canonicalizeUnicodeLanguageId = void 0;
var tslib_1 = require("tslib");
var aliases_1 = require("./data/aliases");
var parser_1 = require("./parser");
var likelySubtags = tslib_1.__importStar(require("cldr-core/supplemental/likelySubtags.json"));
var emitter_1 = require("./emitter");
function canonicalizeAttrs(strs) {
    return Object.keys(strs.reduce(function (all, str) {
        all[str.toLowerCase()] = 1;
        return all;
    }, {})).sort();
}
function canonicalizeKVs(arr) {
    var all = {};
    var result = [];
    for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
        var kv = arr_1[_i];
        if (kv[0] in all) {
            continue;
        }
        all[kv[0]] = 1;
        if (!kv[1] || kv[1] === 'true') {
            result.push([kv[0].toLowerCase()]);
        }
        else {
            result.push([kv[0].toLowerCase(), kv[1].toLowerCase()]);
        }
    }
    return result.sort(compareKV);
}
function compareKV(t1, t2) {
    return t1[0] < t2[0] ? -1 : t1[0] > t2[0] ? 1 : 0;
}
function compareExtension(e1, e2) {
    return e1.type < e2.type ? -1 : e1.type > e2.type ? 1 : 0;
}
function mergeVariants(v1, v2) {
    var result = tslib_1.__spreadArrays(v1);
    for (var _i = 0, v2_1 = v2; _i < v2_1.length; _i++) {
        var v = v2_1[_i];
        if (v1.indexOf(v) < 0) {
            result.push(v);
        }
    }
    return result;
}
/**
 * CAVEAT: We don't do this section in the spec bc they have no JSON data
 * Use the bcp47 data to replace keys, types, tfields, and tvalues by their canonical forms. See Section 3.6.4 U Extension Data Files) and Section 3.7.1 T Extension Data Files. The aliases are in the alias attribute value, while the canonical is in the name attribute value. For example,
Because of the following bcp47 data:
<key name="ms"â€¦>â€¦<type name="uksystem" â€¦ alias="imperial" â€¦ />â€¦</key>
We get the following transformation:
en-u-ms-imperial â‡’ en-u-ms-uksystem
 * @param lang
 */
function canonicalizeUnicodeLanguageId(unicodeLanguageId) {
    /**
     * If the language subtag matches the type attribute of a languageAlias element in Supplemental Data, replace the language subtag with the replacement value.
     *  1. If there are additional subtags in the replacement value, add them to the result, but only if there is no corresponding subtag already in the tag.
     *  2. Five special deprecated grandfathered codes (such as i-default) are in type attributes, and are also replaced.
     */
    // From https://github.com/unicode-org/icu/blob/master/icu4j/main/classes/core/src/com/ibm/icu/util/ULocale.java#L1246
    // Try language _ variant
    var finalLangAst = unicodeLanguageId;
    if (unicodeLanguageId.variants.length) {
        var replacedLang_1 = '';
        for (var _i = 0, _a = unicodeLanguageId.variants; _i < _a.length; _i++) {
            var variant = _a[_i];
            if ((replacedLang_1 =
                aliases_1.languageAlias[emitter_1.emitUnicodeLanguageId({
                    lang: unicodeLanguageId.lang,
                    variants: [variant],
                })])) {
                var replacedLangAst = parser_1.parseUnicodeLanguageId(replacedLang_1.split(parser_1.SEPARATOR));
                finalLangAst = {
                    lang: replacedLangAst.lang,
                    script: finalLangAst.script || replacedLangAst.script,
                    region: finalLangAst.region || replacedLangAst.region,
                    variants: mergeVariants(finalLangAst.variants, replacedLangAst.variants),
                };
                break;
            }
        }
    }
    // language _ script _ country
    // ug-Arab-CN -> ug-CN
    if (finalLangAst.script && finalLangAst.region) {
        var replacedLang_2 = aliases_1.languageAlias[emitter_1.emitUnicodeLanguageId({
            lang: finalLangAst.lang,
            script: finalLangAst.script,
            region: finalLangAst.region,
            variants: [],
        })];
        if (replacedLang_2) {
            var replacedLangAst = parser_1.parseUnicodeLanguageId(replacedLang_2.split(parser_1.SEPARATOR));
            finalLangAst = {
                lang: replacedLangAst.lang,
                script: replacedLangAst.script,
                region: replacedLangAst.region,
                variants: finalLangAst.variants,
            };
        }
    }
    // language _ country
    // eg. az_AZ -> az_Latn_A
    if (finalLangAst.region) {
        var replacedLang_3 = aliases_1.languageAlias[emitter_1.emitUnicodeLanguageId({
            lang: finalLangAst.lang,
            region: finalLangAst.region,
            variants: [],
        })];
        if (replacedLang_3) {
            var replacedLangAst = parser_1.parseUnicodeLanguageId(replacedLang_3.split(parser_1.SEPARATOR));
            finalLangAst = {
                lang: replacedLangAst.lang,
                script: finalLangAst.script || replacedLangAst.script,
                region: replacedLangAst.region,
                variants: finalLangAst.variants,
            };
        }
    }
    // only language
    // e.g. twi -> ak
    var replacedLang = aliases_1.languageAlias[emitter_1.emitUnicodeLanguageId({
        lang: finalLangAst.lang,
        variants: [],
    })];
    if (replacedLang) {
        var replacedLangAst = parser_1.parseUnicodeLanguageId(replacedLang.split(parser_1.SEPARATOR));
        finalLangAst = {
            lang: replacedLangAst.lang,
            script: finalLangAst.script || replacedLangAst.script,
            region: finalLangAst.region || replacedLangAst.region,
            variants: finalLangAst.variants,
        };
    }
    if (finalLangAst.region) {
        var region = finalLangAst.region.toUpperCase();
        var regionAlias = aliases_1.territoryAlias[region];
        var replacedRegion = void 0;
        if (regionAlias) {
            var regions = regionAlias.split(' ');
            replacedRegion = regions[0];
            var likelySubtag = likelySubtags.supplemental.likelySubtags[emitter_1.emitUnicodeLanguageId({
                lang: finalLangAst.lang,
                script: finalLangAst.script,
                variants: [],
            })];
            if (likelySubtag) {
                var likelyRegion = parser_1.parseUnicodeLanguageId(likelySubtag.split(parser_1.SEPARATOR)).region;
                if (likelyRegion && regions.indexOf(likelyRegion) > -1) {
                    replacedRegion = likelyRegion;
                }
            }
        }
        if (replacedRegion) {
            finalLangAst.region = replacedRegion;
        }
        finalLangAst.region = finalLangAst.region.toUpperCase();
    }
    if (finalLangAst.script) {
        finalLangAst.script =
            finalLangAst.script[0].toUpperCase() +
                finalLangAst.script.slice(1).toLowerCase();
        if (aliases_1.scriptAlias[finalLangAst.script]) {
            finalLangAst.script = aliases_1.scriptAlias[finalLangAst.script];
        }
    }
    if (finalLangAst.variants.length) {
        for (var i = 0; i < finalLangAst.variants.length; i++) {
            var variant = finalLangAst.variants[i].toLowerCase();
            if (aliases_1.variantAlias[variant]) {
                var alias = aliases_1.variantAlias[variant];
                if (parser_1.isUnicodeVariantSubtag(alias)) {
                    finalLangAst.variants[i] = alias;
                }
                else if (parser_1.isUnicodeLanguageSubtag(alias)) {
                    // Yes this can happen per the spec
                    finalLangAst.lang = alias;
                }
            }
        }
        finalLangAst.variants.sort();
    }
    return finalLangAst;
}
exports.canonicalizeUnicodeLanguageId = canonicalizeUnicodeLanguageId;
/**
 * Canonicalize based on
 * https://www.unicode.org/reports/tr35/tr35.html#Canonical_Unicode_Locale_Identifiers
 * https://tc39.es/ecma402/#sec-canonicalizeunicodelocaleid
 * IMPORTANT: This modifies the object inline
 * @param locale
 */
function canonicalizeUnicodeLocaleId(locale) {
    locale.lang = canonicalizeUnicodeLanguageId(locale.lang);
    if (locale.extensions) {
        for (var _i = 0, _a = locale.extensions; _i < _a.length; _i++) {
            var extension = _a[_i];
            switch (extension.type) {
                case 'u':
                    extension.keywords = canonicalizeKVs(extension.keywords);
                    if (extension.attributes) {
                        extension.attributes = canonicalizeAttrs(extension.attributes);
                    }
                    break;
                case 't':
                    if (extension.lang) {
                        extension.lang = canonicalizeUnicodeLanguageId(extension.lang);
                    }
                    extension.fields = canonicalizeKVs(extension.fields);
                    break;
                default:
                    extension.value = extension.value.toLowerCase();
                    break;
            }
        }
        locale.extensions.sort(compareExtension);
    }
    return locale;
}
exports.canonicalizeUnicodeLocaleId = canonicalizeUnicodeLocaleId;

},{"./data/aliases":78,"./emitter":79,"./parser":80,"cldr-core/supplemental/likelySubtags.json":86,"tslib":88}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.variantAlias = exports.scriptAlias = exports.territoryAlias = exports.languageAlias = void 0;
/* @generated */
// prettier-ignore  
exports.languageAlias = {
    "aa-saaho": "ssy",
    "aam": "aas",
    "aar": "aa",
    "abk": "ab",
    "adp": "dz",
    "afr": "af",
    "agp": "apf",
    "ais": "ami",
    "aju": "jrb",
    "aka": "ak",
    "alb": "sq",
    "als": "sq",
    "amh": "am",
    "ara": "ar",
    "arb": "ar",
    "arg": "an",
    "arm": "hy",
    "art-lojban": "jbo",
    "asd": "snz",
    "asm": "as",
    "aue": "ktz",
    "ava": "av",
    "ave": "ae",
    "aym": "ay",
    "ayr": "ay",
    "ayx": "nun",
    "aze": "az",
    "azj": "az",
    "bak": "ba",
    "bam": "bm",
    "baq": "eu",
    "baz": "nvo",
    "bcc": "bal",
    "bcl": "bik",
    "bel": "be",
    "ben": "bn",
    "bgm": "bcg",
    "bh": "bho",
    "bhk": "fbl",
    "bih": "bho",
    "bis": "bi",
    "bjd": "drl",
    "bjq": "bzc",
    "bkb": "ebk",
    "bod": "bo",
    "bos": "bs",
    "bre": "br",
    "btb": "beb",
    "bul": "bg",
    "bur": "my",
    "bxk": "luy",
    "bxr": "bua",
    "cat": "ca",
    "ccq": "rki",
    "cel-gaulish": "xtg",
    "ces": "cs",
    "cha": "ch",
    "che": "ce",
    "chi": "zh",
    "chu": "cu",
    "chv": "cv",
    "cjr": "mom",
    "cka": "cmr",
    "cld": "syr",
    "cmk": "xch",
    "cmn": "zh",
    "cnr": "sr-ME",
    "cor": "kw",
    "cos": "co",
    "coy": "pij",
    "cqu": "quh",
    "cre": "cr",
    "cwd": "cr",
    "cym": "cy",
    "cze": "cs",
    "daf": "dnj",
    "dan": "da",
    "dap": "njz",
    "deu": "de",
    "dgo": "doi",
    "dhd": "mwr",
    "dik": "din",
    "diq": "zza",
    "dit": "dif",
    "div": "dv",
    "djl": "dze",
    "dkl": "aqd",
    "drh": "mn",
    "drr": "kzk",
    "drw": "fa-AF",
    "dud": "uth",
    "duj": "dwu",
    "dut": "nl",
    "dwl": "dbt",
    "dzo": "dz",
    "ekk": "et",
    "ell": "el",
    "elp": "amq",
    "emk": "man",
    "en-GB-oed": "en-GB-oxendict",
    "eng": "en",
    "epo": "eo",
    "esk": "ik",
    "est": "et",
    "eus": "eu",
    "ewe": "ee",
    "fao": "fo",
    "fas": "fa",
    "fat": "ak",
    "fij": "fj",
    "fin": "fi",
    "fra": "fr",
    "fre": "fr",
    "fry": "fy",
    "fuc": "ff",
    "ful": "ff",
    "gav": "dev",
    "gaz": "om",
    "gbc": "wny",
    "gbo": "grb",
    "geo": "ka",
    "ger": "de",
    "gfx": "vaj",
    "ggn": "gvr",
    "ggo": "esg",
    "ggr": "gtu",
    "gio": "aou",
    "gla": "gd",
    "gle": "ga",
    "glg": "gl",
    "gli": "kzk",
    "glv": "gv",
    "gno": "gon",
    "gre": "el",
    "grn": "gn",
    "gti": "nyc",
    "gug": "gn",
    "guj": "gu",
    "guv": "duz",
    "gya": "gba",
    "hat": "ht",
    "hau": "ha",
    "hbs": "sr-Latn",
    "hdn": "hai",
    "hea": "hmn",
    "heb": "he",
    "her": "hz",
    "him": "srx",
    "hin": "hi",
    "hmo": "ho",
    "hrr": "jal",
    "hrv": "hr",
    "hun": "hu",
    "hy-arevmda": "hyw",
    "hye": "hy",
    "i-ami": "ami",
    "i-bnn": "bnn",
    "i-default": "en-x-i-default",
    "i-enochian": "und-x-i-enochian",
    "i-hak": "hak",
    "i-klingon": "tlh",
    "i-lux": "lb",
    "i-mingo": "see-x-i-mingo",
    "i-navajo": "nv",
    "i-pwn": "pwn",
    "i-tao": "tao",
    "i-tay": "tay",
    "i-tsu": "tsu",
    "ibi": "opa",
    "ibo": "ig",
    "ice": "is",
    "ido": "io",
    "iii": "ii",
    "ike": "iu",
    "iku": "iu",
    "ile": "ie",
    "ill": "ilm",
    "ilw": "gal",
    "in": "id",
    "ina": "ia",
    "ind": "id",
    "ipk": "ik",
    "isl": "is",
    "ita": "it",
    "iw": "he",
    "izi": "eza",
    "jar": "jgk",
    "jav": "jv",
    "jeg": "oyb",
    "ji": "yi",
    "jpn": "ja",
    "jw": "jv",
    "kal": "kl",
    "kan": "kn",
    "kas": "ks",
    "kat": "ka",
    "kau": "kr",
    "kaz": "kk",
    "kdv": "zkd",
    "kgc": "tdf",
    "kgd": "ncq",
    "kgh": "kml",
    "khk": "mn",
    "khm": "km",
    "kik": "ki",
    "kin": "rw",
    "kir": "ky",
    "kmr": "ku",
    "knc": "kr",
    "kng": "kg",
    "knn": "kok",
    "koj": "kwv",
    "kom": "kv",
    "kon": "kg",
    "kor": "ko",
    "kpp": "jkm",
    "kpv": "kv",
    "krm": "bmf",
    "ktr": "dtp",
    "kua": "kj",
    "kur": "ku",
    "kvs": "gdj",
    "kwq": "yam",
    "kxe": "tvd",
    "kxl": "kru",
    "kzh": "dgl",
    "kzj": "dtp",
    "kzt": "dtp",
    "lao": "lo",
    "lat": "la",
    "lav": "lv",
    "lbk": "bnc",
    "leg": "enl",
    "lii": "raq",
    "lim": "li",
    "lin": "ln",
    "lit": "lt",
    "llo": "ngt",
    "lmm": "rmx",
    "ltz": "lb",
    "lub": "lu",
    "lug": "lg",
    "lvs": "lv",
    "mac": "mk",
    "mah": "mh",
    "mal": "ml",
    "mao": "mi",
    "mar": "mr",
    "may": "ms",
    "meg": "cir",
    "mgx": "jbk",
    "mhr": "chm",
    "mkd": "mk",
    "mlg": "mg",
    "mlt": "mt",
    "mnk": "man",
    "mnt": "wnn",
    "mo": "ro",
    "mof": "xnt",
    "mol": "ro",
    "mon": "mn",
    "mri": "mi",
    "msa": "ms",
    "mst": "mry",
    "mup": "raj",
    "mwd": "dmw",
    "mwj": "vaj",
    "mya": "my",
    "myd": "aog",
    "myt": "mry",
    "nad": "xny",
    "nau": "na",
    "nav": "nv",
    "nbf": "nru",
    "nbl": "nr",
    "nbx": "ekc",
    "ncp": "kdz",
    "nde": "nd",
    "ndo": "ng",
    "nep": "ne",
    "nld": "nl",
    "nln": "azd",
    "nlr": "nrk",
    "nno": "nn",
    "nns": "nbr",
    "nnx": "ngv",
    "no": "nb",
    "no-bok": "nb",
    "no-bokmal": "nb",
    "no-nyn": "nn",
    "no-nynorsk": "nn",
    "nob": "nb",
    "noo": "dtd",
    "nor": "nb",
    "npi": "ne",
    "nts": "pij",
    "nxu": "bpp",
    "nya": "ny",
    "oci": "oc",
    "ojg": "oj",
    "oji": "oj",
    "ori": "or",
    "orm": "om",
    "ory": "or",
    "oss": "os",
    "oun": "vaj",
    "pan": "pa",
    "pbu": "ps",
    "pcr": "adx",
    "per": "fa",
    "pes": "fa",
    "pli": "pi",
    "plt": "mg",
    "pmc": "huw",
    "pmu": "phr",
    "pnb": "lah",
    "pol": "pl",
    "por": "pt",
    "ppa": "bfy",
    "ppr": "lcq",
    "prs": "fa-AF",
    "pry": "prt",
    "pus": "ps",
    "puz": "pub",
    "que": "qu",
    "quz": "qu",
    "rmr": "emx",
    "rmy": "rom",
    "roh": "rm",
    "ron": "ro",
    "rum": "ro",
    "run": "rn",
    "rus": "ru",
    "sag": "sg",
    "san": "sa",
    "sap": "aqt",
    "sca": "hle",
    "scc": "sr",
    "scr": "hr",
    "sgl": "isk",
    "sgn-BE-FR": "sfb",
    "sgn-BE-NL": "vgt",
    "sgn-BR": "bzs",
    "sgn-CH-DE": "sgg",
    "sgn-CO": "csn",
    "sgn-DE": "gsg",
    "sgn-DK": "dsl",
    "sgn-ES": "ssp",
    "sgn-FR": "fsl",
    "sgn-GB": "bfi",
    "sgn-GR": "gss",
    "sgn-IE": "isg",
    "sgn-IT": "ise",
    "sgn-JP": "jsl",
    "sgn-MX": "mfs",
    "sgn-NI": "ncs",
    "sgn-NL": "dse",
    "sgn-NO": "nsi",
    "sgn-PT": "psr",
    "sgn-SE": "swl",
    "sgn-US": "ase",
    "sgn-ZA": "sfs",
    "sh": "sr-Latn",
    "sin": "si",
    "skk": "oyb",
    "slk": "sk",
    "slo": "sk",
    "slv": "sl",
    "sme": "se",
    "smo": "sm",
    "sna": "sn",
    "snd": "sd",
    "som": "so",
    "sot": "st",
    "spa": "es",
    "spy": "kln",
    "sqi": "sq",
    "src": "sc",
    "srd": "sc",
    "srp": "sr",
    "ssw": "ss",
    "sul": "sgd",
    "sum": "ulw",
    "sun": "su",
    "swa": "sw",
    "swc": "sw-CD",
    "swe": "sv",
    "swh": "sw",
    "tah": "ty",
    "tam": "ta",
    "tat": "tt",
    "tdu": "dtp",
    "tel": "te",
    "tgg": "bjp",
    "tgk": "tg",
    "tgl": "fil",
    "tha": "th",
    "thc": "tpo",
    "thw": "ola",
    "thx": "oyb",
    "tib": "bo",
    "tid": "itd",
    "tie": "ras",
    "tir": "ti",
    "tkk": "twm",
    "tl": "fil",
    "tlw": "weo",
    "tmp": "tyj",
    "tne": "kak",
    "tnf": "fa-AF",
    "ton": "to",
    "tsf": "taj",
    "tsn": "tn",
    "tso": "ts",
    "ttq": "tmh",
    "tuk": "tk",
    "tur": "tr",
    "tw": "ak",
    "twi": "ak",
    "uig": "ug",
    "ukr": "uk",
    "umu": "del",
    "und-aaland": "und-AX",
    "und-arevela": "und",
    "und-arevmda": "und",
    "und-bokmal": "und",
    "und-hakka": "und",
    "und-hepburn-heploc": "und-alalc97",
    "und-lojban": "und",
    "und-nynorsk": "und",
    "und-saaho": "und",
    "und-xiang": "und",
    "unp": "wro",
    "uok": "ema",
    "urd": "ur",
    "uzb": "uz",
    "uzn": "uz",
    "ven": "ve",
    "vie": "vi",
    "vol": "vo",
    "wel": "cy",
    "wgw": "wgb",
    "wit": "nol",
    "wiw": "nwo",
    "wln": "wa",
    "wol": "wo",
    "xba": "cax",
    "xho": "xh",
    "xia": "acn",
    "xkh": "waw",
    "xpe": "kpe",
    "xrq": "dmw",
    "xsj": "suj",
    "xsl": "den",
    "ybd": "rki",
    "ydd": "yi",
    "yen": "ynq",
    "yid": "yi",
    "yiy": "yrm",
    "yma": "lrr",
    "ymt": "mtm",
    "yor": "yo",
    "yos": "zom",
    "yuu": "yug",
    "zai": "zap",
    "zh-cmn": "zh",
    "zh-cmn-Hans": "zh-Hans",
    "zh-cmn-Hant": "zh-Hant",
    "zh-gan": "gan",
    "zh-guoyu": "zh",
    "zh-hakka": "hak",
    "zh-min": "nan-x-zh-min",
    "zh-min-nan": "nan",
    "zh-wuu": "wuu",
    "zh-xiang": "hsn",
    "zh-yue": "yue",
    "zha": "za",
    "zho": "zh",
    "zir": "scv",
    "zsm": "ms",
    "zul": "zu",
    "zyb": "za"
};
exports.territoryAlias = {
    "100": "BG",
    "104": "MM",
    "108": "BI",
    "112": "BY",
    "116": "KH",
    "120": "CM",
    "124": "CA",
    "132": "CV",
    "136": "KY",
    "140": "CF",
    "144": "LK",
    "148": "TD",
    "152": "CL",
    "156": "CN",
    "158": "TW",
    "162": "CX",
    "166": "CC",
    "170": "CO",
    "172": "RU AM AZ BY GE KG KZ MD TJ TM UA UZ",
    "174": "KM",
    "175": "YT",
    "178": "CG",
    "180": "CD",
    "184": "CK",
    "188": "CR",
    "191": "HR",
    "192": "CU",
    "196": "CY",
    "200": "CZ SK",
    "203": "CZ",
    "204": "BJ",
    "208": "DK",
    "212": "DM",
    "214": "DO",
    "218": "EC",
    "222": "SV",
    "226": "GQ",
    "230": "ET",
    "231": "ET",
    "232": "ER",
    "233": "EE",
    "234": "FO",
    "238": "FK",
    "239": "GS",
    "242": "FJ",
    "246": "FI",
    "248": "AX",
    "249": "FR",
    "250": "FR",
    "254": "GF",
    "258": "PF",
    "260": "TF",
    "262": "DJ",
    "266": "GA",
    "268": "GE",
    "270": "GM",
    "275": "PS",
    "276": "DE",
    "278": "DE",
    "280": "DE",
    "288": "GH",
    "292": "GI",
    "296": "KI",
    "300": "GR",
    "304": "GL",
    "308": "GD",
    "312": "GP",
    "316": "GU",
    "320": "GT",
    "324": "GN",
    "328": "GY",
    "332": "HT",
    "334": "HM",
    "336": "VA",
    "340": "HN",
    "344": "HK",
    "348": "HU",
    "352": "IS",
    "356": "IN",
    "360": "ID",
    "364": "IR",
    "368": "IQ",
    "372": "IE",
    "376": "IL",
    "380": "IT",
    "384": "CI",
    "388": "JM",
    "392": "JP",
    "398": "KZ",
    "400": "JO",
    "404": "KE",
    "408": "KP",
    "410": "KR",
    "414": "KW",
    "417": "KG",
    "418": "LA",
    "422": "LB",
    "426": "LS",
    "428": "LV",
    "430": "LR",
    "434": "LY",
    "438": "LI",
    "440": "LT",
    "442": "LU",
    "446": "MO",
    "450": "MG",
    "454": "MW",
    "458": "MY",
    "462": "MV",
    "466": "ML",
    "470": "MT",
    "474": "MQ",
    "478": "MR",
    "480": "MU",
    "484": "MX",
    "492": "MC",
    "496": "MN",
    "498": "MD",
    "499": "ME",
    "500": "MS",
    "504": "MA",
    "508": "MZ",
    "512": "OM",
    "516": "NA",
    "520": "NR",
    "524": "NP",
    "528": "NL",
    "530": "CW SX BQ",
    "531": "CW",
    "532": "CW SX BQ",
    "533": "AW",
    "534": "SX",
    "535": "BQ",
    "536": "SA IQ",
    "540": "NC",
    "548": "VU",
    "554": "NZ",
    "558": "NI",
    "562": "NE",
    "566": "NG",
    "570": "NU",
    "574": "NF",
    "578": "NO",
    "580": "MP",
    "581": "UM",
    "582": "FM MH MP PW",
    "583": "FM",
    "584": "MH",
    "585": "PW",
    "586": "PK",
    "591": "PA",
    "598": "PG",
    "600": "PY",
    "604": "PE",
    "608": "PH",
    "612": "PN",
    "616": "PL",
    "620": "PT",
    "624": "GW",
    "626": "TL",
    "630": "PR",
    "634": "QA",
    "638": "RE",
    "642": "RO",
    "643": "RU",
    "646": "RW",
    "652": "BL",
    "654": "SH",
    "659": "KN",
    "660": "AI",
    "662": "LC",
    "663": "MF",
    "666": "PM",
    "670": "VC",
    "674": "SM",
    "678": "ST",
    "682": "SA",
    "686": "SN",
    "688": "RS",
    "690": "SC",
    "694": "SL",
    "702": "SG",
    "703": "SK",
    "704": "VN",
    "705": "SI",
    "706": "SO",
    "710": "ZA",
    "716": "ZW",
    "720": "YE",
    "724": "ES",
    "728": "SS",
    "729": "SD",
    "732": "EH",
    "736": "SD",
    "740": "SR",
    "744": "SJ",
    "748": "SZ",
    "752": "SE",
    "756": "CH",
    "760": "SY",
    "762": "TJ",
    "764": "TH",
    "768": "TG",
    "772": "TK",
    "776": "TO",
    "780": "TT",
    "784": "AE",
    "788": "TN",
    "792": "TR",
    "795": "TM",
    "796": "TC",
    "798": "TV",
    "800": "UG",
    "804": "UA",
    "807": "MK",
    "810": "RU AM AZ BY EE GE KZ KG LV LT MD TJ TM UA UZ",
    "818": "EG",
    "826": "GB",
    "830": "JE GG",
    "831": "GG",
    "832": "JE",
    "833": "IM",
    "834": "TZ",
    "840": "US",
    "850": "VI",
    "854": "BF",
    "858": "UY",
    "860": "UZ",
    "862": "VE",
    "876": "WF",
    "882": "WS",
    "886": "YE",
    "887": "YE",
    "890": "RS ME SI HR MK BA",
    "891": "RS ME",
    "894": "ZM",
    "958": "AA",
    "959": "QM",
    "960": "QN",
    "962": "QP",
    "963": "QQ",
    "964": "QR",
    "965": "QS",
    "966": "QT",
    "967": "EU",
    "968": "QV",
    "969": "QW",
    "970": "QX",
    "971": "QY",
    "972": "QZ",
    "973": "XA",
    "974": "XB",
    "975": "XC",
    "976": "XD",
    "977": "XE",
    "978": "XF",
    "979": "XG",
    "980": "XH",
    "981": "XI",
    "982": "XJ",
    "983": "XK",
    "984": "XL",
    "985": "XM",
    "986": "XN",
    "987": "XO",
    "988": "XP",
    "989": "XQ",
    "990": "XR",
    "991": "XS",
    "992": "XT",
    "993": "XU",
    "994": "XV",
    "995": "XW",
    "996": "XX",
    "997": "XY",
    "998": "XZ",
    "999": "ZZ",
    "004": "AF",
    "008": "AL",
    "010": "AQ",
    "012": "DZ",
    "016": "AS",
    "020": "AD",
    "024": "AO",
    "028": "AG",
    "031": "AZ",
    "032": "AR",
    "036": "AU",
    "040": "AT",
    "044": "BS",
    "048": "BH",
    "050": "BD",
    "051": "AM",
    "052": "BB",
    "056": "BE",
    "060": "BM",
    "062": "034 143",
    "064": "BT",
    "068": "BO",
    "070": "BA",
    "072": "BW",
    "074": "BV",
    "076": "BR",
    "084": "BZ",
    "086": "IO",
    "090": "SB",
    "092": "VG",
    "096": "BN",
    "AAA": "AA",
    "ABW": "AW",
    "AFG": "AF",
    "AGO": "AO",
    "AIA": "AI",
    "ALA": "AX",
    "ALB": "AL",
    "AN": "CW SX BQ",
    "AND": "AD",
    "ANT": "CW SX BQ",
    "ARE": "AE",
    "ARG": "AR",
    "ARM": "AM",
    "ASC": "AC",
    "ASM": "AS",
    "ATA": "AQ",
    "ATF": "TF",
    "ATG": "AG",
    "AUS": "AU",
    "AUT": "AT",
    "AZE": "AZ",
    "BDI": "BI",
    "BEL": "BE",
    "BEN": "BJ",
    "BES": "BQ",
    "BFA": "BF",
    "BGD": "BD",
    "BGR": "BG",
    "BHR": "BH",
    "BHS": "BS",
    "BIH": "BA",
    "BLM": "BL",
    "BLR": "BY",
    "BLZ": "BZ",
    "BMU": "BM",
    "BOL": "BO",
    "BRA": "BR",
    "BRB": "BB",
    "BRN": "BN",
    "BTN": "BT",
    "BU": "MM",
    "BUR": "MM",
    "BVT": "BV",
    "BWA": "BW",
    "CAF": "CF",
    "CAN": "CA",
    "CCK": "CC",
    "CHE": "CH",
    "CHL": "CL",
    "CHN": "CN",
    "CIV": "CI",
    "CMR": "CM",
    "COD": "CD",
    "COG": "CG",
    "COK": "CK",
    "COL": "CO",
    "COM": "KM",
    "CPT": "CP",
    "CPV": "CV",
    "CRI": "CR",
    "CS": "RS ME",
    "CT": "KI",
    "CUB": "CU",
    "CUW": "CW",
    "CXR": "CX",
    "CYM": "KY",
    "CYP": "CY",
    "CZE": "CZ",
    "DD": "DE",
    "DDR": "DE",
    "DEU": "DE",
    "DGA": "DG",
    "DJI": "DJ",
    "DMA": "DM",
    "DNK": "DK",
    "DOM": "DO",
    "DY": "BJ",
    "DZA": "DZ",
    "ECU": "EC",
    "EGY": "EG",
    "ERI": "ER",
    "ESH": "EH",
    "ESP": "ES",
    "EST": "EE",
    "ETH": "ET",
    "FIN": "FI",
    "FJI": "FJ",
    "FLK": "FK",
    "FQ": "AQ TF",
    "FRA": "FR",
    "FRO": "FO",
    "FSM": "FM",
    "FX": "FR",
    "FXX": "FR",
    "GAB": "GA",
    "GBR": "GB",
    "GEO": "GE",
    "GGY": "GG",
    "GHA": "GH",
    "GIB": "GI",
    "GIN": "GN",
    "GLP": "GP",
    "GMB": "GM",
    "GNB": "GW",
    "GNQ": "GQ",
    "GRC": "GR",
    "GRD": "GD",
    "GRL": "GL",
    "GTM": "GT",
    "GUF": "GF",
    "GUM": "GU",
    "GUY": "GY",
    "HKG": "HK",
    "HMD": "HM",
    "HND": "HN",
    "HRV": "HR",
    "HTI": "HT",
    "HUN": "HU",
    "HV": "BF",
    "IDN": "ID",
    "IMN": "IM",
    "IND": "IN",
    "IOT": "IO",
    "IRL": "IE",
    "IRN": "IR",
    "IRQ": "IQ",
    "ISL": "IS",
    "ISR": "IL",
    "ITA": "IT",
    "JAM": "JM",
    "JEY": "JE",
    "JOR": "JO",
    "JPN": "JP",
    "JT": "UM",
    "KAZ": "KZ",
    "KEN": "KE",
    "KGZ": "KG",
    "KHM": "KH",
    "KIR": "KI",
    "KNA": "KN",
    "KOR": "KR",
    "KWT": "KW",
    "LAO": "LA",
    "LBN": "LB",
    "LBR": "LR",
    "LBY": "LY",
    "LCA": "LC",
    "LIE": "LI",
    "LKA": "LK",
    "LSO": "LS",
    "LTU": "LT",
    "LUX": "LU",
    "LVA": "LV",
    "MAC": "MO",
    "MAF": "MF",
    "MAR": "MA",
    "MCO": "MC",
    "MDA": "MD",
    "MDG": "MG",
    "MDV": "MV",
    "MEX": "MX",
    "MHL": "MH",
    "MI": "UM",
    "MKD": "MK",
    "MLI": "ML",
    "MLT": "MT",
    "MMR": "MM",
    "MNE": "ME",
    "MNG": "MN",
    "MNP": "MP",
    "MOZ": "MZ",
    "MRT": "MR",
    "MSR": "MS",
    "MTQ": "MQ",
    "MUS": "MU",
    "MWI": "MW",
    "MYS": "MY",
    "MYT": "YT",
    "NAM": "NA",
    "NCL": "NC",
    "NER": "NE",
    "NFK": "NF",
    "NGA": "NG",
    "NH": "VU",
    "NIC": "NI",
    "NIU": "NU",
    "NLD": "NL",
    "NOR": "NO",
    "NPL": "NP",
    "NQ": "AQ",
    "NRU": "NR",
    "NT": "SA IQ",
    "NTZ": "SA IQ",
    "NZL": "NZ",
    "OMN": "OM",
    "PAK": "PK",
    "PAN": "PA",
    "PC": "FM MH MP PW",
    "PCN": "PN",
    "PER": "PE",
    "PHL": "PH",
    "PLW": "PW",
    "PNG": "PG",
    "POL": "PL",
    "PRI": "PR",
    "PRK": "KP",
    "PRT": "PT",
    "PRY": "PY",
    "PSE": "PS",
    "PU": "UM",
    "PYF": "PF",
    "PZ": "PA",
    "QAT": "QA",
    "QMM": "QM",
    "QNN": "QN",
    "QPP": "QP",
    "QQQ": "QQ",
    "QRR": "QR",
    "QSS": "QS",
    "QTT": "QT",
    "QU": "EU",
    "QUU": "EU",
    "QVV": "QV",
    "QWW": "QW",
    "QXX": "QX",
    "QYY": "QY",
    "QZZ": "QZ",
    "REU": "RE",
    "RH": "ZW",
    "ROU": "RO",
    "RUS": "RU",
    "RWA": "RW",
    "SAU": "SA",
    "SCG": "RS ME",
    "SDN": "SD",
    "SEN": "SN",
    "SGP": "SG",
    "SGS": "GS",
    "SHN": "SH",
    "SJM": "SJ",
    "SLB": "SB",
    "SLE": "SL",
    "SLV": "SV",
    "SMR": "SM",
    "SOM": "SO",
    "SPM": "PM",
    "SRB": "RS",
    "SSD": "SS",
    "STP": "ST",
    "SU": "RU AM AZ BY EE GE KZ KG LV LT MD TJ TM UA UZ",
    "SUN": "RU AM AZ BY EE GE KZ KG LV LT MD TJ TM UA UZ",
    "SUR": "SR",
    "SVK": "SK",
    "SVN": "SI",
    "SWE": "SE",
    "SWZ": "SZ",
    "SXM": "SX",
    "SYC": "SC",
    "SYR": "SY",
    "TAA": "TA",
    "TCA": "TC",
    "TCD": "TD",
    "TGO": "TG",
    "THA": "TH",
    "TJK": "TJ",
    "TKL": "TK",
    "TKM": "TM",
    "TLS": "TL",
    "TMP": "TL",
    "TON": "TO",
    "TP": "TL",
    "TTO": "TT",
    "TUN": "TN",
    "TUR": "TR",
    "TUV": "TV",
    "TWN": "TW",
    "TZA": "TZ",
    "UGA": "UG",
    "UK": "GB",
    "UKR": "UA",
    "UMI": "UM",
    "URY": "UY",
    "USA": "US",
    "UZB": "UZ",
    "VAT": "VA",
    "VCT": "VC",
    "VD": "VN",
    "VEN": "VE",
    "VGB": "VG",
    "VIR": "VI",
    "VNM": "VN",
    "VUT": "VU",
    "WK": "UM",
    "WLF": "WF",
    "WSM": "WS",
    "XAA": "XA",
    "XBB": "XB",
    "XCC": "XC",
    "XDD": "XD",
    "XEE": "XE",
    "XFF": "XF",
    "XGG": "XG",
    "XHH": "XH",
    "XII": "XI",
    "XJJ": "XJ",
    "XKK": "XK",
    "XLL": "XL",
    "XMM": "XM",
    "XNN": "XN",
    "XOO": "XO",
    "XPP": "XP",
    "XQQ": "XQ",
    "XRR": "XR",
    "XSS": "XS",
    "XTT": "XT",
    "XUU": "XU",
    "XVV": "XV",
    "XWW": "XW",
    "XXX": "XX",
    "XYY": "XY",
    "XZZ": "XZ",
    "YD": "YE",
    "YEM": "YE",
    "YMD": "YE",
    "YU": "RS ME",
    "YUG": "RS ME",
    "ZAF": "ZA",
    "ZAR": "CD",
    "ZMB": "ZM",
    "ZR": "CD",
    "ZWE": "ZW",
    "ZZZ": "ZZ"
};
exports.scriptAlias = {
    "Qaai": "Zinh"
};
exports.variantAlias = {
    "heploc": "alalc97",
    "polytoni": "polyton"
};

},{}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.emitUnicodeLocaleId = exports.emitUnicodeLanguageId = void 0;
var tslib_1 = require("tslib");
function emitUnicodeLanguageId(lang) {
    if (!lang) {
        return '';
    }
    return tslib_1.__spreadArrays([lang.lang, lang.script, lang.region], (lang.variants || [])).filter(Boolean)
        .join('-');
}
exports.emitUnicodeLanguageId = emitUnicodeLanguageId;
function emitUnicodeLocaleId(_a) {
    var lang = _a.lang, extensions = _a.extensions;
    var chunks = [emitUnicodeLanguageId(lang)];
    for (var _i = 0, extensions_1 = extensions; _i < extensions_1.length; _i++) {
        var ext = extensions_1[_i];
        chunks.push(ext.type);
        switch (ext.type) {
            case 'u':
                chunks.push.apply(chunks, tslib_1.__spreadArrays(ext.attributes, ext.keywords.reduce(function (all, kv) { return all.concat(kv); }, [])));
                break;
            case 't':
                chunks.push.apply(chunks, tslib_1.__spreadArrays([emitUnicodeLanguageId(ext.lang)], ext.fields.reduce(function (all, kv) { return all.concat(kv); }, [])));
                break;
            default:
                chunks.push(ext.value);
                break;
        }
    }
    return chunks.filter(Boolean).join('-');
}
exports.emitUnicodeLocaleId = emitUnicodeLocaleId;

},{"tslib":88}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseUnicodeLocaleId = exports.parseUnicodeLanguageId = exports.isUnicodeVariantSubtag = exports.isUnicodeScriptSubtag = exports.isUnicodeRegionSubtag = exports.isStructurallyValidLanguageTag = exports.isUnicodeLanguageSubtag = exports.SEPARATOR = void 0;
var tslib_1 = require("tslib");
var ALPHANUM_1_8 = /^[a-z0-9]{1,8}$/i;
var ALPHANUM_2_8 = /^[a-z0-9]{2,8}$/i;
var ALPHANUM_3_8 = /^[a-z0-9]{3,8}$/i;
var KEY_REGEX = /^[a-z0-9][a-z]$/i;
var TYPE_REGEX = /^[a-z0-9]{3,8}$/i;
var ALPHA_4 = /^[a-z]{4}$/i;
// alphanum-[tTuUxX]
var OTHER_EXTENSION_TYPE = /^[0-9a-svwyz]$/i;
var UNICODE_REGION_SUBTAG_REGEX = /^([a-z]{2}|[0-9]{3})$/i;
var UNICODE_VARIANT_SUBTAG_REGEX = /^([a-z0-9]{5,8}|[0-9][a-z0-9]{3})$/i;
var UNICODE_LANGUAGE_SUBTAG_REGEX = /^([a-z]{2,3}|[a-z]{5,8})$/i;
var TKEY_REGEX = /^[a-z][0-9]$/i;
exports.SEPARATOR = '-';
function isUnicodeLanguageSubtag(lang) {
    return UNICODE_LANGUAGE_SUBTAG_REGEX.test(lang);
}
exports.isUnicodeLanguageSubtag = isUnicodeLanguageSubtag;
function isStructurallyValidLanguageTag(tag) {
    try {
        parseUnicodeLanguageId(tag.split(exports.SEPARATOR));
    }
    catch (e) {
        return false;
    }
    return true;
}
exports.isStructurallyValidLanguageTag = isStructurallyValidLanguageTag;
function isUnicodeRegionSubtag(region) {
    return UNICODE_REGION_SUBTAG_REGEX.test(region);
}
exports.isUnicodeRegionSubtag = isUnicodeRegionSubtag;
function isUnicodeScriptSubtag(script) {
    return ALPHA_4.test(script);
}
exports.isUnicodeScriptSubtag = isUnicodeScriptSubtag;
function isUnicodeVariantSubtag(variant) {
    return UNICODE_VARIANT_SUBTAG_REGEX.test(variant);
}
exports.isUnicodeVariantSubtag = isUnicodeVariantSubtag;
function parseUnicodeLanguageId(chunks) {
    if (typeof chunks === 'string') {
        chunks = chunks.split(exports.SEPARATOR);
    }
    var lang = chunks.shift();
    if (!lang) {
        throw new RangeError('Missing unicode_language_subtag');
    }
    if (lang === 'root') {
        return { lang: 'root', variants: [] };
    }
    // unicode_language_subtag
    if (!isUnicodeLanguageSubtag(lang)) {
        throw new RangeError('Malformed unicode_language_subtag');
    }
    var script;
    // unicode_script_subtag
    if (isUnicodeScriptSubtag(chunks[0])) {
        script = chunks.shift();
    }
    var region;
    // unicode_region_subtag
    if (isUnicodeRegionSubtag(chunks[0])) {
        region = chunks.shift();
    }
    var variants = {};
    while (chunks.length && isUnicodeVariantSubtag(chunks[0])) {
        var variant = chunks.shift();
        if (variant in variants) {
            throw new RangeError("Duplicate variant \"" + variant + "\"");
        }
        variants[variant] = 1;
    }
    return {
        lang: lang,
        script: script,
        region: region,
        variants: Object.keys(variants),
    };
}
exports.parseUnicodeLanguageId = parseUnicodeLanguageId;
function parseUnicodeExtension(chunks) {
    var keywords = [];
    var keyword;
    while (chunks.length && (keyword = parseKeyword(chunks))) {
        keywords.push(keyword);
    }
    if (keywords.length) {
        return {
            type: 'u',
            keywords: keywords,
            attributes: [],
        };
    }
    // Mix of attributes & keywords
    // Check for attributes first
    var attributes = [];
    while (chunks.length && ALPHANUM_3_8.test(chunks[0])) {
        attributes.push(chunks.shift());
    }
    while (chunks.length && (keyword = parseKeyword(chunks))) {
        keywords.push(keyword);
    }
    if (keywords.length || attributes.length) {
        return {
            type: 'u',
            attributes: attributes,
            keywords: keywords,
        };
    }
    throw new RangeError('Malformed unicode_extension');
}
function parseKeyword(chunks) {
    var key;
    if (!KEY_REGEX.test(chunks[0])) {
        return;
    }
    key = chunks.shift();
    var type = [];
    while (chunks.length && TYPE_REGEX.test(chunks[0])) {
        type.push(chunks.shift());
    }
    var value = '';
    if (type.length) {
        value = type.join(exports.SEPARATOR);
    }
    return [key, value];
}
function parseTransformedExtension(chunks) {
    var lang;
    try {
        lang = parseUnicodeLanguageId(chunks);
    }
    catch (e) {
        // Try just parsing tfield
    }
    var fields = [];
    while (chunks.length && TKEY_REGEX.test(chunks[0])) {
        var key = chunks.shift();
        var value = [];
        while (chunks.length && ALPHANUM_3_8.test(chunks[0])) {
            value.push(chunks.shift());
        }
        if (!value.length) {
            throw new RangeError("Missing tvalue for tkey \"" + key + "\"");
        }
        fields.push([key, value.join(exports.SEPARATOR)]);
    }
    if (fields.length) {
        return {
            type: 't',
            fields: fields,
            lang: lang,
        };
    }
    throw new RangeError('Malformed transformed_extension');
}
function parsePuExtension(chunks) {
    var exts = [];
    while (chunks.length && ALPHANUM_1_8.test(chunks[0])) {
        exts.push(chunks.shift());
    }
    if (exts.length) {
        return {
            type: 'x',
            value: exts.join(exports.SEPARATOR),
        };
    }
    throw new RangeError('Malformed private_use_extension');
}
function parseOtherExtensionValue(chunks) {
    var exts = [];
    while (chunks.length && ALPHANUM_2_8.test(chunks[0])) {
        exts.push(chunks.shift());
    }
    if (exts.length) {
        return exts.join(exports.SEPARATOR);
    }
    return '';
}
function parseExtensions(chunks) {
    if (!chunks.length) {
        return { extensions: [] };
    }
    var extensions = [];
    var unicodeExtension;
    var transformedExtension;
    var puExtension;
    var otherExtensionMap = {};
    do {
        var type = chunks.shift();
        switch (type) {
            case 'u':
            case 'U':
                if (unicodeExtension) {
                    throw new RangeError('There can only be 1 -u- extension');
                }
                unicodeExtension = parseUnicodeExtension(chunks);
                extensions.push(unicodeExtension);
                break;
            case 't':
            case 'T':
                if (transformedExtension) {
                    throw new RangeError('There can only be 1 -t- extension');
                }
                transformedExtension = parseTransformedExtension(chunks);
                extensions.push(transformedExtension);
                break;
            case 'x':
            case 'X':
                if (puExtension) {
                    throw new RangeError('There can only be 1 -x- extension');
                }
                puExtension = parsePuExtension(chunks);
                extensions.push(puExtension);
                break;
            default:
                if (!OTHER_EXTENSION_TYPE.test(type)) {
                    throw new RangeError('Malformed extension type');
                }
                if (type in otherExtensionMap) {
                    throw new RangeError("There can only be 1 -" + type + "- extension");
                }
                var extension = {
                    type: type,
                    value: parseOtherExtensionValue(chunks),
                };
                otherExtensionMap[extension.type] = extension;
                extensions.push(extension);
                break;
        }
    } while (chunks.length);
    return { extensions: extensions };
}
function parseUnicodeLocaleId(locale) {
    var chunks = locale.split(exports.SEPARATOR);
    var lang = parseUnicodeLanguageId(chunks);
    return tslib_1.__assign({ lang: lang }, parseExtensions(chunks));
}
exports.parseUnicodeLocaleId = parseUnicodeLocaleId;

},{"tslib":88}],81:[function(require,module,exports){
arguments[4][66][0].apply(exports,arguments)
},{"dup":66}],82:[function(require,module,exports){
"use strict";
// Type-only circular import
// eslint-disable-next-line import/no-cycle
Object.defineProperty(exports, "__esModule", { value: true });
var internalSlotMap = new WeakMap();
function getInternalSlots(x) {
    var internalSlots = internalSlotMap.get(x);
    if (!internalSlots) {
        internalSlots = Object.create(null);
        internalSlotMap.set(x, internalSlots);
    }
    return internalSlots;
}
exports.default = getInternalSlots;

},{}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Locale = void 0;
var tslib_1 = require("tslib");
var ecma402_abstract_1 = require("@formatjs/ecma402-abstract");
var intl_getcanonicallocales_1 = require("@formatjs/intl-getcanonicallocales");
var likelySubtagsData = tslib_1.__importStar(require("cldr-core/supplemental/likelySubtags.json"));
var get_internal_slots_1 = tslib_1.__importDefault(require("./get_internal_slots"));
var likelySubtags = likelySubtagsData.supplemental.likelySubtags;
var RELEVANT_EXTENSION_KEYS = ['ca', 'co', 'hc', 'kf', 'kn', 'nu'];
var UNICODE_TYPE_REGEX = /^[a-z0-9]{3,8}(-[a-z0-9]{3,8})*$/i;
function applyOptionsToTag(tag, options) {
    ecma402_abstract_1.invariant(typeof tag === 'string', 'language tag must be a string');
    ecma402_abstract_1.invariant(intl_getcanonicallocales_1.isStructurallyValidLanguageTag(tag), 'malformed language tag', RangeError);
    var language = ecma402_abstract_1.GetOption(options, 'language', 'string', undefined, undefined);
    if (language !== undefined) {
        ecma402_abstract_1.invariant(intl_getcanonicallocales_1.isUnicodeLanguageSubtag(language), 'Malformed unicode_language_subtag', RangeError);
    }
    var script = ecma402_abstract_1.GetOption(options, 'script', 'string', undefined, undefined);
    if (script !== undefined) {
        ecma402_abstract_1.invariant(intl_getcanonicallocales_1.isUnicodeScriptSubtag(script), 'Malformed unicode_script_subtag', RangeError);
    }
    var region = ecma402_abstract_1.GetOption(options, 'region', 'string', undefined, undefined);
    if (region !== undefined) {
        ecma402_abstract_1.invariant(intl_getcanonicallocales_1.isUnicodeRegionSubtag(region), 'Malformed unicode_region_subtag', RangeError);
    }
    var languageId = intl_getcanonicallocales_1.parseUnicodeLanguageId(tag);
    if (language !== undefined) {
        languageId.lang = language;
    }
    if (script !== undefined) {
        languageId.script = script;
    }
    if (region !== undefined) {
        languageId.region = region;
    }
    return Intl.getCanonicalLocales(intl_getcanonicallocales_1.emitUnicodeLocaleId(tslib_1.__assign(tslib_1.__assign({}, intl_getcanonicallocales_1.parseUnicodeLocaleId(tag)), { lang: languageId })))[0];
}
function applyUnicodeExtensionToTag(tag, options, relevantExtensionKeys) {
    var unicodeExtension;
    var keywords = [];
    var ast = intl_getcanonicallocales_1.parseUnicodeLocaleId(tag);
    for (var _i = 0, _a = ast.extensions; _i < _a.length; _i++) {
        var ext = _a[_i];
        if (ext.type === 'u') {
            unicodeExtension = ext;
            if (Array.isArray(ext.keywords))
                keywords = ext.keywords;
        }
    }
    var result = Object.create(null);
    for (var _b = 0, relevantExtensionKeys_1 = relevantExtensionKeys; _b < relevantExtensionKeys_1.length; _b++) {
        var key = relevantExtensionKeys_1[_b];
        var value = void 0, entry = void 0;
        for (var _c = 0, keywords_1 = keywords; _c < keywords_1.length; _c++) {
            var keyword = keywords_1[_c];
            if (keyword[0] === key) {
                entry = keyword;
                value = entry[1];
            }
        }
        ecma402_abstract_1.invariant(key in options, key + " must be in options");
        var optionsValue = options[key];
        if (optionsValue !== undefined) {
            ecma402_abstract_1.invariant(typeof optionsValue === 'string', "Value for " + key + " must be a string");
            value = optionsValue;
            if (entry) {
                entry[1] = value;
            }
            else {
                keywords.push([key, value]);
            }
        }
        result[key] = value;
    }
    if (!unicodeExtension) {
        if (keywords.length) {
            ast.extensions.push({
                type: 'u',
                keywords: keywords,
                attributes: [],
            });
        }
    }
    else {
        unicodeExtension.keywords = keywords;
    }
    result.locale = Intl
        .getCanonicalLocales(intl_getcanonicallocales_1.emitUnicodeLocaleId(ast))[0];
    return result;
}
function mergeUnicodeLanguageId(lang, script, region, variants, replacement) {
    if (variants === void 0) { variants = []; }
    if (!replacement) {
        return {
            lang: lang || 'und',
            script: script,
            region: region,
            variants: variants,
        };
    }
    return {
        lang: !lang || lang === 'und' ? replacement.lang : lang,
        script: script || replacement.script,
        region: region || replacement.region,
        variants: tslib_1.__spreadArrays(variants, replacement.variants),
    };
}
function addLikelySubtags(tag) {
    var ast = intl_getcanonicallocales_1.parseUnicodeLocaleId(tag);
    var unicodeLangId = ast.lang;
    var lang = unicodeLangId.lang, script = unicodeLangId.script, region = unicodeLangId.region, variants = unicodeLangId.variants;
    if (script && region) {
        var match_1 = likelySubtags[intl_getcanonicallocales_1.emitUnicodeLanguageId({ lang: lang, script: script, region: region, variants: [] })];
        if (match_1) {
            var parts_1 = intl_getcanonicallocales_1.parseUnicodeLanguageId(match_1);
            ast.lang = mergeUnicodeLanguageId(undefined, undefined, undefined, variants, parts_1);
            return intl_getcanonicallocales_1.emitUnicodeLocaleId(ast);
        }
    }
    if (script) {
        var match_2 = likelySubtags[intl_getcanonicallocales_1.emitUnicodeLanguageId({ lang: lang, script: script, variants: [] })];
        if (match_2) {
            var parts_2 = intl_getcanonicallocales_1.parseUnicodeLanguageId(match_2);
            ast.lang = mergeUnicodeLanguageId(undefined, undefined, region, variants, parts_2);
            return intl_getcanonicallocales_1.emitUnicodeLocaleId(ast);
        }
    }
    if (region) {
        var match_3 = likelySubtags[intl_getcanonicallocales_1.emitUnicodeLanguageId({ lang: lang, region: region, variants: [] })];
        if (match_3) {
            var parts_3 = intl_getcanonicallocales_1.parseUnicodeLanguageId(match_3);
            ast.lang = mergeUnicodeLanguageId(undefined, script, undefined, variants, parts_3);
            return intl_getcanonicallocales_1.emitUnicodeLocaleId(ast);
        }
    }
    var match = likelySubtags[lang] ||
        likelySubtags[intl_getcanonicallocales_1.emitUnicodeLanguageId({ lang: 'und', script: script, variants: [] })];
    if (!match) {
        throw new Error("No match for addLikelySubtags");
    }
    var parts = intl_getcanonicallocales_1.parseUnicodeLanguageId(match);
    ast.lang = mergeUnicodeLanguageId(undefined, script, region, variants, parts);
    return intl_getcanonicallocales_1.emitUnicodeLocaleId(ast);
}
/**
 * From: https://github.com/unicode-org/icu/blob/4231ca5be053a22a1be24eb891817458c97db709/icu4j/main/classes/core/src/com/ibm/icu/util/ULocale.java#L2395
 * @param tag
 */
function removeLikelySubtags(tag) {
    var maxLocale = addLikelySubtags(tag);
    if (!maxLocale) {
        return tag;
    }
    maxLocale = intl_getcanonicallocales_1.emitUnicodeLanguageId(tslib_1.__assign(tslib_1.__assign({}, intl_getcanonicallocales_1.parseUnicodeLanguageId(maxLocale)), { variants: [] }));
    var ast = intl_getcanonicallocales_1.parseUnicodeLocaleId(tag);
    var _a = ast.lang, lang = _a.lang, script = _a.script, region = _a.region, variants = _a.variants;
    var trial = addLikelySubtags(intl_getcanonicallocales_1.emitUnicodeLanguageId({ lang: lang, variants: [] }));
    if (trial === maxLocale) {
        return intl_getcanonicallocales_1.emitUnicodeLocaleId(tslib_1.__assign(tslib_1.__assign({}, ast), { lang: mergeUnicodeLanguageId(lang, undefined, undefined, variants) }));
    }
    if (region) {
        var trial_1 = addLikelySubtags(intl_getcanonicallocales_1.emitUnicodeLanguageId({ lang: lang, region: region, variants: [] }));
        if (trial_1 === maxLocale) {
            return intl_getcanonicallocales_1.emitUnicodeLocaleId(tslib_1.__assign(tslib_1.__assign({}, ast), { lang: mergeUnicodeLanguageId(lang, undefined, region, variants) }));
        }
    }
    if (script) {
        var trial_2 = addLikelySubtags(intl_getcanonicallocales_1.emitUnicodeLanguageId({ lang: lang, script: script, variants: [] }));
        if (trial_2 === maxLocale) {
            return intl_getcanonicallocales_1.emitUnicodeLocaleId(tslib_1.__assign(tslib_1.__assign({}, ast), { lang: mergeUnicodeLanguageId(lang, script, undefined, variants) }));
        }
    }
    return tag;
}
var Locale = /** @class */ (function () {
    function Locale(tag, opts) {
        // test262/test/intl402/RelativeTimeFormat/constructor/constructor/newtarget-undefined.js
        // Cannot use `new.target` bc of IE11 & TS transpiles it to something else
        var newTarget = this && this instanceof Locale ? this.constructor : void 0;
        if (!newTarget) {
            throw new TypeError("Intl.Locale must be called with 'new'");
        }
        var relevantExtensionKeys = Locale.relevantExtensionKeys;
        var internalSlotsList = [
            'initializedLocale',
            'locale',
            'calendar',
            'collation',
            'hourCycle',
            'numberingSystem',
        ];
        if (relevantExtensionKeys.indexOf('kf') > -1) {
            internalSlotsList.push('caseFirst');
        }
        if (relevantExtensionKeys.indexOf('kn') > -1) {
            internalSlotsList.push('numeric');
        }
        if (tag === undefined) {
            throw new TypeError("First argument to Intl.Locale constructor can't be empty or missing");
        }
        if (typeof tag !== 'string' && typeof tag !== 'object') {
            throw new TypeError('tag must be a string or object');
        }
        var internalSlots;
        if (typeof tag === 'object' &&
            (internalSlots = get_internal_slots_1.default(tag)) &&
            internalSlots.initializedLocale) {
            tag = internalSlots.locale;
        }
        else {
            tag = tag.toString();
        }
        internalSlots = get_internal_slots_1.default(this);
        var options;
        if (opts === undefined) {
            options = Object.create(null);
        }
        else {
            options = ecma402_abstract_1.ToObject(opts);
        }
        tag = applyOptionsToTag(tag, options);
        var opt = Object.create(null);
        var calendar = ecma402_abstract_1.GetOption(options, 'calendar', 'string', undefined, undefined);
        if (calendar !== undefined) {
            if (!UNICODE_TYPE_REGEX.test(calendar)) {
                throw new RangeError('invalid calendar');
            }
        }
        opt.ca = calendar;
        var collation = ecma402_abstract_1.GetOption(options, 'collation', 'string', undefined, undefined);
        if (collation !== undefined) {
            if (!UNICODE_TYPE_REGEX.test(collation)) {
                throw new RangeError('invalid collation');
            }
        }
        opt.co = collation;
        var hc = ecma402_abstract_1.GetOption(options, 'hourCycle', 'string', ['h11', 'h12', 'h23', 'h24'], undefined);
        opt.hc = hc;
        var kf = ecma402_abstract_1.GetOption(options, 'caseFirst', 'string', ['upper', 'lower', 'false'], undefined);
        opt.kf = kf;
        var _kn = ecma402_abstract_1.GetOption(options, 'numeric', 'boolean', undefined, undefined);
        var kn;
        if (_kn !== undefined) {
            kn = String(_kn);
        }
        opt.kn = kn;
        var numberingSystem = ecma402_abstract_1.GetOption(options, 'numberingSystem', 'string', undefined, undefined);
        if (numberingSystem !== undefined) {
            if (!UNICODE_TYPE_REGEX.test(numberingSystem)) {
                throw new RangeError('Invalid numberingSystem');
            }
        }
        opt.nu = numberingSystem;
        var r = applyUnicodeExtensionToTag(tag, opt, relevantExtensionKeys);
        internalSlots.locale = r.locale;
        internalSlots.calendar = r.ca;
        internalSlots.collation = r.co;
        internalSlots.hourCycle = r.hc;
        if (relevantExtensionKeys.indexOf('kf') > -1) {
            internalSlots.caseFirst = r.kf;
        }
        if (relevantExtensionKeys.indexOf('kn') > -1) {
            internalSlots.numeric = ecma402_abstract_1.SameValue(r.kn, 'true');
        }
        internalSlots.numberingSystem = r.nu;
    }
    /**
     * https://www.unicode.org/reports/tr35/#Likely_Subtags
     */
    Locale.prototype.maximize = function () {
        var locale = get_internal_slots_1.default(this).locale;
        try {
            var maximizedLocale = addLikelySubtags(locale);
            return new Locale(maximizedLocale);
        }
        catch (e) {
            return new Locale(locale);
        }
    };
    /**
     * https://www.unicode.org/reports/tr35/#Likely_Subtags
     */
    Locale.prototype.minimize = function () {
        var locale = get_internal_slots_1.default(this).locale;
        try {
            var minimizedLocale = removeLikelySubtags(locale);
            return new Locale(minimizedLocale);
        }
        catch (e) {
            return new Locale(locale);
        }
    };
    Locale.prototype.toString = function () {
        return get_internal_slots_1.default(this).locale;
    };
    Object.defineProperty(Locale.prototype, "baseName", {
        get: function () {
            var locale = get_internal_slots_1.default(this).locale;
            return intl_getcanonicallocales_1.emitUnicodeLanguageId(intl_getcanonicallocales_1.parseUnicodeLanguageId(locale));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Locale.prototype, "calendar", {
        get: function () {
            return get_internal_slots_1.default(this).calendar;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Locale.prototype, "collation", {
        get: function () {
            return get_internal_slots_1.default(this).collation;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Locale.prototype, "hourCycle", {
        get: function () {
            return get_internal_slots_1.default(this).hourCycle;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Locale.prototype, "caseFirst", {
        get: function () {
            return get_internal_slots_1.default(this).caseFirst;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Locale.prototype, "numeric", {
        get: function () {
            return get_internal_slots_1.default(this).numeric;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Locale.prototype, "numberingSystem", {
        get: function () {
            return get_internal_slots_1.default(this).numberingSystem;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Locale.prototype, "language", {
        /**
         * https://tc39.es/proposal-intl-locale/#sec-Intl.Locale.prototype.language
         */
        get: function () {
            var locale = get_internal_slots_1.default(this).locale;
            return intl_getcanonicallocales_1.parseUnicodeLanguageId(locale).lang;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Locale.prototype, "script", {
        /**
         * https://tc39.es/proposal-intl-locale/#sec-Intl.Locale.prototype.script
         */
        get: function () {
            var locale = get_internal_slots_1.default(this).locale;
            return intl_getcanonicallocales_1.parseUnicodeLanguageId(locale).script;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Locale.prototype, "region", {
        /**
         * https://tc39.es/proposal-intl-locale/#sec-Intl.Locale.prototype.region
         */
        get: function () {
            var locale = get_internal_slots_1.default(this).locale;
            return intl_getcanonicallocales_1.parseUnicodeLanguageId(locale).region;
        },
        enumerable: false,
        configurable: true
    });
    Locale.relevantExtensionKeys = RELEVANT_EXTENSION_KEYS;
    return Locale;
}());
exports.Locale = Locale;
try {
    if (typeof Symbol !== 'undefined') {
        Object.defineProperty(Locale.prototype, Symbol.toStringTag, {
            value: 'Intl.Locale',
            writable: false,
            enumerable: false,
            configurable: true,
        });
    }
    Object.defineProperty(Locale.prototype.constructor, 'length', {
        value: 1,
        writable: false,
        enumerable: false,
        configurable: true,
    });
}
catch (e) {
    // Meta fix so we're test262-compliant, not important
}
exports.default = Locale;

},{"./get_internal_slots":82,"@formatjs/ecma402-abstract":64,"@formatjs/intl-getcanonicallocales":76,"cldr-core/supplemental/likelySubtags.json":86,"tslib":88}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require("./");
var should_polyfill_1 = require("./should-polyfill");
if (should_polyfill_1.shouldPolyfill()) {
    Object.defineProperty(Intl, 'Locale', {
        value: _1.Locale,
        writable: true,
        enumerable: false,
        configurable: true,
    });
}

},{"./":83,"./should-polyfill":85}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shouldPolyfill = void 0;
/**
 * https://bugs.chromium.org/p/v8/issues/detail?id=10682
 */
function hasIntlGetCanonicalLocalesBug() {
    try {
        return new Intl.Locale('und-x-private').toString() === 'x-private';
    }
    catch (e) {
        return true;
    }
}
function shouldPolyfill() {
    return (typeof Intl === 'undefined' ||
        !('Locale' in Intl) ||
        hasIntlGetCanonicalLocalesBug());
}
exports.shouldPolyfill = shouldPolyfill;

},{}],86:[function(require,module,exports){
module.exports={
  "supplemental": {
    "version": {
      "_unicodeVersion": "13.0.0",
      "_cldrVersion": "38"
    },
    "likelySubtags": {
      "aa": "aa-Latn-ET",
      "aai": "aai-Latn-ZZ",
      "aak": "aak-Latn-ZZ",
      "aau": "aau-Latn-ZZ",
      "ab": "ab-Cyrl-GE",
      "abi": "abi-Latn-ZZ",
      "abq": "abq-Cyrl-ZZ",
      "abr": "abr-Latn-GH",
      "abt": "abt-Latn-ZZ",
      "aby": "aby-Latn-ZZ",
      "acd": "acd-Latn-ZZ",
      "ace": "ace-Latn-ID",
      "ach": "ach-Latn-UG",
      "ada": "ada-Latn-GH",
      "ade": "ade-Latn-ZZ",
      "adj": "adj-Latn-ZZ",
      "adp": "adp-Tibt-BT",
      "ady": "ady-Cyrl-RU",
      "adz": "adz-Latn-ZZ",
      "ae": "ae-Avst-IR",
      "aeb": "aeb-Arab-TN",
      "aey": "aey-Latn-ZZ",
      "af": "af-Latn-ZA",
      "agc": "agc-Latn-ZZ",
      "agd": "agd-Latn-ZZ",
      "agg": "agg-Latn-ZZ",
      "agm": "agm-Latn-ZZ",
      "ago": "ago-Latn-ZZ",
      "agq": "agq-Latn-CM",
      "aha": "aha-Latn-ZZ",
      "ahl": "ahl-Latn-ZZ",
      "aho": "aho-Ahom-IN",
      "ajg": "ajg-Latn-ZZ",
      "ak": "ak-Latn-GH",
      "akk": "akk-Xsux-IQ",
      "ala": "ala-Latn-ZZ",
      "ali": "ali-Latn-ZZ",
      "aln": "aln-Latn-XK",
      "alt": "alt-Cyrl-RU",
      "am": "am-Ethi-ET",
      "amm": "amm-Latn-ZZ",
      "amn": "amn-Latn-ZZ",
      "amo": "amo-Latn-NG",
      "amp": "amp-Latn-ZZ",
      "an": "an-Latn-ES",
      "anc": "anc-Latn-ZZ",
      "ank": "ank-Latn-ZZ",
      "ann": "ann-Latn-ZZ",
      "any": "any-Latn-ZZ",
      "aoj": "aoj-Latn-ZZ",
      "aom": "aom-Latn-ZZ",
      "aoz": "aoz-Latn-ID",
      "apc": "apc-Arab-ZZ",
      "apd": "apd-Arab-TG",
      "ape": "ape-Latn-ZZ",
      "apr": "apr-Latn-ZZ",
      "aps": "aps-Latn-ZZ",
      "apz": "apz-Latn-ZZ",
      "ar": "ar-Arab-EG",
      "arc": "arc-Armi-IR",
      "arc-Nbat": "arc-Nbat-JO",
      "arc-Palm": "arc-Palm-SY",
      "arh": "arh-Latn-ZZ",
      "arn": "arn-Latn-CL",
      "aro": "aro-Latn-BO",
      "arq": "arq-Arab-DZ",
      "ars": "ars-Arab-SA",
      "ary": "ary-Arab-MA",
      "arz": "arz-Arab-EG",
      "as": "as-Beng-IN",
      "asa": "asa-Latn-TZ",
      "ase": "ase-Sgnw-US",
      "asg": "asg-Latn-ZZ",
      "aso": "aso-Latn-ZZ",
      "ast": "ast-Latn-ES",
      "ata": "ata-Latn-ZZ",
      "atg": "atg-Latn-ZZ",
      "atj": "atj-Latn-CA",
      "auy": "auy-Latn-ZZ",
      "av": "av-Cyrl-RU",
      "avl": "avl-Arab-ZZ",
      "avn": "avn-Latn-ZZ",
      "avt": "avt-Latn-ZZ",
      "avu": "avu-Latn-ZZ",
      "awa": "awa-Deva-IN",
      "awb": "awb-Latn-ZZ",
      "awo": "awo-Latn-ZZ",
      "awx": "awx-Latn-ZZ",
      "ay": "ay-Latn-BO",
      "ayb": "ayb-Latn-ZZ",
      "az": "az-Latn-AZ",
      "az-Arab": "az-Arab-IR",
      "az-IQ": "az-Arab-IQ",
      "az-IR": "az-Arab-IR",
      "az-RU": "az-Cyrl-RU",
      "ba": "ba-Cyrl-RU",
      "bal": "bal-Arab-PK",
      "ban": "ban-Latn-ID",
      "bap": "bap-Deva-NP",
      "bar": "bar-Latn-AT",
      "bas": "bas-Latn-CM",
      "bav": "bav-Latn-ZZ",
      "bax": "bax-Bamu-CM",
      "bba": "bba-Latn-ZZ",
      "bbb": "bbb-Latn-ZZ",
      "bbc": "bbc-Latn-ID",
      "bbd": "bbd-Latn-ZZ",
      "bbj": "bbj-Latn-CM",
      "bbp": "bbp-Latn-ZZ",
      "bbr": "bbr-Latn-ZZ",
      "bcf": "bcf-Latn-ZZ",
      "bch": "bch-Latn-ZZ",
      "bci": "bci-Latn-CI",
      "bcm": "bcm-Latn-ZZ",
      "bcn": "bcn-Latn-ZZ",
      "bco": "bco-Latn-ZZ",
      "bcq": "bcq-Ethi-ZZ",
      "bcu": "bcu-Latn-ZZ",
      "bdd": "bdd-Latn-ZZ",
      "be": "be-Cyrl-BY",
      "bef": "bef-Latn-ZZ",
      "beh": "beh-Latn-ZZ",
      "bej": "bej-Arab-SD",
      "bem": "bem-Latn-ZM",
      "bet": "bet-Latn-ZZ",
      "bew": "bew-Latn-ID",
      "bex": "bex-Latn-ZZ",
      "bez": "bez-Latn-TZ",
      "bfd": "bfd-Latn-CM",
      "bfq": "bfq-Taml-IN",
      "bft": "bft-Arab-PK",
      "bfy": "bfy-Deva-IN",
      "bg": "bg-Cyrl-BG",
      "bgc": "bgc-Deva-IN",
      "bgn": "bgn-Arab-PK",
      "bgx": "bgx-Grek-TR",
      "bhb": "bhb-Deva-IN",
      "bhg": "bhg-Latn-ZZ",
      "bhi": "bhi-Deva-IN",
      "bhl": "bhl-Latn-ZZ",
      "bho": "bho-Deva-IN",
      "bhy": "bhy-Latn-ZZ",
      "bi": "bi-Latn-VU",
      "bib": "bib-Latn-ZZ",
      "big": "big-Latn-ZZ",
      "bik": "bik-Latn-PH",
      "bim": "bim-Latn-ZZ",
      "bin": "bin-Latn-NG",
      "bio": "bio-Latn-ZZ",
      "biq": "biq-Latn-ZZ",
      "bjh": "bjh-Latn-ZZ",
      "bji": "bji-Ethi-ZZ",
      "bjj": "bjj-Deva-IN",
      "bjn": "bjn-Latn-ID",
      "bjo": "bjo-Latn-ZZ",
      "bjr": "bjr-Latn-ZZ",
      "bjt": "bjt-Latn-SN",
      "bjz": "bjz-Latn-ZZ",
      "bkc": "bkc-Latn-ZZ",
      "bkm": "bkm-Latn-CM",
      "bkq": "bkq-Latn-ZZ",
      "bku": "bku-Latn-PH",
      "bkv": "bkv-Latn-ZZ",
      "blt": "blt-Tavt-VN",
      "bm": "bm-Latn-ML",
      "bmh": "bmh-Latn-ZZ",
      "bmk": "bmk-Latn-ZZ",
      "bmq": "bmq-Latn-ML",
      "bmu": "bmu-Latn-ZZ",
      "bn": "bn-Beng-BD",
      "bng": "bng-Latn-ZZ",
      "bnm": "bnm-Latn-ZZ",
      "bnp": "bnp-Latn-ZZ",
      "bo": "bo-Tibt-CN",
      "boj": "boj-Latn-ZZ",
      "bom": "bom-Latn-ZZ",
      "bon": "bon-Latn-ZZ",
      "bpy": "bpy-Beng-IN",
      "bqc": "bqc-Latn-ZZ",
      "bqi": "bqi-Arab-IR",
      "bqp": "bqp-Latn-ZZ",
      "bqv": "bqv-Latn-CI",
      "br": "br-Latn-FR",
      "bra": "bra-Deva-IN",
      "brh": "brh-Arab-PK",
      "brx": "brx-Deva-IN",
      "brz": "brz-Latn-ZZ",
      "bs": "bs-Latn-BA",
      "bsj": "bsj-Latn-ZZ",
      "bsq": "bsq-Bass-LR",
      "bss": "bss-Latn-CM",
      "bst": "bst-Ethi-ZZ",
      "bto": "bto-Latn-PH",
      "btt": "btt-Latn-ZZ",
      "btv": "btv-Deva-PK",
      "bua": "bua-Cyrl-RU",
      "buc": "buc-Latn-YT",
      "bud": "bud-Latn-ZZ",
      "bug": "bug-Latn-ID",
      "buk": "buk-Latn-ZZ",
      "bum": "bum-Latn-CM",
      "buo": "buo-Latn-ZZ",
      "bus": "bus-Latn-ZZ",
      "buu": "buu-Latn-ZZ",
      "bvb": "bvb-Latn-GQ",
      "bwd": "bwd-Latn-ZZ",
      "bwr": "bwr-Latn-ZZ",
      "bxh": "bxh-Latn-ZZ",
      "bye": "bye-Latn-ZZ",
      "byn": "byn-Ethi-ER",
      "byr": "byr-Latn-ZZ",
      "bys": "bys-Latn-ZZ",
      "byv": "byv-Latn-CM",
      "byx": "byx-Latn-ZZ",
      "bza": "bza-Latn-ZZ",
      "bze": "bze-Latn-ML",
      "bzf": "bzf-Latn-ZZ",
      "bzh": "bzh-Latn-ZZ",
      "bzw": "bzw-Latn-ZZ",
      "ca": "ca-Latn-ES",
      "cad": "cad-Latn-US",
      "can": "can-Latn-ZZ",
      "cbj": "cbj-Latn-ZZ",
      "cch": "cch-Latn-NG",
      "ccp": "ccp-Cakm-BD",
      "ce": "ce-Cyrl-RU",
      "ceb": "ceb-Latn-PH",
      "cfa": "cfa-Latn-ZZ",
      "cgg": "cgg-Latn-UG",
      "ch": "ch-Latn-GU",
      "chk": "chk-Latn-FM",
      "chm": "chm-Cyrl-RU",
      "cho": "cho-Latn-US",
      "chp": "chp-Latn-CA",
      "chr": "chr-Cher-US",
      "cic": "cic-Latn-US",
      "cja": "cja-Arab-KH",
      "cjm": "cjm-Cham-VN",
      "cjv": "cjv-Latn-ZZ",
      "ckb": "ckb-Arab-IQ",
      "ckl": "ckl-Latn-ZZ",
      "cko": "cko-Latn-ZZ",
      "cky": "cky-Latn-ZZ",
      "cla": "cla-Latn-ZZ",
      "cme": "cme-Latn-ZZ",
      "cmg": "cmg-Soyo-MN",
      "co": "co-Latn-FR",
      "cop": "cop-Copt-EG",
      "cps": "cps-Latn-PH",
      "cr": "cr-Cans-CA",
      "crh": "crh-Cyrl-UA",
      "crj": "crj-Cans-CA",
      "crk": "crk-Cans-CA",
      "crl": "crl-Cans-CA",
      "crm": "crm-Cans-CA",
      "crs": "crs-Latn-SC",
      "cs": "cs-Latn-CZ",
      "csb": "csb-Latn-PL",
      "csw": "csw-Cans-CA",
      "ctd": "ctd-Pauc-MM",
      "cu": "cu-Cyrl-RU",
      "cu-Glag": "cu-Glag-BG",
      "cv": "cv-Cyrl-RU",
      "cy": "cy-Latn-GB",
      "da": "da-Latn-DK",
      "dad": "dad-Latn-ZZ",
      "daf": "daf-Latn-CI",
      "dag": "dag-Latn-ZZ",
      "dah": "dah-Latn-ZZ",
      "dak": "dak-Latn-US",
      "dar": "dar-Cyrl-RU",
      "dav": "dav-Latn-KE",
      "dbd": "dbd-Latn-ZZ",
      "dbq": "dbq-Latn-ZZ",
      "dcc": "dcc-Arab-IN",
      "ddn": "ddn-Latn-ZZ",
      "de": "de-Latn-DE",
      "ded": "ded-Latn-ZZ",
      "den": "den-Latn-CA",
      "dga": "dga-Latn-ZZ",
      "dgh": "dgh-Latn-ZZ",
      "dgi": "dgi-Latn-ZZ",
      "dgl": "dgl-Arab-ZZ",
      "dgr": "dgr-Latn-CA",
      "dgz": "dgz-Latn-ZZ",
      "dia": "dia-Latn-ZZ",
      "dje": "dje-Latn-NE",
      "dnj": "dnj-Latn-CI",
      "dob": "dob-Latn-ZZ",
      "doi": "doi-Deva-IN",
      "dop": "dop-Latn-ZZ",
      "dow": "dow-Latn-ZZ",
      "drh": "drh-Mong-CN",
      "dri": "dri-Latn-ZZ",
      "drs": "drs-Ethi-ZZ",
      "dsb": "dsb-Latn-DE",
      "dtm": "dtm-Latn-ML",
      "dtp": "dtp-Latn-MY",
      "dts": "dts-Latn-ZZ",
      "dty": "dty-Deva-NP",
      "dua": "dua-Latn-CM",
      "duc": "duc-Latn-ZZ",
      "dud": "dud-Latn-ZZ",
      "dug": "dug-Latn-ZZ",
      "dv": "dv-Thaa-MV",
      "dva": "dva-Latn-ZZ",
      "dww": "dww-Latn-ZZ",
      "dyo": "dyo-Latn-SN",
      "dyu": "dyu-Latn-BF",
      "dz": "dz-Tibt-BT",
      "dzg": "dzg-Latn-ZZ",
      "ebu": "ebu-Latn-KE",
      "ee": "ee-Latn-GH",
      "efi": "efi-Latn-NG",
      "egl": "egl-Latn-IT",
      "egy": "egy-Egyp-EG",
      "eka": "eka-Latn-ZZ",
      "eky": "eky-Kali-MM",
      "el": "el-Grek-GR",
      "ema": "ema-Latn-ZZ",
      "emi": "emi-Latn-ZZ",
      "en": "en-Latn-US",
      "en-Shaw": "en-Shaw-GB",
      "enn": "enn-Latn-ZZ",
      "enq": "enq-Latn-ZZ",
      "eo": "eo-Latn-001",
      "eri": "eri-Latn-ZZ",
      "es": "es-Latn-ES",
      "esg": "esg-Gonm-IN",
      "esu": "esu-Latn-US",
      "et": "et-Latn-EE",
      "etr": "etr-Latn-ZZ",
      "ett": "ett-Ital-IT",
      "etu": "etu-Latn-ZZ",
      "etx": "etx-Latn-ZZ",
      "eu": "eu-Latn-ES",
      "ewo": "ewo-Latn-CM",
      "ext": "ext-Latn-ES",
      "eza": "eza-Latn-ZZ",
      "fa": "fa-Arab-IR",
      "faa": "faa-Latn-ZZ",
      "fab": "fab-Latn-ZZ",
      "fag": "fag-Latn-ZZ",
      "fai": "fai-Latn-ZZ",
      "fan": "fan-Latn-GQ",
      "ff": "ff-Latn-SN",
      "ff-Adlm": "ff-Adlm-GN",
      "ffi": "ffi-Latn-ZZ",
      "ffm": "ffm-Latn-ML",
      "fi": "fi-Latn-FI",
      "fia": "fia-Arab-SD",
      "fil": "fil-Latn-PH",
      "fit": "fit-Latn-SE",
      "fj": "fj-Latn-FJ",
      "flr": "flr-Latn-ZZ",
      "fmp": "fmp-Latn-ZZ",
      "fo": "fo-Latn-FO",
      "fod": "fod-Latn-ZZ",
      "fon": "fon-Latn-BJ",
      "for": "for-Latn-ZZ",
      "fpe": "fpe-Latn-ZZ",
      "fqs": "fqs-Latn-ZZ",
      "fr": "fr-Latn-FR",
      "frc": "frc-Latn-US",
      "frp": "frp-Latn-FR",
      "frr": "frr-Latn-DE",
      "frs": "frs-Latn-DE",
      "fub": "fub-Arab-CM",
      "fud": "fud-Latn-WF",
      "fue": "fue-Latn-ZZ",
      "fuf": "fuf-Latn-GN",
      "fuh": "fuh-Latn-ZZ",
      "fuq": "fuq-Latn-NE",
      "fur": "fur-Latn-IT",
      "fuv": "fuv-Latn-NG",
      "fuy": "fuy-Latn-ZZ",
      "fvr": "fvr-Latn-SD",
      "fy": "fy-Latn-NL",
      "ga": "ga-Latn-IE",
      "gaa": "gaa-Latn-GH",
      "gaf": "gaf-Latn-ZZ",
      "gag": "gag-Latn-MD",
      "gah": "gah-Latn-ZZ",
      "gaj": "gaj-Latn-ZZ",
      "gam": "gam-Latn-ZZ",
      "gan": "gan-Hans-CN",
      "gaw": "gaw-Latn-ZZ",
      "gay": "gay-Latn-ID",
      "gba": "gba-Latn-ZZ",
      "gbf": "gbf-Latn-ZZ",
      "gbm": "gbm-Deva-IN",
      "gby": "gby-Latn-ZZ",
      "gbz": "gbz-Arab-IR",
      "gcr": "gcr-Latn-GF",
      "gd": "gd-Latn-GB",
      "gde": "gde-Latn-ZZ",
      "gdn": "gdn-Latn-ZZ",
      "gdr": "gdr-Latn-ZZ",
      "geb": "geb-Latn-ZZ",
      "gej": "gej-Latn-ZZ",
      "gel": "gel-Latn-ZZ",
      "gez": "gez-Ethi-ET",
      "gfk": "gfk-Latn-ZZ",
      "ggn": "ggn-Deva-NP",
      "ghs": "ghs-Latn-ZZ",
      "gil": "gil-Latn-KI",
      "gim": "gim-Latn-ZZ",
      "gjk": "gjk-Arab-PK",
      "gjn": "gjn-Latn-ZZ",
      "gju": "gju-Arab-PK",
      "gkn": "gkn-Latn-ZZ",
      "gkp": "gkp-Latn-ZZ",
      "gl": "gl-Latn-ES",
      "glk": "glk-Arab-IR",
      "gmm": "gmm-Latn-ZZ",
      "gmv": "gmv-Ethi-ZZ",
      "gn": "gn-Latn-PY",
      "gnd": "gnd-Latn-ZZ",
      "gng": "gng-Latn-ZZ",
      "god": "god-Latn-ZZ",
      "gof": "gof-Ethi-ZZ",
      "goi": "goi-Latn-ZZ",
      "gom": "gom-Deva-IN",
      "gon": "gon-Telu-IN",
      "gor": "gor-Latn-ID",
      "gos": "gos-Latn-NL",
      "got": "got-Goth-UA",
      "grb": "grb-Latn-ZZ",
      "grc": "grc-Cprt-CY",
      "grc-Linb": "grc-Linb-GR",
      "grt": "grt-Beng-IN",
      "grw": "grw-Latn-ZZ",
      "gsw": "gsw-Latn-CH",
      "gu": "gu-Gujr-IN",
      "gub": "gub-Latn-BR",
      "guc": "guc-Latn-CO",
      "gud": "gud-Latn-ZZ",
      "gur": "gur-Latn-GH",
      "guw": "guw-Latn-ZZ",
      "gux": "gux-Latn-ZZ",
      "guz": "guz-Latn-KE",
      "gv": "gv-Latn-IM",
      "gvf": "gvf-Latn-ZZ",
      "gvr": "gvr-Deva-NP",
      "gvs": "gvs-Latn-ZZ",
      "gwc": "gwc-Arab-ZZ",
      "gwi": "gwi-Latn-CA",
      "gwt": "gwt-Arab-ZZ",
      "gyi": "gyi-Latn-ZZ",
      "ha": "ha-Latn-NG",
      "ha-CM": "ha-Arab-CM",
      "ha-SD": "ha-Arab-SD",
      "hag": "hag-Latn-ZZ",
      "hak": "hak-Hans-CN",
      "ham": "ham-Latn-ZZ",
      "haw": "haw-Latn-US",
      "haz": "haz-Arab-AF",
      "hbb": "hbb-Latn-ZZ",
      "hdy": "hdy-Ethi-ZZ",
      "he": "he-Hebr-IL",
      "hhy": "hhy-Latn-ZZ",
      "hi": "hi-Deva-IN",
      "hia": "hia-Latn-ZZ",
      "hif": "hif-Latn-FJ",
      "hig": "hig-Latn-ZZ",
      "hih": "hih-Latn-ZZ",
      "hil": "hil-Latn-PH",
      "hla": "hla-Latn-ZZ",
      "hlu": "hlu-Hluw-TR",
      "hmd": "hmd-Plrd-CN",
      "hmt": "hmt-Latn-ZZ",
      "hnd": "hnd-Arab-PK",
      "hne": "hne-Deva-IN",
      "hnj": "hnj-Hmng-LA",
      "hnn": "hnn-Latn-PH",
      "hno": "hno-Arab-PK",
      "ho": "ho-Latn-PG",
      "hoc": "hoc-Deva-IN",
      "hoj": "hoj-Deva-IN",
      "hot": "hot-Latn-ZZ",
      "hr": "hr-Latn-HR",
      "hsb": "hsb-Latn-DE",
      "hsn": "hsn-Hans-CN",
      "ht": "ht-Latn-HT",
      "hu": "hu-Latn-HU",
      "hui": "hui-Latn-ZZ",
      "hy": "hy-Armn-AM",
      "hz": "hz-Latn-NA",
      "ia": "ia-Latn-001",
      "ian": "ian-Latn-ZZ",
      "iar": "iar-Latn-ZZ",
      "iba": "iba-Latn-MY",
      "ibb": "ibb-Latn-NG",
      "iby": "iby-Latn-ZZ",
      "ica": "ica-Latn-ZZ",
      "ich": "ich-Latn-ZZ",
      "id": "id-Latn-ID",
      "idd": "idd-Latn-ZZ",
      "idi": "idi-Latn-ZZ",
      "idu": "idu-Latn-ZZ",
      "ife": "ife-Latn-TG",
      "ig": "ig-Latn-NG",
      "igb": "igb-Latn-ZZ",
      "ige": "ige-Latn-ZZ",
      "ii": "ii-Yiii-CN",
      "ijj": "ijj-Latn-ZZ",
      "ik": "ik-Latn-US",
      "ikk": "ikk-Latn-ZZ",
      "ikt": "ikt-Latn-CA",
      "ikw": "ikw-Latn-ZZ",
      "ikx": "ikx-Latn-ZZ",
      "ilo": "ilo-Latn-PH",
      "imo": "imo-Latn-ZZ",
      "in": "in-Latn-ID",
      "inh": "inh-Cyrl-RU",
      "io": "io-Latn-001",
      "iou": "iou-Latn-ZZ",
      "iri": "iri-Latn-ZZ",
      "is": "is-Latn-IS",
      "it": "it-Latn-IT",
      "iu": "iu-Cans-CA",
      "iw": "iw-Hebr-IL",
      "iwm": "iwm-Latn-ZZ",
      "iws": "iws-Latn-ZZ",
      "izh": "izh-Latn-RU",
      "izi": "izi-Latn-ZZ",
      "ja": "ja-Jpan-JP",
      "jab": "jab-Latn-ZZ",
      "jam": "jam-Latn-JM",
      "jar": "jar-Latn-ZZ",
      "jbo": "jbo-Latn-001",
      "jbu": "jbu-Latn-ZZ",
      "jen": "jen-Latn-ZZ",
      "jgk": "jgk-Latn-ZZ",
      "jgo": "jgo-Latn-CM",
      "ji": "ji-Hebr-UA",
      "jib": "jib-Latn-ZZ",
      "jmc": "jmc-Latn-TZ",
      "jml": "jml-Deva-NP",
      "jra": "jra-Latn-ZZ",
      "jut": "jut-Latn-DK",
      "jv": "jv-Latn-ID",
      "jw": "jw-Latn-ID",
      "ka": "ka-Geor-GE",
      "kaa": "kaa-Cyrl-UZ",
      "kab": "kab-Latn-DZ",
      "kac": "kac-Latn-MM",
      "kad": "kad-Latn-ZZ",
      "kai": "kai-Latn-ZZ",
      "kaj": "kaj-Latn-NG",
      "kam": "kam-Latn-KE",
      "kao": "kao-Latn-ML",
      "kbd": "kbd-Cyrl-RU",
      "kbm": "kbm-Latn-ZZ",
      "kbp": "kbp-Latn-ZZ",
      "kbq": "kbq-Latn-ZZ",
      "kbx": "kbx-Latn-ZZ",
      "kby": "kby-Arab-NE",
      "kcg": "kcg-Latn-NG",
      "kck": "kck-Latn-ZW",
      "kcl": "kcl-Latn-ZZ",
      "kct": "kct-Latn-ZZ",
      "kde": "kde-Latn-TZ",
      "kdh": "kdh-Arab-TG",
      "kdl": "kdl-Latn-ZZ",
      "kdt": "kdt-Thai-TH",
      "kea": "kea-Latn-CV",
      "ken": "ken-Latn-CM",
      "kez": "kez-Latn-ZZ",
      "kfo": "kfo-Latn-CI",
      "kfr": "kfr-Deva-IN",
      "kfy": "kfy-Deva-IN",
      "kg": "kg-Latn-CD",
      "kge": "kge-Latn-ID",
      "kgf": "kgf-Latn-ZZ",
      "kgp": "kgp-Latn-BR",
      "kha": "kha-Latn-IN",
      "khb": "khb-Talu-CN",
      "khn": "khn-Deva-IN",
      "khq": "khq-Latn-ML",
      "khs": "khs-Latn-ZZ",
      "kht": "kht-Mymr-IN",
      "khw": "khw-Arab-PK",
      "khz": "khz-Latn-ZZ",
      "ki": "ki-Latn-KE",
      "kij": "kij-Latn-ZZ",
      "kiu": "kiu-Latn-TR",
      "kiw": "kiw-Latn-ZZ",
      "kj": "kj-Latn-NA",
      "kjd": "kjd-Latn-ZZ",
      "kjg": "kjg-Laoo-LA",
      "kjs": "kjs-Latn-ZZ",
      "kjy": "kjy-Latn-ZZ",
      "kk": "kk-Cyrl-KZ",
      "kk-AF": "kk-Arab-AF",
      "kk-Arab": "kk-Arab-CN",
      "kk-CN": "kk-Arab-CN",
      "kk-IR": "kk-Arab-IR",
      "kk-MN": "kk-Arab-MN",
      "kkc": "kkc-Latn-ZZ",
      "kkj": "kkj-Latn-CM",
      "kl": "kl-Latn-GL",
      "kln": "kln-Latn-KE",
      "klq": "klq-Latn-ZZ",
      "klt": "klt-Latn-ZZ",
      "klx": "klx-Latn-ZZ",
      "km": "km-Khmr-KH",
      "kmb": "kmb-Latn-AO",
      "kmh": "kmh-Latn-ZZ",
      "kmo": "kmo-Latn-ZZ",
      "kms": "kms-Latn-ZZ",
      "kmu": "kmu-Latn-ZZ",
      "kmw": "kmw-Latn-ZZ",
      "kn": "kn-Knda-IN",
      "knf": "knf-Latn-GW",
      "knp": "knp-Latn-ZZ",
      "ko": "ko-Kore-KR",
      "koi": "koi-Cyrl-RU",
      "kok": "kok-Deva-IN",
      "kol": "kol-Latn-ZZ",
      "kos": "kos-Latn-FM",
      "koz": "koz-Latn-ZZ",
      "kpe": "kpe-Latn-LR",
      "kpf": "kpf-Latn-ZZ",
      "kpo": "kpo-Latn-ZZ",
      "kpr": "kpr-Latn-ZZ",
      "kpx": "kpx-Latn-ZZ",
      "kqb": "kqb-Latn-ZZ",
      "kqf": "kqf-Latn-ZZ",
      "kqs": "kqs-Latn-ZZ",
      "kqy": "kqy-Ethi-ZZ",
      "kr": "kr-Latn-ZZ",
      "krc": "krc-Cyrl-RU",
      "kri": "kri-Latn-SL",
      "krj": "krj-Latn-PH",
      "krl": "krl-Latn-RU",
      "krs": "krs-Latn-ZZ",
      "kru": "kru-Deva-IN",
      "ks": "ks-Arab-IN",
      "ksb": "ksb-Latn-TZ",
      "ksd": "ksd-Latn-ZZ",
      "ksf": "ksf-Latn-CM",
      "ksh": "ksh-Latn-DE",
      "ksj": "ksj-Latn-ZZ",
      "ksr": "ksr-Latn-ZZ",
      "ktb": "ktb-Ethi-ZZ",
      "ktm": "ktm-Latn-ZZ",
      "kto": "kto-Latn-ZZ",
      "ktr": "ktr-Latn-MY",
      "ku": "ku-Latn-TR",
      "ku-Arab": "ku-Arab-IQ",
      "ku-LB": "ku-Arab-LB",
      "ku-Yezi": "ku-Yezi-GE",
      "kub": "kub-Latn-ZZ",
      "kud": "kud-Latn-ZZ",
      "kue": "kue-Latn-ZZ",
      "kuj": "kuj-Latn-ZZ",
      "kum": "kum-Cyrl-RU",
      "kun": "kun-Latn-ZZ",
      "kup": "kup-Latn-ZZ",
      "kus": "kus-Latn-ZZ",
      "kv": "kv-Cyrl-RU",
      "kvg": "kvg-Latn-ZZ",
      "kvr": "kvr-Latn-ID",
      "kvx": "kvx-Arab-PK",
      "kw": "kw-Latn-GB",
      "kwj": "kwj-Latn-ZZ",
      "kwo": "kwo-Latn-ZZ",
      "kwq": "kwq-Latn-ZZ",
      "kxa": "kxa-Latn-ZZ",
      "kxc": "kxc-Ethi-ZZ",
      "kxe": "kxe-Latn-ZZ",
      "kxl": "kxl-Deva-IN",
      "kxm": "kxm-Thai-TH",
      "kxp": "kxp-Arab-PK",
      "kxw": "kxw-Latn-ZZ",
      "kxz": "kxz-Latn-ZZ",
      "ky": "ky-Cyrl-KG",
      "ky-Arab": "ky-Arab-CN",
      "ky-CN": "ky-Arab-CN",
      "ky-Latn": "ky-Latn-TR",
      "ky-TR": "ky-Latn-TR",
      "kye": "kye-Latn-ZZ",
      "kyx": "kyx-Latn-ZZ",
      "kzh": "kzh-Arab-ZZ",
      "kzj": "kzj-Latn-MY",
      "kzr": "kzr-Latn-ZZ",
      "kzt": "kzt-Latn-MY",
      "la": "la-Latn-VA",
      "lab": "lab-Lina-GR",
      "lad": "lad-Hebr-IL",
      "lag": "lag-Latn-TZ",
      "lah": "lah-Arab-PK",
      "laj": "laj-Latn-UG",
      "las": "las-Latn-ZZ",
      "lb": "lb-Latn-LU",
      "lbe": "lbe-Cyrl-RU",
      "lbu": "lbu-Latn-ZZ",
      "lbw": "lbw-Latn-ID",
      "lcm": "lcm-Latn-ZZ",
      "lcp": "lcp-Thai-CN",
      "ldb": "ldb-Latn-ZZ",
      "led": "led-Latn-ZZ",
      "lee": "lee-Latn-ZZ",
      "lem": "lem-Latn-ZZ",
      "lep": "lep-Lepc-IN",
      "leq": "leq-Latn-ZZ",
      "leu": "leu-Latn-ZZ",
      "lez": "lez-Cyrl-RU",
      "lg": "lg-Latn-UG",
      "lgg": "lgg-Latn-ZZ",
      "li": "li-Latn-NL",
      "lia": "lia-Latn-ZZ",
      "lid": "lid-Latn-ZZ",
      "lif": "lif-Deva-NP",
      "lif-Limb": "lif-Limb-IN",
      "lig": "lig-Latn-ZZ",
      "lih": "lih-Latn-ZZ",
      "lij": "lij-Latn-IT",
      "lis": "lis-Lisu-CN",
      "ljp": "ljp-Latn-ID",
      "lki": "lki-Arab-IR",
      "lkt": "lkt-Latn-US",
      "lle": "lle-Latn-ZZ",
      "lln": "lln-Latn-ZZ",
      "lmn": "lmn-Telu-IN",
      "lmo": "lmo-Latn-IT",
      "lmp": "lmp-Latn-ZZ",
      "ln": "ln-Latn-CD",
      "lns": "lns-Latn-ZZ",
      "lnu": "lnu-Latn-ZZ",
      "lo": "lo-Laoo-LA",
      "loj": "loj-Latn-ZZ",
      "lok": "lok-Latn-ZZ",
      "lol": "lol-Latn-CD",
      "lor": "lor-Latn-ZZ",
      "los": "los-Latn-ZZ",
      "loz": "loz-Latn-ZM",
      "lrc": "lrc-Arab-IR",
      "lt": "lt-Latn-LT",
      "ltg": "ltg-Latn-LV",
      "lu": "lu-Latn-CD",
      "lua": "lua-Latn-CD",
      "luo": "luo-Latn-KE",
      "luy": "luy-Latn-KE",
      "luz": "luz-Arab-IR",
      "lv": "lv-Latn-LV",
      "lwl": "lwl-Thai-TH",
      "lzh": "lzh-Hans-CN",
      "lzz": "lzz-Latn-TR",
      "mad": "mad-Latn-ID",
      "maf": "maf-Latn-CM",
      "mag": "mag-Deva-IN",
      "mai": "mai-Deva-IN",
      "mak": "mak-Latn-ID",
      "man": "man-Latn-GM",
      "man-GN": "man-Nkoo-GN",
      "man-Nkoo": "man-Nkoo-GN",
      "mas": "mas-Latn-KE",
      "maw": "maw-Latn-ZZ",
      "maz": "maz-Latn-MX",
      "mbh": "mbh-Latn-ZZ",
      "mbo": "mbo-Latn-ZZ",
      "mbq": "mbq-Latn-ZZ",
      "mbu": "mbu-Latn-ZZ",
      "mbw": "mbw-Latn-ZZ",
      "mci": "mci-Latn-ZZ",
      "mcp": "mcp-Latn-ZZ",
      "mcq": "mcq-Latn-ZZ",
      "mcr": "mcr-Latn-ZZ",
      "mcu": "mcu-Latn-ZZ",
      "mda": "mda-Latn-ZZ",
      "mde": "mde-Arab-ZZ",
      "mdf": "mdf-Cyrl-RU",
      "mdh": "mdh-Latn-PH",
      "mdj": "mdj-Latn-ZZ",
      "mdr": "mdr-Latn-ID",
      "mdx": "mdx-Ethi-ZZ",
      "med": "med-Latn-ZZ",
      "mee": "mee-Latn-ZZ",
      "mek": "mek-Latn-ZZ",
      "men": "men-Latn-SL",
      "mer": "mer-Latn-KE",
      "met": "met-Latn-ZZ",
      "meu": "meu-Latn-ZZ",
      "mfa": "mfa-Arab-TH",
      "mfe": "mfe-Latn-MU",
      "mfn": "mfn-Latn-ZZ",
      "mfo": "mfo-Latn-ZZ",
      "mfq": "mfq-Latn-ZZ",
      "mg": "mg-Latn-MG",
      "mgh": "mgh-Latn-MZ",
      "mgl": "mgl-Latn-ZZ",
      "mgo": "mgo-Latn-CM",
      "mgp": "mgp-Deva-NP",
      "mgy": "mgy-Latn-TZ",
      "mh": "mh-Latn-MH",
      "mhi": "mhi-Latn-ZZ",
      "mhl": "mhl-Latn-ZZ",
      "mi": "mi-Latn-NZ",
      "mif": "mif-Latn-ZZ",
      "min": "min-Latn-ID",
      "mis": "mis-Hatr-IQ",
      "mis-Medf": "mis-Medf-NG",
      "miw": "miw-Latn-ZZ",
      "mk": "mk-Cyrl-MK",
      "mki": "mki-Arab-ZZ",
      "mkl": "mkl-Latn-ZZ",
      "mkp": "mkp-Latn-ZZ",
      "mkw": "mkw-Latn-ZZ",
      "ml": "ml-Mlym-IN",
      "mle": "mle-Latn-ZZ",
      "mlp": "mlp-Latn-ZZ",
      "mls": "mls-Latn-SD",
      "mmo": "mmo-Latn-ZZ",
      "mmu": "mmu-Latn-ZZ",
      "mmx": "mmx-Latn-ZZ",
      "mn": "mn-Cyrl-MN",
      "mn-CN": "mn-Mong-CN",
      "mn-Mong": "mn-Mong-CN",
      "mna": "mna-Latn-ZZ",
      "mnf": "mnf-Latn-ZZ",
      "mni": "mni-Beng-IN",
      "mnw": "mnw-Mymr-MM",
      "mo": "mo-Latn-RO",
      "moa": "moa-Latn-ZZ",
      "moe": "moe-Latn-CA",
      "moh": "moh-Latn-CA",
      "mos": "mos-Latn-BF",
      "mox": "mox-Latn-ZZ",
      "mpp": "mpp-Latn-ZZ",
      "mps": "mps-Latn-ZZ",
      "mpt": "mpt-Latn-ZZ",
      "mpx": "mpx-Latn-ZZ",
      "mql": "mql-Latn-ZZ",
      "mr": "mr-Deva-IN",
      "mrd": "mrd-Deva-NP",
      "mrj": "mrj-Cyrl-RU",
      "mro": "mro-Mroo-BD",
      "ms": "ms-Latn-MY",
      "ms-CC": "ms-Arab-CC",
      "mt": "mt-Latn-MT",
      "mtc": "mtc-Latn-ZZ",
      "mtf": "mtf-Latn-ZZ",
      "mti": "mti-Latn-ZZ",
      "mtr": "mtr-Deva-IN",
      "mua": "mua-Latn-CM",
      "mur": "mur-Latn-ZZ",
      "mus": "mus-Latn-US",
      "mva": "mva-Latn-ZZ",
      "mvn": "mvn-Latn-ZZ",
      "mvy": "mvy-Arab-PK",
      "mwk": "mwk-Latn-ML",
      "mwr": "mwr-Deva-IN",
      "mwv": "mwv-Latn-ID",
      "mww": "mww-Hmnp-US",
      "mxc": "mxc-Latn-ZW",
      "mxm": "mxm-Latn-ZZ",
      "my": "my-Mymr-MM",
      "myk": "myk-Latn-ZZ",
      "mym": "mym-Ethi-ZZ",
      "myv": "myv-Cyrl-RU",
      "myw": "myw-Latn-ZZ",
      "myx": "myx-Latn-UG",
      "myz": "myz-Mand-IR",
      "mzk": "mzk-Latn-ZZ",
      "mzm": "mzm-Latn-ZZ",
      "mzn": "mzn-Arab-IR",
      "mzp": "mzp-Latn-ZZ",
      "mzw": "mzw-Latn-ZZ",
      "mzz": "mzz-Latn-ZZ",
      "na": "na-Latn-NR",
      "nac": "nac-Latn-ZZ",
      "naf": "naf-Latn-ZZ",
      "nak": "nak-Latn-ZZ",
      "nan": "nan-Hans-CN",
      "nap": "nap-Latn-IT",
      "naq": "naq-Latn-NA",
      "nas": "nas-Latn-ZZ",
      "nb": "nb-Latn-NO",
      "nca": "nca-Latn-ZZ",
      "nce": "nce-Latn-ZZ",
      "ncf": "ncf-Latn-ZZ",
      "nch": "nch-Latn-MX",
      "nco": "nco-Latn-ZZ",
      "ncu": "ncu-Latn-ZZ",
      "nd": "nd-Latn-ZW",
      "ndc": "ndc-Latn-MZ",
      "nds": "nds-Latn-DE",
      "ne": "ne-Deva-NP",
      "neb": "neb-Latn-ZZ",
      "new": "new-Deva-NP",
      "nex": "nex-Latn-ZZ",
      "nfr": "nfr-Latn-ZZ",
      "ng": "ng-Latn-NA",
      "nga": "nga-Latn-ZZ",
      "ngb": "ngb-Latn-ZZ",
      "ngl": "ngl-Latn-MZ",
      "nhb": "nhb-Latn-ZZ",
      "nhe": "nhe-Latn-MX",
      "nhw": "nhw-Latn-MX",
      "nif": "nif-Latn-ZZ",
      "nii": "nii-Latn-ZZ",
      "nij": "nij-Latn-ID",
      "nin": "nin-Latn-ZZ",
      "niu": "niu-Latn-NU",
      "niy": "niy-Latn-ZZ",
      "niz": "niz-Latn-ZZ",
      "njo": "njo-Latn-IN",
      "nkg": "nkg-Latn-ZZ",
      "nko": "nko-Latn-ZZ",
      "nl": "nl-Latn-NL",
      "nmg": "nmg-Latn-CM",
      "nmz": "nmz-Latn-ZZ",
      "nn": "nn-Latn-NO",
      "nnf": "nnf-Latn-ZZ",
      "nnh": "nnh-Latn-CM",
      "nnk": "nnk-Latn-ZZ",
      "nnm": "nnm-Latn-ZZ",
      "nnp": "nnp-Wcho-IN",
      "no": "no-Latn-NO",
      "nod": "nod-Lana-TH",
      "noe": "noe-Deva-IN",
      "non": "non-Runr-SE",
      "nop": "nop-Latn-ZZ",
      "nou": "nou-Latn-ZZ",
      "nqo": "nqo-Nkoo-GN",
      "nr": "nr-Latn-ZA",
      "nrb": "nrb-Latn-ZZ",
      "nsk": "nsk-Cans-CA",
      "nsn": "nsn-Latn-ZZ",
      "nso": "nso-Latn-ZA",
      "nss": "nss-Latn-ZZ",
      "ntm": "ntm-Latn-ZZ",
      "ntr": "ntr-Latn-ZZ",
      "nui": "nui-Latn-ZZ",
      "nup": "nup-Latn-ZZ",
      "nus": "nus-Latn-SS",
      "nuv": "nuv-Latn-ZZ",
      "nux": "nux-Latn-ZZ",
      "nv": "nv-Latn-US",
      "nwb": "nwb-Latn-ZZ",
      "nxq": "nxq-Latn-CN",
      "nxr": "nxr-Latn-ZZ",
      "ny": "ny-Latn-MW",
      "nym": "nym-Latn-TZ",
      "nyn": "nyn-Latn-UG",
      "nzi": "nzi-Latn-GH",
      "oc": "oc-Latn-FR",
      "ogc": "ogc-Latn-ZZ",
      "okr": "okr-Latn-ZZ",
      "okv": "okv-Latn-ZZ",
      "om": "om-Latn-ET",
      "ong": "ong-Latn-ZZ",
      "onn": "onn-Latn-ZZ",
      "ons": "ons-Latn-ZZ",
      "opm": "opm-Latn-ZZ",
      "or": "or-Orya-IN",
      "oro": "oro-Latn-ZZ",
      "oru": "oru-Arab-ZZ",
      "os": "os-Cyrl-GE",
      "osa": "osa-Osge-US",
      "ota": "ota-Arab-ZZ",
      "otk": "otk-Orkh-MN",
      "ozm": "ozm-Latn-ZZ",
      "pa": "pa-Guru-IN",
      "pa-Arab": "pa-Arab-PK",
      "pa-PK": "pa-Arab-PK",
      "pag": "pag-Latn-PH",
      "pal": "pal-Phli-IR",
      "pal-Phlp": "pal-Phlp-CN",
      "pam": "pam-Latn-PH",
      "pap": "pap-Latn-AW",
      "pau": "pau-Latn-PW",
      "pbi": "pbi-Latn-ZZ",
      "pcd": "pcd-Latn-FR",
      "pcm": "pcm-Latn-NG",
      "pdc": "pdc-Latn-US",
      "pdt": "pdt-Latn-CA",
      "ped": "ped-Latn-ZZ",
      "peo": "peo-Xpeo-IR",
      "pex": "pex-Latn-ZZ",
      "pfl": "pfl-Latn-DE",
      "phl": "phl-Arab-ZZ",
      "phn": "phn-Phnx-LB",
      "pil": "pil-Latn-ZZ",
      "pip": "pip-Latn-ZZ",
      "pka": "pka-Brah-IN",
      "pko": "pko-Latn-KE",
      "pl": "pl-Latn-PL",
      "pla": "pla-Latn-ZZ",
      "pms": "pms-Latn-IT",
      "png": "png-Latn-ZZ",
      "pnn": "pnn-Latn-ZZ",
      "pnt": "pnt-Grek-GR",
      "pon": "pon-Latn-FM",
      "ppa": "ppa-Deva-IN",
      "ppo": "ppo-Latn-ZZ",
      "pra": "pra-Khar-PK",
      "prd": "prd-Arab-IR",
      "prg": "prg-Latn-001",
      "ps": "ps-Arab-AF",
      "pss": "pss-Latn-ZZ",
      "pt": "pt-Latn-BR",
      "ptp": "ptp-Latn-ZZ",
      "puu": "puu-Latn-GA",
      "pwa": "pwa-Latn-ZZ",
      "qu": "qu-Latn-PE",
      "quc": "quc-Latn-GT",
      "qug": "qug-Latn-EC",
      "rai": "rai-Latn-ZZ",
      "raj": "raj-Deva-IN",
      "rao": "rao-Latn-ZZ",
      "rcf": "rcf-Latn-RE",
      "rej": "rej-Latn-ID",
      "rel": "rel-Latn-ZZ",
      "res": "res-Latn-ZZ",
      "rgn": "rgn-Latn-IT",
      "rhg": "rhg-Arab-MM",
      "ria": "ria-Latn-IN",
      "rif": "rif-Tfng-MA",
      "rif-NL": "rif-Latn-NL",
      "rjs": "rjs-Deva-NP",
      "rkt": "rkt-Beng-BD",
      "rm": "rm-Latn-CH",
      "rmf": "rmf-Latn-FI",
      "rmo": "rmo-Latn-CH",
      "rmt": "rmt-Arab-IR",
      "rmu": "rmu-Latn-SE",
      "rn": "rn-Latn-BI",
      "rna": "rna-Latn-ZZ",
      "rng": "rng-Latn-MZ",
      "ro": "ro-Latn-RO",
      "rob": "rob-Latn-ID",
      "rof": "rof-Latn-TZ",
      "roo": "roo-Latn-ZZ",
      "rro": "rro-Latn-ZZ",
      "rtm": "rtm-Latn-FJ",
      "ru": "ru-Cyrl-RU",
      "rue": "rue-Cyrl-UA",
      "rug": "rug-Latn-SB",
      "rw": "rw-Latn-RW",
      "rwk": "rwk-Latn-TZ",
      "rwo": "rwo-Latn-ZZ",
      "ryu": "ryu-Kana-JP",
      "sa": "sa-Deva-IN",
      "saf": "saf-Latn-GH",
      "sah": "sah-Cyrl-RU",
      "saq": "saq-Latn-KE",
      "sas": "sas-Latn-ID",
      "sat": "sat-Olck-IN",
      "sav": "sav-Latn-SN",
      "saz": "saz-Saur-IN",
      "sba": "sba-Latn-ZZ",
      "sbe": "sbe-Latn-ZZ",
      "sbp": "sbp-Latn-TZ",
      "sc": "sc-Latn-IT",
      "sck": "sck-Deva-IN",
      "scl": "scl-Arab-ZZ",
      "scn": "scn-Latn-IT",
      "sco": "sco-Latn-GB",
      "scs": "scs-Latn-CA",
      "sd": "sd-Arab-PK",
      "sd-Deva": "sd-Deva-IN",
      "sd-Khoj": "sd-Khoj-IN",
      "sd-Sind": "sd-Sind-IN",
      "sdc": "sdc-Latn-IT",
      "sdh": "sdh-Arab-IR",
      "se": "se-Latn-NO",
      "sef": "sef-Latn-CI",
      "seh": "seh-Latn-MZ",
      "sei": "sei-Latn-MX",
      "ses": "ses-Latn-ML",
      "sg": "sg-Latn-CF",
      "sga": "sga-Ogam-IE",
      "sgs": "sgs-Latn-LT",
      "sgw": "sgw-Ethi-ZZ",
      "sgz": "sgz-Latn-ZZ",
      "shi": "shi-Tfng-MA",
      "shk": "shk-Latn-ZZ",
      "shn": "shn-Mymr-MM",
      "shu": "shu-Arab-ZZ",
      "si": "si-Sinh-LK",
      "sid": "sid-Latn-ET",
      "sig": "sig-Latn-ZZ",
      "sil": "sil-Latn-ZZ",
      "sim": "sim-Latn-ZZ",
      "sjr": "sjr-Latn-ZZ",
      "sk": "sk-Latn-SK",
      "skc": "skc-Latn-ZZ",
      "skr": "skr-Arab-PK",
      "sks": "sks-Latn-ZZ",
      "sl": "sl-Latn-SI",
      "sld": "sld-Latn-ZZ",
      "sli": "sli-Latn-PL",
      "sll": "sll-Latn-ZZ",
      "sly": "sly-Latn-ID",
      "sm": "sm-Latn-WS",
      "sma": "sma-Latn-SE",
      "smj": "smj-Latn-SE",
      "smn": "smn-Latn-FI",
      "smp": "smp-Samr-IL",
      "smq": "smq-Latn-ZZ",
      "sms": "sms-Latn-FI",
      "sn": "sn-Latn-ZW",
      "snc": "snc-Latn-ZZ",
      "snk": "snk-Latn-ML",
      "snp": "snp-Latn-ZZ",
      "snx": "snx-Latn-ZZ",
      "sny": "sny-Latn-ZZ",
      "so": "so-Latn-SO",
      "sog": "sog-Sogd-UZ",
      "sok": "sok-Latn-ZZ",
      "soq": "soq-Latn-ZZ",
      "sou": "sou-Thai-TH",
      "soy": "soy-Latn-ZZ",
      "spd": "spd-Latn-ZZ",
      "spl": "spl-Latn-ZZ",
      "sps": "sps-Latn-ZZ",
      "sq": "sq-Latn-AL",
      "sr": "sr-Cyrl-RS",
      "sr-ME": "sr-Latn-ME",
      "sr-RO": "sr-Latn-RO",
      "sr-RU": "sr-Latn-RU",
      "sr-TR": "sr-Latn-TR",
      "srb": "srb-Sora-IN",
      "srn": "srn-Latn-SR",
      "srr": "srr-Latn-SN",
      "srx": "srx-Deva-IN",
      "ss": "ss-Latn-ZA",
      "ssd": "ssd-Latn-ZZ",
      "ssg": "ssg-Latn-ZZ",
      "ssy": "ssy-Latn-ER",
      "st": "st-Latn-ZA",
      "stk": "stk-Latn-ZZ",
      "stq": "stq-Latn-DE",
      "su": "su-Latn-ID",
      "sua": "sua-Latn-ZZ",
      "sue": "sue-Latn-ZZ",
      "suk": "suk-Latn-TZ",
      "sur": "sur-Latn-ZZ",
      "sus": "sus-Latn-GN",
      "sv": "sv-Latn-SE",
      "sw": "sw-Latn-TZ",
      "swb": "swb-Arab-YT",
      "swc": "swc-Latn-CD",
      "swg": "swg-Latn-DE",
      "swp": "swp-Latn-ZZ",
      "swv": "swv-Deva-IN",
      "sxn": "sxn-Latn-ID",
      "sxw": "sxw-Latn-ZZ",
      "syl": "syl-Beng-BD",
      "syr": "syr-Syrc-IQ",
      "szl": "szl-Latn-PL",
      "ta": "ta-Taml-IN",
      "taj": "taj-Deva-NP",
      "tal": "tal-Latn-ZZ",
      "tan": "tan-Latn-ZZ",
      "taq": "taq-Latn-ZZ",
      "tbc": "tbc-Latn-ZZ",
      "tbd": "tbd-Latn-ZZ",
      "tbf": "tbf-Latn-ZZ",
      "tbg": "tbg-Latn-ZZ",
      "tbo": "tbo-Latn-ZZ",
      "tbw": "tbw-Latn-PH",
      "tbz": "tbz-Latn-ZZ",
      "tci": "tci-Latn-ZZ",
      "tcy": "tcy-Knda-IN",
      "tdd": "tdd-Tale-CN",
      "tdg": "tdg-Deva-NP",
      "tdh": "tdh-Deva-NP",
      "tdu": "tdu-Latn-MY",
      "te": "te-Telu-IN",
      "ted": "ted-Latn-ZZ",
      "tem": "tem-Latn-SL",
      "teo": "teo-Latn-UG",
      "tet": "tet-Latn-TL",
      "tfi": "tfi-Latn-ZZ",
      "tg": "tg-Cyrl-TJ",
      "tg-Arab": "tg-Arab-PK",
      "tg-PK": "tg-Arab-PK",
      "tgc": "tgc-Latn-ZZ",
      "tgo": "tgo-Latn-ZZ",
      "tgu": "tgu-Latn-ZZ",
      "th": "th-Thai-TH",
      "thl": "thl-Deva-NP",
      "thq": "thq-Deva-NP",
      "thr": "thr-Deva-NP",
      "ti": "ti-Ethi-ET",
      "tif": "tif-Latn-ZZ",
      "tig": "tig-Ethi-ER",
      "tik": "tik-Latn-ZZ",
      "tim": "tim-Latn-ZZ",
      "tio": "tio-Latn-ZZ",
      "tiv": "tiv-Latn-NG",
      "tk": "tk-Latn-TM",
      "tkl": "tkl-Latn-TK",
      "tkr": "tkr-Latn-AZ",
      "tkt": "tkt-Deva-NP",
      "tl": "tl-Latn-PH",
      "tlf": "tlf-Latn-ZZ",
      "tlx": "tlx-Latn-ZZ",
      "tly": "tly-Latn-AZ",
      "tmh": "tmh-Latn-NE",
      "tmy": "tmy-Latn-ZZ",
      "tn": "tn-Latn-ZA",
      "tnh": "tnh-Latn-ZZ",
      "to": "to-Latn-TO",
      "tof": "tof-Latn-ZZ",
      "tog": "tog-Latn-MW",
      "toq": "toq-Latn-ZZ",
      "tpi": "tpi-Latn-PG",
      "tpm": "tpm-Latn-ZZ",
      "tpz": "tpz-Latn-ZZ",
      "tqo": "tqo-Latn-ZZ",
      "tr": "tr-Latn-TR",
      "tru": "tru-Latn-TR",
      "trv": "trv-Latn-TW",
      "trw": "trw-Arab-PK",
      "ts": "ts-Latn-ZA",
      "tsd": "tsd-Grek-GR",
      "tsf": "tsf-Deva-NP",
      "tsg": "tsg-Latn-PH",
      "tsj": "tsj-Tibt-BT",
      "tsw": "tsw-Latn-ZZ",
      "tt": "tt-Cyrl-RU",
      "ttd": "ttd-Latn-ZZ",
      "tte": "tte-Latn-ZZ",
      "ttj": "ttj-Latn-UG",
      "ttr": "ttr-Latn-ZZ",
      "tts": "tts-Thai-TH",
      "ttt": "ttt-Latn-AZ",
      "tuh": "tuh-Latn-ZZ",
      "tul": "tul-Latn-ZZ",
      "tum": "tum-Latn-MW",
      "tuq": "tuq-Latn-ZZ",
      "tvd": "tvd-Latn-ZZ",
      "tvl": "tvl-Latn-TV",
      "tvu": "tvu-Latn-ZZ",
      "twh": "twh-Latn-ZZ",
      "twq": "twq-Latn-NE",
      "txg": "txg-Tang-CN",
      "ty": "ty-Latn-PF",
      "tya": "tya-Latn-ZZ",
      "tyv": "tyv-Cyrl-RU",
      "tzm": "tzm-Latn-MA",
      "ubu": "ubu-Latn-ZZ",
      "udm": "udm-Cyrl-RU",
      "ug": "ug-Arab-CN",
      "ug-Cyrl": "ug-Cyrl-KZ",
      "ug-KZ": "ug-Cyrl-KZ",
      "ug-MN": "ug-Cyrl-MN",
      "uga": "uga-Ugar-SY",
      "uk": "uk-Cyrl-UA",
      "uli": "uli-Latn-FM",
      "umb": "umb-Latn-AO",
      "und": "en-Latn-US",
      "und-002": "en-Latn-NG",
      "und-003": "en-Latn-US",
      "und-005": "pt-Latn-BR",
      "und-009": "en-Latn-AU",
      "und-011": "en-Latn-NG",
      "und-013": "es-Latn-MX",
      "und-014": "sw-Latn-TZ",
      "und-015": "ar-Arab-EG",
      "und-017": "sw-Latn-CD",
      "und-018": "en-Latn-ZA",
      "und-019": "en-Latn-US",
      "und-021": "en-Latn-US",
      "und-029": "es-Latn-CU",
      "und-030": "zh-Hans-CN",
      "und-034": "hi-Deva-IN",
      "und-035": "id-Latn-ID",
      "und-039": "it-Latn-IT",
      "und-053": "en-Latn-AU",
      "und-054": "en-Latn-PG",
      "und-057": "en-Latn-GU",
      "und-061": "sm-Latn-WS",
      "und-142": "zh-Hans-CN",
      "und-143": "uz-Latn-UZ",
      "und-145": "ar-Arab-SA",
      "und-150": "ru-Cyrl-RU",
      "und-151": "ru-Cyrl-RU",
      "und-154": "en-Latn-GB",
      "und-155": "de-Latn-DE",
      "und-202": "en-Latn-NG",
      "und-419": "es-Latn-419",
      "und-AD": "ca-Latn-AD",
      "und-Adlm": "ff-Adlm-GN",
      "und-AE": "ar-Arab-AE",
      "und-AF": "fa-Arab-AF",
      "und-Aghb": "lez-Aghb-RU",
      "und-Ahom": "aho-Ahom-IN",
      "und-AL": "sq-Latn-AL",
      "und-AM": "hy-Armn-AM",
      "und-AO": "pt-Latn-AO",
      "und-AQ": "und-Latn-AQ",
      "und-AR": "es-Latn-AR",
      "und-Arab": "ar-Arab-EG",
      "und-Arab-CC": "ms-Arab-CC",
      "und-Arab-CN": "ug-Arab-CN",
      "und-Arab-GB": "ks-Arab-GB",
      "und-Arab-ID": "ms-Arab-ID",
      "und-Arab-IN": "ur-Arab-IN",
      "und-Arab-KH": "cja-Arab-KH",
      "und-Arab-MM": "rhg-Arab-MM",
      "und-Arab-MN": "kk-Arab-MN",
      "und-Arab-MU": "ur-Arab-MU",
      "und-Arab-NG": "ha-Arab-NG",
      "und-Arab-PK": "ur-Arab-PK",
      "und-Arab-TG": "apd-Arab-TG",
      "und-Arab-TH": "mfa-Arab-TH",
      "und-Arab-TJ": "fa-Arab-TJ",
      "und-Arab-TR": "az-Arab-TR",
      "und-Arab-YT": "swb-Arab-YT",
      "und-Armi": "arc-Armi-IR",
      "und-Armn": "hy-Armn-AM",
      "und-AS": "sm-Latn-AS",
      "und-AT": "de-Latn-AT",
      "und-Avst": "ae-Avst-IR",
      "und-AW": "nl-Latn-AW",
      "und-AX": "sv-Latn-AX",
      "und-AZ": "az-Latn-AZ",
      "und-BA": "bs-Latn-BA",
      "und-Bali": "ban-Bali-ID",
      "und-Bamu": "bax-Bamu-CM",
      "und-Bass": "bsq-Bass-LR",
      "und-Batk": "bbc-Batk-ID",
      "und-BD": "bn-Beng-BD",
      "und-BE": "nl-Latn-BE",
      "und-Beng": "bn-Beng-BD",
      "und-BF": "fr-Latn-BF",
      "und-BG": "bg-Cyrl-BG",
      "und-BH": "ar-Arab-BH",
      "und-Bhks": "sa-Bhks-IN",
      "und-BI": "rn-Latn-BI",
      "und-BJ": "fr-Latn-BJ",
      "und-BL": "fr-Latn-BL",
      "und-BN": "ms-Latn-BN",
      "und-BO": "es-Latn-BO",
      "und-Bopo": "zh-Bopo-TW",
      "und-BQ": "pap-Latn-BQ",
      "und-BR": "pt-Latn-BR",
      "und-Brah": "pka-Brah-IN",
      "und-Brai": "fr-Brai-FR",
      "und-BT": "dz-Tibt-BT",
      "und-Bugi": "bug-Bugi-ID",
      "und-Buhd": "bku-Buhd-PH",
      "und-BV": "und-Latn-BV",
      "und-BY": "be-Cyrl-BY",
      "und-Cakm": "ccp-Cakm-BD",
      "und-Cans": "cr-Cans-CA",
      "und-Cari": "xcr-Cari-TR",
      "und-CD": "sw-Latn-CD",
      "und-CF": "fr-Latn-CF",
      "und-CG": "fr-Latn-CG",
      "und-CH": "de-Latn-CH",
      "und-Cham": "cjm-Cham-VN",
      "und-Cher": "chr-Cher-US",
      "und-Chrs": "xco-Chrs-UZ",
      "und-CI": "fr-Latn-CI",
      "und-CL": "es-Latn-CL",
      "und-CM": "fr-Latn-CM",
      "und-CN": "zh-Hans-CN",
      "und-CO": "es-Latn-CO",
      "und-Copt": "cop-Copt-EG",
      "und-CP": "und-Latn-CP",
      "und-Cprt": "grc-Cprt-CY",
      "und-CR": "es-Latn-CR",
      "und-CU": "es-Latn-CU",
      "und-CV": "pt-Latn-CV",
      "und-CW": "pap-Latn-CW",
      "und-CY": "el-Grek-CY",
      "und-Cyrl": "ru-Cyrl-RU",
      "und-Cyrl-AL": "mk-Cyrl-AL",
      "und-Cyrl-BA": "sr-Cyrl-BA",
      "und-Cyrl-GE": "os-Cyrl-GE",
      "und-Cyrl-GR": "mk-Cyrl-GR",
      "und-Cyrl-MD": "uk-Cyrl-MD",
      "und-Cyrl-RO": "bg-Cyrl-RO",
      "und-Cyrl-SK": "uk-Cyrl-SK",
      "und-Cyrl-TR": "kbd-Cyrl-TR",
      "und-Cyrl-XK": "sr-Cyrl-XK",
      "und-CZ": "cs-Latn-CZ",
      "und-DE": "de-Latn-DE",
      "und-Deva": "hi-Deva-IN",
      "und-Deva-BT": "ne-Deva-BT",
      "und-Deva-FJ": "hif-Deva-FJ",
      "und-Deva-MU": "bho-Deva-MU",
      "und-Deva-PK": "btv-Deva-PK",
      "und-Diak": "dv-Diak-MV",
      "und-DJ": "aa-Latn-DJ",
      "und-DK": "da-Latn-DK",
      "und-DO": "es-Latn-DO",
      "und-Dogr": "doi-Dogr-IN",
      "und-Dupl": "fr-Dupl-FR",
      "und-DZ": "ar-Arab-DZ",
      "und-EA": "es-Latn-EA",
      "und-EC": "es-Latn-EC",
      "und-EE": "et-Latn-EE",
      "und-EG": "ar-Arab-EG",
      "und-Egyp": "egy-Egyp-EG",
      "und-EH": "ar-Arab-EH",
      "und-Elba": "sq-Elba-AL",
      "und-Elym": "arc-Elym-IR",
      "und-ER": "ti-Ethi-ER",
      "und-ES": "es-Latn-ES",
      "und-ET": "am-Ethi-ET",
      "und-Ethi": "am-Ethi-ET",
      "und-EU": "en-Latn-IE",
      "und-EZ": "de-Latn-EZ",
      "und-FI": "fi-Latn-FI",
      "und-FO": "fo-Latn-FO",
      "und-FR": "fr-Latn-FR",
      "und-GA": "fr-Latn-GA",
      "und-GE": "ka-Geor-GE",
      "und-Geor": "ka-Geor-GE",
      "und-GF": "fr-Latn-GF",
      "und-GH": "ak-Latn-GH",
      "und-GL": "kl-Latn-GL",
      "und-Glag": "cu-Glag-BG",
      "und-GN": "fr-Latn-GN",
      "und-Gong": "wsg-Gong-IN",
      "und-Gonm": "esg-Gonm-IN",
      "und-Goth": "got-Goth-UA",
      "und-GP": "fr-Latn-GP",
      "und-GQ": "es-Latn-GQ",
      "und-GR": "el-Grek-GR",
      "und-Gran": "sa-Gran-IN",
      "und-Grek": "el-Grek-GR",
      "und-Grek-TR": "bgx-Grek-TR",
      "und-GS": "und-Latn-GS",
      "und-GT": "es-Latn-GT",
      "und-Gujr": "gu-Gujr-IN",
      "und-Guru": "pa-Guru-IN",
      "und-GW": "pt-Latn-GW",
      "und-Hanb": "zh-Hanb-TW",
      "und-Hang": "ko-Hang-KR",
      "und-Hani": "zh-Hani-CN",
      "und-Hano": "hnn-Hano-PH",
      "und-Hans": "zh-Hans-CN",
      "und-Hant": "zh-Hant-TW",
      "und-Hatr": "mis-Hatr-IQ",
      "und-Hebr": "he-Hebr-IL",
      "und-Hebr-CA": "yi-Hebr-CA",
      "und-Hebr-GB": "yi-Hebr-GB",
      "und-Hebr-SE": "yi-Hebr-SE",
      "und-Hebr-UA": "yi-Hebr-UA",
      "und-Hebr-US": "yi-Hebr-US",
      "und-Hira": "ja-Hira-JP",
      "und-HK": "zh-Hant-HK",
      "und-Hluw": "hlu-Hluw-TR",
      "und-HM": "und-Latn-HM",
      "und-Hmng": "hnj-Hmng-LA",
      "und-Hmnp": "mww-Hmnp-US",
      "und-HN": "es-Latn-HN",
      "und-HR": "hr-Latn-HR",
      "und-HT": "ht-Latn-HT",
      "und-HU": "hu-Latn-HU",
      "und-Hung": "hu-Hung-HU",
      "und-IC": "es-Latn-IC",
      "und-ID": "id-Latn-ID",
      "und-IL": "he-Hebr-IL",
      "und-IN": "hi-Deva-IN",
      "und-IQ": "ar-Arab-IQ",
      "und-IR": "fa-Arab-IR",
      "und-IS": "is-Latn-IS",
      "und-IT": "it-Latn-IT",
      "und-Ital": "ett-Ital-IT",
      "und-Jamo": "ko-Jamo-KR",
      "und-Java": "jv-Java-ID",
      "und-JO": "ar-Arab-JO",
      "und-JP": "ja-Jpan-JP",
      "und-Jpan": "ja-Jpan-JP",
      "und-Kali": "eky-Kali-MM",
      "und-Kana": "ja-Kana-JP",
      "und-KE": "sw-Latn-KE",
      "und-KG": "ky-Cyrl-KG",
      "und-KH": "km-Khmr-KH",
      "und-Khar": "pra-Khar-PK",
      "und-Khmr": "km-Khmr-KH",
      "und-Khoj": "sd-Khoj-IN",
      "und-Kits": "zkt-Kits-CN",
      "und-KM": "ar-Arab-KM",
      "und-Knda": "kn-Knda-IN",
      "und-Kore": "ko-Kore-KR",
      "und-KP": "ko-Kore-KP",
      "und-KR": "ko-Kore-KR",
      "und-Kthi": "bho-Kthi-IN",
      "und-KW": "ar-Arab-KW",
      "und-KZ": "ru-Cyrl-KZ",
      "und-LA": "lo-Laoo-LA",
      "und-Lana": "nod-Lana-TH",
      "und-Laoo": "lo-Laoo-LA",
      "und-Latn-AF": "tk-Latn-AF",
      "und-Latn-AM": "ku-Latn-AM",
      "und-Latn-CN": "za-Latn-CN",
      "und-Latn-CY": "tr-Latn-CY",
      "und-Latn-DZ": "fr-Latn-DZ",
      "und-Latn-ET": "en-Latn-ET",
      "und-Latn-GE": "ku-Latn-GE",
      "und-Latn-IR": "tk-Latn-IR",
      "und-Latn-KM": "fr-Latn-KM",
      "und-Latn-MA": "fr-Latn-MA",
      "und-Latn-MK": "sq-Latn-MK",
      "und-Latn-MM": "kac-Latn-MM",
      "und-Latn-MO": "pt-Latn-MO",
      "und-Latn-MR": "fr-Latn-MR",
      "und-Latn-RU": "krl-Latn-RU",
      "und-Latn-SY": "fr-Latn-SY",
      "und-Latn-TN": "fr-Latn-TN",
      "und-Latn-TW": "trv-Latn-TW",
      "und-Latn-UA": "pl-Latn-UA",
      "und-LB": "ar-Arab-LB",
      "und-Lepc": "lep-Lepc-IN",
      "und-LI": "de-Latn-LI",
      "und-Limb": "lif-Limb-IN",
      "und-Lina": "lab-Lina-GR",
      "und-Linb": "grc-Linb-GR",
      "und-Lisu": "lis-Lisu-CN",
      "und-LK": "si-Sinh-LK",
      "und-LS": "st-Latn-LS",
      "und-LT": "lt-Latn-LT",
      "und-LU": "fr-Latn-LU",
      "und-LV": "lv-Latn-LV",
      "und-LY": "ar-Arab-LY",
      "und-Lyci": "xlc-Lyci-TR",
      "und-Lydi": "xld-Lydi-TR",
      "und-MA": "ar-Arab-MA",
      "und-Mahj": "hi-Mahj-IN",
      "und-Maka": "mak-Maka-ID",
      "und-Mand": "myz-Mand-IR",
      "und-Mani": "xmn-Mani-CN",
      "und-Marc": "bo-Marc-CN",
      "und-MC": "fr-Latn-MC",
      "und-MD": "ro-Latn-MD",
      "und-ME": "sr-Latn-ME",
      "und-Medf": "mis-Medf-NG",
      "und-Mend": "men-Mend-SL",
      "und-Merc": "xmr-Merc-SD",
      "und-Mero": "xmr-Mero-SD",
      "und-MF": "fr-Latn-MF",
      "und-MG": "mg-Latn-MG",
      "und-MK": "mk-Cyrl-MK",
      "und-ML": "bm-Latn-ML",
      "und-Mlym": "ml-Mlym-IN",
      "und-MM": "my-Mymr-MM",
      "und-MN": "mn-Cyrl-MN",
      "und-MO": "zh-Hant-MO",
      "und-Modi": "mr-Modi-IN",
      "und-Mong": "mn-Mong-CN",
      "und-MQ": "fr-Latn-MQ",
      "und-MR": "ar-Arab-MR",
      "und-Mroo": "mro-Mroo-BD",
      "und-MT": "mt-Latn-MT",
      "und-Mtei": "mni-Mtei-IN",
      "und-MU": "mfe-Latn-MU",
      "und-Mult": "skr-Mult-PK",
      "und-MV": "dv-Thaa-MV",
      "und-MX": "es-Latn-MX",
      "und-MY": "ms-Latn-MY",
      "und-Mymr": "my-Mymr-MM",
      "und-Mymr-IN": "kht-Mymr-IN",
      "und-Mymr-TH": "mnw-Mymr-TH",
      "und-MZ": "pt-Latn-MZ",
      "und-NA": "af-Latn-NA",
      "und-Nand": "sa-Nand-IN",
      "und-Narb": "xna-Narb-SA",
      "und-Nbat": "arc-Nbat-JO",
      "und-NC": "fr-Latn-NC",
      "und-NE": "ha-Latn-NE",
      "und-Newa": "new-Newa-NP",
      "und-NI": "es-Latn-NI",
      "und-Nkoo": "man-Nkoo-GN",
      "und-NL": "nl-Latn-NL",
      "und-NO": "nb-Latn-NO",
      "und-NP": "ne-Deva-NP",
      "und-Nshu": "zhx-Nshu-CN",
      "und-Ogam": "sga-Ogam-IE",
      "und-Olck": "sat-Olck-IN",
      "und-OM": "ar-Arab-OM",
      "und-Orkh": "otk-Orkh-MN",
      "und-Orya": "or-Orya-IN",
      "und-Osge": "osa-Osge-US",
      "und-Osma": "so-Osma-SO",
      "und-PA": "es-Latn-PA",
      "und-Palm": "arc-Palm-SY",
      "und-Pauc": "ctd-Pauc-MM",
      "und-PE": "es-Latn-PE",
      "und-Perm": "kv-Perm-RU",
      "und-PF": "fr-Latn-PF",
      "und-PG": "tpi-Latn-PG",
      "und-PH": "fil-Latn-PH",
      "und-Phag": "lzh-Phag-CN",
      "und-Phli": "pal-Phli-IR",
      "und-Phlp": "pal-Phlp-CN",
      "und-Phnx": "phn-Phnx-LB",
      "und-PK": "ur-Arab-PK",
      "und-PL": "pl-Latn-PL",
      "und-Plrd": "hmd-Plrd-CN",
      "und-PM": "fr-Latn-PM",
      "und-PR": "es-Latn-PR",
      "und-Prti": "xpr-Prti-IR",
      "und-PS": "ar-Arab-PS",
      "und-PT": "pt-Latn-PT",
      "und-PW": "pau-Latn-PW",
      "und-PY": "gn-Latn-PY",
      "und-QA": "ar-Arab-QA",
      "und-QO": "en-Latn-DG",
      "und-RE": "fr-Latn-RE",
      "und-Rjng": "rej-Rjng-ID",
      "und-RO": "ro-Latn-RO",
      "und-Rohg": "rhg-Rohg-MM",
      "und-RS": "sr-Cyrl-RS",
      "und-RU": "ru-Cyrl-RU",
      "und-Runr": "non-Runr-SE",
      "und-RW": "rw-Latn-RW",
      "und-SA": "ar-Arab-SA",
      "und-Samr": "smp-Samr-IL",
      "und-Sarb": "xsa-Sarb-YE",
      "und-Saur": "saz-Saur-IN",
      "und-SC": "fr-Latn-SC",
      "und-SD": "ar-Arab-SD",
      "und-SE": "sv-Latn-SE",
      "und-Sgnw": "ase-Sgnw-US",
      "und-Shaw": "en-Shaw-GB",
      "und-Shrd": "sa-Shrd-IN",
      "und-SI": "sl-Latn-SI",
      "und-Sidd": "sa-Sidd-IN",
      "und-Sind": "sd-Sind-IN",
      "und-Sinh": "si-Sinh-LK",
      "und-SJ": "nb-Latn-SJ",
      "und-SK": "sk-Latn-SK",
      "und-SM": "it-Latn-SM",
      "und-SN": "fr-Latn-SN",
      "und-SO": "so-Latn-SO",
      "und-Sogd": "sog-Sogd-UZ",
      "und-Sogo": "sog-Sogo-UZ",
      "und-Sora": "srb-Sora-IN",
      "und-Soyo": "cmg-Soyo-MN",
      "und-SR": "nl-Latn-SR",
      "und-ST": "pt-Latn-ST",
      "und-Sund": "su-Sund-ID",
      "und-SV": "es-Latn-SV",
      "und-SY": "ar-Arab-SY",
      "und-Sylo": "syl-Sylo-BD",
      "und-Syrc": "syr-Syrc-IQ",
      "und-Tagb": "tbw-Tagb-PH",
      "und-Takr": "doi-Takr-IN",
      "und-Tale": "tdd-Tale-CN",
      "und-Talu": "khb-Talu-CN",
      "und-Taml": "ta-Taml-IN",
      "und-Tang": "txg-Tang-CN",
      "und-Tavt": "blt-Tavt-VN",
      "und-TD": "fr-Latn-TD",
      "und-Telu": "te-Telu-IN",
      "und-TF": "fr-Latn-TF",
      "und-Tfng": "zgh-Tfng-MA",
      "und-TG": "fr-Latn-TG",
      "und-Tglg": "fil-Tglg-PH",
      "und-TH": "th-Thai-TH",
      "und-Thaa": "dv-Thaa-MV",
      "und-Thai": "th-Thai-TH",
      "und-Thai-CN": "lcp-Thai-CN",
      "und-Thai-KH": "kdt-Thai-KH",
      "und-Thai-LA": "kdt-Thai-LA",
      "und-Tibt": "bo-Tibt-CN",
      "und-Tirh": "mai-Tirh-IN",
      "und-TJ": "tg-Cyrl-TJ",
      "und-TK": "tkl-Latn-TK",
      "und-TL": "pt-Latn-TL",
      "und-TM": "tk-Latn-TM",
      "und-TN": "ar-Arab-TN",
      "und-TO": "to-Latn-TO",
      "und-TR": "tr-Latn-TR",
      "und-TV": "tvl-Latn-TV",
      "und-TW": "zh-Hant-TW",
      "und-TZ": "sw-Latn-TZ",
      "und-UA": "uk-Cyrl-UA",
      "und-UG": "sw-Latn-UG",
      "und-Ugar": "uga-Ugar-SY",
      "und-UY": "es-Latn-UY",
      "und-UZ": "uz-Latn-UZ",
      "und-VA": "it-Latn-VA",
      "und-Vaii": "vai-Vaii-LR",
      "und-VE": "es-Latn-VE",
      "und-VN": "vi-Latn-VN",
      "und-VU": "bi-Latn-VU",
      "und-Wara": "hoc-Wara-IN",
      "und-Wcho": "nnp-Wcho-IN",
      "und-WF": "fr-Latn-WF",
      "und-WS": "sm-Latn-WS",
      "und-XK": "sq-Latn-XK",
      "und-Xpeo": "peo-Xpeo-IR",
      "und-Xsux": "akk-Xsux-IQ",
      "und-YE": "ar-Arab-YE",
      "und-Yezi": "ku-Yezi-GE",
      "und-Yiii": "ii-Yiii-CN",
      "und-YT": "fr-Latn-YT",
      "und-Zanb": "cmg-Zanb-MN",
      "und-ZW": "sn-Latn-ZW",
      "unr": "unr-Beng-IN",
      "unr-Deva": "unr-Deva-NP",
      "unr-NP": "unr-Deva-NP",
      "unx": "unx-Beng-IN",
      "uok": "uok-Latn-ZZ",
      "ur": "ur-Arab-PK",
      "uri": "uri-Latn-ZZ",
      "urt": "urt-Latn-ZZ",
      "urw": "urw-Latn-ZZ",
      "usa": "usa-Latn-ZZ",
      "uth": "uth-Latn-ZZ",
      "utr": "utr-Latn-ZZ",
      "uvh": "uvh-Latn-ZZ",
      "uvl": "uvl-Latn-ZZ",
      "uz": "uz-Latn-UZ",
      "uz-AF": "uz-Arab-AF",
      "uz-Arab": "uz-Arab-AF",
      "uz-CN": "uz-Cyrl-CN",
      "vag": "vag-Latn-ZZ",
      "vai": "vai-Vaii-LR",
      "van": "van-Latn-ZZ",
      "ve": "ve-Latn-ZA",
      "vec": "vec-Latn-IT",
      "vep": "vep-Latn-RU",
      "vi": "vi-Latn-VN",
      "vic": "vic-Latn-SX",
      "viv": "viv-Latn-ZZ",
      "vls": "vls-Latn-BE",
      "vmf": "vmf-Latn-DE",
      "vmw": "vmw-Latn-MZ",
      "vo": "vo-Latn-001",
      "vot": "vot-Latn-RU",
      "vro": "vro-Latn-EE",
      "vun": "vun-Latn-TZ",
      "vut": "vut-Latn-ZZ",
      "wa": "wa-Latn-BE",
      "wae": "wae-Latn-CH",
      "waj": "waj-Latn-ZZ",
      "wal": "wal-Ethi-ET",
      "wan": "wan-Latn-ZZ",
      "war": "war-Latn-PH",
      "wbp": "wbp-Latn-AU",
      "wbq": "wbq-Telu-IN",
      "wbr": "wbr-Deva-IN",
      "wci": "wci-Latn-ZZ",
      "wer": "wer-Latn-ZZ",
      "wgi": "wgi-Latn-ZZ",
      "whg": "whg-Latn-ZZ",
      "wib": "wib-Latn-ZZ",
      "wiu": "wiu-Latn-ZZ",
      "wiv": "wiv-Latn-ZZ",
      "wja": "wja-Latn-ZZ",
      "wji": "wji-Latn-ZZ",
      "wls": "wls-Latn-WF",
      "wmo": "wmo-Latn-ZZ",
      "wnc": "wnc-Latn-ZZ",
      "wni": "wni-Arab-KM",
      "wnu": "wnu-Latn-ZZ",
      "wo": "wo-Latn-SN",
      "wob": "wob-Latn-ZZ",
      "wos": "wos-Latn-ZZ",
      "wrs": "wrs-Latn-ZZ",
      "wsg": "wsg-Gong-IN",
      "wsk": "wsk-Latn-ZZ",
      "wtm": "wtm-Deva-IN",
      "wuu": "wuu-Hans-CN",
      "wuv": "wuv-Latn-ZZ",
      "wwa": "wwa-Latn-ZZ",
      "xav": "xav-Latn-BR",
      "xbi": "xbi-Latn-ZZ",
      "xco": "xco-Chrs-UZ",
      "xcr": "xcr-Cari-TR",
      "xes": "xes-Latn-ZZ",
      "xh": "xh-Latn-ZA",
      "xla": "xla-Latn-ZZ",
      "xlc": "xlc-Lyci-TR",
      "xld": "xld-Lydi-TR",
      "xmf": "xmf-Geor-GE",
      "xmn": "xmn-Mani-CN",
      "xmr": "xmr-Merc-SD",
      "xna": "xna-Narb-SA",
      "xnr": "xnr-Deva-IN",
      "xog": "xog-Latn-UG",
      "xon": "xon-Latn-ZZ",
      "xpr": "xpr-Prti-IR",
      "xrb": "xrb-Latn-ZZ",
      "xsa": "xsa-Sarb-YE",
      "xsi": "xsi-Latn-ZZ",
      "xsm": "xsm-Latn-ZZ",
      "xsr": "xsr-Deva-NP",
      "xwe": "xwe-Latn-ZZ",
      "yam": "yam-Latn-ZZ",
      "yao": "yao-Latn-MZ",
      "yap": "yap-Latn-FM",
      "yas": "yas-Latn-ZZ",
      "yat": "yat-Latn-ZZ",
      "yav": "yav-Latn-CM",
      "yay": "yay-Latn-ZZ",
      "yaz": "yaz-Latn-ZZ",
      "yba": "yba-Latn-ZZ",
      "ybb": "ybb-Latn-CM",
      "yby": "yby-Latn-ZZ",
      "yer": "yer-Latn-ZZ",
      "ygr": "ygr-Latn-ZZ",
      "ygw": "ygw-Latn-ZZ",
      "yi": "yi-Hebr-001",
      "yko": "yko-Latn-ZZ",
      "yle": "yle-Latn-ZZ",
      "ylg": "ylg-Latn-ZZ",
      "yll": "yll-Latn-ZZ",
      "yml": "yml-Latn-ZZ",
      "yo": "yo-Latn-NG",
      "yon": "yon-Latn-ZZ",
      "yrb": "yrb-Latn-ZZ",
      "yre": "yre-Latn-ZZ",
      "yrl": "yrl-Latn-BR",
      "yss": "yss-Latn-ZZ",
      "yua": "yua-Latn-MX",
      "yue": "yue-Hant-HK",
      "yue-CN": "yue-Hans-CN",
      "yue-Hans": "yue-Hans-CN",
      "yuj": "yuj-Latn-ZZ",
      "yut": "yut-Latn-ZZ",
      "yuw": "yuw-Latn-ZZ",
      "za": "za-Latn-CN",
      "zag": "zag-Latn-SD",
      "zdj": "zdj-Arab-KM",
      "zea": "zea-Latn-NL",
      "zgh": "zgh-Tfng-MA",
      "zh": "zh-Hans-CN",
      "zh-AU": "zh-Hant-AU",
      "zh-BN": "zh-Hant-BN",
      "zh-Bopo": "zh-Bopo-TW",
      "zh-GB": "zh-Hant-GB",
      "zh-GF": "zh-Hant-GF",
      "zh-Hanb": "zh-Hanb-TW",
      "zh-Hant": "zh-Hant-TW",
      "zh-HK": "zh-Hant-HK",
      "zh-ID": "zh-Hant-ID",
      "zh-MO": "zh-Hant-MO",
      "zh-PA": "zh-Hant-PA",
      "zh-PF": "zh-Hant-PF",
      "zh-PH": "zh-Hant-PH",
      "zh-SR": "zh-Hant-SR",
      "zh-TH": "zh-Hant-TH",
      "zh-TW": "zh-Hant-TW",
      "zh-US": "zh-Hant-US",
      "zh-VN": "zh-Hant-VN",
      "zhx": "zhx-Nshu-CN",
      "zia": "zia-Latn-ZZ",
      "zkt": "zkt-Kits-CN",
      "zlm": "zlm-Latn-TG",
      "zmi": "zmi-Latn-MY",
      "zne": "zne-Latn-ZZ",
      "zu": "zu-Latn-ZA",
      "zza": "zza-Latn-TR"
    }
  }
}

},{}],87:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o) {
  var i = 0;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  i = o[Symbol.iterator]();
  return i.next.bind(i);
}

// these aren't really private, but nor are they really useful to document

/**
 * @private
 */
var LuxonError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(LuxonError, _Error);

  function LuxonError() {
    return _Error.apply(this, arguments) || this;
  }

  return LuxonError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * @private
 */


var InvalidDateTimeError = /*#__PURE__*/function (_LuxonError) {
  _inheritsLoose(InvalidDateTimeError, _LuxonError);

  function InvalidDateTimeError(reason) {
    return _LuxonError.call(this, "Invalid DateTime: " + reason.toMessage()) || this;
  }

  return InvalidDateTimeError;
}(LuxonError);
/**
 * @private
 */

var InvalidIntervalError = /*#__PURE__*/function (_LuxonError2) {
  _inheritsLoose(InvalidIntervalError, _LuxonError2);

  function InvalidIntervalError(reason) {
    return _LuxonError2.call(this, "Invalid Interval: " + reason.toMessage()) || this;
  }

  return InvalidIntervalError;
}(LuxonError);
/**
 * @private
 */

var InvalidDurationError = /*#__PURE__*/function (_LuxonError3) {
  _inheritsLoose(InvalidDurationError, _LuxonError3);

  function InvalidDurationError(reason) {
    return _LuxonError3.call(this, "Invalid Duration: " + reason.toMessage()) || this;
  }

  return InvalidDurationError;
}(LuxonError);
/**
 * @private
 */

var ConflictingSpecificationError = /*#__PURE__*/function (_LuxonError4) {
  _inheritsLoose(ConflictingSpecificationError, _LuxonError4);

  function ConflictingSpecificationError() {
    return _LuxonError4.apply(this, arguments) || this;
  }

  return ConflictingSpecificationError;
}(LuxonError);
/**
 * @private
 */

var InvalidUnitError = /*#__PURE__*/function (_LuxonError5) {
  _inheritsLoose(InvalidUnitError, _LuxonError5);

  function InvalidUnitError(unit) {
    return _LuxonError5.call(this, "Invalid unit " + unit) || this;
  }

  return InvalidUnitError;
}(LuxonError);
/**
 * @private
 */

var InvalidArgumentError = /*#__PURE__*/function (_LuxonError6) {
  _inheritsLoose(InvalidArgumentError, _LuxonError6);

  function InvalidArgumentError() {
    return _LuxonError6.apply(this, arguments) || this;
  }

  return InvalidArgumentError;
}(LuxonError);
/**
 * @private
 */

var ZoneIsAbstractError = /*#__PURE__*/function (_LuxonError7) {
  _inheritsLoose(ZoneIsAbstractError, _LuxonError7);

  function ZoneIsAbstractError() {
    return _LuxonError7.call(this, "Zone is an abstract class") || this;
  }

  return ZoneIsAbstractError;
}(LuxonError);

/**
 * @private
 */
var n = "numeric",
    s = "short",
    l = "long";
var DATE_SHORT = {
  year: n,
  month: n,
  day: n
};
var DATE_MED = {
  year: n,
  month: s,
  day: n
};
var DATE_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s
};
var DATE_FULL = {
  year: n,
  month: l,
  day: n
};
var DATE_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l
};
var TIME_SIMPLE = {
  hour: n,
  minute: n
};
var TIME_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n
};
var TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};
var TIME_24_SIMPLE = {
  hour: n,
  minute: n,
  hour12: false
};
/**
 * {@link toLocaleString}; format like '09:30:23', always 24-hour.
 */

var TIME_24_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
  hour12: false
};
/**
 * {@link toLocaleString}; format like '09:30:23 EDT', always 24-hour.
 */

var TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hour12: false,
  timeZoneName: s
};
/**
 * {@link toLocaleString}; format like '09:30:23 Eastern Daylight Time', always 24-hour.
 */

var TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hour12: false,
  timeZoneName: l
};
/**
 * {@link toLocaleString}; format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
 */

var DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n
};
/**
 * {@link toLocaleString}; format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
 */

var DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
  hour: n,
  minute: n
};
var DATETIME_FULL = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  timeZoneName: s
};
var DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var DATETIME_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  timeZoneName: l
};
var DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};

/*
  This is just a junk drawer, containing anything used across multiple classes.
  Because Luxon is small(ish), this should stay small and we won't worry about splitting
  it up into, say, parsingUtil.js and basicUtil.js and so on. But they are divided up by feature area.
*/
/**
 * @private
 */
// TYPES

function isUndefined(o) {
  return typeof o === "undefined";
}
function isNumber(o) {
  return typeof o === "number";
}
function isInteger(o) {
  return typeof o === "number" && o % 1 === 0;
}
function isString(o) {
  return typeof o === "string";
}
function isDate(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
} // CAPABILITIES

function hasIntl() {
  try {
    return typeof Intl !== "undefined" && Intl.DateTimeFormat;
  } catch (e) {
    return false;
  }
}
function hasFormatToParts() {
  return !isUndefined(Intl.DateTimeFormat.prototype.formatToParts);
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e) {
    return false;
  }
} // OBJECTS AND ARRAYS

function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return undefined;
  }

  return arr.reduce(function (best, next) {
    var pair = [by(next), next];

    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}
function pick(obj, keys) {
  return keys.reduce(function (a, k) {
    a[k] = obj[k];
    return a;
  }, {});
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
} // NUMBERS AND STRINGS

function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
} // x % n but takes the sign of n instead of x

function floorMod(x, n) {
  return x - n * Math.floor(x / n);
}
function padStart(input, n) {
  if (n === void 0) {
    n = 2;
  }

  if (input.toString().length < n) {
    return ("0".repeat(n) + input).slice(-n);
  } else {
    return input.toString();
  }
}
function parseInteger(string) {
  if (isUndefined(string) || string === null || string === "") {
    return undefined;
  } else {
    return parseInt(string, 10);
  }
}
function parseMillis(fraction) {
  // Return undefined (instead of 0) in these cases, where fraction is not set
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return undefined;
  } else {
    var f = parseFloat("0." + fraction) * 1000;
    return Math.floor(f);
  }
}
function roundTo(number, digits, towardZero) {
  if (towardZero === void 0) {
    towardZero = false;
  }

  var factor = Math.pow(10, digits),
      rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number * factor) / factor;
} // DATE BASICS

function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
  var modMonth = floorMod(month - 1, 12) + 1,
      modYear = year + (month - modMonth) / 12;

  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
} // covert a calendar object to a local timestamp (epoch, but with the offset baked in)

function objToLocalTS(obj) {
  var d = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond); // for legacy reasons, years between 0 and 99 are interpreted as 19XX; revert that

  if (obj.year < 100 && obj.year >= 0) {
    d = new Date(d);
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }

  return +d;
}
function weeksInWeekYear(weekYear) {
  var p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7,
      last = weekYear - 1,
      p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
  return p1 === 4 || p2 === 3 ? 53 : 52;
}
function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else return year > 60 ? 1900 + year : 2000 + year;
} // PARSING

function parseZoneInfo(ts, offsetFormat, locale, timeZone) {
  if (timeZone === void 0) {
    timeZone = null;
  }

  var date = new Date(ts),
      intlOpts = {
    hour12: false,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };

  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }

  var modified = Object.assign({
    timeZoneName: offsetFormat
  }, intlOpts),
      intl = hasIntl();

  if (intl && hasFormatToParts()) {
    var parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find(function (m) {
      return m.type.toLowerCase() === "timezonename";
    });
    return parsed ? parsed.value : null;
  } else if (intl) {
    // this probably doesn't work for all locales
    var without = new Intl.DateTimeFormat(locale, intlOpts).format(date),
        included = new Intl.DateTimeFormat(locale, modified).format(date),
        diffed = included.substring(without.length),
        trimmed = diffed.replace(/^[, \u200e]+/, "");
    return trimmed;
  } else {
    return null;
  }
} // signedOffset('-5', '30') -> -330

function signedOffset(offHourStr, offMinuteStr) {
  var offHour = parseInt(offHourStr, 10); // don't || this because we want to preserve -0

  if (Number.isNaN(offHour)) {
    offHour = 0;
  }

  var offMin = parseInt(offMinuteStr, 10) || 0,
      offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
} // COERCION

function asNumber(value) {
  var numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue)) throw new InvalidArgumentError("Invalid unit value " + value);
  return numericValue;
}
function normalizeObject(obj, normalizer, nonUnitKeys) {
  var normalized = {};

  for (var u in obj) {
    if (hasOwnProperty(obj, u)) {
      if (nonUnitKeys.indexOf(u) >= 0) continue;
      var v = obj[u];
      if (v === undefined || v === null) continue;
      normalized[normalizer(u)] = asNumber(v);
    }
  }

  return normalized;
}
function formatOffset(offset, format) {
  var hours = Math.trunc(Math.abs(offset / 60)),
      minutes = Math.trunc(Math.abs(offset % 60)),
      sign = offset >= 0 ? "+" : "-";

  switch (format) {
    case "short":
      return "" + sign + padStart(hours, 2) + ":" + padStart(minutes, 2);

    case "narrow":
      return "" + sign + hours + (minutes > 0 ? ":" + minutes : "");

    case "techie":
      return "" + sign + padStart(hours, 2) + padStart(minutes, 2);

    default:
      throw new RangeError("Value format " + format + " is out of range for property format");
  }
}
function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}
var ianaRegex = /[A-Za-z_+-]{1,256}(:?\/[A-Za-z_+-]{1,256}(\/[A-Za-z_+-]{1,256})?)?/;

function stringify(obj) {
  return JSON.stringify(obj, Object.keys(obj).sort());
}
/**
 * @private
 */


var monthsLong = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
var monthsShort = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length) {
  switch (length) {
    case "narrow":
      return monthsNarrow;

    case "short":
      return monthsShort;

    case "long":
      return monthsLong;

    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];

    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];

    default:
      return null;
  }
}
var weekdaysLong = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length) {
  switch (length) {
    case "narrow":
      return weekdaysNarrow;

    case "short":
      return weekdaysShort;

    case "long":
      return weekdaysLong;

    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];

    default:
      return null;
  }
}
var meridiems = ["AM", "PM"];
var erasLong = ["Before Christ", "Anno Domini"];
var erasShort = ["BC", "AD"];
var erasNarrow = ["B", "A"];
function eras(length) {
  switch (length) {
    case "narrow":
      return erasNarrow;

    case "short":
      return erasShort;

    case "long":
      return erasLong;

    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}
function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}
function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit, count, numeric, narrow) {
  if (numeric === void 0) {
    numeric = "always";
  }

  if (narrow === void 0) {
    narrow = false;
  }

  var units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  var lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;

  if (numeric === "auto" && lastable) {
    var isDay = unit === "days";

    switch (count) {
      case 1:
        return isDay ? "tomorrow" : "next " + units[unit][0];

      case -1:
        return isDay ? "yesterday" : "last " + units[unit][0];

      case 0:
        return isDay ? "today" : "this " + units[unit][0];

    }
  }

  var isInPast = Object.is(count, -0) || count < 0,
      fmtValue = Math.abs(count),
      singular = fmtValue === 1,
      lilUnits = units[unit],
      fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
  return isInPast ? fmtValue + " " + fmtUnit + " ago" : "in " + fmtValue + " " + fmtUnit;
}
function formatString(knownFormat) {
  // these all have the offsets removed because we don't have access to them
  // without all the intl stuff this is backfilling
  var filtered = pick(knownFormat, ["weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "hour12"]),
      key = stringify(filtered),
      dateTimeHuge = "EEEE, LLLL d, yyyy, h:mm a";

  switch (key) {
    case stringify(DATE_SHORT):
      return "M/d/yyyy";

    case stringify(DATE_MED):
      return "LLL d, yyyy";

    case stringify(DATE_MED_WITH_WEEKDAY):
      return "EEE, LLL d, yyyy";

    case stringify(DATE_FULL):
      return "LLLL d, yyyy";

    case stringify(DATE_HUGE):
      return "EEEE, LLLL d, yyyy";

    case stringify(TIME_SIMPLE):
      return "h:mm a";

    case stringify(TIME_WITH_SECONDS):
      return "h:mm:ss a";

    case stringify(TIME_WITH_SHORT_OFFSET):
      return "h:mm a";

    case stringify(TIME_WITH_LONG_OFFSET):
      return "h:mm a";

    case stringify(TIME_24_SIMPLE):
      return "HH:mm";

    case stringify(TIME_24_WITH_SECONDS):
      return "HH:mm:ss";

    case stringify(TIME_24_WITH_SHORT_OFFSET):
      return "HH:mm";

    case stringify(TIME_24_WITH_LONG_OFFSET):
      return "HH:mm";

    case stringify(DATETIME_SHORT):
      return "M/d/yyyy, h:mm a";

    case stringify(DATETIME_MED):
      return "LLL d, yyyy, h:mm a";

    case stringify(DATETIME_FULL):
      return "LLLL d, yyyy, h:mm a";

    case stringify(DATETIME_HUGE):
      return dateTimeHuge;

    case stringify(DATETIME_SHORT_WITH_SECONDS):
      return "M/d/yyyy, h:mm:ss a";

    case stringify(DATETIME_MED_WITH_SECONDS):
      return "LLL d, yyyy, h:mm:ss a";

    case stringify(DATETIME_MED_WITH_WEEKDAY):
      return "EEE, d LLL yyyy, h:mm a";

    case stringify(DATETIME_FULL_WITH_SECONDS):
      return "LLLL d, yyyy, h:mm:ss a";

    case stringify(DATETIME_HUGE_WITH_SECONDS):
      return "EEEE, LLLL d, yyyy, h:mm:ss a";

    default:
      return dateTimeHuge;
  }
}

function stringifyTokens(splits, tokenToString) {
  var s = "";

  for (var _iterator = _createForOfIteratorHelperLoose(splits), _step; !(_step = _iterator()).done;) {
    var token = _step.value;

    if (token.literal) {
      s += token.val;
    } else {
      s += tokenToString(token.val);
    }
  }

  return s;
}

var _macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};
/**
 * @private
 */

var Formatter = /*#__PURE__*/function () {
  Formatter.create = function create(locale, opts) {
    if (opts === void 0) {
      opts = {};
    }

    return new Formatter(locale, opts);
  };

  Formatter.parseFormat = function parseFormat(fmt) {
    var current = null,
        currentFull = "",
        bracketed = false;
    var splits = [];

    for (var i = 0; i < fmt.length; i++) {
      var c = fmt.charAt(i);

      if (c === "'") {
        if (currentFull.length > 0) {
          splits.push({
            literal: bracketed,
            val: currentFull
          });
        }

        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c;
      } else if (c === current) {
        currentFull += c;
      } else {
        if (currentFull.length > 0) {
          splits.push({
            literal: false,
            val: currentFull
          });
        }

        currentFull = c;
        current = c;
      }
    }

    if (currentFull.length > 0) {
      splits.push({
        literal: bracketed,
        val: currentFull
      });
    }

    return splits;
  };

  Formatter.macroTokenToFormatOpts = function macroTokenToFormatOpts(token) {
    return _macroTokenToFormatOpts[token];
  };

  function Formatter(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }

  var _proto = Formatter.prototype;

  _proto.formatWithSystemDefault = function formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }

    var df = this.systemLoc.dtFormatter(dt, Object.assign({}, this.opts, opts));
    return df.format();
  };

  _proto.formatDateTime = function formatDateTime(dt, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var df = this.loc.dtFormatter(dt, Object.assign({}, this.opts, opts));
    return df.format();
  };

  _proto.formatDateTimeParts = function formatDateTimeParts(dt, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var df = this.loc.dtFormatter(dt, Object.assign({}, this.opts, opts));
    return df.formatToParts();
  };

  _proto.resolvedOptions = function resolvedOptions(dt, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var df = this.loc.dtFormatter(dt, Object.assign({}, this.opts, opts));
    return df.resolvedOptions();
  };

  _proto.num = function num(n, p) {
    if (p === void 0) {
      p = 0;
    }

    // we get some perf out of doing this here, annoyingly
    if (this.opts.forceSimple) {
      return padStart(n, p);
    }

    var opts = Object.assign({}, this.opts);

    if (p > 0) {
      opts.padTo = p;
    }

    return this.loc.numberFormatter(opts).format(n);
  };

  _proto.formatDateTimeFromString = function formatDateTimeFromString(dt, fmt) {
    var _this = this;

    var knownEnglish = this.loc.listingMode() === "en",
        useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory" && hasFormatToParts(),
        string = function string(opts, extract) {
      return _this.loc.extract(dt, opts, extract);
    },
        formatOffset = function formatOffset(opts) {
      if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
        return "Z";
      }

      return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
    },
        meridiem = function meridiem() {
      return knownEnglish ? meridiemForDateTime(dt) : string({
        hour: "numeric",
        hour12: true
      }, "dayperiod");
    },
        month = function month(length, standalone) {
      return knownEnglish ? monthForDateTime(dt, length) : string(standalone ? {
        month: length
      } : {
        month: length,
        day: "numeric"
      }, "month");
    },
        weekday = function weekday(length, standalone) {
      return knownEnglish ? weekdayForDateTime(dt, length) : string(standalone ? {
        weekday: length
      } : {
        weekday: length,
        month: "long",
        day: "numeric"
      }, "weekday");
    },
        maybeMacro = function maybeMacro(token) {
      var formatOpts = Formatter.macroTokenToFormatOpts(token);

      if (formatOpts) {
        return _this.formatWithSystemDefault(dt, formatOpts);
      } else {
        return token;
      }
    },
        era = function era(length) {
      return knownEnglish ? eraForDateTime(dt, length) : string({
        era: length
      }, "era");
    },
        tokenToString = function tokenToString(token) {
      // Where possible: http://cldr.unicode.org/translation/date-time#TOC-Stand-Alone-vs.-Format-Styles
      switch (token) {
        // ms
        case "S":
          return _this.num(dt.millisecond);

        case "u": // falls through

        case "SSS":
          return _this.num(dt.millisecond, 3);
        // seconds

        case "s":
          return _this.num(dt.second);

        case "ss":
          return _this.num(dt.second, 2);
        // minutes

        case "m":
          return _this.num(dt.minute);

        case "mm":
          return _this.num(dt.minute, 2);
        // hours

        case "h":
          return _this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);

        case "hh":
          return _this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);

        case "H":
          return _this.num(dt.hour);

        case "HH":
          return _this.num(dt.hour, 2);
        // offset

        case "Z":
          // like +6
          return formatOffset({
            format: "narrow",
            allowZ: _this.opts.allowZ
          });

        case "ZZ":
          // like +06:00
          return formatOffset({
            format: "short",
            allowZ: _this.opts.allowZ
          });

        case "ZZZ":
          // like +0600
          return formatOffset({
            format: "techie",
            allowZ: _this.opts.allowZ
          });

        case "ZZZZ":
          // like EST
          return dt.zone.offsetName(dt.ts, {
            format: "short",
            locale: _this.loc.locale
          });

        case "ZZZZZ":
          // like Eastern Standard Time
          return dt.zone.offsetName(dt.ts, {
            format: "long",
            locale: _this.loc.locale
          });
        // zone

        case "z":
          // like America/New_York
          return dt.zoneName;
        // meridiems

        case "a":
          return meridiem();
        // dates

        case "d":
          return useDateTimeFormatter ? string({
            day: "numeric"
          }, "day") : _this.num(dt.day);

        case "dd":
          return useDateTimeFormatter ? string({
            day: "2-digit"
          }, "day") : _this.num(dt.day, 2);
        // weekdays - standalone

        case "c":
          // like 1
          return _this.num(dt.weekday);

        case "ccc":
          // like 'Tues'
          return weekday("short", true);

        case "cccc":
          // like 'Tuesday'
          return weekday("long", true);

        case "ccccc":
          // like 'T'
          return weekday("narrow", true);
        // weekdays - format

        case "E":
          // like 1
          return _this.num(dt.weekday);

        case "EEE":
          // like 'Tues'
          return weekday("short", false);

        case "EEEE":
          // like 'Tuesday'
          return weekday("long", false);

        case "EEEEE":
          // like 'T'
          return weekday("narrow", false);
        // months - standalone

        case "L":
          // like 1
          return useDateTimeFormatter ? string({
            month: "numeric",
            day: "numeric"
          }, "month") : _this.num(dt.month);

        case "LL":
          // like 01, doesn't seem to work
          return useDateTimeFormatter ? string({
            month: "2-digit",
            day: "numeric"
          }, "month") : _this.num(dt.month, 2);

        case "LLL":
          // like Jan
          return month("short", true);

        case "LLLL":
          // like January
          return month("long", true);

        case "LLLLL":
          // like J
          return month("narrow", true);
        // months - format

        case "M":
          // like 1
          return useDateTimeFormatter ? string({
            month: "numeric"
          }, "month") : _this.num(dt.month);

        case "MM":
          // like 01
          return useDateTimeFormatter ? string({
            month: "2-digit"
          }, "month") : _this.num(dt.month, 2);

        case "MMM":
          // like Jan
          return month("short", false);

        case "MMMM":
          // like January
          return month("long", false);

        case "MMMMM":
          // like J
          return month("narrow", false);
        // years

        case "y":
          // like 2014
          return useDateTimeFormatter ? string({
            year: "numeric"
          }, "year") : _this.num(dt.year);

        case "yy":
          // like 14
          return useDateTimeFormatter ? string({
            year: "2-digit"
          }, "year") : _this.num(dt.year.toString().slice(-2), 2);

        case "yyyy":
          // like 0012
          return useDateTimeFormatter ? string({
            year: "numeric"
          }, "year") : _this.num(dt.year, 4);

        case "yyyyyy":
          // like 000012
          return useDateTimeFormatter ? string({
            year: "numeric"
          }, "year") : _this.num(dt.year, 6);
        // eras

        case "G":
          // like AD
          return era("short");

        case "GG":
          // like Anno Domini
          return era("long");

        case "GGGGG":
          return era("narrow");

        case "kk":
          return _this.num(dt.weekYear.toString().slice(-2), 2);

        case "kkkk":
          return _this.num(dt.weekYear, 4);

        case "W":
          return _this.num(dt.weekNumber);

        case "WW":
          return _this.num(dt.weekNumber, 2);

        case "o":
          return _this.num(dt.ordinal);

        case "ooo":
          return _this.num(dt.ordinal, 3);

        case "q":
          // like 1
          return _this.num(dt.quarter);

        case "qq":
          // like 01
          return _this.num(dt.quarter, 2);

        case "X":
          return _this.num(Math.floor(dt.ts / 1000));

        case "x":
          return _this.num(dt.ts);

        default:
          return maybeMacro(token);
      }
    };

    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
  };

  _proto.formatDurationFromString = function formatDurationFromString(dur, fmt) {
    var _this2 = this;

    var tokenToField = function tokenToField(token) {
      switch (token[0]) {
        case "S":
          return "millisecond";

        case "s":
          return "second";

        case "m":
          return "minute";

        case "h":
          return "hour";

        case "d":
          return "day";

        case "M":
          return "month";

        case "y":
          return "year";

        default:
          return null;
      }
    },
        tokenToString = function tokenToString(lildur) {
      return function (token) {
        var mapped = tokenToField(token);

        if (mapped) {
          return _this2.num(lildur.get(mapped), token.length);
        } else {
          return token;
        }
      };
    },
        tokens = Formatter.parseFormat(fmt),
        realTokens = tokens.reduce(function (found, _ref) {
      var literal = _ref.literal,
          val = _ref.val;
      return literal ? found : found.concat(val);
    }, []),
        collapsed = dur.shiftTo.apply(dur, realTokens.map(tokenToField).filter(function (t) {
      return t;
    }));

    return stringifyTokens(tokens, tokenToString(collapsed));
  };

  return Formatter;
}();

var Invalid = /*#__PURE__*/function () {
  function Invalid(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }

  var _proto = Invalid.prototype;

  _proto.toMessage = function toMessage() {
    if (this.explanation) {
      return this.reason + ": " + this.explanation;
    } else {
      return this.reason;
    }
  };

  return Invalid;
}();

/**
 * @interface
 */

var Zone = /*#__PURE__*/function () {
  function Zone() {}

  var _proto = Zone.prototype;

  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  _proto.offsetName = function offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  ;

  _proto.formatOffset = function formatOffset(ts, format) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  ;

  _proto.offset = function offset(ts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  ;

  _proto.equals = function equals(otherZone) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  ;

  _createClass(Zone, [{
    key: "type",

    /**
     * The type of zone
     * @abstract
     * @type {string}
     */
    get: function get() {
      throw new ZoneIsAbstractError();
    }
    /**
     * The name of this zone.
     * @abstract
     * @type {string}
     */

  }, {
    key: "name",
    get: function get() {
      throw new ZoneIsAbstractError();
    }
    /**
     * Returns whether the offset is known to be fixed for the whole year.
     * @abstract
     * @type {boolean}
     */

  }, {
    key: "universal",
    get: function get() {
      throw new ZoneIsAbstractError();
    }
  }, {
    key: "isValid",
    get: function get() {
      throw new ZoneIsAbstractError();
    }
  }]);

  return Zone;
}();

var singleton = null;
/**
 * Represents the local zone for this Javascript environment.
 * @implements {Zone}
 */

var LocalZone = /*#__PURE__*/function (_Zone) {
  _inheritsLoose(LocalZone, _Zone);

  function LocalZone() {
    return _Zone.apply(this, arguments) || this;
  }

  var _proto = LocalZone.prototype;

  /** @override **/
  _proto.offsetName = function offsetName(ts, _ref) {
    var format = _ref.format,
        locale = _ref.locale;
    return parseZoneInfo(ts, format, locale);
  }
  /** @override **/
  ;

  _proto.formatOffset = function formatOffset$1(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /** @override **/
  ;

  _proto.offset = function offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }
  /** @override **/
  ;

  _proto.equals = function equals(otherZone) {
    return otherZone.type === "local";
  }
  /** @override **/
  ;

  _createClass(LocalZone, [{
    key: "type",

    /** @override **/
    get: function get() {
      return "local";
    }
    /** @override **/

  }, {
    key: "name",
    get: function get() {
      if (hasIntl()) {
        return new Intl.DateTimeFormat().resolvedOptions().timeZone;
      } else return "local";
    }
    /** @override **/

  }, {
    key: "universal",
    get: function get() {
      return false;
    }
  }, {
    key: "isValid",
    get: function get() {
      return true;
    }
  }], [{
    key: "instance",

    /**
     * Get a singleton instance of the local zone
     * @return {LocalZone}
     */
    get: function get() {
      if (singleton === null) {
        singleton = new LocalZone();
      }

      return singleton;
    }
  }]);

  return LocalZone;
}(Zone);

var matchingRegex = RegExp("^" + ianaRegex.source + "$");
var dtfCache = {};

function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
  }

  return dtfCache[zone];
}

var typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5
};

function hackyOffset(dtf, date) {
  var formatted = dtf.format(date).replace(/\u200E/g, ""),
      parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted),
      fMonth = parsed[1],
      fDay = parsed[2],
      fYear = parsed[3],
      fHour = parsed[4],
      fMinute = parsed[5],
      fSecond = parsed[6];
  return [fYear, fMonth, fDay, fHour, fMinute, fSecond];
}

function partsOffset(dtf, date) {
  var formatted = dtf.formatToParts(date),
      filled = [];

  for (var i = 0; i < formatted.length; i++) {
    var _formatted$i = formatted[i],
        type = _formatted$i.type,
        value = _formatted$i.value,
        pos = typeToPos[type];

    if (!isUndefined(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }

  return filled;
}

var ianaZoneCache = {};
/**
 * A zone identified by an IANA identifier, like America/New_York
 * @implements {Zone}
 */

var IANAZone = /*#__PURE__*/function (_Zone) {
  _inheritsLoose(IANAZone, _Zone);

  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  IANAZone.create = function create(name) {
    if (!ianaZoneCache[name]) {
      ianaZoneCache[name] = new IANAZone(name);
    }

    return ianaZoneCache[name];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  ;

  IANAZone.resetCache = function resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Fantasia/Castle") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @return {boolean}
   */
  ;

  IANAZone.isValidSpecifier = function isValidSpecifier(s) {
    return !!(s && s.match(matchingRegex));
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  ;

  IANAZone.isValidZone = function isValidZone(zone) {
    try {
      new Intl.DateTimeFormat("en-US", {
        timeZone: zone
      }).format();
      return true;
    } catch (e) {
      return false;
    }
  } // Etc/GMT+8 -> -480

  /** @ignore */
  ;

  IANAZone.parseGMTOffset = function parseGMTOffset(specifier) {
    if (specifier) {
      var match = specifier.match(/^Etc\/GMT([+-]\d{1,2})$/i);

      if (match) {
        return -60 * parseInt(match[1]);
      }
    }

    return null;
  };

  function IANAZone(name) {
    var _this;

    _this = _Zone.call(this) || this;
    /** @private **/

    _this.zoneName = name;
    /** @private **/

    _this.valid = IANAZone.isValidZone(name);
    return _this;
  }
  /** @override **/


  var _proto = IANAZone.prototype;

  /** @override **/
  _proto.offsetName = function offsetName(ts, _ref) {
    var format = _ref.format,
        locale = _ref.locale;
    return parseZoneInfo(ts, format, locale, this.name);
  }
  /** @override **/
  ;

  _proto.formatOffset = function formatOffset$1(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /** @override **/
  ;

  _proto.offset = function offset(ts) {
    var date = new Date(ts),
        dtf = makeDTF(this.name),
        _ref2 = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date),
        year = _ref2[0],
        month = _ref2[1],
        day = _ref2[2],
        hour = _ref2[3],
        minute = _ref2[4],
        second = _ref2[5],
        adjustedHour = hour === 24 ? 0 : hour;

    var asUTC = objToLocalTS({
      year: year,
      month: month,
      day: day,
      hour: adjustedHour,
      minute: minute,
      second: second,
      millisecond: 0
    });
    var asTS = +date;
    var over = asTS % 1000;
    asTS -= over >= 0 ? over : 1000 + over;
    return (asUTC - asTS) / (60 * 1000);
  }
  /** @override **/
  ;

  _proto.equals = function equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }
  /** @override **/
  ;

  _createClass(IANAZone, [{
    key: "type",
    get: function get() {
      return "iana";
    }
    /** @override **/

  }, {
    key: "name",
    get: function get() {
      return this.zoneName;
    }
    /** @override **/

  }, {
    key: "universal",
    get: function get() {
      return false;
    }
  }, {
    key: "isValid",
    get: function get() {
      return this.valid;
    }
  }]);

  return IANAZone;
}(Zone);

var singleton$1 = null;
/**
 * A zone with a fixed offset (meaning no DST)
 * @implements {Zone}
 */

var FixedOffsetZone = /*#__PURE__*/function (_Zone) {
  _inheritsLoose(FixedOffsetZone, _Zone);

  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  FixedOffsetZone.instance = function instance(offset) {
    return offset === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  ;

  FixedOffsetZone.parseSpecifier = function parseSpecifier(s) {
    if (s) {
      var r = s.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);

      if (r) {
        return new FixedOffsetZone(signedOffset(r[1], r[2]));
      }
    }

    return null;
  };

  _createClass(FixedOffsetZone, null, [{
    key: "utcInstance",

    /**
     * Get a singleton instance of UTC
     * @return {FixedOffsetZone}
     */
    get: function get() {
      if (singleton$1 === null) {
        singleton$1 = new FixedOffsetZone(0);
      }

      return singleton$1;
    }
  }]);

  function FixedOffsetZone(offset) {
    var _this;

    _this = _Zone.call(this) || this;
    /** @private **/

    _this.fixed = offset;
    return _this;
  }
  /** @override **/


  var _proto = FixedOffsetZone.prototype;

  /** @override **/
  _proto.offsetName = function offsetName() {
    return this.name;
  }
  /** @override **/
  ;

  _proto.formatOffset = function formatOffset$1(ts, format) {
    return formatOffset(this.fixed, format);
  }
  /** @override **/
  ;

  /** @override **/
  _proto.offset = function offset() {
    return this.fixed;
  }
  /** @override **/
  ;

  _proto.equals = function equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }
  /** @override **/
  ;

  _createClass(FixedOffsetZone, [{
    key: "type",
    get: function get() {
      return "fixed";
    }
    /** @override **/

  }, {
    key: "name",
    get: function get() {
      return this.fixed === 0 ? "UTC" : "UTC" + formatOffset(this.fixed, "narrow");
    }
  }, {
    key: "universal",
    get: function get() {
      return true;
    }
  }, {
    key: "isValid",
    get: function get() {
      return true;
    }
  }]);

  return FixedOffsetZone;
}(Zone);

/**
 * A zone that failed to parse. You should never need to instantiate this.
 * @implements {Zone}
 */

var InvalidZone = /*#__PURE__*/function (_Zone) {
  _inheritsLoose(InvalidZone, _Zone);

  function InvalidZone(zoneName) {
    var _this;

    _this = _Zone.call(this) || this;
    /**  @private */

    _this.zoneName = zoneName;
    return _this;
  }
  /** @override **/


  var _proto = InvalidZone.prototype;

  /** @override **/
  _proto.offsetName = function offsetName() {
    return null;
  }
  /** @override **/
  ;

  _proto.formatOffset = function formatOffset() {
    return "";
  }
  /** @override **/
  ;

  _proto.offset = function offset() {
    return NaN;
  }
  /** @override **/
  ;

  _proto.equals = function equals() {
    return false;
  }
  /** @override **/
  ;

  _createClass(InvalidZone, [{
    key: "type",
    get: function get() {
      return "invalid";
    }
    /** @override **/

  }, {
    key: "name",
    get: function get() {
      return this.zoneName;
    }
    /** @override **/

  }, {
    key: "universal",
    get: function get() {
      return false;
    }
  }, {
    key: "isValid",
    get: function get() {
      return false;
    }
  }]);

  return InvalidZone;
}(Zone);

/**
 * @private
 */
function normalizeZone(input, defaultZone) {
  var offset;

  if (isUndefined(input) || input === null) {
    return defaultZone;
  } else if (input instanceof Zone) {
    return input;
  } else if (isString(input)) {
    var lowered = input.toLowerCase();
    if (lowered === "local") return defaultZone;else if (lowered === "utc" || lowered === "gmt") return FixedOffsetZone.utcInstance;else if ((offset = IANAZone.parseGMTOffset(input)) != null) {
      // handle Etc/GMT-4, which V8 chokes on
      return FixedOffsetZone.instance(offset);
    } else if (IANAZone.isValidSpecifier(lowered)) return IANAZone.create(input);else return FixedOffsetZone.parseSpecifier(lowered) || new InvalidZone(input);
  } else if (isNumber(input)) {
    return FixedOffsetZone.instance(input);
  } else if (typeof input === "object" && input.offset && typeof input.offset === "number") {
    // This is dumb, but the instanceof check above doesn't seem to really work
    // so we're duck checking it
    return input;
  } else {
    return new InvalidZone(input);
  }
}

var now = function now() {
  return Date.now();
},
    defaultZone = null,
    // not setting this directly to LocalZone.instance bc loading order issues
defaultLocale = null,
    defaultNumberingSystem = null,
    defaultOutputCalendar = null,
    throwOnInvalid = false;
/**
 * Settings contains static getters and setters that control Luxon's overall behavior. Luxon is a simple library with few options, but the ones it does have live here.
 */


var Settings = /*#__PURE__*/function () {
  function Settings() {}

  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  Settings.resetCaches = function resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
  };

  _createClass(Settings, null, [{
    key: "now",

    /**
     * Get the callback for returning the current timestamp.
     * @type {function}
     */
    get: function get() {
      return now;
    }
    /**
     * Set the callback for returning the current timestamp.
     * The function should return a number, which will be interpreted as an Epoch millisecond count
     * @type {function}
     * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
     * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
     */
    ,
    set: function set(n) {
      now = n;
    }
    /**
     * Get the default time zone to create DateTimes in.
     * @type {string}
     */

  }, {
    key: "defaultZoneName",
    get: function get() {
      return Settings.defaultZone.name;
    }
    /**
     * Set the default time zone to create DateTimes in. Does not affect existing instances.
     * @type {string}
     */
    ,
    set: function set(z) {
      if (!z) {
        defaultZone = null;
      } else {
        defaultZone = normalizeZone(z);
      }
    }
    /**
     * Get the default time zone object to create DateTimes in. Does not affect existing instances.
     * @type {Zone}
     */

  }, {
    key: "defaultZone",
    get: function get() {
      return defaultZone || LocalZone.instance;
    }
    /**
     * Get the default locale to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */

  }, {
    key: "defaultLocale",
    get: function get() {
      return defaultLocale;
    }
    /**
     * Set the default locale to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    ,
    set: function set(locale) {
      defaultLocale = locale;
    }
    /**
     * Get the default numbering system to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */

  }, {
    key: "defaultNumberingSystem",
    get: function get() {
      return defaultNumberingSystem;
    }
    /**
     * Set the default numbering system to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    ,
    set: function set(numberingSystem) {
      defaultNumberingSystem = numberingSystem;
    }
    /**
     * Get the default output calendar to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */

  }, {
    key: "defaultOutputCalendar",
    get: function get() {
      return defaultOutputCalendar;
    }
    /**
     * Set the default output calendar to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    ,
    set: function set(outputCalendar) {
      defaultOutputCalendar = outputCalendar;
    }
    /**
     * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
     * @type {boolean}
     */

  }, {
    key: "throwOnInvalid",
    get: function get() {
      return throwOnInvalid;
    }
    /**
     * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
     * @type {boolean}
     */
    ,
    set: function set(t) {
      throwOnInvalid = t;
    }
  }]);

  return Settings;
}();

var intlDTCache = {};

function getCachedDTF(locString, opts) {
  if (opts === void 0) {
    opts = {};
  }

  var key = JSON.stringify([locString, opts]);
  var dtf = intlDTCache[key];

  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }

  return dtf;
}

var intlNumCache = {};

function getCachedINF(locString, opts) {
  if (opts === void 0) {
    opts = {};
  }

  var key = JSON.stringify([locString, opts]);
  var inf = intlNumCache[key];

  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }

  return inf;
}

var intlRelCache = {};

function getCachedRTF(locString, opts) {
  if (opts === void 0) {
    opts = {};
  }

  var _opts = opts,
      base = _opts.base,
      cacheKeyOpts = _objectWithoutPropertiesLoose(_opts, ["base"]); // exclude `base` from the options


  var key = JSON.stringify([locString, cacheKeyOpts]);
  var inf = intlRelCache[key];

  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }

  return inf;
}

var sysLocaleCache = null;

function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else if (hasIntl()) {
    var computedSys = new Intl.DateTimeFormat().resolvedOptions().locale; // node sometimes defaults to "und". Override that because that is dumb

    sysLocaleCache = !computedSys || computedSys === "und" ? "en-US" : computedSys;
    return sysLocaleCache;
  } else {
    sysLocaleCache = "en-US";
    return sysLocaleCache;
  }
}

function parseLocaleString(localeStr) {
  // I really want to avoid writing a BCP 47 parser
  // see, e.g. https://github.com/wooorm/bcp-47
  // Instead, we'll do this:
  // a) if the string has no -u extensions, just leave it alone
  // b) if it does, use Intl to resolve everything
  // c) if Intl fails, try again without the -u
  var uIndex = localeStr.indexOf("-u-");

  if (uIndex === -1) {
    return [localeStr];
  } else {
    var options;
    var smaller = localeStr.substring(0, uIndex);

    try {
      options = getCachedDTF(localeStr).resolvedOptions();
    } catch (e) {
      options = getCachedDTF(smaller).resolvedOptions();
    }

    var _options = options,
        numberingSystem = _options.numberingSystem,
        calendar = _options.calendar; // return the smaller one so that we can append the calendar and numbering overrides to it

    return [smaller, numberingSystem, calendar];
  }
}

function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (hasIntl()) {
    if (outputCalendar || numberingSystem) {
      localeStr += "-u";

      if (outputCalendar) {
        localeStr += "-ca-" + outputCalendar;
      }

      if (numberingSystem) {
        localeStr += "-nu-" + numberingSystem;
      }

      return localeStr;
    } else {
      return localeStr;
    }
  } else {
    return [];
  }
}

function mapMonths(f) {
  var ms = [];

  for (var i = 1; i <= 12; i++) {
    var dt = DateTime.utc(2016, i, 1);
    ms.push(f(dt));
  }

  return ms;
}

function mapWeekdays(f) {
  var ms = [];

  for (var i = 1; i <= 7; i++) {
    var dt = DateTime.utc(2016, 11, 13 + i);
    ms.push(f(dt));
  }

  return ms;
}

function listStuff(loc, length, defaultOK, englishFn, intlFn) {
  var mode = loc.listingMode(defaultOK);

  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}

function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || hasIntl() && new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
  }
}
/**
 * @private
 */


var PolyNumberFormatter = /*#__PURE__*/function () {
  function PolyNumberFormatter(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;

    if (!forceSimple && hasIntl()) {
      var intlOpts = {
        useGrouping: false
      };
      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }

  var _proto = PolyNumberFormatter.prototype;

  _proto.format = function format(i) {
    if (this.inf) {
      var fixed = this.floor ? Math.floor(i) : i;
      return this.inf.format(fixed);
    } else {
      // to match the browser's numberformatter defaults
      var _fixed = this.floor ? Math.floor(i) : roundTo(i, 3);

      return padStart(_fixed, this.padTo);
    }
  };

  return PolyNumberFormatter;
}();
/**
 * @private
 */


var PolyDateFormatter = /*#__PURE__*/function () {
  function PolyDateFormatter(dt, intl, opts) {
    this.opts = opts;
    this.hasIntl = hasIntl();
    var z;

    if (dt.zone.universal && this.hasIntl) {
      // Chromium doesn't support fixed-offset zones like Etc/GMT+8 in its formatter,
      // See https://bugs.chromium.org/p/chromium/issues/detail?id=364374.
      // So we have to make do. Two cases:
      // 1. The format options tell us to show the zone. We can't do that, so the best
      // we can do is format the date in UTC.
      // 2. The format options don't tell us to show the zone. Then we can adjust them
      // the time and tell the formatter to show it to us in UTC, so that the time is right
      // and the bad zone doesn't show up.
      // We can clean all this up when Chrome fixes this.
      z = "UTC";

      if (opts.timeZoneName) {
        this.dt = dt;
      } else {
        this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1000);
      }
    } else if (dt.zone.type === "local") {
      this.dt = dt;
    } else {
      this.dt = dt;
      z = dt.zone.name;
    }

    if (this.hasIntl) {
      var intlOpts = Object.assign({}, this.opts);

      if (z) {
        intlOpts.timeZone = z;
      }

      this.dtf = getCachedDTF(intl, intlOpts);
    }
  }

  var _proto2 = PolyDateFormatter.prototype;

  _proto2.format = function format() {
    if (this.hasIntl) {
      return this.dtf.format(this.dt.toJSDate());
    } else {
      var tokenFormat = formatString(this.opts),
          loc = Locale.create("en-US");
      return Formatter.create(loc).formatDateTimeFromString(this.dt, tokenFormat);
    }
  };

  _proto2.formatToParts = function formatToParts() {
    if (this.hasIntl && hasFormatToParts()) {
      return this.dtf.formatToParts(this.dt.toJSDate());
    } else {
      // This is kind of a cop out. We actually could do this for English. However, we couldn't do it for intl strings
      // and IMO it's too weird to have an uncanny valley like that
      return [];
    }
  };

  _proto2.resolvedOptions = function resolvedOptions() {
    if (this.hasIntl) {
      return this.dtf.resolvedOptions();
    } else {
      return {
        locale: "en-US",
        numberingSystem: "latn",
        outputCalendar: "gregory"
      };
    }
  };

  return PolyDateFormatter;
}();
/**
 * @private
 */


var PolyRelFormatter = /*#__PURE__*/function () {
  function PolyRelFormatter(intl, isEnglish, opts) {
    this.opts = Object.assign({
      style: "long"
    }, opts);

    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }

  var _proto3 = PolyRelFormatter.prototype;

  _proto3.format = function format(count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
    }
  };

  _proto3.formatToParts = function formatToParts(count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  };

  return PolyRelFormatter;
}();
/**
 * @private
 */


var Locale = /*#__PURE__*/function () {
  Locale.fromOpts = function fromOpts(opts) {
    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
  };

  Locale.create = function create(locale, numberingSystem, outputCalendar, defaultToEN) {
    if (defaultToEN === void 0) {
      defaultToEN = false;
    }

    var specifiedLocale = locale || Settings.defaultLocale,
        // the system locale is useful for human readable strings but annoying for parsing/formatting known formats
    localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale()),
        numberingSystemR = numberingSystem || Settings.defaultNumberingSystem,
        outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
  };

  Locale.resetCache = function resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  };

  Locale.fromObject = function fromObject(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        locale = _ref.locale,
        numberingSystem = _ref.numberingSystem,
        outputCalendar = _ref.outputCalendar;

    return Locale.create(locale, numberingSystem, outputCalendar);
  };

  function Locale(locale, numbering, outputCalendar, specifiedLocale) {
    var _parseLocaleString = parseLocaleString(locale),
        parsedLocale = _parseLocaleString[0],
        parsedNumberingSystem = _parseLocaleString[1],
        parsedOutputCalendar = _parseLocaleString[2];

    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = {
      format: {},
      standalone: {}
    };
    this.monthsCache = {
      format: {},
      standalone: {}
    };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }

  var _proto4 = Locale.prototype;

  _proto4.listingMode = function listingMode(defaultOK) {
    if (defaultOK === void 0) {
      defaultOK = true;
    }

    var intl = hasIntl(),
        hasFTP = intl && hasFormatToParts(),
        isActuallyEn = this.isEnglish(),
        hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");

    if (!hasFTP && !(isActuallyEn && hasNoWeirdness) && !defaultOK) {
      return "error";
    } else if (!hasFTP || isActuallyEn && hasNoWeirdness) {
      return "en";
    } else {
      return "intl";
    }
  };

  _proto4.clone = function clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, alts.defaultToEN || false);
    }
  };

  _proto4.redefaultToEN = function redefaultToEN(alts) {
    if (alts === void 0) {
      alts = {};
    }

    return this.clone(Object.assign({}, alts, {
      defaultToEN: true
    }));
  };

  _proto4.redefaultToSystem = function redefaultToSystem(alts) {
    if (alts === void 0) {
      alts = {};
    }

    return this.clone(Object.assign({}, alts, {
      defaultToEN: false
    }));
  };

  _proto4.months = function months$1(length, format, defaultOK) {
    var _this = this;

    if (format === void 0) {
      format = false;
    }

    if (defaultOK === void 0) {
      defaultOK = true;
    }

    return listStuff(this, length, defaultOK, months, function () {
      var intl = format ? {
        month: length,
        day: "numeric"
      } : {
        month: length
      },
          formatStr = format ? "format" : "standalone";

      if (!_this.monthsCache[formatStr][length]) {
        _this.monthsCache[formatStr][length] = mapMonths(function (dt) {
          return _this.extract(dt, intl, "month");
        });
      }

      return _this.monthsCache[formatStr][length];
    });
  };

  _proto4.weekdays = function weekdays$1(length, format, defaultOK) {
    var _this2 = this;

    if (format === void 0) {
      format = false;
    }

    if (defaultOK === void 0) {
      defaultOK = true;
    }

    return listStuff(this, length, defaultOK, weekdays, function () {
      var intl = format ? {
        weekday: length,
        year: "numeric",
        month: "long",
        day: "numeric"
      } : {
        weekday: length
      },
          formatStr = format ? "format" : "standalone";

      if (!_this2.weekdaysCache[formatStr][length]) {
        _this2.weekdaysCache[formatStr][length] = mapWeekdays(function (dt) {
          return _this2.extract(dt, intl, "weekday");
        });
      }

      return _this2.weekdaysCache[formatStr][length];
    });
  };

  _proto4.meridiems = function meridiems$1(defaultOK) {
    var _this3 = this;

    if (defaultOK === void 0) {
      defaultOK = true;
    }

    return listStuff(this, undefined, defaultOK, function () {
      return meridiems;
    }, function () {
      // In theory there could be aribitrary day periods. We're gonna assume there are exactly two
      // for AM and PM. This is probably wrong, but it's makes parsing way easier.
      if (!_this3.meridiemCache) {
        var intl = {
          hour: "numeric",
          hour12: true
        };
        _this3.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(function (dt) {
          return _this3.extract(dt, intl, "dayperiod");
        });
      }

      return _this3.meridiemCache;
    });
  };

  _proto4.eras = function eras$1(length, defaultOK) {
    var _this4 = this;

    if (defaultOK === void 0) {
      defaultOK = true;
    }

    return listStuff(this, length, defaultOK, eras, function () {
      var intl = {
        era: length
      }; // This is utter bullshit. Different calendars are going to define eras totally differently. What I need is the minimum set of dates
      // to definitely enumerate them.

      if (!_this4.eraCache[length]) {
        _this4.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(function (dt) {
          return _this4.extract(dt, intl, "era");
        });
      }

      return _this4.eraCache[length];
    });
  };

  _proto4.extract = function extract(dt, intlOpts, field) {
    var df = this.dtFormatter(dt, intlOpts),
        results = df.formatToParts(),
        matching = results.find(function (m) {
      return m.type.toLowerCase() === field;
    });
    return matching ? matching.value : null;
  };

  _proto4.numberFormatter = function numberFormatter(opts) {
    if (opts === void 0) {
      opts = {};
    }

    // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)
    // (in contrast, the rest of the condition is used heavily)
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  };

  _proto4.dtFormatter = function dtFormatter(dt, intlOpts) {
    if (intlOpts === void 0) {
      intlOpts = {};
    }

    return new PolyDateFormatter(dt, this.intl, intlOpts);
  };

  _proto4.relFormatter = function relFormatter(opts) {
    if (opts === void 0) {
      opts = {};
    }

    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  };

  _proto4.isEnglish = function isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || hasIntl() && new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  };

  _proto4.equals = function equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  };

  _createClass(Locale, [{
    key: "fastNumbers",
    get: function get() {
      if (this.fastNumbersCached == null) {
        this.fastNumbersCached = supportsFastNumbers(this);
      }

      return this.fastNumbersCached;
    }
  }]);

  return Locale;
}();

/*
 * This file handles parsing for well-specified formats. Here's how it works:
 * Two things go into parsing: a regex to match with and an extractor to take apart the groups in the match.
 * An extractor is just a function that takes a regex match array and returns a { year: ..., month: ... } object
 * parse() does the work of executing the regex and applying the extractor. It takes multiple regex/extractor pairs to try in sequence.
 * Extractors can take a "cursor" representing the offset in the match to look at. This makes it easy to combine extractors.
 * combineExtractors() does the work of combining them, keeping track of the cursor through multiple extractions.
 * Some extractions are super dumb and simpleParse and fromStrings help DRY them.
 */

function combineRegexes() {
  for (var _len = arguments.length, regexes = new Array(_len), _key = 0; _key < _len; _key++) {
    regexes[_key] = arguments[_key];
  }

  var full = regexes.reduce(function (f, r) {
    return f + r.source;
  }, "");
  return RegExp("^" + full + "$");
}

function combineExtractors() {
  for (var _len2 = arguments.length, extractors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    extractors[_key2] = arguments[_key2];
  }

  return function (m) {
    return extractors.reduce(function (_ref, ex) {
      var mergedVals = _ref[0],
          mergedZone = _ref[1],
          cursor = _ref[2];

      var _ex = ex(m, cursor),
          val = _ex[0],
          zone = _ex[1],
          next = _ex[2];

      return [Object.assign(mergedVals, val), mergedZone || zone, next];
    }, [{}, null, 1]).slice(0, 2);
  };
}

function parse(s) {
  if (s == null) {
    return [null, null];
  }

  for (var _len3 = arguments.length, patterns = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    patterns[_key3 - 1] = arguments[_key3];
  }

  for (var _i = 0, _patterns = patterns; _i < _patterns.length; _i++) {
    var _patterns$_i = _patterns[_i],
        regex = _patterns$_i[0],
        extractor = _patterns$_i[1];
    var m = regex.exec(s);

    if (m) {
      return extractor(m);
    }
  }

  return [null, null];
}

function simpleParse() {
  for (var _len4 = arguments.length, keys = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    keys[_key4] = arguments[_key4];
  }

  return function (match, cursor) {
    var ret = {};
    var i;

    for (i = 0; i < keys.length; i++) {
      ret[keys[i]] = parseInteger(match[cursor + i]);
    }

    return [ret, null, cursor + i];
  };
} // ISO and SQL parsing


var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/,
    isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/,
    isoTimeRegex = RegExp("" + isoTimeBaseRegex.source + offsetRegex.source + "?"),
    isoTimeExtensionRegex = RegExp("(?:T" + isoTimeRegex.source + ")?"),
    isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/,
    isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/,
    isoOrdinalRegex = /(\d{4})-?(\d{3})/,
    extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay"),
    extractISOOrdinalData = simpleParse("year", "ordinal"),
    sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/,
    // dumbed-down version of the ISO one
sqlTimeRegex = RegExp(isoTimeBaseRegex.source + " ?(?:" + offsetRegex.source + "|(" + ianaRegex.source + "))?"),
    sqlTimeExtensionRegex = RegExp("(?: " + sqlTimeRegex.source + ")?");

function int(match, pos, fallback) {
  var m = match[pos];
  return isUndefined(m) ? fallback : parseInteger(m);
}

function extractISOYmd(match, cursor) {
  var item = {
    year: int(match, cursor),
    month: int(match, cursor + 1, 1),
    day: int(match, cursor + 2, 1)
  };
  return [item, null, cursor + 3];
}

function extractISOTime(match, cursor) {
  var item = {
    hour: int(match, cursor, 0),
    minute: int(match, cursor + 1, 0),
    second: int(match, cursor + 2, 0),
    millisecond: parseMillis(match[cursor + 3])
  };
  return [item, null, cursor + 4];
}

function extractISOOffset(match, cursor) {
  var local = !match[cursor] && !match[cursor + 1],
      fullOffset = signedOffset(match[cursor + 1], match[cursor + 2]),
      zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}

function extractIANAZone(match, cursor) {
  var zone = match[cursor] ? IANAZone.create(match[cursor]) : null;
  return [{}, zone, cursor + 1];
} // ISO duration parsing


var isoDuration = /^-?P(?:(?:(-?\d{1,9})Y)?(?:(-?\d{1,9})M)?(?:(-?\d{1,9})W)?(?:(-?\d{1,9})D)?(?:T(?:(-?\d{1,9})H)?(?:(-?\d{1,9})M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,9}))?S)?)?)$/;

function extractISODuration(match) {
  var s = match[0],
      yearStr = match[1],
      monthStr = match[2],
      weekStr = match[3],
      dayStr = match[4],
      hourStr = match[5],
      minuteStr = match[6],
      secondStr = match[7],
      millisecondsStr = match[8];
  var hasNegativePrefix = s[0] === "-";

  var maybeNegate = function maybeNegate(num) {
    return num && hasNegativePrefix ? -num : num;
  };

  return [{
    years: maybeNegate(parseInteger(yearStr)),
    months: maybeNegate(parseInteger(monthStr)),
    weeks: maybeNegate(parseInteger(weekStr)),
    days: maybeNegate(parseInteger(dayStr)),
    hours: maybeNegate(parseInteger(hourStr)),
    minutes: maybeNegate(parseInteger(minuteStr)),
    seconds: maybeNegate(parseInteger(secondStr)),
    milliseconds: maybeNegate(parseMillis(millisecondsStr))
  }];
} // These are a little braindead. EDT *should* tell us that we're in, say, America/New_York
// and not just that we're in -240 *right now*. But since I don't think these are used that often
// I'm just going to ignore that


var obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};

function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  var result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr) result.second = parseInteger(secondStr);

  if (weekdayStr) {
    result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }

  return result;
} // RFC 2822/5322


var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;

function extractRFC2822(match) {
  var weekdayStr = match[1],
      dayStr = match[2],
      monthStr = match[3],
      yearStr = match[4],
      hourStr = match[5],
      minuteStr = match[6],
      secondStr = match[7],
      obsOffset = match[8],
      milOffset = match[9],
      offHourStr = match[10],
      offMinuteStr = match[11],
      result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  var offset;

  if (obsOffset) {
    offset = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset = 0;
  } else {
    offset = signedOffset(offHourStr, offMinuteStr);
  }

  return [result, new FixedOffsetZone(offset)];
}

function preprocessRFC2822(s) {
  // Remove comments and folding whitespace and replace multiple-spaces with a single space
  return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
} // http date


var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/,
    rfc850 = /^(Monday|Tuesday|Wedsday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/,
    ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;

function extractRFC1123Or850(match) {
  var weekdayStr = match[1],
      dayStr = match[2],
      monthStr = match[3],
      yearStr = match[4],
      hourStr = match[5],
      minuteStr = match[6],
      secondStr = match[7],
      result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}

function extractASCII(match) {
  var weekdayStr = match[1],
      monthStr = match[2],
      dayStr = match[3],
      hourStr = match[4],
      minuteStr = match[5],
      secondStr = match[6],
      yearStr = match[7],
      result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}

var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
var extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset);
var extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset);
var extractISOOrdinalDataAndTime = combineExtractors(extractISOOrdinalData, extractISOTime);
var extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset);
/**
 * @private
 */

function parseISODate(s) {
  return parse(s, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDataAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]);
}
function parseRFC2822Date(s) {
  return parse(preprocessRFC2822(s), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s) {
  return parse(s, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]);
}
function parseISODuration(s) {
  return parse(s, [isoDuration, extractISODuration]);
}
var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
var extractISOYmdTimeOffsetAndIANAZone = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
var extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
function parseSQL(s) {
  return parse(s, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeOffsetAndIANAZone], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]);
}

var INVALID = "Invalid Duration"; // unit conversion constants

var lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1000
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1000
  },
  hours: {
    minutes: 60,
    seconds: 60 * 60,
    milliseconds: 60 * 60 * 1000
  },
  minutes: {
    seconds: 60,
    milliseconds: 60 * 1000
  },
  seconds: {
    milliseconds: 1000
  }
},
    casualMatrix = Object.assign({
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1000
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1000
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1000
  }
}, lowOrderMatrix),
    daysInYearAccurate = 146097.0 / 400,
    daysInMonthAccurate = 146097.0 / 4800,
    accurateMatrix = Object.assign({
  years: {
    quarters: 4,
    months: 12,
    weeks: daysInYearAccurate / 7,
    days: daysInYearAccurate,
    hours: daysInYearAccurate * 24,
    minutes: daysInYearAccurate * 24 * 60,
    seconds: daysInYearAccurate * 24 * 60 * 60,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000
  },
  quarters: {
    months: 3,
    weeks: daysInYearAccurate / 28,
    days: daysInYearAccurate / 4,
    hours: daysInYearAccurate * 24 / 4,
    minutes: daysInYearAccurate * 24 * 60 / 4,
    seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000 / 4
  },
  months: {
    weeks: daysInMonthAccurate / 7,
    days: daysInMonthAccurate,
    hours: daysInMonthAccurate * 24,
    minutes: daysInMonthAccurate * 24 * 60,
    seconds: daysInMonthAccurate * 24 * 60 * 60,
    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000
  }
}, lowOrderMatrix); // units ordered by size

var orderedUnits = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"];
var reverseUnits = orderedUnits.slice(0).reverse(); // clone really means "create another instance just like this one, but with these changes"

function clone(dur, alts, clear) {
  if (clear === void 0) {
    clear = false;
  }

  // deep merge for vals
  var conf = {
    values: clear ? alts.values : Object.assign({}, dur.values, alts.values || {}),
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy
  };
  return new Duration(conf);
}

function antiTrunc(n) {
  return n < 0 ? Math.floor(n) : Math.ceil(n);
} // NB: mutates parameters


function convert(matrix, fromMap, fromUnit, toMap, toUnit) {
  var conv = matrix[toUnit][fromUnit],
      raw = fromMap[fromUnit] / conv,
      sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]),
      // ok, so this is wild, but see the matrix in the tests
  added = !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
  toMap[toUnit] += added;
  fromMap[fromUnit] -= added * conv;
} // NB: mutates parameters


function normalizeValues(matrix, vals) {
  reverseUnits.reduce(function (previous, current) {
    if (!isUndefined(vals[current])) {
      if (previous) {
        convert(matrix, vals, previous, vals, current);
      }

      return current;
    } else {
      return previous;
    }
  }, null);
}
/**
 * A Duration object represents a period of time, like "2 months" or "1 day, 1 hour". Conceptually, it's just a map of units to their quantities, accompanied by some additional configuration and methods for creating, parsing, interrogating, transforming, and formatting them. They can be used on their own or in conjunction with other Luxon types; for example, you can use {@link DateTime.plus} to add a Duration object to a DateTime, producing another DateTime.
 *
 * Here is a brief overview of commonly used methods and getters in Duration:
 *
 * * **Creation** To create a Duration, use {@link Duration.fromMillis}, {@link Duration.fromObject}, or {@link Duration.fromISO}.
 * * **Unit values** See the {@link Duration.years}, {@link Duration.months}, {@link Duration.weeks}, {@link Duration.days}, {@link Duration.hours}, {@link Duration.minutes}, {@link Duration.seconds}, {@link Duration.milliseconds} accessors.
 * * **Configuration** See  {@link Duration.locale} and {@link Duration.numberingSystem} accessors.
 * * **Transformation** To create new Durations out of old ones use {@link Duration.plus}, {@link Duration.minus}, {@link Duration.normalize}, {@link Duration.set}, {@link Duration.reconfigure}, {@link Duration.shiftTo}, and {@link Duration.negate}.
 * * **Output** To convert the Duration into other representations, see {@link Duration.as}, {@link Duration.toISO}, {@link Duration.toFormat}, and {@link Duration.toJSON}
 *
 * There's are more methods documented below. In addition, for more information on subtler topics like internationalization and validity, see the external documentation.
 */


var Duration = /*#__PURE__*/function () {
  /**
   * @private
   */
  function Duration(config) {
    var accurate = config.conversionAccuracy === "longterm" || false;
    /**
     * @access private
     */

    this.values = config.values;
    /**
     * @access private
     */

    this.loc = config.loc || Locale.create();
    /**
     * @access private
     */

    this.conversionAccuracy = accurate ? "longterm" : "casual";
    /**
     * @access private
     */

    this.invalid = config.invalid || null;
    /**
     * @access private
     */

    this.matrix = accurate ? accurateMatrix : casualMatrix;
    /**
     * @access private
     */

    this.isLuxonDuration = true;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */


  Duration.fromMillis = function fromMillis(count, opts) {
    return Duration.fromObject(Object.assign({
      milliseconds: count
    }, opts));
  }
  /**
   * Create a Duration from a Javascript object with keys like 'years' and 'hours.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {string} [obj.locale='en-US'] - the locale to use
   * @param {string} obj.numberingSystem - the numbering system to use
   * @param {string} [obj.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  ;

  Duration.fromObject = function fromObject(obj) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError("Duration.fromObject: argument expected to be an object, got " + (obj === null ? "null" : typeof obj));
    }

    return new Duration({
      values: normalizeObject(obj, Duration.normalizeUnit, ["locale", "numberingSystem", "conversionAccuracy", "zone" // a bit of debt; it's super inconvenient internally not to be able to blindly pass this
      ]),
      loc: Locale.fromObject(obj),
      conversionAccuracy: obj.conversionAccuracy
    });
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  ;

  Duration.fromISO = function fromISO(text, opts) {
    var _parseISODuration = parseISODuration(text),
        parsed = _parseISODuration[0];

    if (parsed) {
      var obj = Object.assign(parsed, opts);
      return Duration.fromObject(obj);
    } else {
      return Duration.invalid("unparsable", "the input \"" + text + "\" can't be parsed as ISO 8601");
    }
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  ;

  Duration.invalid = function invalid(reason, explanation) {
    if (explanation === void 0) {
      explanation = null;
    }

    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }

    var invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);

    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new Duration({
        invalid: invalid
      });
    }
  }
  /**
   * @private
   */
  ;

  Duration.normalizeUnit = function normalizeUnit(unit) {
    var normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit ? unit.toLowerCase() : unit];
    if (!normalized) throw new InvalidUnitError(unit);
    return normalized;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  ;

  Duration.isDuration = function isDuration(o) {
    return o && o.isLuxonDuration || false;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  ;

  var _proto = Duration.prototype;

  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * The duration will be converted to the set of units in the format string using {@link Duration.shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  _proto.toFormat = function toFormat(fmt, opts) {
    if (opts === void 0) {
      opts = {};
    }

    // reverse-compat since 1.2; we always round down now, never up, and we do it by default
    var fmtOpts = Object.assign({}, opts, {
      floor: opts.round !== false && opts.floor !== false
    });
    return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID;
  }
  /**
   * Returns a Javascript object with this Duration's values.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  ;

  _proto.toObject = function toObject(opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (!this.isValid) return {};
    var base = Object.assign({}, this.values);

    if (opts.includeConfig) {
      base.conversionAccuracy = this.conversionAccuracy;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }

    return base;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  ;

  _proto.toISO = function toISO() {
    // we could use the formatter, but this is an easier way to get the minimum string
    if (!this.isValid) return null;
    var s = "P";
    if (this.years !== 0) s += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0) s += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0) s += this.weeks + "W";
    if (this.days !== 0) s += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) s += "T";
    if (this.hours !== 0) s += this.hours + "H";
    if (this.minutes !== 0) s += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0) // this will handle "floating point madness" by removing extra decimal places
      // https://stackoverflow.com/questions/588004/is-floating-point-math-broken
      s += roundTo(this.seconds + this.milliseconds / 1000, 3) + "S";
    if (s === "P") s += "T0S";
    return s;
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  ;

  _proto.toJSON = function toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  ;

  _proto.toString = function toString() {
    return this.toISO();
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  ;

  _proto.valueOf = function valueOf() {
    return this.as("milliseconds");
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  ;

  _proto.plus = function plus(duration) {
    if (!this.isValid) return this;
    var dur = friendlyDuration(duration),
        result = {};

    for (var _iterator = _createForOfIteratorHelperLoose(orderedUnits), _step; !(_step = _iterator()).done;) {
      var k = _step.value;

      if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
        result[k] = dur.get(k) + this.get(k);
      }
    }

    return clone(this, {
      values: result
    }, true);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  ;

  _proto.minus = function minus(duration) {
    if (!this.isValid) return this;
    var dur = friendlyDuration(duration);
    return this.plus(dur.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnit(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnit((x, u) => u === "hour" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  ;

  _proto.mapUnits = function mapUnits(fn) {
    if (!this.isValid) return this;
    var result = {};

    for (var _i = 0, _Object$keys = Object.keys(this.values); _i < _Object$keys.length; _i++) {
      var k = _Object$keys[_i];
      result[k] = asNumber(fn(this.values[k], k));
    }

    return clone(this, {
      values: result
    }, true);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).years //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).months //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).days //=> 3
   * @return {number}
   */
  ;

  _proto.get = function get(unit) {
    return this[Duration.normalizeUnit(unit)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  ;

  _proto.set = function set(values) {
    if (!this.isValid) return this;
    var mixed = Object.assign(this.values, normalizeObject(values, Duration.normalizeUnit, []));
    return clone(this, {
      values: mixed
    });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  ;

  _proto.reconfigure = function reconfigure(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        locale = _ref.locale,
        numberingSystem = _ref.numberingSystem,
        conversionAccuracy = _ref.conversionAccuracy;

    var loc = this.loc.clone({
      locale: locale,
      numberingSystem: numberingSystem
    }),
        opts = {
      loc: loc
    };

    if (conversionAccuracy) {
      opts.conversionAccuracy = conversionAccuracy;
    }

    return clone(this, opts);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  ;

  _proto.as = function as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @return {Duration}
   */
  ;

  _proto.normalize = function normalize() {
    if (!this.isValid) return this;
    var vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone(this, {
      values: vals
    }, true);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  ;

  _proto.shiftTo = function shiftTo() {
    for (var _len = arguments.length, units = new Array(_len), _key = 0; _key < _len; _key++) {
      units[_key] = arguments[_key];
    }

    if (!this.isValid) return this;

    if (units.length === 0) {
      return this;
    }

    units = units.map(function (u) {
      return Duration.normalizeUnit(u);
    });
    var built = {},
        accumulated = {},
        vals = this.toObject();
    var lastUnit;

    for (var _iterator2 = _createForOfIteratorHelperLoose(orderedUnits), _step2; !(_step2 = _iterator2()).done;) {
      var k = _step2.value;

      if (units.indexOf(k) >= 0) {
        lastUnit = k;
        var own = 0; // anything we haven't boiled down yet should get boiled to this unit

        for (var ak in accumulated) {
          own += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        } // plus anything that's already in this unit


        if (isNumber(vals[k])) {
          own += vals[k];
        }

        var i = Math.trunc(own);
        built[k] = i;
        accumulated[k] = own - i; // we'd like to absorb these fractions in another unit
        // plus anything further down the chain that should be rolled up in to this

        for (var down in vals) {
          if (orderedUnits.indexOf(down) > orderedUnits.indexOf(k)) {
            convert(this.matrix, vals, down, built, k);
          }
        } // otherwise, keep it in the wings to boil it later

      } else if (isNumber(vals[k])) {
        accumulated[k] = vals[k];
      }
    } // anything leftover becomes the decimal for the last unit
    // lastUnit must be defined since units is not empty


    for (var key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }

    return clone(this, {
      values: built
    }, true).normalize();
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  ;

  _proto.negate = function negate() {
    if (!this.isValid) return this;
    var negated = {};

    for (var _i2 = 0, _Object$keys2 = Object.keys(this.values); _i2 < _Object$keys2.length; _i2++) {
      var k = _Object$keys2[_i2];
      negated[k] = -this.values[k];
    }

    return clone(this, {
      values: negated
    }, true);
  }
  /**
   * Get the years.
   * @type {number}
   */
  ;

  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  _proto.equals = function equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }

    if (!this.loc.equals(other.loc)) {
      return false;
    }

    for (var _iterator3 = _createForOfIteratorHelperLoose(orderedUnits), _step3; !(_step3 = _iterator3()).done;) {
      var u = _step3.value;

      if (this.values[u] !== other.values[u]) {
        return false;
      }
    }

    return true;
  };

  _createClass(Duration, [{
    key: "locale",
    get: function get() {
      return this.isValid ? this.loc.locale : null;
    }
    /**
     * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
     *
     * @type {string}
     */

  }, {
    key: "numberingSystem",
    get: function get() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
  }, {
    key: "years",
    get: function get() {
      return this.isValid ? this.values.years || 0 : NaN;
    }
    /**
     * Get the quarters.
     * @type {number}
     */

  }, {
    key: "quarters",
    get: function get() {
      return this.isValid ? this.values.quarters || 0 : NaN;
    }
    /**
     * Get the months.
     * @type {number}
     */

  }, {
    key: "months",
    get: function get() {
      return this.isValid ? this.values.months || 0 : NaN;
    }
    /**
     * Get the weeks
     * @type {number}
     */

  }, {
    key: "weeks",
    get: function get() {
      return this.isValid ? this.values.weeks || 0 : NaN;
    }
    /**
     * Get the days.
     * @type {number}
     */

  }, {
    key: "days",
    get: function get() {
      return this.isValid ? this.values.days || 0 : NaN;
    }
    /**
     * Get the hours.
     * @type {number}
     */

  }, {
    key: "hours",
    get: function get() {
      return this.isValid ? this.values.hours || 0 : NaN;
    }
    /**
     * Get the minutes.
     * @type {number}
     */

  }, {
    key: "minutes",
    get: function get() {
      return this.isValid ? this.values.minutes || 0 : NaN;
    }
    /**
     * Get the seconds.
     * @return {number}
     */

  }, {
    key: "seconds",
    get: function get() {
      return this.isValid ? this.values.seconds || 0 : NaN;
    }
    /**
     * Get the milliseconds.
     * @return {number}
     */

  }, {
    key: "milliseconds",
    get: function get() {
      return this.isValid ? this.values.milliseconds || 0 : NaN;
    }
    /**
     * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
     * on invalid DateTimes or Intervals.
     * @return {boolean}
     */

  }, {
    key: "isValid",
    get: function get() {
      return this.invalid === null;
    }
    /**
     * Returns an error code if this Duration became invalid, or null if the Duration is valid
     * @return {string}
     */

  }, {
    key: "invalidReason",
    get: function get() {
      return this.invalid ? this.invalid.reason : null;
    }
    /**
     * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
     * @type {string}
     */

  }, {
    key: "invalidExplanation",
    get: function get() {
      return this.invalid ? this.invalid.explanation : null;
    }
  }]);

  return Duration;
}();
function friendlyDuration(durationish) {
  if (isNumber(durationish)) {
    return Duration.fromMillis(durationish);
  } else if (Duration.isDuration(durationish)) {
    return durationish;
  } else if (typeof durationish === "object") {
    return Duration.fromObject(durationish);
  } else {
    throw new InvalidArgumentError("Unknown duration argument " + durationish + " of type " + typeof durationish);
  }
}

var INVALID$1 = "Invalid Interval"; // checks if the start is equal to or before the end

function validateStartEnd(start, end) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start) {
    return Interval.invalid("end before start", "The end of an interval must be after its start, but you had start=" + start.toISO() + " and end=" + end.toISO());
  } else {
    return null;
  }
}
/**
 * An Interval object represents a half-open interval of time, where each endpoint is a {@link DateTime}. Conceptually, it's a container for those two endpoints, accompanied by methods for creating, parsing, interrogating, comparing, transforming, and formatting them.
 *
 * Here is a brief overview of the most commonly used methods and getters in Interval:
 *
 * * **Creation** To create an Interval, use {@link fromDateTimes}, {@link after}, {@link before}, or {@link fromISO}.
 * * **Accessors** Use {@link start} and {@link end} to get the start and end.
 * * **Interrogation** To analyze the Interval, use {@link count}, {@link length}, {@link hasSame}, {@link contains}, {@link isAfter}, or {@link isBefore}.
 * * **Transformation** To create other Intervals out of this one, use {@link set}, {@link splitAt}, {@link splitBy}, {@link divideEqually}, {@link merge}, {@link xor}, {@link union}, {@link intersection}, or {@link difference}.
 * * **Comparison** To compare this Interval to another one, use {@link equals}, {@link overlaps}, {@link abutsStart}, {@link abutsEnd}, {@link engulfs}.
 * * **Output** To convert the Interval into other representations, see {@link toString}, {@link toISO}, {@link toISODate}, {@link toISOTime}, {@link toFormat}, and {@link toDuration}.
 */


var Interval = /*#__PURE__*/function () {
  /**
   * @private
   */
  function Interval(config) {
    /**
     * @access private
     */
    this.s = config.start;
    /**
     * @access private
     */

    this.e = config.end;
    /**
     * @access private
     */

    this.invalid = config.invalid || null;
    /**
     * @access private
     */

    this.isLuxonInterval = true;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */


  Interval.invalid = function invalid(reason, explanation) {
    if (explanation === void 0) {
      explanation = null;
    }

    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }

    var invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);

    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new Interval({
        invalid: invalid
      });
    }
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  ;

  Interval.fromDateTimes = function fromDateTimes(start, end) {
    var builtStart = friendlyDateTime(start),
        builtEnd = friendlyDateTime(end);
    var validateError = validateStartEnd(builtStart, builtEnd);

    if (validateError == null) {
      return new Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  ;

  Interval.after = function after(start, duration) {
    var dur = friendlyDuration(duration),
        dt = friendlyDateTime(start);
    return Interval.fromDateTimes(dt, dt.plus(dur));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  ;

  Interval.before = function before(end, duration) {
    var dur = friendlyDuration(duration),
        dt = friendlyDateTime(end);
    return Interval.fromDateTimes(dt.minus(dur), dt);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime.fromISO} and optionally {@link Duration.fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  ;

  Interval.fromISO = function fromISO(text, opts) {
    var _split = (text || "").split("/", 2),
        s = _split[0],
        e = _split[1];

    if (s && e) {
      var start, startIsValid;

      try {
        start = DateTime.fromISO(s, opts);
        startIsValid = start.isValid;
      } catch (e) {
        startIsValid = false;
      }

      var end, endIsValid;

      try {
        end = DateTime.fromISO(e, opts);
        endIsValid = end.isValid;
      } catch (e) {
        endIsValid = false;
      }

      if (startIsValid && endIsValid) {
        return Interval.fromDateTimes(start, end);
      }

      if (startIsValid) {
        var dur = Duration.fromISO(e, opts);

        if (dur.isValid) {
          return Interval.after(start, dur);
        }
      } else if (endIsValid) {
        var _dur = Duration.fromISO(s, opts);

        if (_dur.isValid) {
          return Interval.before(end, _dur);
        }
      }
    }

    return Interval.invalid("unparsable", "the input \"" + text + "\" can't be parsed as ISO 8601");
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  ;

  Interval.isInterval = function isInterval(o) {
    return o && o.isLuxonInterval || false;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  ;

  var _proto = Interval.prototype;

  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  _proto.length = function length(unit) {
    if (unit === void 0) {
      unit = "milliseconds";
    }

    return this.isValid ? this.toDuration.apply(this, [unit]).get(unit) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @return {number}
   */
  ;

  _proto.count = function count(unit) {
    if (unit === void 0) {
      unit = "milliseconds";
    }

    if (!this.isValid) return NaN;
    var start = this.start.startOf(unit),
        end = this.end.startOf(unit);
    return Math.floor(end.diff(start, unit).get(unit)) + 1;
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  ;

  _proto.hasSame = function hasSame(unit) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  ;

  _proto.isEmpty = function isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  ;

  _proto.isAfter = function isAfter(dateTime) {
    if (!this.isValid) return false;
    return this.s > dateTime;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  ;

  _proto.isBefore = function isBefore(dateTime) {
    if (!this.isValid) return false;
    return this.e <= dateTime;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  ;

  _proto.contains = function contains(dateTime) {
    if (!this.isValid) return false;
    return this.s <= dateTime && this.e > dateTime;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  ;

  _proto.set = function set(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        start = _ref.start,
        end = _ref.end;

    if (!this.isValid) return this;
    return Interval.fromDateTimes(start || this.s, end || this.e);
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...[DateTime]} dateTimes - the unit of time to count.
   * @return {[Interval]}
   */
  ;

  _proto.splitAt = function splitAt() {
    var _this = this;

    if (!this.isValid) return [];

    for (var _len = arguments.length, dateTimes = new Array(_len), _key = 0; _key < _len; _key++) {
      dateTimes[_key] = arguments[_key];
    }

    var sorted = dateTimes.map(friendlyDateTime).filter(function (d) {
      return _this.contains(d);
    }).sort(),
        results = [];
    var s = this.s,
        i = 0;

    while (s < this.e) {
      var added = sorted[i] || this.e,
          next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s, next));
      s = next;
      i += 1;
    }

    return results;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {[Interval]}
   */
  ;

  _proto.splitBy = function splitBy(duration) {
    var dur = friendlyDuration(duration);

    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }

    var s = this.s,
        added,
        next;
    var results = [];

    while (s < this.e) {
      added = s.plus(dur);
      next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s, next));
      s = next;
    }

    return results;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {[Interval]}
   */
  ;

  _proto.divideEqually = function divideEqually(numberOfParts) {
    if (!this.isValid) return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  ;

  _proto.overlaps = function overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  ;

  _proto.abutsStart = function abutsStart(other) {
    if (!this.isValid) return false;
    return +this.e === +other.s;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  ;

  _proto.abutsEnd = function abutsEnd(other) {
    if (!this.isValid) return false;
    return +other.e === +this.s;
  }
  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  ;

  _proto.engulfs = function engulfs(other) {
    if (!this.isValid) return false;
    return this.s <= other.s && this.e >= other.e;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  ;

  _proto.equals = function equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }

    return this.s.equals(other.s) && this.e.equals(other.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  ;

  _proto.intersection = function intersection(other) {
    if (!this.isValid) return this;
    var s = this.s > other.s ? this.s : other.s,
        e = this.e < other.e ? this.e : other.e;

    if (s > e) {
      return null;
    } else {
      return Interval.fromDateTimes(s, e);
    }
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  ;

  _proto.union = function union(other) {
    if (!this.isValid) return this;
    var s = this.s < other.s ? this.s : other.s,
        e = this.e > other.e ? this.e : other.e;
    return Interval.fromDateTimes(s, e);
  }
  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {[Interval]} intervals
   * @return {[Interval]}
   */
  ;

  Interval.merge = function merge(intervals) {
    var _intervals$sort$reduc = intervals.sort(function (a, b) {
      return a.s - b.s;
    }).reduce(function (_ref2, item) {
      var sofar = _ref2[0],
          current = _ref2[1];

      if (!current) {
        return [sofar, item];
      } else if (current.overlaps(item) || current.abutsStart(item)) {
        return [sofar, current.union(item)];
      } else {
        return [sofar.concat([current]), item];
      }
    }, [[], null]),
        found = _intervals$sort$reduc[0],
        final = _intervals$sort$reduc[1];

    if (final) {
      found.push(final);
    }

    return found;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {[Interval]} intervals
   * @return {[Interval]}
   */
  ;

  Interval.xor = function xor(intervals) {
    var _Array$prototype;

    var start = null,
        currentCount = 0;

    var results = [],
        ends = intervals.map(function (i) {
      return [{
        time: i.s,
        type: "s"
      }, {
        time: i.e,
        type: "e"
      }];
    }),
        flattened = (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, ends),
        arr = flattened.sort(function (a, b) {
      return a.time - b.time;
    });

    for (var _iterator = _createForOfIteratorHelperLoose(arr), _step; !(_step = _iterator()).done;) {
      var i = _step.value;
      currentCount += i.type === "s" ? 1 : -1;

      if (currentCount === 1) {
        start = i.time;
      } else {
        if (start && +start !== +i.time) {
          results.push(Interval.fromDateTimes(start, i.time));
        }

        start = null;
      }
    }

    return Interval.merge(results);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {[Interval]}
   */
  ;

  _proto.difference = function difference() {
    var _this2 = this;

    for (var _len2 = arguments.length, intervals = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      intervals[_key2] = arguments[_key2];
    }

    return Interval.xor([this].concat(intervals)).map(function (i) {
      return _this2.intersection(i);
    }).filter(function (i) {
      return i && !i.isEmpty();
    });
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  ;

  _proto.toString = function toString() {
    if (!this.isValid) return INVALID$1;
    return "[" + this.s.toISO() + " \u2013 " + this.e.toISO() + ")";
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime.toISO}
   * @return {string}
   */
  ;

  _proto.toISO = function toISO(opts) {
    if (!this.isValid) return INVALID$1;
    return this.s.toISO(opts) + "/" + this.e.toISO(opts);
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  ;

  _proto.toISODate = function toISODate() {
    if (!this.isValid) return INVALID$1;
    return this.s.toISODate() + "/" + this.e.toISODate();
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime.toISO}
   * @return {string}
   */
  ;

  _proto.toISOTime = function toISOTime(opts) {
    if (!this.isValid) return INVALID$1;
    return this.s.toISOTime(opts) + "/" + this.e.toISOTime(opts);
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format string.
   * @param {string} dateFormat - the format string. This string formats the start and end time. See {@link DateTime.toFormat} for details.
   * @param {Object} opts - options
   * @param {string} [opts.separator =  ' â€“ '] - a separator to place between the start and end representations
   * @return {string}
   */
  ;

  _proto.toFormat = function toFormat(dateFormat, _temp2) {
    var _ref3 = _temp2 === void 0 ? {} : _temp2,
        _ref3$separator = _ref3.separator,
        separator = _ref3$separator === void 0 ? " â€“ " : _ref3$separator;

    if (!this.isValid) return INVALID$1;
    return "" + this.s.toFormat(dateFormat) + separator + this.e.toFormat(dateFormat);
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  ;

  _proto.toDuration = function toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }

    return this.e.diff(this.s, unit, opts);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  ;

  _proto.mapEndpoints = function mapEndpoints(mapFn) {
    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  };

  _createClass(Interval, [{
    key: "start",
    get: function get() {
      return this.isValid ? this.s : null;
    }
    /**
     * Returns the end of the Interval
     * @type {DateTime}
     */

  }, {
    key: "end",
    get: function get() {
      return this.isValid ? this.e : null;
    }
    /**
     * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
     * @type {boolean}
     */

  }, {
    key: "isValid",
    get: function get() {
      return this.invalidReason === null;
    }
    /**
     * Returns an error code if this Interval is invalid, or null if the Interval is valid
     * @type {string}
     */

  }, {
    key: "invalidReason",
    get: function get() {
      return this.invalid ? this.invalid.reason : null;
    }
    /**
     * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
     * @type {string}
     */

  }, {
    key: "invalidExplanation",
    get: function get() {
      return this.invalid ? this.invalid.explanation : null;
    }
  }]);

  return Interval;
}();

/**
 * The Info class contains static methods for retrieving general time and date related data. For example, it has methods for finding out if a time zone has a DST, for listing the months in any supported locale, and for discovering which of Luxon features are available in the current environment.
 */

var Info = /*#__PURE__*/function () {
  function Info() {}

  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  Info.hasDST = function hasDST(zone) {
    if (zone === void 0) {
      zone = Settings.defaultZone;
    }

    var proto = DateTime.local().setZone(zone).set({
      month: 12
    });
    return !zone.universal && proto.offset !== proto.set({
      month: 6
    }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  ;

  Info.isValidIANAZone = function isValidIANAZone(zone) {
    return IANAZone.isValidSpecifier(zone) && IANAZone.isValidZone(zone);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone.isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  ;

  Info.normalizeZone = function normalizeZone$1(input) {
    return normalizeZone(input, Settings.defaultZone);
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> 'Ù¡'
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'RabiÊ» I'
   * @return {[string]}
   */
  ;

  Info.months = function months(length, _temp) {
    if (length === void 0) {
      length = "long";
    }

    var _ref = _temp === void 0 ? {} : _temp,
        _ref$locale = _ref.locale,
        locale = _ref$locale === void 0 ? null : _ref$locale,
        _ref$numberingSystem = _ref.numberingSystem,
        numberingSystem = _ref$numberingSystem === void 0 ? null : _ref$numberingSystem,
        _ref$outputCalendar = _ref.outputCalendar,
        outputCalendar = _ref$outputCalendar === void 0 ? "gregory" : _ref$outputCalendar;

    return Locale.create(locale, numberingSystem, outputCalendar).months(length);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {[string]}
   */
  ;

  Info.monthsFormat = function monthsFormat(length, _temp2) {
    if (length === void 0) {
      length = "long";
    }

    var _ref2 = _temp2 === void 0 ? {} : _temp2,
        _ref2$locale = _ref2.locale,
        locale = _ref2$locale === void 0 ? null : _ref2$locale,
        _ref2$numberingSystem = _ref2.numberingSystem,
        numberingSystem = _ref2$numberingSystem === void 0 ? null : _ref2$numberingSystem,
        _ref2$outputCalendar = _ref2.outputCalendar,
        outputCalendar = _ref2$outputCalendar === void 0 ? "gregory" : _ref2$outputCalendar;

    return Locale.create(locale, numberingSystem, outputCalendar).months(length, true);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'Ø§Ù„Ø§Ø«Ù†ÙŠÙ†'
   * @return {[string]}
   */
  ;

  Info.weekdays = function weekdays(length, _temp3) {
    if (length === void 0) {
      length = "long";
    }

    var _ref3 = _temp3 === void 0 ? {} : _temp3,
        _ref3$locale = _ref3.locale,
        locale = _ref3$locale === void 0 ? null : _ref3$locale,
        _ref3$numberingSystem = _ref3.numberingSystem,
        numberingSystem = _ref3$numberingSystem === void 0 ? null : _ref3$numberingSystem;

    return Locale.create(locale, numberingSystem, null).weekdays(length);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link weekdays}
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @return {[string]}
   */
  ;

  Info.weekdaysFormat = function weekdaysFormat(length, _temp4) {
    if (length === void 0) {
      length = "long";
    }

    var _ref4 = _temp4 === void 0 ? {} : _temp4,
        _ref4$locale = _ref4.locale,
        locale = _ref4$locale === void 0 ? null : _ref4$locale,
        _ref4$numberingSystem = _ref4.numberingSystem,
        numberingSystem = _ref4$numberingSystem === void 0 ? null : _ref4$numberingSystem;

    return Locale.create(locale, numberingSystem, null).weekdays(length, true);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ 'á€”á€¶á€”á€€á€º', 'á€Šá€”á€±' ]
   * @return {[string]}
   */
  ;

  Info.meridiems = function meridiems(_temp5) {
    var _ref5 = _temp5 === void 0 ? {} : _temp5,
        _ref5$locale = _ref5.locale,
        locale = _ref5$locale === void 0 ? null : _ref5$locale;

    return Locale.create(locale).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant JÃ©sus-Christ', 'aprÃ¨s JÃ©sus-Christ' ]
   * @return {[string]}
   */
  ;

  Info.eras = function eras(length, _temp6) {
    if (length === void 0) {
      length = "short";
    }

    var _ref6 = _temp6 === void 0 ? {} : _temp6,
        _ref6$locale = _ref6.locale,
        locale = _ref6$locale === void 0 ? null : _ref6$locale;

    return Locale.create(locale, null, "gregory").eras(length);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, timezone support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `zones`: whether this environment supports IANA timezones
   * * `intlTokens`: whether this environment supports internationalized token-based formatting/parsing
   * * `intl`: whether this environment supports general internationalization
   * * `relative`: whether this environment supports relative time formatting
   * @example Info.features() //=> { intl: true, intlTokens: false, zones: true, relative: false }
   * @return {Object}
   */
  ;

  Info.features = function features() {
    var intl = false,
        intlTokens = false,
        zones = false,
        relative = false;

    if (hasIntl()) {
      intl = true;
      intlTokens = hasFormatToParts();
      relative = hasRelative();

      try {
        zones = new Intl.DateTimeFormat("en", {
          timeZone: "America/New_York"
        }).resolvedOptions().timeZone === "America/New_York";
      } catch (e) {
        zones = false;
      }
    }

    return {
      intl: intl,
      intlTokens: intlTokens,
      zones: zones,
      relative: relative
    };
  };

  return Info;
}();

function dayDiff(earlier, later) {
  var utcDayStart = function utcDayStart(dt) {
    return dt.toUTC(0, {
      keepLocalTime: true
    }).startOf("day").valueOf();
  },
      ms = utcDayStart(later) - utcDayStart(earlier);

  return Math.floor(Duration.fromMillis(ms).as("days"));
}

function highOrderDiffs(cursor, later, units) {
  var differs = [["years", function (a, b) {
    return b.year - a.year;
  }], ["months", function (a, b) {
    return b.month - a.month + (b.year - a.year) * 12;
  }], ["weeks", function (a, b) {
    var days = dayDiff(a, b);
    return (days - days % 7) / 7;
  }], ["days", dayDiff]];
  var results = {};
  var lowestOrder, highWater;

  for (var _i = 0, _differs = differs; _i < _differs.length; _i++) {
    var _differs$_i = _differs[_i],
        unit = _differs$_i[0],
        differ = _differs$_i[1];

    if (units.indexOf(unit) >= 0) {
      var _cursor$plus;

      lowestOrder = unit;
      var delta = differ(cursor, later);
      highWater = cursor.plus((_cursor$plus = {}, _cursor$plus[unit] = delta, _cursor$plus));

      if (highWater > later) {
        var _cursor$plus2;

        cursor = cursor.plus((_cursor$plus2 = {}, _cursor$plus2[unit] = delta - 1, _cursor$plus2));
        delta -= 1;
      } else {
        cursor = highWater;
      }

      results[unit] = delta;
    }
  }

  return [cursor, results, highWater, lowestOrder];
}

function _diff (earlier, later, units, opts) {
  var _highOrderDiffs = highOrderDiffs(earlier, later, units),
      cursor = _highOrderDiffs[0],
      results = _highOrderDiffs[1],
      highWater = _highOrderDiffs[2],
      lowestOrder = _highOrderDiffs[3];

  var remainingMillis = later - cursor;
  var lowerOrderUnits = units.filter(function (u) {
    return ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0;
  });

  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      var _cursor$plus3;

      highWater = cursor.plus((_cursor$plus3 = {}, _cursor$plus3[lowestOrder] = 1, _cursor$plus3));
    }

    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }

  var duration = Duration.fromObject(Object.assign(results, opts));

  if (lowerOrderUnits.length > 0) {
    var _Duration$fromMillis;

    return (_Duration$fromMillis = Duration.fromMillis(remainingMillis, opts)).shiftTo.apply(_Duration$fromMillis, lowerOrderUnits).plus(duration);
  } else {
    return duration;
  }
}

var numberingSystems = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[ã€‡|ä¸€|äºŒ|ä¸‰|å››|äº”|å…­|ä¸ƒ|å…«|ä¹]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d"
};
var numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
}; // eslint-disable-next-line

var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
  var value = parseInt(str, 10);

  if (isNaN(value)) {
    value = "";

    for (var i = 0; i < str.length; i++) {
      var code = str.charCodeAt(i);

      if (str[i].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i]);
      } else {
        for (var key in numberingSystemsUTF16) {
          var _numberingSystemsUTF = numberingSystemsUTF16[key],
              min = _numberingSystemsUTF[0],
              max = _numberingSystemsUTF[1];

          if (code >= min && code <= max) {
            value += code - min;
          }
        }
      }
    }

    return parseInt(value, 10);
  } else {
    return value;
  }
}
function digitRegex(_ref, append) {
  var numberingSystem = _ref.numberingSystem;

  if (append === void 0) {
    append = "";
  }

  return new RegExp("" + numberingSystems[numberingSystem || "latn"] + append);
}

var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";

function intUnit(regex, post) {
  if (post === void 0) {
    post = function post(i) {
      return i;
    };
  }

  return {
    regex: regex,
    deser: function deser(_ref) {
      var s = _ref[0];
      return post(parseDigits(s));
    }
  };
}

var NBSP = String.fromCharCode(160);
var spaceOrNBSP = "( |" + NBSP + ")";
var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");

function fixListRegex(s) {
  // make dots optional and also make them literal
  // make space and non breakable space characters interchangeable
  return s.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}

function stripInsensitivities(s) {
  return s.replace(/\./g, "") // ignore dots that were made optional
  .replace(spaceOrNBSPRegExp, " ") // interchange space and nbsp
  .toLowerCase();
}

function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: function deser(_ref2) {
        var s = _ref2[0];
        return strings.findIndex(function (i) {
          return stripInsensitivities(s) === stripInsensitivities(i);
        }) + startIndex;
      }
    };
  }
}

function offset(regex, groups) {
  return {
    regex: regex,
    deser: function deser(_ref3) {
      var h = _ref3[1],
          m = _ref3[2];
      return signedOffset(h, m);
    },
    groups: groups
  };
}

function simple(regex) {
  return {
    regex: regex,
    deser: function deser(_ref4) {
      var s = _ref4[0];
      return s;
    }
  };
}

function escapeToken(value) {
  // eslint-disable-next-line no-useless-escape
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}

function unitForToken(token, loc) {
  var one = digitRegex(loc),
      two = digitRegex(loc, "{2}"),
      three = digitRegex(loc, "{3}"),
      four = digitRegex(loc, "{4}"),
      six = digitRegex(loc, "{6}"),
      oneOrTwo = digitRegex(loc, "{1,2}"),
      oneToThree = digitRegex(loc, "{1,3}"),
      oneToSix = digitRegex(loc, "{1,6}"),
      oneToNine = digitRegex(loc, "{1,9}"),
      twoToFour = digitRegex(loc, "{2,4}"),
      fourToSix = digitRegex(loc, "{4,6}"),
      literal = function literal(t) {
    return {
      regex: RegExp(escapeToken(t.val)),
      deser: function deser(_ref5) {
        var s = _ref5[0];
        return s;
      },
      literal: true
    };
  },
      unitate = function unitate(t) {
    if (token.literal) {
      return literal(t);
    }

    switch (t.val) {
      // era
      case "G":
        return oneOf(loc.eras("short", false), 0);

      case "GG":
        return oneOf(loc.eras("long", false), 0);
      // years

      case "y":
        return intUnit(oneToSix);

      case "yy":
        return intUnit(twoToFour, untruncateYear);

      case "yyyy":
        return intUnit(four);

      case "yyyyy":
        return intUnit(fourToSix);

      case "yyyyyy":
        return intUnit(six);
      // months

      case "M":
        return intUnit(oneOrTwo);

      case "MM":
        return intUnit(two);

      case "MMM":
        return oneOf(loc.months("short", true, false), 1);

      case "MMMM":
        return oneOf(loc.months("long", true, false), 1);

      case "L":
        return intUnit(oneOrTwo);

      case "LL":
        return intUnit(two);

      case "LLL":
        return oneOf(loc.months("short", false, false), 1);

      case "LLLL":
        return oneOf(loc.months("long", false, false), 1);
      // dates

      case "d":
        return intUnit(oneOrTwo);

      case "dd":
        return intUnit(two);
      // ordinals

      case "o":
        return intUnit(oneToThree);

      case "ooo":
        return intUnit(three);
      // time

      case "HH":
        return intUnit(two);

      case "H":
        return intUnit(oneOrTwo);

      case "hh":
        return intUnit(two);

      case "h":
        return intUnit(oneOrTwo);

      case "mm":
        return intUnit(two);

      case "m":
        return intUnit(oneOrTwo);

      case "q":
        return intUnit(oneOrTwo);

      case "qq":
        return intUnit(two);

      case "s":
        return intUnit(oneOrTwo);

      case "ss":
        return intUnit(two);

      case "S":
        return intUnit(oneToThree);

      case "SSS":
        return intUnit(three);

      case "u":
        return simple(oneToNine);
      // meridiem

      case "a":
        return oneOf(loc.meridiems(), 0);
      // weekYear (k)

      case "kkkk":
        return intUnit(four);

      case "kk":
        return intUnit(twoToFour, untruncateYear);
      // weekNumber (W)

      case "W":
        return intUnit(oneOrTwo);

      case "WW":
        return intUnit(two);
      // weekdays

      case "E":
      case "c":
        return intUnit(one);

      case "EEE":
        return oneOf(loc.weekdays("short", false, false), 1);

      case "EEEE":
        return oneOf(loc.weekdays("long", false, false), 1);

      case "ccc":
        return oneOf(loc.weekdays("short", true, false), 1);

      case "cccc":
        return oneOf(loc.weekdays("long", true, false), 1);
      // offset/zone

      case "Z":
      case "ZZ":
        return offset(new RegExp("([+-]" + oneOrTwo.source + ")(?::(" + two.source + "))?"), 2);

      case "ZZZ":
        return offset(new RegExp("([+-]" + oneOrTwo.source + ")(" + two.source + ")?"), 2);
      // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing
      // because we don't have any way to figure out what they are

      case "z":
        return simple(/[a-z_+-/]{1,256}?/i);

      default:
        return literal(t);
    }
  };

  var unit = unitate(token) || {
    invalidReason: MISSING_FTP
  };
  unit.token = token;
  return unit;
}

var partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour: {
    numeric: "h",
    "2-digit": "hh"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  }
};

function tokenForPart(part, locale, formatOpts) {
  var type = part.type,
      value = part.value;

  if (type === "literal") {
    return {
      literal: true,
      val: value
    };
  }

  var style = formatOpts[type];
  var val = partTypeStyleToTokenVal[type];

  if (typeof val === "object") {
    val = val[style];
  }

  if (val) {
    return {
      literal: false,
      val: val
    };
  }

  return undefined;
}

function buildRegex(units) {
  var re = units.map(function (u) {
    return u.regex;
  }).reduce(function (f, r) {
    return f + "(" + r.source + ")";
  }, "");
  return ["^" + re + "$", units];
}

function match(input, regex, handlers) {
  var matches = input.match(regex);

  if (matches) {
    var all = {};
    var matchIndex = 1;

    for (var i in handlers) {
      if (hasOwnProperty(handlers, i)) {
        var h = handlers[i],
            groups = h.groups ? h.groups + 1 : 1;

        if (!h.literal && h.token) {
          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
        }

        matchIndex += groups;
      }
    }

    return [matches, all];
  } else {
    return [matches, {}];
  }
}

function dateTimeFromMatches(matches) {
  var toField = function toField(token) {
    switch (token) {
      case "S":
        return "millisecond";

      case "s":
        return "second";

      case "m":
        return "minute";

      case "h":
      case "H":
        return "hour";

      case "d":
        return "day";

      case "o":
        return "ordinal";

      case "L":
      case "M":
        return "month";

      case "y":
        return "year";

      case "E":
      case "c":
        return "weekday";

      case "W":
        return "weekNumber";

      case "k":
        return "weekYear";

      case "q":
        return "quarter";

      default:
        return null;
    }
  };

  var zone;

  if (!isUndefined(matches.Z)) {
    zone = new FixedOffsetZone(matches.Z);
  } else if (!isUndefined(matches.z)) {
    zone = IANAZone.create(matches.z);
  } else {
    zone = null;
  }

  if (!isUndefined(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }

  if (!isUndefined(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }

  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }

  if (!isUndefined(matches.u)) {
    matches.S = parseMillis(matches.u);
  }

  var vals = Object.keys(matches).reduce(function (r, k) {
    var f = toField(k);

    if (f) {
      r[f] = matches[k];
    }

    return r;
  }, {});
  return [vals, zone];
}

var dummyDateTimeCache = null;

function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }

  return dummyDateTimeCache;
}

function maybeExpandMacroToken(token, locale) {
  if (token.literal) {
    return token;
  }

  var formatOpts = Formatter.macroTokenToFormatOpts(token.val);

  if (!formatOpts) {
    return token;
  }

  var formatter = Formatter.create(locale, formatOpts);
  var parts = formatter.formatDateTimeParts(getDummyDateTime());
  var tokens = parts.map(function (p) {
    return tokenForPart(p, locale, formatOpts);
  });

  if (tokens.includes(undefined)) {
    return token;
  }

  return tokens;
}

function expandMacroTokens(tokens, locale) {
  var _Array$prototype;

  return (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, tokens.map(function (t) {
    return maybeExpandMacroToken(t, locale);
  }));
}
/**
 * @private
 */


function explainFromTokens(locale, input, format) {
  var tokens = expandMacroTokens(Formatter.parseFormat(format), locale),
      units = tokens.map(function (t) {
    return unitForToken(t, locale);
  }),
      disqualifyingUnit = units.find(function (t) {
    return t.invalidReason;
  });

  if (disqualifyingUnit) {
    return {
      input: input,
      tokens: tokens,
      invalidReason: disqualifyingUnit.invalidReason
    };
  } else {
    var _buildRegex = buildRegex(units),
        regexString = _buildRegex[0],
        handlers = _buildRegex[1],
        regex = RegExp(regexString, "i"),
        _match = match(input, regex, handlers),
        rawMatches = _match[0],
        matches = _match[1],
        _ref6 = matches ? dateTimeFromMatches(matches) : [null, null],
        result = _ref6[0],
        zone = _ref6[1];

    if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
      throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
    }

    return {
      input: input,
      tokens: tokens,
      regex: regex,
      rawMatches: rawMatches,
      matches: matches,
      result: result,
      zone: zone
    };
  }
}
function parseFromTokens(locale, input, format) {
  var _explainFromTokens = explainFromTokens(locale, input, format),
      result = _explainFromTokens.result,
      zone = _explainFromTokens.zone,
      invalidReason = _explainFromTokens.invalidReason;

  return [result, zone, invalidReason];
}

var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
    leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];

function unitOutOfRange(unit, value) {
  return new Invalid("unit out of range", "you specified " + value + " (of type " + typeof value + ") as a " + unit + ", which is invalid");
}

function dayOfWeek(year, month, day) {
  var js = new Date(Date.UTC(year, month - 1, day)).getUTCDay();
  return js === 0 ? 7 : js;
}

function computeOrdinal(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}

function uncomputeOrdinal(year, ordinal) {
  var table = isLeapYear(year) ? leapLadder : nonLeapLadder,
      month0 = table.findIndex(function (i) {
    return i < ordinal;
  }),
      day = ordinal - table[month0];
  return {
    month: month0 + 1,
    day: day
  };
}
/**
 * @private
 */


function gregorianToWeek(gregObj) {
  var year = gregObj.year,
      month = gregObj.month,
      day = gregObj.day,
      ordinal = computeOrdinal(year, month, day),
      weekday = dayOfWeek(year, month, day);
  var weekNumber = Math.floor((ordinal - weekday + 10) / 7),
      weekYear;

  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear);
  } else if (weekNumber > weeksInWeekYear(year)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }

  return Object.assign({
    weekYear: weekYear,
    weekNumber: weekNumber,
    weekday: weekday
  }, timeObject(gregObj));
}
function weekToGregorian(weekData) {
  var weekYear = weekData.weekYear,
      weekNumber = weekData.weekNumber,
      weekday = weekData.weekday,
      weekdayOfJan4 = dayOfWeek(weekYear, 1, 4),
      yearInDays = daysInYear(weekYear);
  var ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3,
      year;

  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += daysInYear(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }

  var _uncomputeOrdinal = uncomputeOrdinal(year, ordinal),
      month = _uncomputeOrdinal.month,
      day = _uncomputeOrdinal.day;

  return Object.assign({
    year: year,
    month: month,
    day: day
  }, timeObject(weekData));
}
function gregorianToOrdinal(gregData) {
  var year = gregData.year,
      month = gregData.month,
      day = gregData.day,
      ordinal = computeOrdinal(year, month, day);
  return Object.assign({
    year: year,
    ordinal: ordinal
  }, timeObject(gregData));
}
function ordinalToGregorian(ordinalData) {
  var year = ordinalData.year,
      ordinal = ordinalData.ordinal,
      _uncomputeOrdinal2 = uncomputeOrdinal(year, ordinal),
      month = _uncomputeOrdinal2.month,
      day = _uncomputeOrdinal2.day;

  return Object.assign({
    year: year,
    month: month,
    day: day
  }, timeObject(ordinalData));
}
function hasInvalidWeekData(obj) {
  var validYear = isInteger(obj.weekYear),
      validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)),
      validWeekday = integerBetween(obj.weekday, 1, 7);

  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.week);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else return false;
}
function hasInvalidOrdinalData(obj) {
  var validYear = isInteger(obj.year),
      validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));

  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else return false;
}
function hasInvalidGregorianData(obj) {
  var validYear = isInteger(obj.year),
      validMonth = integerBetween(obj.month, 1, 12),
      validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));

  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else return false;
}
function hasInvalidTimeData(obj) {
  var hour = obj.hour,
      minute = obj.minute,
      second = obj.second,
      millisecond = obj.millisecond;
  var validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0,
      validMinute = integerBetween(minute, 0, 59),
      validSecond = integerBetween(second, 0, 59),
      validMillisecond = integerBetween(millisecond, 0, 999);

  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else return false;
}

var INVALID$2 = "Invalid DateTime";
var MAX_DATE = 8.64e15;

function unsupportedZone(zone) {
  return new Invalid("unsupported zone", "the zone \"" + zone.name + "\" is not supported");
} // we cache week data on the DT object and this intermediates the cache


function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }

  return dt.weekData;
} // clone really means, "make a new object with these modifications". all "setters" really use this
// to create a new object while only changing some of the properties


function clone$1(inst, alts) {
  var current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime(Object.assign({}, current, alts, {
    old: current
  }));
} // find the right offset a given local time. The o input is our guess, which determines which
// offset we'll pick in ambiguous cases (e.g. there are two 3 AMs b/c Fallback DST)


function fixOffset(localTS, o, tz) {
  // Our UTC time is just a guess because our offset is just a guess
  var utcGuess = localTS - o * 60 * 1000; // Test whether the zone matches the offset for this ts

  var o2 = tz.offset(utcGuess); // If so, offset didn't change and we're done

  if (o === o2) {
    return [utcGuess, o];
  } // If not, change the ts by the difference in the offset


  utcGuess -= (o2 - o) * 60 * 1000; // If that gives us the local time we want, we're done

  var o3 = tz.offset(utcGuess);

  if (o2 === o3) {
    return [utcGuess, o2];
  } // If it's different, we're in a hole time. The offset has changed, but the we don't adjust the time


  return [localTS - Math.min(o2, o3) * 60 * 1000, Math.max(o2, o3)];
} // convert an epoch timestamp into a calendar object with the given offset


function tsToObj(ts, offset) {
  ts += offset * 60 * 1000;
  var d = new Date(ts);
  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth() + 1,
    day: d.getUTCDate(),
    hour: d.getUTCHours(),
    minute: d.getUTCMinutes(),
    second: d.getUTCSeconds(),
    millisecond: d.getUTCMilliseconds()
  };
} // convert a calendar object to a epoch timestamp


function objToTS(obj, offset, zone) {
  return fixOffset(objToLocalTS(obj), offset, zone);
} // create a new DT instance by adding a duration, adjusting for DSTs


function adjustTime(inst, dur) {
  var oPre = inst.o,
      year = inst.c.year + Math.trunc(dur.years),
      month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3,
      c = Object.assign({}, inst.c, {
    year: year,
    month: month,
    day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
  }),
      millisToAdd = Duration.fromObject({
    years: dur.years - Math.trunc(dur.years),
    quarters: dur.quarters - Math.trunc(dur.quarters),
    months: dur.months - Math.trunc(dur.months),
    weeks: dur.weeks - Math.trunc(dur.weeks),
    days: dur.days - Math.trunc(dur.days),
    hours: dur.hours,
    minutes: dur.minutes,
    seconds: dur.seconds,
    milliseconds: dur.milliseconds
  }).as("milliseconds"),
      localTS = objToLocalTS(c);

  var _fixOffset = fixOffset(localTS, oPre, inst.zone),
      ts = _fixOffset[0],
      o = _fixOffset[1];

  if (millisToAdd !== 0) {
    ts += millisToAdd; // that could have changed the offset by going over a DST, but we want to keep the ts the same

    o = inst.zone.offset(ts);
  }

  return {
    ts: ts,
    o: o
  };
} // helper useful in turning the results of parsing into real dates
// by handling the zone options


function parseDataToDateTime(parsed, parsedZone, opts, format, text) {
  var setZone = opts.setZone,
      zone = opts.zone;

  if (parsed && Object.keys(parsed).length !== 0) {
    var interpretationZone = parsedZone || zone,
        inst = DateTime.fromObject(Object.assign(parsed, opts, {
      zone: interpretationZone,
      // setZone is a valid option in the calling methods, but not in fromObject
      setZone: undefined
    }));
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(new Invalid("unparsable", "the input \"" + text + "\" can't be parsed as " + format));
  }
} // if you want to output a technical format (e.g. RFC 2822), this helper
// helps handle the details


function toTechFormat(dt, format, allowZ) {
  if (allowZ === void 0) {
    allowZ = true;
  }

  return dt.isValid ? Formatter.create(Locale.create("en-US"), {
    allowZ: allowZ,
    forceSimple: true
  }).formatDateTimeFromString(dt, format) : null;
} // technical time formats (e.g. the time part of ISO 8601), take some options
// and this commonizes their handling


function toTechTimeFormat(dt, _ref) {
  var _ref$suppressSeconds = _ref.suppressSeconds,
      suppressSeconds = _ref$suppressSeconds === void 0 ? false : _ref$suppressSeconds,
      _ref$suppressMillisec = _ref.suppressMilliseconds,
      suppressMilliseconds = _ref$suppressMillisec === void 0 ? false : _ref$suppressMillisec,
      includeOffset = _ref.includeOffset,
      _ref$includeZone = _ref.includeZone,
      includeZone = _ref$includeZone === void 0 ? false : _ref$includeZone,
      _ref$spaceZone = _ref.spaceZone,
      spaceZone = _ref$spaceZone === void 0 ? false : _ref$spaceZone,
      _ref$format = _ref.format,
      format = _ref$format === void 0 ? "extended" : _ref$format;
  var fmt = format === "basic" ? "HHmm" : "HH:mm";

  if (!suppressSeconds || dt.second !== 0 || dt.millisecond !== 0) {
    fmt += format === "basic" ? "ss" : ":ss";

    if (!suppressMilliseconds || dt.millisecond !== 0) {
      fmt += ".SSS";
    }
  }

  if ((includeZone || includeOffset) && spaceZone) {
    fmt += " ";
  }

  if (includeZone) {
    fmt += "z";
  } else if (includeOffset) {
    fmt += format === "basic" ? "ZZZ" : "ZZ";
  }

  return toTechFormat(dt, fmt);
} // defaults for unspecified units in the supported calendars


var defaultUnitValues = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
},
    defaultWeekUnitValues = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
},
    defaultOrdinalUnitValues = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}; // Units in the supported calendars, sorted by bigness

var orderedUnits$1 = ["year", "month", "day", "hour", "minute", "second", "millisecond"],
    orderedWeekUnits = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"],
    orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"]; // standardize case and plurality in units

function normalizeUnit(unit) {
  var normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit.toLowerCase()];
  if (!normalized) throw new InvalidUnitError(unit);
  return normalized;
} // this is a dumbed down version of fromObject() that runs about 60% faster
// but doesn't do any validation, makes a bunch of assumptions about what units
// are present, and so on.


function quickDT(obj, zone) {
  // assume we have the higher-order units
  for (var _iterator = _createForOfIteratorHelperLoose(orderedUnits$1), _step; !(_step = _iterator()).done;) {
    var u = _step.value;

    if (isUndefined(obj[u])) {
      obj[u] = defaultUnitValues[u];
    }
  }

  var invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);

  if (invalid) {
    return DateTime.invalid(invalid);
  }

  var tsNow = Settings.now(),
      offsetProvis = zone.offset(tsNow),
      _objToTS = objToTS(obj, offsetProvis, zone),
      ts = _objToTS[0],
      o = _objToTS[1];

  return new DateTime({
    ts: ts,
    zone: zone,
    o: o
  });
}

function diffRelative(start, end, opts) {
  var round = isUndefined(opts.round) ? true : opts.round,
      format = function format(c, unit) {
    c = roundTo(c, round || opts.calendary ? 0 : 2, true);
    var formatter = end.loc.clone(opts).relFormatter(opts);
    return formatter.format(c, unit);
  },
      differ = function differ(unit) {
    if (opts.calendary) {
      if (!end.hasSame(start, unit)) {
        return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
      } else return 0;
    } else {
      return end.diff(start, unit).get(unit);
    }
  };

  if (opts.unit) {
    return format(differ(opts.unit), opts.unit);
  }

  for (var _iterator2 = _createForOfIteratorHelperLoose(opts.units), _step2; !(_step2 = _iterator2()).done;) {
    var unit = _step2.value;
    var count = differ(unit);

    if (Math.abs(count) >= 1) {
      return format(count, unit);
    }
  }

  return format(0, opts.units[opts.units.length - 1]);
}
/**
 * A DateTime is an immutable data structure representing a specific date and time and accompanying methods. It contains class and instance methods for creating, parsing, interrogating, transforming, and formatting them.
 *
 * A DateTime comprises of:
 * * A timestamp. Each DateTime instance refers to a specific millisecond of the Unix epoch.
 * * A time zone. Each instance is considered in the context of a specific zone (by default the local system's zone).
 * * Configuration properties that effect how output strings are formatted, such as `locale`, `numberingSystem`, and `outputCalendar`.
 *
 * Here is a brief overview of the most commonly used functionality it provides:
 *
 * * **Creation**: To create a DateTime from its components, use one of its factory class methods: {@link local}, {@link utc}, and (most flexibly) {@link fromObject}. To create one from a standard string format, use {@link fromISO}, {@link fromHTTP}, and {@link fromRFC2822}. To create one from a custom string format, use {@link fromFormat}. To create one from a native JS date, use {@link fromJSDate}.
 * * **Gregorian calendar and time**: To examine the Gregorian properties of a DateTime individually (i.e as opposed to collectively through {@link toObject}), use the {@link year}, {@link month},
 * {@link day}, {@link hour}, {@link minute}, {@link second}, {@link millisecond} accessors.
 * * **Week calendar**: For ISO week calendar attributes, see the {@link weekYear}, {@link weekNumber}, and {@link weekday} accessors.
 * * **Configuration** See the {@link locale} and {@link numberingSystem} accessors.
 * * **Transformation**: To transform the DateTime into other DateTimes, use {@link set}, {@link reconfigure}, {@link setZone}, {@link setLocale}, {@link plus}, {@link minus}, {@link endOf}, {@link startOf}, {@link toUTC}, and {@link toLocal}.
 * * **Output**: To convert the DateTime to other representations, use the {@link toRelative}, {@link toRelativeCalendar}, {@link toJSON}, {@link toISO}, {@link toHTTP}, {@link toObject}, {@link toRFC2822}, {@link toString}, {@link toLocaleString}, {@link toFormat}, {@link toMillis} and {@link toJSDate}.
 *
 * There's plenty others documented below. In addition, for more information on subtler topics like internationalization, time zones, alternative calendars, validity, and so on, see the external documentation.
 */


var DateTime = /*#__PURE__*/function () {
  /**
   * @access private
   */
  function DateTime(config) {
    var zone = config.zone || Settings.defaultZone;
    var invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
    /**
     * @access private
     */

    this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
    var c = null,
        o = null;

    if (!invalid) {
      var unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);

      if (unchanged) {
        var _ref2 = [config.old.c, config.old.o];
        c = _ref2[0];
        o = _ref2[1];
      } else {
        var ot = zone.offset(this.ts);
        c = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
        c = invalid ? null : c;
        o = invalid ? null : ot;
      }
    }
    /**
     * @access private
     */


    this._zone = zone;
    /**
     * @access private
     */

    this.loc = config.loc || Locale.create();
    /**
     * @access private
     */

    this.invalid = invalid;
    /**
     * @access private
     */

    this.weekData = null;
    /**
     * @access private
     */

    this.c = c;
    /**
     * @access private
     */

    this.o = o;
    /**
     * @access private
     */

    this.isLuxonDateTime = true;
  } // CONSTRUCT

  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                            //~> now
   * @example DateTime.local(2017)                        //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                     //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12)                 //~> 2017-03-12T00:00:00
   * @example DateTime.local(2017, 3, 12, 5)              //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, 45)          //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)      //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765) //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */


  DateTime.local = function local(year, month, day, hour, minute, second, millisecond) {
    if (isUndefined(year)) {
      return new DateTime({
        ts: Settings.now()
      });
    } else {
      return quickDT({
        year: year,
        month: month,
        day: day,
        hour: hour,
        minute: minute,
        second: second,
        millisecond: millisecond
      }, Settings.defaultZone);
    }
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.utc()                            //~> now
   * @example DateTime.utc(2017)                        //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                     //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                 //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)              //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)          //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)      //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765) //~> 2017-03-12T05:45:10.765Z
   * @return {DateTime}
   */
  ;

  DateTime.utc = function utc(year, month, day, hour, minute, second, millisecond) {
    if (isUndefined(year)) {
      return new DateTime({
        ts: Settings.now(),
        zone: FixedOffsetZone.utcInstance
      });
    } else {
      return quickDT({
        year: year,
        month: month,
        day: day,
        hour: hour,
        minute: minute,
        second: second,
        millisecond: millisecond
      }, FixedOffsetZone.utcInstance);
    }
  }
  /**
   * Create a DateTime from a Javascript Date object. Uses the default zone.
   * @param {Date} date - a Javascript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  ;

  DateTime.fromJSDate = function fromJSDate(date, options) {
    if (options === void 0) {
      options = {};
    }

    var ts = isDate(date) ? date.valueOf() : NaN;

    if (Number.isNaN(ts)) {
      return DateTime.invalid("invalid input");
    }

    var zoneToUse = normalizeZone(options.zone, Settings.defaultZone);

    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }

    return new DateTime({
      ts: ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options)
    });
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  ;

  DateTime.fromMillis = function fromMillis(milliseconds, options) {
    if (options === void 0) {
      options = {};
    }

    if (!isNumber(milliseconds)) {
      throw new InvalidArgumentError("fromMillis requires a numerical input, but received a " + typeof milliseconds + " with value " + milliseconds);
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      // this isn't perfect because because we can still end up out of range because of additional shifting, but it's a start
      return DateTime.invalid("Timestamp out of range");
    } else {
      return new DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  ;

  DateTime.fromSeconds = function fromSeconds(seconds, options) {
    if (options === void 0) {
      options = {};
    }

    if (!isNumber(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new DateTime({
        ts: seconds * 1000,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a Javascript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {string|Zone} [obj.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [obj.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} obj.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} obj.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6, zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6, zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6, zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @return {DateTime}
   */
  ;

  DateTime.fromObject = function fromObject(obj) {
    var zoneToUse = normalizeZone(obj.zone, Settings.defaultZone);

    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }

    var tsNow = Settings.now(),
        offsetProvis = zoneToUse.offset(tsNow),
        normalized = normalizeObject(obj, normalizeUnit, ["zone", "locale", "outputCalendar", "numberingSystem"]),
        containsOrdinal = !isUndefined(normalized.ordinal),
        containsGregorYear = !isUndefined(normalized.year),
        containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day),
        containsGregor = containsGregorYear || containsGregorMD,
        definiteWeekDef = normalized.weekYear || normalized.weekNumber,
        loc = Locale.fromObject(obj); // cases:
    // just a weekday -> this week's instance of that weekday, no worries
    // (gregorian data or ordinal) + (weekYear or weekNumber) -> error
    // (gregorian month or day) + ordinal -> error
    // otherwise just use weeks or ordinals or gregorian, depending on what's specified

    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    }

    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }

    var useWeekData = definiteWeekDef || normalized.weekday && !containsGregor; // configure ourselves to deal with gregorian dates or week stuff

    var units,
        defaultValues,
        objNow = tsToObj(tsNow, offsetProvis);

    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits$1;
      defaultValues = defaultUnitValues;
    } // set default values for missing stuff


    var foundFirst = false;

    for (var _iterator3 = _createForOfIteratorHelperLoose(units), _step3; !(_step3 = _iterator3()).done;) {
      var u = _step3.value;
      var v = normalized[u];

      if (!isUndefined(v)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    } // make sure the values we have are in range


    var higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized),
        invalid = higherOrderInvalid || hasInvalidTimeData(normalized);

    if (invalid) {
      return DateTime.invalid(invalid);
    } // compute the actual time


    var gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized,
        _objToTS2 = objToTS(gregorian, offsetProvis, zoneToUse),
        tsFinal = _objToTS2[0],
        offsetFinal = _objToTS2[1],
        inst = new DateTime({
      ts: tsFinal,
      zone: zoneToUse,
      o: offsetFinal,
      loc: loc
    }); // gregorian data + weekday serves only to validate


    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return DateTime.invalid("mismatched weekday", "you can't specify both a weekday of " + normalized.weekday + " and a date of " + inst.toISO());
    }

    return inst;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  ;

  DateTime.fromISO = function fromISO(text, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var _parseISODate = parseISODate(text),
        vals = _parseISODate[0],
        parsedZone = _parseISODate[1];

    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  ;

  DateTime.fromRFC2822 = function fromRFC2822(text, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var _parseRFC2822Date = parseRFC2822Date(text),
        vals = _parseRFC2822Date[0],
        parsedZone = _parseRFC2822Date[1];

    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  ;

  DateTime.fromHTTP = function fromHTTP(text, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var _parseHTTPDate = parseHTTPDate(text),
        vals = _parseHTTPDate[0],
        parsedZone = _parseHTTPDate[1];

    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @see https://moment.github.io/luxon/docs/manual/parsing.html#table-of-tokens
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  ;

  DateTime.fromFormat = function fromFormat(text, fmt, opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (isUndefined(text) || isUndefined(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }

    var _opts = opts,
        _opts$locale = _opts.locale,
        locale = _opts$locale === void 0 ? null : _opts$locale,
        _opts$numberingSystem = _opts.numberingSystem,
        numberingSystem = _opts$numberingSystem === void 0 ? null : _opts$numberingSystem,
        localeToUse = Locale.fromOpts({
      locale: locale,
      numberingSystem: numberingSystem,
      defaultToEN: true
    }),
        _parseFromTokens = parseFromTokens(localeToUse, text, fmt),
        vals = _parseFromTokens[0],
        parsedZone = _parseFromTokens[1],
        invalid = _parseFromTokens[2];

    if (invalid) {
      return DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, "format " + fmt, text);
    }
  }
  /**
   * @deprecated use fromFormat instead
   */
  ;

  DateTime.fromString = function fromString(text, fmt, opts) {
    if (opts === void 0) {
      opts = {};
    }

    return DateTime.fromFormat(text, fmt, opts);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  ;

  DateTime.fromSQL = function fromSQL(text, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var _parseSQL = parseSQL(text),
        vals = _parseSQL[0],
        parsedZone = _parseSQL[1];

    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  ;

  DateTime.invalid = function invalid(reason, explanation) {
    if (explanation === void 0) {
      explanation = null;
    }

    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }

    var invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);

    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new DateTime({
        invalid: invalid
      });
    }
  }
  /**
   * Check if an object is a DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  ;

  DateTime.isDateTime = function isDateTime(o) {
    return o && o.isLuxonDateTime || false;
  } // INFO

  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  ;

  var _proto = DateTime.prototype;

  _proto.get = function get(unit) {
    return this[unit];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  ;

  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  _proto.resolvedLocaleOpts = function resolvedLocaleOpts(opts) {
    if (opts === void 0) {
      opts = {};
    }

    var _Formatter$create$res = Formatter.create(this.loc.clone(opts), opts).resolvedOptions(this),
        locale = _Formatter$create$res.locale,
        numberingSystem = _Formatter$create$res.numberingSystem,
        calendar = _Formatter$create$res.calendar;

    return {
      locale: locale,
      numberingSystem: numberingSystem,
      outputCalendar: calendar
    };
  } // TRANSFORM

  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  ;

  _proto.toUTC = function toUTC(offset, opts) {
    if (offset === void 0) {
      offset = 0;
    }

    if (opts === void 0) {
      opts = {};
    }

    return this.setZone(FixedOffsetZone.instance(offset), opts);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  ;

  _proto.toLocal = function toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link plus}. You may wish to use {@link toLocal} and {@link toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  ;

  _proto.setZone = function setZone(zone, _temp) {
    var _ref3 = _temp === void 0 ? {} : _temp,
        _ref3$keepLocalTime = _ref3.keepLocalTime,
        keepLocalTime = _ref3$keepLocalTime === void 0 ? false : _ref3$keepLocalTime,
        _ref3$keepCalendarTim = _ref3.keepCalendarTime,
        keepCalendarTime = _ref3$keepCalendarTim === void 0 ? false : _ref3$keepCalendarTim;

    zone = normalizeZone(zone, Settings.defaultZone);

    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    } else {
      var newTS = this.ts;

      if (keepLocalTime || keepCalendarTime) {
        var offsetGuess = zone.offset(this.ts);
        var asObj = this.toObject();

        var _objToTS3 = objToTS(asObj, offsetGuess, zone);

        newTS = _objToTS3[0];
      }

      return clone$1(this, {
        ts: newTS,
        zone: zone
      });
    }
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  ;

  _proto.reconfigure = function reconfigure(_temp2) {
    var _ref4 = _temp2 === void 0 ? {} : _temp2,
        locale = _ref4.locale,
        numberingSystem = _ref4.numberingSystem,
        outputCalendar = _ref4.outputCalendar;

    var loc = this.loc.clone({
      locale: locale,
      numberingSystem: numberingSystem,
      outputCalendar: outputCalendar
    });
    return clone$1(this, {
      loc: loc
    });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  ;

  _proto.setLocale = function setLocale(locale) {
    return this.reconfigure({
      locale: locale
    });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link reconfigure} and {@link setZone}.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  ;

  _proto.set = function set(values) {
    if (!this.isValid) return this;
    var normalized = normalizeObject(values, normalizeUnit, []),
        settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday);
    var mixed;

    if (settingWeekStuff) {
      mixed = weekToGregorian(Object.assign(gregorianToWeek(this.c), normalized));
    } else if (!isUndefined(normalized.ordinal)) {
      mixed = ordinalToGregorian(Object.assign(gregorianToOrdinal(this.c), normalized));
    } else {
      mixed = Object.assign(this.toObject(), normalized); // if we didn't set the day but we ended up on an overflow date,
      // use the last day of the right month

      if (isUndefined(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }

    var _objToTS4 = objToTS(mixed, this.o, this.zone),
        ts = _objToTS4[0],
        o = _objToTS4[1];

    return clone$1(this, {
      ts: ts,
      o: o
    });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.local().plus(123) //~> in 123 milliseconds
   * @example DateTime.local().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.local().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.local().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.local().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.local().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  ;

  _proto.plus = function plus(duration) {
    if (!this.isValid) return this;
    var dur = friendlyDuration(duration);
    return clone$1(this, adjustTime(this, dur));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
  */
  ;

  _proto.minus = function minus(duration) {
    if (!this.isValid) return this;
    var dur = friendlyDuration(duration).negate();
    return clone$1(this, adjustTime(this, dur));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  ;

  _proto.startOf = function startOf(unit) {
    if (!this.isValid) return this;
    var o = {},
        normalizedUnit = Duration.normalizeUnit(unit);

    switch (normalizedUnit) {
      case "years":
        o.month = 1;
      // falls through

      case "quarters":
      case "months":
        o.day = 1;
      // falls through

      case "weeks":
      case "days":
        o.hour = 0;
      // falls through

      case "hours":
        o.minute = 0;
      // falls through

      case "minutes":
        o.second = 0;
      // falls through

      case "seconds":
        o.millisecond = 0;
        break;
      // no default, invalid units throw in normalizeUnit()
    }

    if (normalizedUnit === "weeks") {
      o.weekday = 1;
    }

    if (normalizedUnit === "quarters") {
      var q = Math.ceil(this.month / 3);
      o.month = (q - 1) * 3 + 1;
    }

    return this.set(o);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'month', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  ;

  _proto.endOf = function endOf(unit) {
    var _this$plus;

    return this.isValid ? this.plus((_this$plus = {}, _this$plus[unit] = 1, _this$plus)).startOf(unit).minus(1) : this;
  } // OUTPUT

  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/docs/manual/formatting.html#table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @see https://moment.github.io/luxon/docs/manual/formatting.html#table-of-tokens
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options
   * @example DateTime.local().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.local().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.local().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.local().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  ;

  _proto.toFormat = function toFormat(fmt, opts) {
    if (opts === void 0) {
      opts = {};
    }

    return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID$2;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param opts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @example DateTime.local().toLocaleString(); //=> 4/20/2017
   * @example DateTime.local().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.local().toLocaleString({ locale: 'en-gb' }); //=> '20/04/2017'
   * @example DateTime.local().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.local().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.local().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.local().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.local().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.local().toLocaleString({ hour: '2-digit', minute: '2-digit', hour12: false }); //=> '11:32'
   * @return {string}
   */
  ;

  _proto.toLocaleString = function toLocaleString(opts) {
    if (opts === void 0) {
      opts = DATE_SHORT;
    }

    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTime(this) : INVALID$2;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.local().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  ;

  _proto.toLocaleParts = function toLocaleParts(opts) {
    if (opts === void 0) {
      opts = {};
    }

    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.local().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.local().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.local().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  ;

  _proto.toISO = function toISO(opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (!this.isValid) {
      return null;
    }

    return this.toISODate(opts) + "T" + this.toISOTime(opts);
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  ;

  _proto.toISODate = function toISODate(_temp3) {
    var _ref5 = _temp3 === void 0 ? {} : _temp3,
        _ref5$format = _ref5.format,
        format = _ref5$format === void 0 ? "extended" : _ref5$format;

    var fmt = format === "basic" ? "yyyyMMdd" : "yyyy-MM-dd";

    if (this.year > 9999) {
      fmt = "+" + fmt;
    }

    return toTechFormat(this, fmt);
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  ;

  _proto.toISOWeekDate = function toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @return {string}
   */
  ;

  _proto.toISOTime = function toISOTime(_temp4) {
    var _ref6 = _temp4 === void 0 ? {} : _temp4,
        _ref6$suppressMillise = _ref6.suppressMilliseconds,
        suppressMilliseconds = _ref6$suppressMillise === void 0 ? false : _ref6$suppressMillise,
        _ref6$suppressSeconds = _ref6.suppressSeconds,
        suppressSeconds = _ref6$suppressSeconds === void 0 ? false : _ref6$suppressSeconds,
        _ref6$includeOffset = _ref6.includeOffset,
        includeOffset = _ref6$includeOffset === void 0 ? true : _ref6$includeOffset,
        _ref6$format = _ref6.format,
        format = _ref6$format === void 0 ? "extended" : _ref6$format;

    return toTechTimeFormat(this, {
      suppressSeconds: suppressSeconds,
      suppressMilliseconds: suppressMilliseconds,
      includeOffset: includeOffset,
      format: format
    });
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime, always in UTC
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  ;

  _proto.toRFC2822 = function toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  ;

  _proto.toHTTP = function toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  ;

  _proto.toSQLDate = function toSQLDate() {
    return toTechFormat(this, "yyyy-MM-dd");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.local().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.local().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.local().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  ;

  _proto.toSQLTime = function toSQLTime(_temp5) {
    var _ref7 = _temp5 === void 0 ? {} : _temp5,
        _ref7$includeOffset = _ref7.includeOffset,
        includeOffset = _ref7$includeOffset === void 0 ? true : _ref7$includeOffset,
        _ref7$includeZone = _ref7.includeZone,
        includeZone = _ref7$includeZone === void 0 ? false : _ref7$includeZone;

    return toTechTimeFormat(this, {
      includeOffset: includeOffset,
      includeZone: includeZone,
      spaceZone: true
    });
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  ;

  _proto.toSQL = function toSQL(opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (!this.isValid) {
      return null;
    }

    return this.toSQLDate() + " " + this.toSQLTime(opts);
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  ;

  _proto.toString = function toString() {
    return this.isValid ? this.toISO() : INVALID$2;
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link toMillis}
   * @return {number}
   */
  ;

  _proto.valueOf = function valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  ;

  _proto.toMillis = function toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  ;

  _proto.toSeconds = function toSeconds() {
    return this.isValid ? this.ts / 1000 : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  ;

  _proto.toJSON = function toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  ;

  _proto.toBSON = function toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a Javascript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.local().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  ;

  _proto.toObject = function toObject(opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (!this.isValid) return {};
    var base = Object.assign({}, this.c);

    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }

    return base;
  }
  /**
   * Returns a Javascript Date equivalent to this DateTime.
   * @return {Date}
   */
  ;

  _proto.toJSDate = function toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  } // COMPARE

  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  ;

  _proto.diff = function diff(otherDateTime, unit, opts) {
    if (unit === void 0) {
      unit = "milliseconds";
    }

    if (opts === void 0) {
      opts = {};
    }

    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid(this.invalid || otherDateTime.invalid, "created by diffing an invalid DateTime");
    }

    var durOpts = Object.assign({
      locale: this.locale,
      numberingSystem: this.numberingSystem
    }, opts);

    var units = maybeArray(unit).map(Duration.normalizeUnit),
        otherIsLater = otherDateTime.valueOf() > this.valueOf(),
        earlier = otherIsLater ? this : otherDateTime,
        later = otherIsLater ? otherDateTime : this,
        diffed = _diff(earlier, later, units, durOpts);

    return otherIsLater ? diffed.negate() : diffed;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  ;

  _proto.diffNow = function diffNow(unit, opts) {
    if (unit === void 0) {
      unit = "milliseconds";
    }

    if (opts === void 0) {
      opts = {};
    }

    return this.diff(DateTime.local(), unit, opts);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  ;

  _proto.until = function until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @example DateTime.local().hasSame(otherDT, 'day'); //~> true if both the same calendar day
   * @return {boolean}
   */
  ;

  _proto.hasSame = function hasSame(otherDateTime, unit) {
    if (!this.isValid) return false;

    if (unit === "millisecond") {
      return this.valueOf() === otherDateTime.valueOf();
    } else {
      var inputMs = otherDateTime.valueOf();
      return this.startOf(unit) <= inputMs && inputMs <= this.endOf(unit);
    }
  }
  /**
   * Equality check
   * Two DateTimes are equal iff they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  ;

  _proto.equals = function equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.local()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {boolean} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.local().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.local().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 dÃ­a"
   * @example DateTime.local().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.local().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.local().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.local().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  ;

  _proto.toRelative = function toRelative(options) {
    if (options === void 0) {
      options = {};
    }

    if (!this.isValid) return null;
    var base = options.base || DateTime.fromObject({
      zone: this.zone
    }),
        padding = options.padding ? this < base ? -options.padding : options.padding : 0;
    return diffRelative(base, this.plus(padding), Object.assign(options, {
      numeric: "always",
      units: ["years", "months", "days", "hours", "minutes", "seconds"]
    }));
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.local()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.local().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.local().setLocale("es").plus({ days: 1 }).toRelative() //=> ""maÃ±ana"
   * @example DateTime.local().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.local().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  ;

  _proto.toRelativeCalendar = function toRelativeCalendar(options) {
    if (options === void 0) {
      options = {};
    }

    if (!this.isValid) return null;
    return diffRelative(options.base || DateTime.fromObject({
      zone: this.zone
    }), this, Object.assign(options, {
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    }));
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  ;

  DateTime.min = function min() {
    for (var _len = arguments.length, dateTimes = new Array(_len), _key = 0; _key < _len; _key++) {
      dateTimes[_key] = arguments[_key];
    }

    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }

    return bestBy(dateTimes, function (i) {
      return i.valueOf();
    }, Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  ;

  DateTime.max = function max() {
    for (var _len2 = arguments.length, dateTimes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      dateTimes[_key2] = arguments[_key2];
    }

    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }

    return bestBy(dateTimes, function (i) {
      return i.valueOf();
    }, Math.max);
  } // MISC

  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  ;

  DateTime.fromFormatExplain = function fromFormatExplain(text, fmt, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        _options$locale = _options.locale,
        locale = _options$locale === void 0 ? null : _options$locale,
        _options$numberingSys = _options.numberingSystem,
        numberingSystem = _options$numberingSys === void 0 ? null : _options$numberingSys,
        localeToUse = Locale.fromOpts({
      locale: locale,
      numberingSystem: numberingSystem,
      defaultToEN: true
    });
    return explainFromTokens(localeToUse, text, fmt);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  ;

  DateTime.fromStringExplain = function fromStringExplain(text, fmt, options) {
    if (options === void 0) {
      options = {};
    }

    return DateTime.fromFormatExplain(text, fmt, options);
  } // FORMAT PRESETS

  /**
   * {@link toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  ;

  _createClass(DateTime, [{
    key: "isValid",
    get: function get() {
      return this.invalid === null;
    }
    /**
     * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
     * @type {string}
     */

  }, {
    key: "invalidReason",
    get: function get() {
      return this.invalid ? this.invalid.reason : null;
    }
    /**
     * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
     * @type {string}
     */

  }, {
    key: "invalidExplanation",
    get: function get() {
      return this.invalid ? this.invalid.explanation : null;
    }
    /**
     * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
     *
     * @type {string}
     */

  }, {
    key: "locale",
    get: function get() {
      return this.isValid ? this.loc.locale : null;
    }
    /**
     * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
     *
     * @type {string}
     */

  }, {
    key: "numberingSystem",
    get: function get() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
    /**
     * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
     *
     * @type {string}
     */

  }, {
    key: "outputCalendar",
    get: function get() {
      return this.isValid ? this.loc.outputCalendar : null;
    }
    /**
     * Get the time zone associated with this DateTime.
     * @type {Zone}
     */

  }, {
    key: "zone",
    get: function get() {
      return this._zone;
    }
    /**
     * Get the name of the time zone.
     * @type {string}
     */

  }, {
    key: "zoneName",
    get: function get() {
      return this.isValid ? this.zone.name : null;
    }
    /**
     * Get the year
     * @example DateTime.local(2017, 5, 25).year //=> 2017
     * @type {number}
     */

  }, {
    key: "year",
    get: function get() {
      return this.isValid ? this.c.year : NaN;
    }
    /**
     * Get the quarter
     * @example DateTime.local(2017, 5, 25).quarter //=> 2
     * @type {number}
     */

  }, {
    key: "quarter",
    get: function get() {
      return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
    }
    /**
     * Get the month (1-12).
     * @example DateTime.local(2017, 5, 25).month //=> 5
     * @type {number}
     */

  }, {
    key: "month",
    get: function get() {
      return this.isValid ? this.c.month : NaN;
    }
    /**
     * Get the day of the month (1-30ish).
     * @example DateTime.local(2017, 5, 25).day //=> 25
     * @type {number}
     */

  }, {
    key: "day",
    get: function get() {
      return this.isValid ? this.c.day : NaN;
    }
    /**
     * Get the hour of the day (0-23).
     * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
     * @type {number}
     */

  }, {
    key: "hour",
    get: function get() {
      return this.isValid ? this.c.hour : NaN;
    }
    /**
     * Get the minute of the hour (0-59).
     * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
     * @type {number}
     */

  }, {
    key: "minute",
    get: function get() {
      return this.isValid ? this.c.minute : NaN;
    }
    /**
     * Get the second of the minute (0-59).
     * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
     * @type {number}
     */

  }, {
    key: "second",
    get: function get() {
      return this.isValid ? this.c.second : NaN;
    }
    /**
     * Get the millisecond of the second (0-999).
     * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
     * @type {number}
     */

  }, {
    key: "millisecond",
    get: function get() {
      return this.isValid ? this.c.millisecond : NaN;
    }
    /**
     * Get the week year
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2014, 11, 31).weekYear //=> 2015
     * @type {number}
     */

  }, {
    key: "weekYear",
    get: function get() {
      return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
    }
    /**
     * Get the week number of the week year (1-52ish).
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
     * @type {number}
     */

  }, {
    key: "weekNumber",
    get: function get() {
      return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
    }
    /**
     * Get the day of the week.
     * 1 is Monday and 7 is Sunday
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2014, 11, 31).weekday //=> 4
     * @type {number}
     */

  }, {
    key: "weekday",
    get: function get() {
      return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
    }
    /**
     * Get the ordinal (meaning the day of the year)
     * @example DateTime.local(2017, 5, 25).ordinal //=> 145
     * @type {number|DateTime}
     */

  }, {
    key: "ordinal",
    get: function get() {
      return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
    }
    /**
     * Get the human readable short month name, such as 'Oct'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
     * @type {string}
     */

  }, {
    key: "monthShort",
    get: function get() {
      return this.isValid ? Info.months("short", {
        locale: this.locale
      })[this.month - 1] : null;
    }
    /**
     * Get the human readable long month name, such as 'October'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).monthLong //=> October
     * @type {string}
     */

  }, {
    key: "monthLong",
    get: function get() {
      return this.isValid ? Info.months("long", {
        locale: this.locale
      })[this.month - 1] : null;
    }
    /**
     * Get the human readable short weekday, such as 'Mon'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
     * @type {string}
     */

  }, {
    key: "weekdayShort",
    get: function get() {
      return this.isValid ? Info.weekdays("short", {
        locale: this.locale
      })[this.weekday - 1] : null;
    }
    /**
     * Get the human readable long weekday, such as 'Monday'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
     * @type {string}
     */

  }, {
    key: "weekdayLong",
    get: function get() {
      return this.isValid ? Info.weekdays("long", {
        locale: this.locale
      })[this.weekday - 1] : null;
    }
    /**
     * Get the UTC offset of this DateTime in minutes
     * @example DateTime.local().offset //=> -240
     * @example DateTime.utc().offset //=> 0
     * @type {number}
     */

  }, {
    key: "offset",
    get: function get() {
      return this.isValid ? +this.o : NaN;
    }
    /**
     * Get the short human name for the zone's current offset, for example "EST" or "EDT".
     * Defaults to the system's locale if no locale has been specified
     * @type {string}
     */

  }, {
    key: "offsetNameShort",
    get: function get() {
      if (this.isValid) {
        return this.zone.offsetName(this.ts, {
          format: "short",
          locale: this.locale
        });
      } else {
        return null;
      }
    }
    /**
     * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
     * Defaults to the system's locale if no locale has been specified
     * @type {string}
     */

  }, {
    key: "offsetNameLong",
    get: function get() {
      if (this.isValid) {
        return this.zone.offsetName(this.ts, {
          format: "long",
          locale: this.locale
        });
      } else {
        return null;
      }
    }
    /**
     * Get whether this zone's offset ever changes, as in a DST.
     * @type {boolean}
     */

  }, {
    key: "isOffsetFixed",
    get: function get() {
      return this.isValid ? this.zone.universal : null;
    }
    /**
     * Get whether the DateTime is in a DST.
     * @type {boolean}
     */

  }, {
    key: "isInDST",
    get: function get() {
      if (this.isOffsetFixed) {
        return false;
      } else {
        return this.offset > this.set({
          month: 1
        }).offset || this.offset > this.set({
          month: 5
        }).offset;
      }
    }
    /**
     * Returns true if this DateTime is in a leap year, false otherwise
     * @example DateTime.local(2016).isInLeapYear //=> true
     * @example DateTime.local(2013).isInLeapYear //=> false
     * @type {boolean}
     */

  }, {
    key: "isInLeapYear",
    get: function get() {
      return isLeapYear(this.year);
    }
    /**
     * Returns the number of days in this DateTime's month
     * @example DateTime.local(2016, 2).daysInMonth //=> 29
     * @example DateTime.local(2016, 3).daysInMonth //=> 31
     * @type {number}
     */

  }, {
    key: "daysInMonth",
    get: function get() {
      return daysInMonth(this.year, this.month);
    }
    /**
     * Returns the number of days in this DateTime's year
     * @example DateTime.local(2016).daysInYear //=> 366
     * @example DateTime.local(2013).daysInYear //=> 365
     * @type {number}
     */

  }, {
    key: "daysInYear",
    get: function get() {
      return this.isValid ? daysInYear(this.year) : NaN;
    }
    /**
     * Returns the number of weeks in this DateTime's year
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2004).weeksInWeekYear //=> 53
     * @example DateTime.local(2013).weeksInWeekYear //=> 52
     * @type {number}
     */

  }, {
    key: "weeksInWeekYear",
    get: function get() {
      return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
    }
  }], [{
    key: "DATE_SHORT",
    get: function get() {
      return DATE_SHORT;
    }
    /**
     * {@link toLocaleString} format like 'Oct 14, 1983'
     * @type {Object}
     */

  }, {
    key: "DATE_MED",
    get: function get() {
      return DATE_MED;
    }
    /**
     * {@link toLocaleString} format like 'Fri, Oct 14, 1983'
     * @type {Object}
     */

  }, {
    key: "DATE_MED_WITH_WEEKDAY",
    get: function get() {
      return DATE_MED_WITH_WEEKDAY;
    }
    /**
     * {@link toLocaleString} format like 'October 14, 1983'
     * @type {Object}
     */

  }, {
    key: "DATE_FULL",
    get: function get() {
      return DATE_FULL;
    }
    /**
     * {@link toLocaleString} format like 'Tuesday, October 14, 1983'
     * @type {Object}
     */

  }, {
    key: "DATE_HUGE",
    get: function get() {
      return DATE_HUGE;
    }
    /**
     * {@link toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "TIME_SIMPLE",
    get: function get() {
      return TIME_SIMPLE;
    }
    /**
     * {@link toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "TIME_WITH_SECONDS",
    get: function get() {
      return TIME_WITH_SECONDS;
    }
    /**
     * {@link toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "TIME_WITH_SHORT_OFFSET",
    get: function get() {
      return TIME_WITH_SHORT_OFFSET;
    }
    /**
     * {@link toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "TIME_WITH_LONG_OFFSET",
    get: function get() {
      return TIME_WITH_LONG_OFFSET;
    }
    /**
     * {@link toLocaleString} format like '09:30', always 24-hour.
     * @type {Object}
     */

  }, {
    key: "TIME_24_SIMPLE",
    get: function get() {
      return TIME_24_SIMPLE;
    }
    /**
     * {@link toLocaleString} format like '09:30:23', always 24-hour.
     * @type {Object}
     */

  }, {
    key: "TIME_24_WITH_SECONDS",
    get: function get() {
      return TIME_24_WITH_SECONDS;
    }
    /**
     * {@link toLocaleString} format like '09:30:23 EDT', always 24-hour.
     * @type {Object}
     */

  }, {
    key: "TIME_24_WITH_SHORT_OFFSET",
    get: function get() {
      return TIME_24_WITH_SHORT_OFFSET;
    }
    /**
     * {@link toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
     * @type {Object}
     */

  }, {
    key: "TIME_24_WITH_LONG_OFFSET",
    get: function get() {
      return TIME_24_WITH_LONG_OFFSET;
    }
    /**
     * {@link toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "DATETIME_SHORT",
    get: function get() {
      return DATETIME_SHORT;
    }
    /**
     * {@link toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "DATETIME_SHORT_WITH_SECONDS",
    get: function get() {
      return DATETIME_SHORT_WITH_SECONDS;
    }
    /**
     * {@link toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "DATETIME_MED",
    get: function get() {
      return DATETIME_MED;
    }
    /**
     * {@link toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "DATETIME_MED_WITH_SECONDS",
    get: function get() {
      return DATETIME_MED_WITH_SECONDS;
    }
    /**
     * {@link toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "DATETIME_MED_WITH_WEEKDAY",
    get: function get() {
      return DATETIME_MED_WITH_WEEKDAY;
    }
    /**
     * {@link toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "DATETIME_FULL",
    get: function get() {
      return DATETIME_FULL;
    }
    /**
     * {@link toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "DATETIME_FULL_WITH_SECONDS",
    get: function get() {
      return DATETIME_FULL_WITH_SECONDS;
    }
    /**
     * {@link toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "DATETIME_HUGE",
    get: function get() {
      return DATETIME_HUGE;
    }
    /**
     * {@link toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "DATETIME_HUGE_WITH_SECONDS",
    get: function get() {
      return DATETIME_HUGE_WITH_SECONDS;
    }
  }]);

  return DateTime;
}();
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError("Unknown datetime argument: " + dateTimeish + ", of type " + typeof dateTimeish);
  }
}

exports.DateTime = DateTime;
exports.Duration = Duration;
exports.FixedOffsetZone = FixedOffsetZone;
exports.IANAZone = IANAZone;
exports.Info = Info;
exports.Interval = Interval;
exports.InvalidZone = InvalidZone;
exports.LocalZone = LocalZone;
exports.Settings = Settings;
exports.Zone = Zone;


},{}],88:[function(require,module,exports){
(function (global){(function (){
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __spreadArrays;
var __spreadArray;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
var __importStar;
var __importDefault;
var __classPrivateFieldGet;
var __classPrivateFieldSet;
var __createBinding;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };

    __extends = function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function(m, o) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
    };

    __createBinding = Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    });

    __values = function (o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    /** @deprecated */
    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    /** @deprecated */
    __spreadArrays = function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    __spreadArray = function (to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    var __setModuleDefault = Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    };

    __importStar = function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };

    __importDefault = function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };

    __classPrivateFieldGet = function (receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    };

    __classPrivateFieldSet = function (receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
});

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJicm93c2VyLXRlc3QvdGVzdC5qcyIsImxpYi9DYWxlbmRhci5qcyIsImxpYi9FbnZpcm9ubWVudC5qcyIsImxpYi9Mb2NhbGUuanMiLCJsaWIvY291bnRyaWVzLmpzIiwibGliL2xhbmd1YWdlcy5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvZWNtYTQwMi1hYnN0cmFjdC8yNjIuanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3QvQmVzdEF2YWlsYWJsZUxvY2FsZS5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvZWNtYTQwMi1hYnN0cmFjdC9CZXN0Rml0TWF0Y2hlci5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvZWNtYTQwMi1hYnN0cmFjdC9DYW5vbmljYWxpemVMb2NhbGVMaXN0LmpzIiwibm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9lY21hNDAyLWFic3RyYWN0L0Nhbm9uaWNhbGl6ZVRpbWVab25lTmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvZWNtYTQwMi1hYnN0cmFjdC9EYXRlVGltZUZvcm1hdC9CYXNpY0Zvcm1hdE1hdGNoZXIuanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3QvRGF0ZVRpbWVGb3JtYXQvQmVzdEZpdEZvcm1hdE1hdGNoZXIuanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3QvRGF0ZVRpbWVGb3JtYXQvRGF0ZVRpbWVTdHlsZUZvcm1hdC5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvZWNtYTQwMi1hYnN0cmFjdC9EYXRlVGltZUZvcm1hdC9Gb3JtYXREYXRlVGltZS5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvZWNtYTQwMi1hYnN0cmFjdC9EYXRlVGltZUZvcm1hdC9Gb3JtYXREYXRlVGltZVBhdHRlcm4uanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3QvRGF0ZVRpbWVGb3JtYXQvRm9ybWF0RGF0ZVRpbWVSYW5nZS5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvZWNtYTQwMi1hYnN0cmFjdC9EYXRlVGltZUZvcm1hdC9Gb3JtYXREYXRlVGltZVJhbmdlVG9QYXJ0cy5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvZWNtYTQwMi1hYnN0cmFjdC9EYXRlVGltZUZvcm1hdC9Gb3JtYXREYXRlVGltZVRvUGFydHMuanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3QvRGF0ZVRpbWVGb3JtYXQvSW5pdGlhbGl6ZURhdGVUaW1lRm9ybWF0LmpzIiwibm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9lY21hNDAyLWFic3RyYWN0L0RhdGVUaW1lRm9ybWF0L1BhcnRpdGlvbkRhdGVUaW1lUGF0dGVybi5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvZWNtYTQwMi1hYnN0cmFjdC9EYXRlVGltZUZvcm1hdC9QYXJ0aXRpb25EYXRlVGltZVJhbmdlUGF0dGVybi5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvZWNtYTQwMi1hYnN0cmFjdC9EYXRlVGltZUZvcm1hdC9Ub0RhdGVUaW1lT3B0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvZWNtYTQwMi1hYnN0cmFjdC9EYXRlVGltZUZvcm1hdC9Ub0xvY2FsVGltZS5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvZWNtYTQwMi1hYnN0cmFjdC9EYXRlVGltZUZvcm1hdC9za2VsZXRvbi5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvZWNtYTQwMi1hYnN0cmFjdC9EYXRlVGltZUZvcm1hdC91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvZWNtYTQwMi1hYnN0cmFjdC9EZWZhdWx0TnVtYmVyT3B0aW9uLmpzIiwibm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9lY21hNDAyLWFic3RyYWN0L0Rpc3BsYXlOYW1lcy9DYW5vbmljYWxDb2RlRm9yRGlzcGxheU5hbWVzLmpzIiwibm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9lY21hNDAyLWFic3RyYWN0L0dldE51bWJlck9wdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvZWNtYTQwMi1hYnN0cmFjdC9HZXRPcHRpb24uanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3QvSXNTYW5jdGlvbmVkU2ltcGxlVW5pdElkZW50aWZpZXIuanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3QvSXNWYWxpZFRpbWVab25lTmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvZWNtYTQwMi1hYnN0cmFjdC9Jc1dlbGxGb3JtZWRDdXJyZW5jeUNvZGUuanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3QvSXNXZWxsRm9ybWVkVW5pdElkZW50aWZpZXIuanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3QvTG9va3VwTWF0Y2hlci5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvZWNtYTQwMi1hYnN0cmFjdC9Mb29rdXBTdXBwb3J0ZWRMb2NhbGVzLmpzIiwibm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9lY21hNDAyLWFic3RyYWN0L051bWJlckZvcm1hdC9Db21wdXRlRXhwb25lbnQuanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3QvTnVtYmVyRm9ybWF0L0NvbXB1dGVFeHBvbmVudEZvck1hZ25pdHVkZS5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvZWNtYTQwMi1hYnN0cmFjdC9OdW1iZXJGb3JtYXQvQ3VycmVuY3lEaWdpdHMuanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3QvTnVtYmVyRm9ybWF0L0Zvcm1hdE51bWVyaWNUb1BhcnRzLmpzIiwibm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9lY21hNDAyLWFic3RyYWN0L051bWJlckZvcm1hdC9Gb3JtYXROdW1lcmljVG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3QvTnVtYmVyRm9ybWF0L0luaXRpYWxpemVOdW1iZXJGb3JtYXQuanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3QvTnVtYmVyRm9ybWF0L1BhcnRpdGlvbk51bWJlclBhdHRlcm4uanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3QvTnVtYmVyRm9ybWF0L1NldE51bWJlckZvcm1hdERpZ2l0T3B0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvZWNtYTQwMi1hYnN0cmFjdC9OdW1iZXJGb3JtYXQvU2V0TnVtYmVyRm9ybWF0VW5pdE9wdGlvbnMuanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3QvTnVtYmVyRm9ybWF0L1RvUmF3Rml4ZWQuanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3QvTnVtYmVyRm9ybWF0L1RvUmF3UHJlY2lzaW9uLmpzIiwibm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9lY21hNDAyLWFic3RyYWN0L051bWJlckZvcm1hdC9kaWdpdC1tYXBwaW5nLmpzb24iLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3QvTnVtYmVyRm9ybWF0L2Zvcm1hdF90b19wYXJ0cy5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvZWNtYTQwMi1hYnN0cmFjdC9QYXJ0aXRpb25QYXR0ZXJuLmpzIiwibm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9lY21hNDAyLWFic3RyYWN0L1BsdXJhbFJ1bGVzL0dldE9wZXJhbmRzLmpzIiwibm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9lY21hNDAyLWFic3RyYWN0L1BsdXJhbFJ1bGVzL0luaXRpYWxpemVQbHVyYWxSdWxlcy5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvZWNtYTQwMi1hYnN0cmFjdC9QbHVyYWxSdWxlcy9SZXNvbHZlUGx1cmFsLmpzIiwibm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9lY21hNDAyLWFic3RyYWN0L1JlbGF0aXZlVGltZUZvcm1hdC9Gb3JtYXRSZWxhdGl2ZVRpbWUuanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3QvUmVsYXRpdmVUaW1lRm9ybWF0L0Zvcm1hdFJlbGF0aXZlVGltZVRvUGFydHMuanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3QvUmVsYXRpdmVUaW1lRm9ybWF0L0luaXRpYWxpemVSZWxhdGl2ZVRpbWVGb3JtYXQuanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3QvUmVsYXRpdmVUaW1lRm9ybWF0L01ha2VQYXJ0c0xpc3QuanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3QvUmVsYXRpdmVUaW1lRm9ybWF0L1BhcnRpdGlvblJlbGF0aXZlVGltZVBhdHRlcm4uanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3QvUmVsYXRpdmVUaW1lRm9ybWF0L1Npbmd1bGFyUmVsYXRpdmVUaW1lVW5pdC5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvZWNtYTQwMi1hYnN0cmFjdC9SZXNvbHZlTG9jYWxlLmpzIiwibm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9lY21hNDAyLWFic3RyYWN0L1N1cHBvcnRlZExvY2FsZXMuanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3QvVW5pY29kZUV4dGVuc2lvblZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9lY21hNDAyLWFic3RyYWN0L2RhdGEuanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3QvdHlwZXMvZGF0ZS10aW1lLmpzIiwibm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9lY21hNDAyLWFic3RyYWN0L3R5cGVzL2Rpc3BsYXluYW1lcy5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvZWNtYTQwMi1hYnN0cmFjdC91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvaW50bC1kaXNwbGF5bmFtZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtZGlzcGxheW5hbWVzL2xvY2FsZS1kYXRhL2VuLmpzIiwibm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9pbnRsLWRpc3BsYXluYW1lcy9wb2x5ZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvaW50bC1kaXNwbGF5bmFtZXMvc2hvdWxkLXBvbHlmaWxsLmpzIiwibm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9pbnRsLWdldGNhbm9uaWNhbGxvY2FsZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtZ2V0Y2Fub25pY2FsbG9jYWxlcy9zcmMvY2Fub25pY2FsaXplci5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvaW50bC1nZXRjYW5vbmljYWxsb2NhbGVzL3NyYy9kYXRhL2FsaWFzZXMuanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtZ2V0Y2Fub25pY2FsbG9jYWxlcy9zcmMvZW1pdHRlci5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvaW50bC1nZXRjYW5vbmljYWxsb2NhbGVzL3NyYy9wYXJzZXIuanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtbG9jYWxlL2dldF9pbnRlcm5hbF9zbG90cy5qcyIsIm5vZGVfbW9kdWxlcy9AZm9ybWF0anMvaW50bC1sb2NhbGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtbG9jYWxlL3BvbHlmaWxsLmpzIiwibm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9pbnRsLWxvY2FsZS9zaG91bGQtcG9seWZpbGwuanMiLCJub2RlX21vZHVsZXMvY2xkci1jb3JlL3N1cHBsZW1lbnRhbC9saWtlbHlTdWJ0YWdzLmpzb24iLCJub2RlX21vZHVsZXMvbHV4b24vYnVpbGQvY2pzLWJyb3dzZXIvbHV4b24uanMiLCJub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbG5DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzMERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JtUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llcyAqL1xucmVxdWlyZSgnQGZvcm1hdGpzL2ludGwtbG9jYWxlL3BvbHlmaWxsJyk7XG5yZXF1aXJlKCdAZm9ybWF0anMvaW50bC1kaXNwbGF5bmFtZXMvcG9seWZpbGwnKTtcbnJlcXVpcmUoJ0Bmb3JtYXRqcy9pbnRsLWRpc3BsYXluYW1lcy9sb2NhbGUtZGF0YS9lbicpO1xucmVxdWlyZSgnQGZvcm1hdGpzL2ludGwtZ2V0Y2Fub25pY2FsbG9jYWxlcycpO1xuXG5jb25zdCB7IExvY2FsZSB9ID0gcmVxdWlyZSgnLi4vbGliL0xvY2FsZScpO1xuY29uc3QgeyBFbnZpcm9ubWVudCB9ID0gcmVxdWlyZSgnLi4vbGliL0Vudmlyb25tZW50Jyk7XG5jb25zdCB7IENhbGVuZGFyIH0gPSByZXF1aXJlKCcuLi9saWIvQ2FsZW5kYXInKTtcblxuY29uc3QgWUVBUl9PRkZTRVQgPSAxMDA7XG5cbmNvbnN0IFNUQVJUX0RBVEUgPSBuZXcgRGF0ZSgpO1xuXG5pZiAoRW52aXJvbm1lbnQudGVzdCgpID09PSBmYWxzZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYWxlcnQsIG5vLXVuZGVmXG4gIGFsZXJ0KGBZb3VyIGJyb3dzZXIgbm90IHN1cHBvcnQgSW50bCB3ZWxsLmApO1xufVxuXG5jb25zdCBGT1JNQVRfVE9LRU5TID0gW1xuICAnYScsXG4gICdjJyxcbiAgJ2NjYycsXG4gICdjY2NjJyxcbiAgJ2NjY2NjJyxcbiAgJ2QnLFxuICAnRCcsXG4gICdkZCcsXG4gICdERCcsXG4gICdEREQnLFxuICAnRERERCcsXG4gICdFJyxcbiAgJ0VFRScsXG4gICdFRUVFJyxcbiAgJ0VFRUVFJyxcbiAgJ2YnLFxuICAnRicsXG4gICdmZicsXG4gICdGRicsXG4gICdmZmYnLFxuICAnRkZGJyxcbiAgJ2ZmZmYnLFxuICAnRkZGRicsXG4gICdHJyxcbiAgJ0dHJyxcbiAgJ0dHR0dHJyxcbiAgJ2gnLFxuICAnSCcsXG4gICdoaCcsXG4gICdISCcsXG4gICdraycsXG4gICdra2trJyxcbiAgJ0wnLFxuICAnTEwnLFxuICAnTExMJyxcbiAgJ0xMTEwnLFxuICAnTExMTEwnLFxuICAnbScsXG4gICdNJyxcbiAgJ21tJyxcbiAgJ01NJyxcbiAgJ01NTScsXG4gICdNTU1NJyxcbiAgJ01NTU1NJyxcbiAgJ28nLFxuICAnb29vJyxcbiAgJ3EnLFxuICAncXEnLFxuICAnUycsXG4gICdzJyxcbiAgJ3NzJyxcbiAgJ1NTUycsXG4gICd0JyxcbiAgJ1QnLFxuICAndHQnLFxuICAnVFQnLFxuICAndHR0JyxcbiAgJ1RUVCcsXG4gICd0dHR0JyxcbiAgJ1RUVFQnLFxuICAndScsXG4gICdXJyxcbiAgJ1dXJyxcbiAgJ1gnLFxuICAneCcsXG4gICd5JyxcbiAgJ3l5JyxcbiAgJ3l5eXknLFxuICAnWicsXG4gICd6JyxcbiAgJ1paJyxcbiAgJ1paWicsXG4gICdaWlpaJyxcbiAgJ1paWlpaJyxcbl07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXcsIG5vLXVuZGVmXG5uZXcgVnVlKHtcbiAgZWw6ICcjYXBwJyxcbiAgZGF0YToge1xuICAgIGxvY2FsZTogbmV3IExvY2FsZSgnZW4tVVMnKSxcbiAgICBzdXBwb3J0YWJsZTogRW52aXJvbm1lbnQudGVzdCgpLFxuICAgIGZvcm1hdHM6IFtdLFxuICAgIGxhbmc6ICcnLFxuICAgIGNvdW50cnk6ICcnLFxuICAgIGNhbGVuZGFyOiAnJyxcbiAgICB5ZWFyOiAwLFxuICAgIG1vbnRoOiBTVEFSVF9EQVRFLFxuICAgIGhlYWRzOiBbXSxcbiAgICB3ZWVrczogW10sXG4gICAgeWVhcnM6IFtdLFxuICAgIG1vbnRoTGlzdDogW10sXG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5kYXRlID0gU1RBUlRfREFURTtcblxuICAgIHRoaXMubG9jYWxlID0gbmV3IExvY2FsZSgnZW4tVVMnKTtcbiAgICB0aGlzLmxhbmcgPSB0aGlzLmxvY2FsZS5nZXRMYW5ndWFnZUNvZGUoKTtcbiAgICB0aGlzLmNvdW50cnkgPSB0aGlzLmxvY2FsZS5nZXRDb3VudHJ5Q29kZSgpO1xuICAgIHRoaXMuY2FsZW5kYXIgPSB0aGlzLmxvY2FsZS5nZXRDYWxlbmRhcigpO1xuXG4gICAgdGhpcy5jYWxlbmRhck9iamVjdCA9IG5ldyBDYWxlbmRhcih0aGlzLmRhdGUsIHRoaXMubG9jYWxlKTtcbiAgICB0aGlzLmhlYWRzID0gdGhpcy5jYWxlbmRhck9iamVjdC5kYXlXZWVrTGlzdCgpLmhlYWRzO1xuICAgIHRoaXMud2Vla3MgPSB0aGlzLmNhbGVuZGFyT2JqZWN0LmRheVdlZWtMaXN0KCkud2Vla3M7XG4gICAgdGhpcy55ZWFycyA9IHRoaXMuY2FsZW5kYXJPYmplY3QueWVhckxpc3QoWUVBUl9PRkZTRVQpO1xuICAgIHRoaXMueWVhciA9IHRoaXMueWVhcnMuZmluZCgoeSkgPT4geS5zZWxlY3RlZCkuaWQ7XG4gICAgdGhpcy5tb250aExpc3QgPSB0aGlzLmNhbGVuZGFyT2JqZWN0Lm1vbnRoTGlzdCgpO1xuICAgIHRoaXMubW9udGggPSB0aGlzLm1vbnRoTGlzdC5maW5kKChtKSA9PiBtLnNlbGVjdGVkKS5pZDtcbiAgfSxcbiAgY29tcHV0ZWQ6IHt9LFxuICBtZXRob2RzOiB7XG4gICAgc2V0SW5wdXREYXRlKCkge1xuICAgICAgdGhpcy5kcmF3Q2FsZW5kYXIoKTtcbiAgICB9LFxuICAgIGRyYXdDYWxlbmRhcigpIHtcbiAgICAgIHRoaXMuY2FsZW5kYXJPYmplY3QgPSBuZXcgQ2FsZW5kYXIodGhpcy5kYXRlLCB0aGlzLmxvY2FsZSk7XG4gICAgICB0aGlzLmhlYWRzID0gdGhpcy5jYWxlbmRhck9iamVjdC5kYXlXZWVrTGlzdCgpLmhlYWRzO1xuICAgICAgdGhpcy53ZWVrcyA9IHRoaXMuY2FsZW5kYXJPYmplY3QuZGF5V2Vla0xpc3QoKS53ZWVrcztcbiAgICAgIHRoaXMueWVhcnMgPSB0aGlzLmNhbGVuZGFyT2JqZWN0LnllYXJMaXN0KFlFQVJfT0ZGU0VUKTtcbiAgICAgIHRoaXMueWVhciA9IHRoaXMueWVhcnMuZmluZCgoeSkgPT4geS5zZWxlY3RlZCkuaWQ7XG4gICAgICB0aGlzLm1vbnRoTGlzdCA9IHRoaXMuY2FsZW5kYXJPYmplY3QubW9udGhMaXN0KCk7XG4gICAgICB0aGlzLm1vbnRoID0gdGhpcy5tb250aExpc3QuZmluZCgobSkgPT4gbS5zZWxlY3RlZCkuaWQ7XG4gICAgICBjb25zdCBmb3JtYXRzID0gW107XG4gICAgICBGT1JNQVRfVE9LRU5TLmZvckVhY2goKHRva2VuKSA9PiB7XG4gICAgICAgIGZvcm1hdHMucHVzaCh7XG4gICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgc3RyaW5nOiB0aGlzLmNhbGVuZGFyT2JqZWN0LmZvcm1hdCh0b2tlbiwgdGhpcy5kYXRlKSxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZm9ybWF0cyA9IGZvcm1hdHM7XG4gICAgfSxcblxuICAgIGNoYW5nZUxhbmcoKSB7XG4gICAgICB0aGlzLmxvY2FsZSA9IG5ldyBMb2NhbGUodGhpcy5sYW5nKTtcbiAgICAgIHRoaXMubGFuZyA9IHRoaXMubG9jYWxlLmdldExhbmd1YWdlQ29kZSgpO1xuICAgICAgdGhpcy5jb3VudHJ5ID0gdGhpcy5sb2NhbGUuZ2V0Q291bnRyeUNvZGUoKTtcbiAgICAgIHRoaXMuY2FsZW5kYXIgPSB0aGlzLmxvY2FsZS5nZXRDYWxlbmRhcigpO1xuXG4gICAgICBpZiAodGhpcy5sb2NhbGUuaXNSVEwoKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaHRtbCcpLnNldEF0dHJpYnV0ZSgnZGlyJywgJ3J0bCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2h0bWwnKS5zZXRBdHRyaWJ1dGUoJ2RpcicsICdsdHInKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kcmF3Q2FsZW5kYXIoKTtcbiAgICB9LFxuICAgIGNoYW5nZUNvdW50cnkoKSB7XG4gICAgICB0aGlzLmxvY2FsZS5zZXRDb3VudHJ5KHRoaXMuY291bnRyeSk7XG4gICAgICB0aGlzLmRyYXdDYWxlbmRhcigpO1xuICAgIH0sXG4gICAgY2hhbmdlQ2FsZW5kYXIoKSB7XG4gICAgICB0aGlzLmxvY2FsZS5zZXRDYWxlbmRhcih0aGlzLmNhbGVuZGFyKTtcbiAgICAgIHRoaXMuZHJhd0NhbGVuZGFyKCk7XG4gICAgfSxcbiAgICB5ZWFyQ2hhbmdlKCkge1xuICAgICAgdGhpcy5jYWxlbmRhck9iamVjdC55ZWFySnVtcCh0aGlzLnllYXIpO1xuICAgICAgdGhpcy5kYXRlID0gdGhpcy5jYWxlbmRhck9iamVjdC5nZXREYXRlKCk7XG4gICAgICB0aGlzLmRyYXdDYWxlbmRhcigpO1xuICAgIH0sXG4gICAgbW9udGhDaGFuZ2UoKSB7XG4gICAgICB0aGlzLmRhdGUgPSB0aGlzLm1vbnRoO1xuICAgICAgdGhpcy5kcmF3Q2FsZW5kYXIoKTtcbiAgICB9LFxuICAgIHllYXJTaGlmdChuZXh0ID0gdHJ1ZSkge1xuICAgICAgdGhpcy5kYXRlID0gdGhpcy5jYWxlbmRhck9iamVjdC55ZWFyU2hpZnQobmV4dCkuZ2V0RGF0ZSgpO1xuICAgICAgdGhpcy5kcmF3Q2FsZW5kYXIoKTtcbiAgICB9LFxuICAgIG1vbnRoU2hpZnQobmV4dCA9IHRydWUpIHtcbiAgICAgIHRoaXMuZGF0ZSA9IHRoaXMuY2FsZW5kYXJPYmplY3QubW9udGhTaGlmdChuZXh0KS5nZXREYXRlKCk7XG4gICAgICB0aGlzLmRyYXdDYWxlbmRhcigpO1xuICAgIH0sXG4gICAgZGF5U2hpZnQobmV4dCA9IHRydWUpIHtcbiAgICAgIHRoaXMuZGF0ZSA9IHRoaXMuY2FsZW5kYXJPYmplY3QuZGF5U2hpZnQobmV4dCkuZ2V0RGF0ZSgpO1xuICAgICAgdGhpcy5kcmF3Q2FsZW5kYXIoKTtcbiAgICB9LFxuICB9LFxufSk7XG4iLCJjb25zdCBsdXhvbiA9IHJlcXVpcmUoJ2x1eG9uJyk7XG5cbmNvbnN0IHsgTG9jYWxlIH0gPSByZXF1aXJlKCcuL0xvY2FsZScpO1xuXG5jb25zdCBncm91cEJ5ID0gKGl0ZW1zLCBrZXkpID0+XG4gIGl0ZW1zLnJlZHVjZShcbiAgICAocmVzdWx0LCBpdGVtKSA9PiAoe1xuICAgICAgLi4ucmVzdWx0LFxuICAgICAgW2l0ZW1ba2V5XV06IFsuLi4ocmVzdWx0W2l0ZW1ba2V5XV0gfHwgW10pLCBpdGVtXSxcbiAgICB9KSxcbiAgICB7fSxcbiAgKTtcblxuY2xhc3MgQ2FsZW5kYXIge1xuICBjb25zdHJ1Y3RvcihkYXRlID0gbmV3IERhdGUoKSwgbG9jYWxlID0gbmV3IExvY2FsZSgnZW4nKSkge1xuICAgIHRoaXMuc2V0TG9jYWxlKGxvY2FsZSk7XG4gICAgdGhpcy5zZXREYXRlKGRhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtpbXBvcnQoJy4vTG9jYWxlJykuTG9jYWxlfVxuICAgKi9cbiAgZ2V0TG9jYWxlKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9Mb2NhbGUnKS5Mb2NhbGV9IGxvY2FsZVxuICAgKiBAcmV0dXJucyB7Q2FsZW5kYXJ9XG4gICAqL1xuICBzZXRMb2NhbGUobG9jYWxlKSB7XG4gICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge0RhdGV9XG4gICAqL1xuICBnZXREYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtEYXRlfSBkYXRlXG4gICAqIEByZXR1cm5zIHtDYWxlbmRhcn1cbiAgICovXG4gIHNldERhdGUoZGF0ZSkge1xuICAgIHRoaXMuZGF0ZSA9IGRhdGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdFxuICAgKiBAcGFyYW0ge0RhdGV9IGRhdGVcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgZm9ybWF0KGZvcm1hdCwgZGF0ZSA9IHRoaXMuZGF0ZSkge1xuICAgIHJldHVybiBsdXhvbi5EYXRlVGltZS5mcm9tSlNEYXRlKGRhdGUpXG4gICAgICAucmVjb25maWd1cmUoe1xuICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLnRvU3RyaW5nKCksXG4gICAgICAgIG91dHB1dENhbGVuZGFyOiB0aGlzLmxvY2FsZS5nZXRDYWxlbmRhcigpLFxuICAgICAgfSlcbiAgICAgIC50b0Zvcm1hdChmb3JtYXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nW119IHRva2Vuc1xuICAgKiBAcGFyYW0ge0RhdGV9IGRhdGVcbiAgICogQHJldHVybnMge051bWJlcltdfVxuICAgKi9cbiAgdG9rZW5pemUodG9rZW5zLCBkYXRlID0gdGhpcy5kYXRlKSB7XG4gICAgcmV0dXJuIGx1eG9uLkRhdGVUaW1lLmZyb21KU0RhdGUoZGF0ZSlcbiAgICAgIC5yZWNvbmZpZ3VyZSh7XG4gICAgICAgIG91dHB1dENhbGVuZGFyOiB0aGlzLmxvY2FsZS5nZXRDYWxlbmRhcigpLFxuICAgICAgICBsb2NhbGU6ICdlbi1VUycsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbTogJ2xhdG4nLFxuICAgICAgfSlcbiAgICAgIC50b0Zvcm1hdCh0b2tlbnMuam9pbignICcpKVxuICAgICAgLnNwbGl0KCcgJylcbiAgICAgIC5tYXAoKHApID0+IHBhcnNlSW50KHAsIDEwKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuICAgKiBAcmV0dXJucyB7e2lkOiBOdW1iZXIsIHNlbGVjdGVkOiBCb29sZWFuLCB0aXRsZTogU3RyaW5nfVtdfVxuICAgKi9cbiAgeWVhckxpc3QobGVuZ3RoID0gMTApIHtcbiAgICBjb25zdCBbY3VycmVudFllYXJdID0gdGhpcy50b2tlbml6ZShbJ3l5eXknXSwgdGhpcy5kYXRlKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gLWxlbmd0aDsgaSA8PSBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3QgaWQgPSBjdXJyZW50WWVhciArIGk7XG4gICAgICBpZiAoaWQgPj0gMCkge1xuICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgc2VsZWN0ZWQ6IGlkID09PSBjdXJyZW50WWVhcixcbiAgICAgICAgICB0aXRsZTogdGhpcy5sb2NhbGUubnVtYmVyRm9ybWF0KGlkKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRheU9mZnNldFxuICAgKiBAcGFyYW0ge051bWJlcn0gd2FudGVkWWVhclxuICAgKiBAcGFyYW0ge051bWJlcn0gY3VycmVudE1vbnRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjdXJyZW50RGF5XG4gICAqIEByZXR1cm5zIHtEYXRlfG51bGx9XG4gICAqL1xuICB5ZWFyT2Zmc2V0U2VlayhkYXlPZmZzZXQsIHdhbnRlZFllYXIsIGN1cnJlbnRNb250aCwgY3VycmVudERheSkge1xuICAgIGNvbnN0IGR0ID0gbHV4b24uRGF0ZVRpbWUuZnJvbUpTRGF0ZSh0aGlzLmRhdGUpLnBsdXMoeyBkYXk6IGRheU9mZnNldCB9KTtcbiAgICBjb25zdCBbaXRlcmF0ZVllYXIsIGl0ZXJhdGVNb250aCwgaXRlcmF0ZURheV0gPSB0aGlzLnRva2VuaXplKFxuICAgICAgWyd5eXl5JywgJ00nLCAnZCddLFxuICAgICAgZHQudG9KU0RhdGUoKSxcbiAgICApO1xuICAgIGlmIChcbiAgICAgIGl0ZXJhdGVZZWFyID09PSB3YW50ZWRZZWFyICYmXG4gICAgICBpdGVyYXRlTW9udGggPT09IGN1cnJlbnRNb250aCAmJlxuICAgICAgaXRlcmF0ZURheSA9PT0gY3VycmVudERheVxuICAgICkge1xuICAgICAgcmV0dXJuIGR0LnRvSlNEYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3YW50ZWRZZWFyXG4gICAqIEByZXR1cm5zIHtDYWxlbmRhcn1cbiAgICovXG4gIHllYXJKdW1wKHdhbnRlZFllYXIpIHtcbiAgICBjb25zdCBbY3VycmVudFllYXIsIGN1cnJlbnRNb250aCwgY3VycmVudERheV0gPSB0aGlzLnRva2VuaXplKFxuICAgICAgWyd5eXl5JywgJ00nLCAnZCddLFxuICAgICAgdGhpcy5kYXRlLFxuICAgICk7XG5cbiAgICBpZiAod2FudGVkWWVhciA9PT0gY3VycmVudFllYXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGU7XG4gICAgfVxuXG4gICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5hYnMoY3VycmVudFllYXIgLSB3YW50ZWRZZWFyKSAqIDM3MztcblxuICAgIGlmICh3YW50ZWRZZWFyID4gY3VycmVudFllYXIpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG9mZnNldDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSB0aGlzLnllYXJPZmZzZXRTZWVrKFxuICAgICAgICAgIGksXG4gICAgICAgICAgd2FudGVkWWVhcixcbiAgICAgICAgICBjdXJyZW50TW9udGgsXG4gICAgICAgICAgY3VycmVudERheSxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGRhdGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXREYXRlKGRhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSB0aGlzLnllYXJPZmZzZXRTZWVrKFxuICAgICAgICAgIC1pLFxuICAgICAgICAgIHdhbnRlZFllYXIsXG4gICAgICAgICAgY3VycmVudE1vbnRoLFxuICAgICAgICAgIGN1cnJlbnREYXksXG4gICAgICAgICk7XG4gICAgICAgIGlmIChkYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2V0RGF0ZShkYXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtCb29sZWFufSBuZXh0XG4gICAqIEByZXR1cm4ge0xvY2FsZX1cbiAgICovXG4gIHllYXJTaGlmdChuZXh0ID0gdHJ1ZSkge1xuICAgIGNvbnN0IFtjdXJyZW50WWVhcl0gPSB0aGlzLnRva2VuaXplKFsneXl5eSddLCB0aGlzLmRhdGUpO1xuICAgIHJldHVybiB0aGlzLnllYXJKdW1wKG5leHQgPyBjdXJyZW50WWVhciArIDEgOiBjdXJyZW50WWVhciAtIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHt7aWQ6IERhdGUsIHNlbGVjdGVkOiBCb29sZWFuLCB0aXRsZTogU3RyaW5nLCB0aXRsZU51bWJlcjogU3RyaW5nLCB0aXRsZUludDogTnVtYmVyfVtdfVxuICAgKi9cbiAgbW9udGhMaXN0KCkge1xuICAgIGNvbnN0IFtjdXJyZW50WWVhciwgY3VycmVudE1vbnRoLCBjdXJyZW50RGF5XSA9IHRoaXMudG9rZW5pemUoXG4gICAgICBbJ3l5eXknLCAnTScsICdkJ10sXG4gICAgICB0aGlzLmRhdGUsXG4gICAgKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gLTM5NzsgaSA8PSAzOTc7IGkgKz0gMSkge1xuICAgICAgY29uc3QgZHQgPSBsdXhvbi5EYXRlVGltZS5mcm9tSlNEYXRlKHRoaXMuZGF0ZSkucGx1cyh7IGRheTogaSB9KTtcbiAgICAgIGNvbnN0IFtpdGVyYXRlWWVhciwgLCBpdGVyYXRlRGF5XSA9IHRoaXMudG9rZW5pemUoXG4gICAgICAgIFsneXl5eScsICdNJywgJ2QnXSxcbiAgICAgICAgZHQudG9KU0RhdGUoKSxcbiAgICAgICk7XG4gICAgICBpZiAoaXRlcmF0ZVllYXIgPT09IGN1cnJlbnRZZWFyICYmIGN1cnJlbnREYXkgPT09IGl0ZXJhdGVEYXkpIHtcbiAgICAgICAgY29uc3QgW3RpdGxlSW50XSA9IHRoaXMudG9rZW5pemUoWydNJ10sIGR0LnRvSlNEYXRlKCkpO1xuXG4gICAgICAgIGNvbnN0IGRhdGUgPSBkdC50b0pTRGF0ZSgpO1xuXG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICBpZDogZGF0ZSxcbiAgICAgICAgICBzZWxlY3RlZDogdGl0bGVJbnQgPT09IGN1cnJlbnRNb250aCxcbiAgICAgICAgICB0aXRsZTogdGhpcy5mb3JtYXQoJ01NTU0nLCBkdC50b0pTRGF0ZSgpKSxcbiAgICAgICAgICB0aXRsZU51bWJlcjogdGhpcy5mb3JtYXQoJ00nLCBkdC50b0pTRGF0ZSgpKSxcbiAgICAgICAgICB0aXRsZUludCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtCb29sZWFufSBuZXh0XG4gICAqIEByZXR1cm4ge0xvY2FsZX1cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzb25hcmpzL2NvZ25pdGl2ZS1jb21wbGV4aXR5XG4gIG1vbnRoU2hpZnQobmV4dCA9IHRydWUpIHtcbiAgICBjb25zdCBbY3VycmVudFllYXIsIGN1cnJlbnRNb250aCwgY3VycmVudERheV0gPSB0aGlzLnRva2VuaXplKFxuICAgICAgWyd5eXl5JywgJ00nLCAnZCddLFxuICAgICAgdGhpcy5kYXRlLFxuICAgICk7XG4gICAgLy8gY29uc3QgZGVzaXJlTW9udGggPSB1cCA/IGN1cnJlbnRZZWFyXG4gICAgZm9yIChsZXQgaSA9IC0zODsgaSA8PSAzODsgaSArPSAxKSB7XG4gICAgICBjb25zdCBkdCA9IGx1eG9uLkRhdGVUaW1lLmZyb21KU0RhdGUodGhpcy5kYXRlKS5wbHVzKHsgZGF5OiBpIH0pO1xuICAgICAgY29uc3QgZGF0ZSA9IGR0LnRvSlNEYXRlKCk7XG4gICAgICBjb25zdCBbaXRlcmF0ZVllYXIsIGl0ZXJhdGVNb250aCwgaXRlcmF0ZURheV0gPSB0aGlzLnRva2VuaXplKFxuICAgICAgICBbJ3l5eXknLCAnTScsICdkJ10sXG4gICAgICAgIGRhdGUsXG4gICAgICApO1xuICAgICAgaWYgKGl0ZXJhdGVEYXkgIT09IGN1cnJlbnREYXkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgaWYgKGl0ZXJhdGVZZWFyID4gY3VycmVudFllYXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXREYXRlKGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVyYXRlTW9udGggPiBjdXJyZW50TW9udGgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXREYXRlKGRhdGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXRlcmF0ZVllYXIgPCBjdXJyZW50WWVhcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNldERhdGUoZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZXJhdGVNb250aCA8IGN1cnJlbnRNb250aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNldERhdGUoZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtCb29sZWFufSBuZXh0XG4gICAqIEByZXR1cm4ge0xvY2FsZX1cbiAgICovXG4gIGRheVNoaWZ0KG5leHQgPSB0cnVlKSB7XG4gICAgY29uc3QgZHQgPSBsdXhvbi5EYXRlVGltZS5mcm9tSlNEYXRlKHRoaXMuZGF0ZSkucGx1cyh7XG4gICAgICBkYXk6IG5leHQgPyAxIDogLTEsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuc2V0RGF0ZShkdC50b0pTRGF0ZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7e2lkOiBEYXRlLCB3ZWVrRGF5OiBOdW1iZXIsIHNlbGVjdGVkOiBCb29sZWFuLCB0aXRsZTogU3RyaW5nLCB0aXRsZUludDogTnVtYmVyfVtdfVxuICAgKi9cbiAgZGF5TGlzdCgpIHtcbiAgICBjb25zdCBbY3VycmVudFllYXIsIGN1cnJlbnRNb250aCwgY3VycmVudERheV0gPSB0aGlzLnRva2VuaXplKFxuICAgICAgWyd5eXl5JywgJ00nLCAnZCddLFxuICAgICAgdGhpcy5kYXRlLFxuICAgICk7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IC0zODsgaSA8PSAzODsgaSArPSAxKSB7XG4gICAgICBjb25zdCBkdCA9IGx1eG9uLkRhdGVUaW1lLmZyb21KU0RhdGUodGhpcy5kYXRlKS5wbHVzKHsgZGF5OiBpIH0pO1xuICAgICAgY29uc3QgW2l0ZXJhdGVZZWFyLCBpdGVyYXRlTW9udGgsIGl0ZXJhdGVEYXldID0gdGhpcy50b2tlbml6ZShcbiAgICAgICAgWyd5eXl5JywgJ00nLCAnZCddLFxuICAgICAgICBkdC50b0pTRGF0ZSgpLFxuICAgICAgKTtcbiAgICAgIGlmIChpdGVyYXRlWWVhciA9PT0gY3VycmVudFllYXIgJiYgY3VycmVudE1vbnRoID09PSBpdGVyYXRlTW9udGgpIHtcbiAgICAgICAgY29uc3QgW3RpdGxlSW50XSA9IHRoaXMudG9rZW5pemUoWydkJ10sIGR0LnRvSlNEYXRlKCkpO1xuXG4gICAgICAgIGNvbnN0IGRhdGUgPSBkdC50b0pTRGF0ZSgpO1xuXG4gICAgICAgIGNvbnN0IHV0Y0RheSA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTtcbiAgICAgICAgdXRjRGF5LnNldFVUQ0hvdXJzKDEyLCAwLCAwLCAwKTtcblxuICAgICAgICBjb25zdCBsb2NhbGVEYXRlID0gW1xuICAgICAgICAgIGl0ZXJhdGVZZWFyLFxuICAgICAgICAgIGl0ZXJhdGVNb250aC50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyksXG4gICAgICAgICAgaXRlcmF0ZURheS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyksXG4gICAgICAgIF0uam9pbignLScpO1xuICAgICAgICBjb25zdCBsb2NhbGVUaW1lID0gW1xuICAgICAgICAgIGRhdGUuZ2V0SG91cnMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyksXG4gICAgICAgICAgZGF0ZS5nZXRNaW51dGVzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpLFxuICAgICAgICAgIGRhdGUuZ2V0U2Vjb25kcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKSxcbiAgICAgICAgXS5qb2luKCctJyk7XG5cbiAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgIGlkOiBkYXRlLFxuICAgICAgICAgIHV0Y0RheSxcbiAgICAgICAgICBsb2NhbGVEYXRlVGltZTogYCR7bG9jYWxlRGF0ZX0gJHtsb2NhbGVUaW1lfWAsXG4gICAgICAgICAgd2Vla0RheTogZGF0ZS5nZXREYXkoKSxcbiAgICAgICAgICB3ZWVrRW5kOiB0aGlzLmxvY2FsZS5nZXRXZWVrRW5kcygpLmluY2x1ZGVzKGRhdGUuZ2V0RGF5KCkpLFxuICAgICAgICAgIHNlbGVjdGVkOiB0aXRsZUludCA9PT0gY3VycmVudERheSxcbiAgICAgICAgICB0aXRsZTogdGhpcy5mb3JtYXQoJ2QnLCBkdC50b0pTRGF0ZSgpKSxcbiAgICAgICAgICB0aXRsZUludCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBkYXlXZWVrTGlzdCgpIHtcbiAgICBjb25zdCBkYXlMaXN0ID0gdGhpcy5kYXlMaXN0KCk7XG4gICAgY29uc3QgZGF5cyA9IFtdO1xuICAgIGNvbnN0IHdlZWtEYXlzID0gdGhpcy5sb2NhbGUuZ2V0V2Vla0RheXMoKTtcbiAgICBjb25zdCBbd2Vla1N0YXJ0RGF5XSA9IHdlZWtEYXlzO1xuICAgIGNvbnN0IHdlZWtOYW1lcyA9IHt9O1xuICAgIGxldCB3ZWVrTnVtYmVyID0gMDtcbiAgICBkYXlMaXN0LmZvckVhY2goKGRheSkgPT4ge1xuICAgICAgaWYgKCF3ZWVrTmFtZXNbZGF5LndlZWtEYXldKSB7XG4gICAgICAgIHdlZWtOYW1lc1tkYXkud2Vla0RheV0gPSB7XG4gICAgICAgICAgbG9uZzogdGhpcy5mb3JtYXQoJ0VFRScsIGRheS5pZCksXG4gICAgICAgICAgbmFycm93OiB0aGlzLmZvcm1hdCgnRUVFRUUnLCBkYXkuaWQpLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF5LndlZWtEYXkgPT09IHdlZWtTdGFydERheSkge1xuICAgICAgICB3ZWVrTnVtYmVyICs9IDE7XG4gICAgICB9XG5cbiAgICAgIGRheXMucHVzaCh7XG4gICAgICAgIGlkOiBkYXkuaWQsXG4gICAgICAgIHV0Y0RheTogZGF5LnV0Y0RheSxcbiAgICAgICAgbG9jYWxlRGF0ZVRpbWU6IGRheS5sb2NhbGVEYXRlVGltZSxcbiAgICAgICAgd2Vla0RheTogZGF5LndlZWtEYXksXG4gICAgICAgIHdlZWtFbmQ6IGRheS53ZWVrRW5kLFxuICAgICAgICBzZWxlY3RlZDogZGF5LnNlbGVjdGVkLFxuICAgICAgICB0aXRsZTogZGF5LnRpdGxlLFxuICAgICAgICB0aXRsZUludDogZGF5LnRpdGxlSW50LFxuICAgICAgICB3ZWVrTnVtYmVyLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBoZWFkczogW10sXG4gICAgICB3ZWVrczogW10sXG4gICAgfTtcblxuICAgIHdlZWtEYXlzLmZvckVhY2goKG4pID0+IHtcbiAgICAgIHJlc3VsdC5oZWFkcy5wdXNoKHdlZWtOYW1lc1tuXSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCB3ZWVrc0RheUxpc3QgPSBncm91cEJ5KGRheXMsICd3ZWVrTnVtYmVyJyk7XG5cbiAgICBPYmplY3QudmFsdWVzKHdlZWtzRGF5TGlzdCkuZm9yRWFjaCgod2Vla3MpID0+IHtcbiAgICAgIGNvbnN0IHdlZWsgPSBbZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2VdO1xuICAgICAgd2Vla3MuZm9yRWFjaCgoZGF5KSA9PiB7XG4gICAgICAgIGNvbnN0IHdlZWtEYXlJbmRleCA9IHdlZWtEYXlzLmluZGV4T2YoZGF5LmlkLmdldERheSgpKTtcbiAgICAgICAgd2Vlay5zcGxpY2Uod2Vla0RheUluZGV4LCAxLCB7XG4gICAgICAgICAgaWQ6IGRheS5pZCxcbiAgICAgICAgICB1dGNEYXk6IGRheS51dGNEYXksXG4gICAgICAgICAgbG9jYWxlRGF0ZVRpbWU6IGRheS5sb2NhbGVEYXRlVGltZSxcbiAgICAgICAgICB3ZWVrRGF5OiBkYXkud2Vla0RheSxcbiAgICAgICAgICB3ZWVrRW5kOiBkYXkud2Vla0VuZCxcbiAgICAgICAgICBzZWxlY3RlZDogZGF5LnNlbGVjdGVkLFxuICAgICAgICAgIHRpdGxlOiBkYXkudGl0bGUsXG4gICAgICAgICAgdGl0bGVJbnQ6IGRheS50aXRsZUludCxcbiAgICAgICAgICB3ZWVrTnVtYmVyLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmVzdWx0LndlZWtzLnB1c2god2Vlayk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBDYWxlbmRhciB9O1xuIiwiY2xhc3MgRW52aXJvbm1lbnQge1xuICAvKipcbiAgICogQHN0YXRpY1xuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyB0ZXN0KCkge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2YgSW50bCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBJbnRsLkNvbGxhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdHlwZW9mIEludGwuRGF0ZVRpbWVGb3JtYXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgSW50bC5EYXRlVGltZUZvcm1hdC5wcm90b3R5cGUuZm9ybWF0VG9QYXJ0cyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBJbnRsLkRhdGVUaW1lRm9ybWF0LnByb3RvdHlwZS5yZXNvbHZlZE9wdGlvbnMgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgSW50bC5OdW1iZXJGb3JtYXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgSW50bC5QbHVyYWxSdWxlcyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBJbnRsLkRpc3BsYXlOYW1lcyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBJbnRsLkxpc3RGb3JtYXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgSW50bC5Mb2NhbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgSW50bC5nZXRDYW5vbmljYWxMb2NhbGVzICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdHlwZW9mIEludGwuUmVsYXRpdmVUaW1lRm9ybWF0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgbmV3IEludGwuRGlzcGxheU5hbWVzKCdlbi1VUycsIHsgdHlwZTogJ3JlZ2lvbicgfSkub2YoJ0lSJykgPT09ICdJcmFuJyAmJlxuICAgICAgbmV3IEludGwuRGlzcGxheU5hbWVzKCdlbi1VUycsIHsgdHlwZTogJ2xhbmd1YWdlJyB9KS5vZignZmEnKSA9PT1cbiAgICAgICAgJ1BlcnNpYW4nXG4gICAgKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgRW52aXJvbm1lbnQgfTtcbiIsImNvbnN0IGx1eG9uID0gcmVxdWlyZSgnbHV4b24nKTtcblxuY29uc3QgY291bnRyaWVzID0gcmVxdWlyZSgnLi9jb3VudHJpZXMnKTtcbmNvbnN0IGxhbmd1YWdlcyA9IHJlcXVpcmUoJy4vbGFuZ3VhZ2VzJyk7XG5cbi8qKiBAdHlwZSB7Q2FsZW5kYXJTeXN0ZW1bXX0gKi9cbmNvbnN0IFN1cHBvcnRlZENhbGVuZGFycyA9IFtcbiAgJ2dyZWdvcnknLFxuICAncGVyc2lhbicsXG4gICdpc2xhbWljYycsXG4gICdpc2xhbWljJyxcbiAgJ2J1ZGRoaXN0JyxcbiAgJ2NvcHRpYycsXG4gICdldGhpb2FhJyxcbiAgJ2V0aGlvcGljJyxcbiAgJ2hlYnJldycsXG4gICdpbmRpYW4nLFxuICAnamFwYW5lc2UnLFxuICAncm9jJyxcbl07XG5cbi8qKlxuICogQHR5cGVkZWYgeydidWRkaGlzdCd8J2NvcHRpYyd8J2V0aGlvYWEnfCdldGhpb3BpYyd8J2dyZWdvcnknfCdoZWJyZXcnfCdpbmRpYW4nfCdpc2xhbWljJ3wnaXNsYW1pY2MnfCdqYXBhbmVzZSd8J3BlcnNpYW4nfCdyb2MnfSBDYWxlbmRhclN5c3RlbVxuICogQHR5cGVkZWYgeydhcmFiJ3wnYXJhYmV4dCd8J2JhbGknfCdiZW5nJ3wnZGV2YSd8J2Z1bGx3aWRlJ3wnZ3Vqcid8J2d1cnUnfCdoYW5pZGVjJ3wna2htcid8J2tuZGEnfCdsYW9vJ3wnbGF0bid8J2xpbWInfCdtbHltJ3wnbW9uZyd8J215bXInfCdvcnlhJ3wndGFtbGRlYyd8J3RlbHUnfCd0aGFpJ3wndGlidCd9IE51bWVyaWNTeXN0ZW1UeXBlXG4gKiBAdHlwZWRlZiB7J0FDJ3wnQUQnfCdBRSd8J0FGJ3wnQUcnfCdBSSd8J0FMJ3wnQU0nfCdBTyd8J0FSJ3wnQVMnfCdBVCd8J0FVJ3wnQVcnfCdBWCd8J0FaJ3wnQkEnfCdCQid8J0JEJ3wnQkUnfCdCRid8J0JHJ3wnQkgnfCdCSSd8J0JKJ3wnQkwnfCdCTSd8J0JOJ3wnQk8nfCdCUSd8J0JSJ3wnQlMnfCdCVCd8J0JXJ3wnQlknfCdCWid8J0NBJ3wnQ0MnfCdDRCd8J0NGJ3wnQ0cnfCdDSCd8J0NJJ3wnQ0snfCdDTCd8J0NNJ3wnQ04nfCdDTyd8J0NSJ3wnQ1UnfCdDVid8J0NXJ3wnQ1gnfCdDWSd8J0NaJ3wnREUnfCdERyd8J0RKJ3wnREsnfCdETSd8J0RPJ3wnRFonfCdFQSd8J0VDJ3wnRUUnfCdFRyd8J0VIJ3wnRVInfCdFUyd8J0VUJ3wnRkknfCdGSid8J0ZLJ3wnRk0nfCdGTyd8J0ZSJ3wnR0EnfCdHQid8J0dEJ3wnR0UnfCdHRid8J0dHJ3wnR0gnfCdHSSd8J0dMJ3wnR00nfCdHTid8J0dQJ3wnR1EnfCdHUid8J0dUJ3wnR1UnfCdHVyd8J0dZJ3wnSEsnfCdITid8J0hSJ3wnSFQnfCdIVSd8J0lDJ3wnSUQnfCdJRSd8J0lMJ3wnSU0nfCdJTid8J0lPJ3wnSVEnfCdJUid8J0lTJ3wnSVQnfCdKRSd8J0pNJ3wnSk8nfCdKUCd8J0tFJ3wnS0cnfCdLSCd8J0tJJ3wnS00nfCdLTid8J0tQJ3wnS1InfCdLVyd8J0tZJ3wnS1onfCdMQSd8J0xCJ3wnTEMnfCdMSSd8J0xLJ3wnTFInfCdMUyd8J0xUJ3wnTFUnfCdMVid8J0xZJ3wnTUEnfCdNQyd8J01EJ3wnTUUnfCdNRid8J01HJ3wnTUgnfCdNSyd8J01MJ3wnTU0nfCdNTid8J01PJ3wnTVAnfCdNUSd8J01SJ3wnTVMnfCdNVCd8J01VJ3wnTVYnfCdNVyd8J01YJ3wnTVknfCdNWid8J05BJ3wnTkMnfCdORSd8J05GJ3wnTkcnfCdOSSd8J05MJ3wnTk8nfCdOUCd8J05SJ3wnTlUnfCdOWid8J09NJ3wnUEEnfCdQRSd8J1BGJ3wnUEcnfCdQSCd8J1BLJ3wnUEwnfCdQTSd8J1BOJ3wnUFInfCdQUyd8J1BUJ3wnUFcnfCdQWSd8J1FBJ3wnUkUnfCdSTyd8J1JTJ3wnUlUnfCdSVyd8J1NBJ3wnU0InfCdTQyd8J1NEJ3wnU0UnfCdTRyd8J1NIJ3wnU0knfCdTSid8J1NLJ3wnU0wnfCdTTSd8J1NOJ3wnU08nfCdTUid8J1NTJ3wnU1QnfCdTVid8J1NYJ3wnU1knfCdTWid8J1RBJ3wnVEMnfCdURCd8J1RGJ3wnVEcnfCdUSCd8J1RKJ3wnVEsnfCdUTCd8J1RNJ3wnVE4nfCdUTyd8J1RSJ3wnVFQnfCdUVid8J1RXJ3wnVFonfCdVQSd8J1VHJ3wnVU0nfCdVUyd8J1VZJ3wnVVonfCdWQSd8J1ZDJ3wnVkUnfCdWRyd8J1ZJJ3wnVk4nfCdWVSd8J1dGJ3wnV1MnfCdYSyd8J1lFJ3wnWVQnfCdaQSd8J1pNJ3wnWlcnfSBDb3VudHJ5SVNPQ29kZVxuICogQHR5cGVkZWYgeydhYSd8J2FmJ3wnYXInfCdheid8J2JlJ3wnYmcnfCdiaSd8J2JtJ3wnYm4nfCdicyd8J2NhJ3wnY3MnfCdkYSd8J2RlJ3wnZHYnfCdkeid8J2VsJ3wnZW4nfCdlcyd8J2V0J3wnZmEnfCdmaSd8J2ZvJ3wnZnInfCdnbid8J2hhJ3wnaGUnfCdoaSd8J2hyJ3wnaHQnfCdodSd8J2h5J3wnaWQnfCdpcyd8J2l0J3wnamEnfCdrYSd8J2tsJ3wna20nfCdrbyd8J2t5J3wnbG8nfCdsdCd8J2x2J3wnbWcnfCdtayd8J21uJ3wnbXMnfCdtdCd8J215J3wnbmInfCduZSd8J25sJ3wncGwnfCdwdCd8J3JuJ3wncm8nfCdydSd8J3J3J3wnc2knfCdzayd8J3NsJ3wnc20nfCdzbid8J3NvJ3wnc3EnfCdzcid8J3N0J3wnc3YnfCdzdyd8J3RnJ3wndGgnfCd0aSd8J3RrJ3wndG8nfCd0cid8J3VyJ3wndXonfCd2aSd8J3dvJ3wnemgnfSBMYW5ndWFnZUlTT0NvZGVcbiAqL1xuXG5jbGFzcyBMb2NhbGUge1xuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdHRlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWRlbnRcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBjYWxlbmRhck5hbWUoZm9ybWF0dGVkLCBpZGVudCkge1xuICAgIGNvbnN0IGNhbWVsQ2FzZSA9IGlkZW50LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgaWRlbnQuc2xpY2UoMSk7XG4gICAgaWYgKGZvcm1hdHRlZC5tYXRjaCgvXkVSQS8pIHx8IGZvcm1hdHRlZCA9PT0gJ251bGwnKSB7XG4gICAgICByZXR1cm4gY2FtZWxDYXNlO1xuICAgIH1cbiAgICBpZiAoaWRlbnQgPT09ICdpc2xhbWljYycpIHtcbiAgICAgIHJldHVybiBgJHtmb3JtYXR0ZWR9KGMpYDtcbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdHRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbG9jYWxlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihsb2NhbGUpIHtcbiAgICBjb25zdCBpTG9jYWxlID0gbmV3IEludGwuTG9jYWxlKEludGwuZ2V0Q2Fub25pY2FsTG9jYWxlcyhsb2NhbGUpKTtcbiAgICBjb25zdCBjb3VudHJ5ID0gaUxvY2FsZS5tYXhpbWl6ZSgpLnJlZ2lvbjtcbiAgICB0aGlzLmxhbmd1YWdlID0gaUxvY2FsZS5tYXhpbWl6ZSgpLmxhbmd1YWdlO1xuICAgIHRoaXMuc2V0Q291bnRyeShjb3VudHJ5KTtcbiAgICB0aGlzLm51bWJlcmluZ1N5c3RlbSA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChcbiAgICAgIHRoaXMudG9TdHJpbmcoKSxcbiAgICApLnJlc29sdmVkT3B0aW9ucygpLm51bWJlcmluZ1N5c3RlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMubGFuZ3VhZ2V9LSR7dGhpcy5jb3VudHJ5fWA7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge0xhbmd1YWdlSVNPQ29kZX1cbiAgICovXG4gIGdldExhbmd1YWdlQ29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5sYW5ndWFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Q291bnRyeUlTT0NvZGV9XG4gICAqL1xuICBnZXRDb3VudHJ5Q29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb3VudHJ5O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICBnZXRDb3VudHJ5RmxhZygpIHtcbiAgICByZXR1cm4gdGhpcy5mbGFnO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtDYWxlbmRhcn1cbiAgICovXG4gIGdldENhbGVuZGFyKCkge1xuICAgIHJldHVybiB0aGlzLmNhbGVuZGFyO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgaXNSVEwobGFuZyA9IHRoaXMubGFuZ3VhZ2UpIHtcbiAgICByZXR1cm4gWydhcicsICdkdicsICdmYScsICdoZScsICdwcycsICd1cicsICd5aSddLmluY2x1ZGVzKGxhbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtOdW1lcmljU3lzdGVtfVxuICAgKi9cbiAgZ2V0TnVtYmVyaW5nU3lzdGVtKCkge1xuICAgIHJldHVybiB0aGlzLm51bWJlcmluZ1N5c3RlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyXG4gICAqIEBwYXJhbSB7SW50bC5OdW1iZXJGb3JtYXRPcHRpb25zfSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICBudW1iZXJGb3JtYXQoXG4gICAgbnVtYmVyLFxuICAgIG9wdGlvbnMgPSB7XG4gICAgICB1c2VHcm91cGluZzogZmFsc2UsXG4gICAgfSxcbiAgKSB7XG4gICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KHRoaXMudG9TdHJpbmcoKSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQobnVtYmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RhdGV9IGRhdGUxXG4gICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZTJcbiAgICogQHBhcmFtIHtJbnRsLlJlbGF0aXZlVGltZUZvcm1hdE9wdGlvbnN9IG9wdGlvbnNcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIHJlbGF0aXZlVGltZVN0cmluZyhcbiAgICBkYXRlMSxcbiAgICBkYXRlMiA9IG5ldyBEYXRlKCksXG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHN0eWxlOiAnbmFycm93JyxcbiAgICB9LFxuICApIHtcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQodGhpcy5sYW5ndWFnZSwgb3B0aW9ucyk7XG4gICAgY29uc3QgZGlmZiA9IGRhdGUxIC0gZGF0ZTI7XG4gICAgY29uc3QgZGlmZkFicyA9IE1hdGguYWJzKGRpZmYpO1xuICAgIGNvbnN0IHggPSBkaWZmID4gMCA/IDEgOiAtMTtcblxuICAgIGNvbnN0IG1hdHJpeCA9IHtcbiAgICAgIHllYXI6IDMxNTM2MDAwMDAwLFxuICAgICAgbW9udGg6IDI1OTIwMDAwMDAsXG4gICAgICBkYXk6IDg2NDAwMDAwLFxuICAgICAgaG91cjogMzYwMDAwMCxcbiAgICAgIG1pbnV0ZTogNjAwMDAsXG4gICAgICBzZWNvbmQ6IDEwMDAsXG4gICAgfTtcblxuICAgIGxldCBvdXRwdXQgPSAnJztcblxuICAgIE9iamVjdC5rZXlzKG1hdHJpeCkuZm9yRWFjaCgodW5pdCkgPT4ge1xuICAgICAgY29uc3QgaW50ZXJ2YWwgPSBtYXRyaXhbdW5pdF07XG4gICAgICBpZiAob3V0cHV0ID09PSAnJyAmJiBkaWZmQWJzID4gaW50ZXJ2YWwpIHtcbiAgICAgICAgb3V0cHV0ID0gZm9ybWF0dGVyLmZvcm1hdCh4ICogTWF0aC5yb3VuZChkaWZmQWJzIC8gaW50ZXJ2YWwpLCB1bml0KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb3VudHJ5SVNPQ29kZX0gY291bnRyeVxuICAgKiBAcmV0dXJucyB7TG9jYWxlfVxuICAgKi9cbiAgc2V0Q291bnRyeShjb3VudHJ5KSB7XG4gICAgdGhpcy53ZWVrZGF5cyA9IFsxLCAyLCAzLCA0LCA1LCA2LCAwXTtcbiAgICB0aGlzLndlZWtlbmRzID0gWzYsIDBdO1xuICAgIHRoaXMuZmxhZyA9ICfwn4e/8J+Hvyc7XG4gICAgdGhpcy5jYWxlbmRhciA9ICdncmVnb3J5JztcblxuICAgIGlmIChjb3VudHJpZXNbY291bnRyeV0pIHtcbiAgICAgIHRoaXMuZmxhZyA9IGNvdW50cmllc1tjb3VudHJ5XS5mO1xuXG4gICAgICBpZiAoY291bnRyaWVzW2NvdW50cnldLndkKSB7XG4gICAgICAgIHRoaXMud2Vla2RheXMgPSBjb3VudHJpZXNbY291bnRyeV0ud2Q7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb3VudHJpZXNbY291bnRyeV0ud2UpIHtcbiAgICAgICAgdGhpcy53ZWVrZW5kcyA9IGNvdW50cmllc1tjb3VudHJ5XS53ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvdW50cmllc1tjb3VudHJ5XS5jKSB7XG4gICAgICAgIHRoaXMuY2FsZW5kYXIgPSBjb3VudHJpZXNbY291bnRyeV0uYztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNvdW50cnkgPSBjb3VudHJ5O1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDYWxlbmRhclN5c3RlbX0gY2FsZW5kYXJcbiAgICogQHJldHVybnMge0xvY2FsZX1cbiAgICovXG4gIHNldENhbGVuZGFyKGNhbGVuZGFyKSB7XG4gICAgdGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtOdW1iZXJbXX1cbiAgICovXG4gIGdldFdlZWtEYXlzKCkge1xuICAgIHJldHVybiB0aGlzLndlZWtkYXlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtOdW1iZXJbXX1cbiAgICovXG4gIGdldFdlZWtFbmRzKCkge1xuICAgIHJldHVybiB0aGlzLndlZWtlbmRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3sgaWQ6IENvdW50cnlJU09Db2RlLCBzZWxlY3RlZDogQm9vbGVhbiwgZGVmYXVsdExhbmd1YWdlOiBMYW5ndWFnZUlTT0NvZGUsIGZsYWc6IFN0cmluZywgdGl0bGU6IFN0cmluZywgdGl0bGVOYXRpdmU6IFN0cmluZyB9W119XG4gICAqL1xuICBnZXRDb3VudHJ5TGlzdCgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhjb3VudHJpZXMpLmZvckVhY2goKGNvZGUpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBjb3VudHJpZXNbY29kZV07XG4gICAgICBjb25zdCB0aXRsZSA9IG5ldyBJbnRsLkRpc3BsYXlOYW1lcyhbdGhpcy5sYW5ndWFnZV0sIHtcbiAgICAgICAgdHlwZTogJ3JlZ2lvbicsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHRpdGxlTmF0aXZlID0gbmV3IEludGwuRGlzcGxheU5hbWVzKFtkYXRhLmxdLCB7IHR5cGU6ICdyZWdpb24nIH0pO1xuXG4gICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgIGlkOiBjb2RlLFxuICAgICAgICBzZWxlY3RlZDogdGhpcy5jb3VudHJ5ID09PSBjb2RlLFxuICAgICAgICBkZWZhdWx0TGFuZ3VhZ2U6IGNvZGUubCxcbiAgICAgICAgZmxhZzogZGF0YS5mLFxuICAgICAgICB0aXRsZTogdGl0bGUub2YoY29kZSksXG4gICAgICAgIHRpdGxlTmF0aXZlOiB0aXRsZU5hdGl2ZS5vZihjb2RlKSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7e2lkOiBMYW5ndWFnZUlTT0NvZGUsIHNlbGVjdGVkOiBCb29sZWFuLCBydGw6IEJvb2xlYW4sIHRpdGxlOiBTdHJpbmcsIHRpdGxlTmF0aXZlOiBTdHJpbmd9W119XG4gICAqL1xuICBnZXRMYW5ndWFnZUxpc3QoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGFuZ3VhZ2VzLmZvckVhY2goKGNvZGUpID0+IHtcbiAgICAgIGNvbnN0IHRpdGxlID0gbmV3IEludGwuRGlzcGxheU5hbWVzKFt0aGlzLmxhbmd1YWdlXSwge1xuICAgICAgICB0eXBlOiAnbGFuZ3VhZ2UnLFxuICAgICAgfSk7XG4gICAgICBjb25zdCB0aXRsZU5hdGl2ZSA9IG5ldyBJbnRsLkRpc3BsYXlOYW1lcyhbY29kZV0sIHsgdHlwZTogJ2xhbmd1YWdlJyB9KTtcblxuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICBpZDogY29kZSxcbiAgICAgICAgc2VsZWN0ZWQ6IHRoaXMubGFuZ3VhZ2UgPT09IGNvZGUsXG4gICAgICAgIHJ0bDogdGhpcy5pc1JUTChjb2RlKSxcbiAgICAgICAgdGl0bGU6IHRpdGxlLm9mKGNvZGUpLFxuICAgICAgICB0aXRsZU5hdGl2ZTogdGl0bGVOYXRpdmUub2YoY29kZSksXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3tpZDogQ2FsZW5kYXIsIHNlbGVjdGVkOiBCb29sZWFuLCBsb25nOiBTdHJpbmcsIHNob3J0OiBTdHJpbmd9W119XG4gICAqL1xuICBnZXRDYWxlbmRhckxpc3QoKSB7XG4gICAgcmV0dXJuIFN1cHBvcnRlZENhbGVuZGFycy5tYXAoKGlkZW50KSA9PiB7XG4gICAgICBjb25zdCBkID0gbHV4b24uRGF0ZVRpbWUubG9jYWwoKS5yZWNvbmZpZ3VyZSh7XG4gICAgICAgIGxvY2FsZTogdGhpcy5sYW5ndWFnZSxcbiAgICAgICAgb3V0cHV0Q2FsZW5kYXI6IGlkZW50LFxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogaWRlbnQsXG4gICAgICAgIHNlbGVjdGVkOiB0aGlzLmNhbGVuZGFyID09PSBpZGVudCxcbiAgICAgICAgdGl0bGU6IHRoaXMuY29uc3RydWN0b3IuY2FsZW5kYXJOYW1lKGQudG9Gb3JtYXQoJ0dHJyksIGlkZW50KSxcbiAgICAgICAgdGl0bGVTaG9ydDogdGhpcy5jb25zdHJ1Y3Rvci5jYWxlbmRhck5hbWUoZC50b0Zvcm1hdCgnRycpLCBpZGVudCksXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBMb2NhbGUsIFN1cHBvcnRlZENhbGVuZGFycyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFDOiB7IGY6ICfwn4em8J+HqCcsIGw6ICdlbicgfSxcbiAgQUQ6IHsgZjogJ/Cfh6bwn4epJywgbDogJ2NhJyB9LFxuICBBRTogeyBmOiAn8J+HpvCfh6onLCBsOiAnYXInLCB3ZDogWzYsIDAsIDEsIDIsIDMsIDQsIDVdLCB3ZTogWzUsIDZdIH0sXG4gIEFGOiB7IGY6ICfwn4em8J+HqycsIGw6ICdmYScsIGM6ICdwZXJzaWFuJywgd2Q6IFs2LCAwLCAxLCAyLCAzLCA0LCA1XSwgd2U6IFs0LCA1XSB9LFxuICBBRzogeyBmOiAn8J+HpvCfh6wnLCBsOiAnZW4nLCB3ZDogWzAsIDEsIDIsIDMsIDQsIDUsIDZdIH0sXG4gIEFJOiB7IGY6ICfwn4em8J+HricsIGw6ICdlbicgfSxcbiAgQUw6IHsgZjogJ/Cfh6bwn4exJywgbDogJ3NxJyB9LFxuICBBTTogeyBmOiAn8J+HpvCfh7InLCBsOiAnaHknIH0sXG4gIEFPOiB7IGY6ICfwn4em8J+HtCcsIGw6ICdwdCcgfSxcbiAgQVI6IHsgZjogJ/Cfh6bwn4e3JywgbDogJ2VzJyB9LFxuICBBUzogeyBmOiAn8J+HpvCfh7gnLCBsOiAnZW4nLCB3ZDogWzAsIDEsIDIsIDMsIDQsIDUsIDZdIH0sXG4gIEFUOiB7IGY6ICfwn4em8J+HuScsIGw6ICdkZScgfSxcbiAgQVU6IHsgZjogJ/Cfh6bwn4e6JywgbDogJ2VuJywgd2Q6IFswLCAxLCAyLCAzLCA0LCA1LCA2XSB9LFxuICBBVzogeyBmOiAn8J+HpvCfh7wnLCBsOiAnbmwnIH0sXG4gIEFYOiB7IGY6ICfwn4em8J+HvScsIGw6ICdzdicgfSxcbiAgQVo6IHsgZjogJ/Cfh6bwn4e/JywgbDogJ2F6JyB9LFxuICBCQTogeyBmOiAn8J+Hp/Cfh6YnLCBsOiAnYnMnIH0sXG4gIEJCOiB7IGY6ICfwn4en8J+HpycsIGw6ICdlbicgfSxcbiAgQkQ6IHsgZjogJ/Cfh6fwn4epJywgbDogJ2JuJywgd2Q6IFswLCAxLCAyLCAzLCA0LCA1LCA2XSB9LFxuICBCRTogeyBmOiAn8J+Hp/Cfh6onLCBsOiAnZW4nIH0sXG4gIEJGOiB7IGY6ICfwn4en8J+HqycsIGw6ICdmcicgfSxcbiAgQkc6IHsgZjogJ/Cfh6fwn4esJywgbDogJ2JnJyB9LFxuICBCSDogeyBmOiAn8J+Hp/Cfh60nLCBsOiAnYXInLCB3ZDogWzYsIDAsIDEsIDIsIDMsIDQsIDVdLCB3ZTogWzUsIDZdIH0sXG4gIEJJOiB7IGY6ICfwn4en8J+HricsIGw6ICdybicgfSxcbiAgQko6IHsgZjogJ/Cfh6fwn4evJywgbDogJ2ZyJyB9LFxuICBCTDogeyBmOiAn8J+Hp/Cfh7EnLCBsOiAnZnInIH0sXG4gIEJNOiB7IGY6ICfwn4en8J+HsicsIGw6ICdlbicgfSxcbiAgQk46IHsgZjogJ/Cfh6fwn4ezJywgbDogJ21zJyB9LFxuICBCTzogeyBmOiAn8J+Hp/Cfh7QnLCBsOiAnZXMnIH0sXG4gIEJROiB7IGY6ICfwn4en8J+HticsIGw6ICdubCcgfSxcbiAgQlI6IHsgZjogJ/Cfh6fwn4e3JywgbDogJ3B0Jywgd2Q6IFswLCAxLCAyLCAzLCA0LCA1LCA2XSB9LFxuICBCUzogeyBmOiAn8J+Hp/Cfh7gnLCBsOiAnZW4nLCB3ZDogWzAsIDEsIDIsIDMsIDQsIDUsIDZdIH0sXG4gIEJUOiB7IGY6ICfwn4en8J+HuScsIGw6ICdkeicsIHdkOiBbMCwgMSwgMiwgMywgNCwgNSwgNl0gfSxcbiAgQlc6IHsgZjogJ/Cfh6fwn4e8JywgbDogJ2VuJywgd2Q6IFswLCAxLCAyLCAzLCA0LCA1LCA2XSB9LFxuICBCWTogeyBmOiAn8J+Hp/Cfh74nLCBsOiAnYmUnIH0sXG4gIEJaOiB7IGY6ICfwn4en8J+HvycsIGw6ICdlbicsIHdkOiBbMCwgMSwgMiwgMywgNCwgNSwgNl0gfSxcbiAgQ0E6IHsgZjogJ/Cfh6jwn4emJywgbDogJ2VuJywgd2Q6IFswLCAxLCAyLCAzLCA0LCA1LCA2XSB9LFxuICBDQzogeyBmOiAn8J+HqPCfh6gnLCBsOiAnZW4nIH0sXG4gIENEOiB7IGY6ICfwn4eo8J+HqScsIGw6ICdmcicgfSxcbiAgQ0Y6IHsgZjogJ/Cfh6jwn4erJywgbDogJ2ZyJyB9LFxuICBDRzogeyBmOiAn8J+HqPCfh6wnLCBsOiAnZnInIH0sXG4gIENIOiB7IGY6ICfwn4eo8J+HrScsIGw6ICdkZScgfSxcbiAgQ0k6IHsgZjogJ/Cfh6jwn4euJywgbDogJ2ZyJyB9LFxuICBDSzogeyBmOiAn8J+HqPCfh7AnLCBsOiAnZW4nIH0sXG4gIENMOiB7IGY6ICfwn4eo8J+HsScsIGw6ICdlcycgfSxcbiAgQ006IHsgZjogJ/Cfh6jwn4eyJywgbDogJ2ZyJyB9LFxuICBDTjogeyBmOiAn8J+HqPCfh7MnLCBsOiAnemgnLCB3ZDogWzAsIDEsIDIsIDMsIDQsIDUsIDZdIH0sXG4gIENPOiB7IGY6ICfwn4eo8J+HtCcsIGw6ICdlcycsIHdkOiBbMCwgMSwgMiwgMywgNCwgNSwgNl0gfSxcbiAgQ1I6IHsgZjogJ/Cfh6jwn4e3JywgbDogJ2VzJyB9LFxuICBDVTogeyBmOiAn8J+HqPCfh7onLCBsOiAnZXMnIH0sXG4gIENWOiB7IGY6ICfwn4eo8J+HuycsIGw6ICdwdCcgfSxcbiAgQ1c6IHsgZjogJ/Cfh6jwn4e8JywgbDogJ25sJyB9LFxuICBDWDogeyBmOiAn8J+HqPCfh70nLCBsOiAnZW4nIH0sXG4gIENZOiB7IGY6ICfwn4eo8J+HvicsIGw6ICdlbCcgfSxcbiAgQ1o6IHsgZjogJ/Cfh6jwn4e/JywgbDogJ2NzJyB9LFxuICBERTogeyBmOiAn8J+HqfCfh6onLCBsOiAnZGUnIH0sXG4gIERHOiB7IGY6ICfwn4ep8J+HrCcsIGw6ICdlbicgfSxcbiAgREo6IHsgZjogJ/Cfh6nwn4evJywgbDogJ2FhJywgd2Q6IFs2LCAwLCAxLCAyLCAzLCA0LCA1XSB9LFxuICBESzogeyBmOiAn8J+HqfCfh7AnLCBsOiAnZGEnIH0sXG4gIERNOiB7IGY6ICfwn4ep8J+HsicsIGw6ICdlbicsIHdkOiBbMCwgMSwgMiwgMywgNCwgNSwgNl0gfSxcbiAgRE86IHsgZjogJ/Cfh6nwn4e0JywgbDogJ2VzJywgd2Q6IFswLCAxLCAyLCAzLCA0LCA1LCA2XSB9LFxuICBEWjogeyBmOiAn8J+HqfCfh78nLCBsOiAnYXInLCB3ZDogWzYsIDAsIDEsIDIsIDMsIDQsIDVdLCB3ZTogWzUsIDZdIH0sXG4gIEVBOiB7IGY6ICfwn4eq8J+HpicsIGw6ICdlcycgfSxcbiAgRUM6IHsgZjogJ/Cfh6rwn4eoJywgbDogJ2VzJyB9LFxuICBFRTogeyBmOiAn8J+HqvCfh6onLCBsOiAnZXQnIH0sXG4gIEVHOiB7IGY6ICfwn4eq8J+HrCcsIGw6ICdhcicsIHdkOiBbNiwgMCwgMSwgMiwgMywgNCwgNV0sIHdlOiBbNSwgNl0gfSxcbiAgRUg6IHsgZjogJ/Cfh6rwn4etJywgbDogJ2FyJyB9LFxuICBFUjogeyBmOiAn8J+HqvCfh7cnLCBsOiAndGknIH0sXG4gIEVTOiB7IGY6ICfwn4eq8J+HuCcsIGw6ICdlcycgfSxcbiAgRVQ6IHsgZjogJ/Cfh6rwn4e5JywgbDogJ2VuJywgd2Q6IFswLCAxLCAyLCAzLCA0LCA1LCA2XSB9LFxuICBGSTogeyBmOiAn8J+Hq/Cfh64nLCBsOiAnZmknIH0sXG4gIEZKOiB7IGY6ICfwn4er8J+HrycsIGw6ICdlbicgfSxcbiAgRks6IHsgZjogJ/Cfh6vwn4ewJywgbDogJ2VuJyB9LFxuICBGTTogeyBmOiAn8J+Hq/Cfh7InLCBsOiAnZW4nIH0sXG4gIEZPOiB7IGY6ICfwn4er8J+HtCcsIGw6ICdmbycgfSxcbiAgRlI6IHsgZjogJ/Cfh6vwn4e3JywgbDogJ2ZyJyB9LFxuICBHQTogeyBmOiAn8J+HrPCfh6YnLCBsOiAnZnInIH0sXG4gIEdCOiB7IGY6ICfwn4es8J+HpycsIGw6ICdlbicgfSxcbiAgR0Q6IHsgZjogJ/Cfh6zwn4epJywgbDogJ2VuJyB9LFxuICBHRTogeyBmOiAn8J+HrPCfh6onLCBsOiAna2EnIH0sXG4gIEdGOiB7IGY6ICfwn4es8J+HqycsIGw6ICdmcicgfSxcbiAgR0c6IHsgZjogJ/Cfh6zwn4esJywgbDogJ2VuJyB9LFxuICBHSDogeyBmOiAn8J+HrPCfh60nLCBsOiAnZW4nIH0sXG4gIEdJOiB7IGY6ICfwn4es8J+HricsIGw6ICdlbicgfSxcbiAgR0w6IHsgZjogJ/Cfh6zwn4exJywgbDogJ2tsJyB9LFxuICBHTTogeyBmOiAn8J+HrPCfh7InLCBsOiAnZW4nIH0sXG4gIEdOOiB7IGY6ICfwn4es8J+HsycsIGw6ICdmcicgfSxcbiAgR1A6IHsgZjogJ/Cfh6zwn4e1JywgbDogJ2ZyJyB9LFxuICBHUTogeyBmOiAn8J+HrPCfh7YnLCBsOiAnZXMnIH0sXG4gIEdSOiB7IGY6ICfwn4es8J+HtycsIGw6ICdlbCcgfSxcbiAgR1Q6IHsgZjogJ/Cfh6zwn4e5JywgbDogJ2VzJywgd2Q6IFswLCAxLCAyLCAzLCA0LCA1LCA2XSB9LFxuICBHVTogeyBmOiAn8J+HrPCfh7onLCBsOiAnZW4nLCB3ZDogWzAsIDEsIDIsIDMsIDQsIDUsIDZdIH0sXG4gIEdXOiB7IGY6ICfwn4es8J+HvCcsIGw6ICdwdCcgfSxcbiAgR1k6IHsgZjogJ/Cfh6zwn4e+JywgbDogJ2VuJyB9LFxuICBISzogeyBmOiAn8J+HrfCfh7AnLCBsOiAnemgnLCB3ZDogWzAsIDEsIDIsIDMsIDQsIDUsIDZdIH0sXG4gIEhOOiB7IGY6ICfwn4et8J+HsycsIGw6ICdlcycsIHdkOiBbMCwgMSwgMiwgMywgNCwgNSwgNl0gfSxcbiAgSFI6IHsgZjogJ/Cfh63wn4e3JywgbDogJ2hyJyB9LFxuICBIVDogeyBmOiAn8J+HrfCfh7knLCBsOiAnaHQnIH0sXG4gIEhVOiB7IGY6ICfwn4et8J+HuicsIGw6ICdodScgfSxcbiAgSUM6IHsgZjogJ/Cfh67wn4eoJywgbDogJ2VzJyB9LFxuICBJRDogeyBmOiAn8J+HrvCfh6knLCBsOiAnaWQnLCB3ZDogWzAsIDEsIDIsIDMsIDQsIDUsIDZdIH0sXG4gIElFOiB7IGY6ICfwn4eu8J+HqicsIGw6ICdlbicgfSxcbiAgSUw6IHsgZjogJ/Cfh67wn4exJywgbDogJ2hlJywgd2Q6IFswLCAxLCAyLCAzLCA0LCA1LCA2XSwgd2U6IFs1LCA2XSB9LFxuICBJTTogeyBmOiAn8J+HrvCfh7InLCBsOiAnZW4nIH0sXG4gIElOOiB7IGY6ICfwn4eu8J+HsycsIGw6ICdoaScsIHdkOiBbMCwgMSwgMiwgMywgNCwgNSwgNl0sIHdlOiBbMF0gfSxcbiAgSU86IHsgZjogJ/Cfh67wn4e0JywgbDogJ2VuJyB9LFxuICBJUTogeyBmOiAn8J+HrvCfh7YnLCBsOiAnYXInLCB3ZDogWzYsIDAsIDEsIDIsIDMsIDQsIDVdLCB3ZTogWzUsIDZdIH0sXG4gIElSOiB7IGY6ICfwn4eu8J+HtycsIGw6ICdmYScsIGM6ICdwZXJzaWFuJywgd2Q6IFs2LCAwLCAxLCAyLCAzLCA0LCA1XSwgd2U6IFs1XSB9LFxuICBJUzogeyBmOiAn8J+HrvCfh7gnLCBsOiAnaXMnIH0sXG4gIElUOiB7IGY6ICfwn4eu8J+HuScsIGw6ICdpdCcgfSxcbiAgSkU6IHsgZjogJ/Cfh6/wn4eqJywgbDogJ2VuJyB9LFxuICBKTTogeyBmOiAn8J+Hr/Cfh7InLCBsOiAnZW4nLCB3ZDogWzAsIDEsIDIsIDMsIDQsIDUsIDZdIH0sXG4gIEpPOiB7IGY6ICfwn4ev8J+HtCcsIGw6ICdhcicsIHdkOiBbNiwgMCwgMSwgMiwgMywgNCwgNV0sIHdlOiBbNSwgNl0gfSxcbiAgSlA6IHsgZjogJ/Cfh6/wn4e1JywgbDogJ2phJywgd2Q6IFswLCAxLCAyLCAzLCA0LCA1LCA2XSB9LFxuICBLRTogeyBmOiAn8J+HsPCfh6onLCBsOiAnc3cnLCB3ZDogWzAsIDEsIDIsIDMsIDQsIDUsIDZdIH0sXG4gIEtHOiB7IGY6ICfwn4ew8J+HrCcsIGw6ICdreScgfSxcbiAgS0g6IHsgZjogJ/Cfh7Dwn4etJywgbDogJ2ttJywgd2Q6IFswLCAxLCAyLCAzLCA0LCA1LCA2XSB9LFxuICBLSTogeyBmOiAn8J+HsPCfh64nLCBsOiAnZW4nIH0sXG4gIEtNOiB7IGY6ICfwn4ew8J+HsicsIGw6ICdhcicgfSxcbiAgS046IHsgZjogJ/Cfh7Dwn4ezJywgbDogJ2VuJyB9LFxuICBLUDogeyBmOiAn8J+HsPCfh7UnLCBsOiAna28nIH0sXG4gIEtSOiB7IGY6ICfwn4ew8J+HtycsIGw6ICdrbycsIHdkOiBbMCwgMSwgMiwgMywgNCwgNSwgNl0gfSxcbiAgS1c6IHsgZjogJ/Cfh7Dwn4e8JywgbDogJ2FyJywgd2Q6IFs2LCAwLCAxLCAyLCAzLCA0LCA1XSwgd2U6IFs1LCA2XSB9LFxuICBLWTogeyBmOiAn8J+HsPCfh74nLCBsOiAnZW4nIH0sXG4gIEtaOiB7IGY6ICfwn4ew8J+HvycsIGw6ICdydScgfSxcbiAgTEE6IHsgZjogJ/Cfh7Hwn4emJywgbDogJ2xvJywgd2Q6IFswLCAxLCAyLCAzLCA0LCA1LCA2XSB9LFxuICBMQjogeyBmOiAn8J+HsfCfh6cnLCBsOiAnYXInIH0sXG4gIExDOiB7IGY6ICfwn4ex8J+HqCcsIGw6ICdlbicgfSxcbiAgTEk6IHsgZjogJ/Cfh7Hwn4euJywgbDogJ2RlJyB9LFxuICBMSzogeyBmOiAn8J+HsfCfh7AnLCBsOiAnc2knIH0sXG4gIExSOiB7IGY6ICfwn4ex8J+HtycsIGw6ICdlbicgfSxcbiAgTFM6IHsgZjogJ/Cfh7Hwn4e4JywgbDogJ3N0JyB9LFxuICBMVDogeyBmOiAn8J+HsfCfh7knLCBsOiAnbHQnIH0sXG4gIExVOiB7IGY6ICfwn4ex8J+HuicsIGw6ICdmcicgfSxcbiAgTFY6IHsgZjogJ/Cfh7Hwn4e7JywgbDogJ2x2JyB9LFxuICBMWTogeyBmOiAn8J+HsfCfh74nLCBsOiAnYXInLCB3ZDogWzYsIDAsIDEsIDIsIDMsIDQsIDVdLCB3ZTogWzUsIDZdIH0sXG4gIE1BOiB7IGY6ICfwn4ey8J+HpicsIGw6ICdmcicgfSxcbiAgTUM6IHsgZjogJ/Cfh7Lwn4eoJywgbDogJ2ZyJyB9LFxuICBNRDogeyBmOiAn8J+HsvCfh6knLCBsOiAncm8nIH0sXG4gIE1FOiB7IGY6ICfwn4ey8J+HqicsIGw6ICdzcScgfSxcbiAgTUY6IHsgZjogJ/Cfh7Lwn4erJywgbDogJ2ZyJyB9LFxuICBNRzogeyBmOiAn8J+HsvCfh6wnLCBsOiAnbWcnIH0sXG4gIE1IOiB7IGY6ICfwn4ey8J+HrScsIGw6ICdlbicsIHdkOiBbMCwgMSwgMiwgMywgNCwgNSwgNl0gfSxcbiAgTUs6IHsgZjogJ/Cfh7Lwn4ewJywgbDogJ21rJyB9LFxuICBNTDogeyBmOiAn8J+HsvCfh7EnLCBsOiAnYm0nIH0sXG4gIE1NOiB7IGY6ICfwn4ey8J+HsicsIGw6ICdteScsIHdkOiBbMCwgMSwgMiwgMywgNCwgNSwgNl0gfSxcbiAgTU46IHsgZjogJ/Cfh7Lwn4ezJywgbDogJ21uJyB9LFxuICBNTzogeyBmOiAn8J+HsvCfh7QnLCBsOiAnemgnLCB3ZDogWzAsIDEsIDIsIDMsIDQsIDUsIDZdIH0sXG4gIE1QOiB7IGY6ICfwn4ey8J+HtScsIGw6ICdlbicgfSxcbiAgTVE6IHsgZjogJ/Cfh7Lwn4e2JywgbDogJ2ZyJyB9LFxuICBNUjogeyBmOiAn8J+HsvCfh7cnLCBsOiAnYXInIH0sXG4gIE1TOiB7IGY6ICfwn4ey8J+HuCcsIGw6ICdlbicgfSxcbiAgTVQ6IHsgZjogJ/Cfh7Lwn4e5JywgbDogJ210Jywgd2Q6IFswLCAxLCAyLCAzLCA0LCA1LCA2XSB9LFxuICBNVTogeyBmOiAn8J+HsvCfh7onLCBsOiAnZW4nIH0sXG4gIE1WOiB7IGY6ICfwn4ey8J+HuycsIGw6ICdkdicsIHdkOiBbNSwgNiwgMCwgMSwgMiwgMywgNF0gfSxcbiAgTVc6IHsgZjogJ/Cfh7Lwn4e8JywgbDogJ2VuJyB9LFxuICBNWDogeyBmOiAn8J+HsvCfh70nLCBsOiAnZXMnLCB3ZDogWzAsIDEsIDIsIDMsIDQsIDUsIDZdIH0sXG4gIE1ZOiB7IGY6ICfwn4ey8J+HvicsIGw6ICdtcycgfSxcbiAgTVo6IHsgZjogJ/Cfh7Lwn4e/JywgbDogJ3B0Jywgd2Q6IFswLCAxLCAyLCAzLCA0LCA1LCA2XSB9LFxuICBOQTogeyBmOiAn8J+Hs/Cfh6YnLCBsOiAnYWYnIH0sXG4gIE5DOiB7IGY6ICfwn4ez8J+HqCcsIGw6ICdmcicgfSxcbiAgTkU6IHsgZjogJ/Cfh7Pwn4eqJywgbDogJ2hhJyB9LFxuICBORjogeyBmOiAn8J+Hs/Cfh6snLCBsOiAnZW4nIH0sXG4gIE5HOiB7IGY6ICfwn4ez8J+HrCcsIGw6ICdlbicgfSxcbiAgTkk6IHsgZjogJ/Cfh7Pwn4euJywgbDogJ2VzJywgd2Q6IFswLCAxLCAyLCAzLCA0LCA1LCA2XSB9LFxuICBOTDogeyBmOiAn8J+Hs/Cfh7EnLCBsOiAnbmwnIH0sXG4gIE5POiB7IGY6ICfwn4ez8J+HtCcsIGw6ICduYicgfSxcbiAgTlA6IHsgZjogJ/Cfh7Pwn4e1JywgbDogJ25lJywgd2Q6IFswLCAxLCAyLCAzLCA0LCA1LCA2XSB9LFxuICBOUjogeyBmOiAn8J+Hs/Cfh7cnLCBsOiAnZW4nIH0sXG4gIE5VOiB7IGY6ICfwn4ez8J+HuicsIGw6ICdlbicgfSxcbiAgTlo6IHsgZjogJ/Cfh7Pwn4e/JywgbDogJ2VuJyB9LFxuICBPTTogeyBmOiAn8J+HtPCfh7InLCBsOiAnYXInLCB3ZDogWzYsIDAsIDEsIDIsIDMsIDQsIDVdLCB3ZTogWzUsIDZdIH0sXG4gIFBBOiB7IGY6ICfwn4e18J+HpicsIGw6ICdlcycsIHdkOiBbMCwgMSwgMiwgMywgNCwgNSwgNl0gfSxcbiAgUEU6IHsgZjogJ/Cfh7Xwn4eqJywgbDogJ2VzJywgd2Q6IFswLCAxLCAyLCAzLCA0LCA1LCA2XSB9LFxuICBQRjogeyBmOiAn8J+HtfCfh6snLCBsOiAnZnInIH0sXG4gIFBHOiB7IGY6ICfwn4e18J+HrCcsIGw6ICdlbicgfSxcbiAgUEg6IHsgZjogJ/Cfh7Xwn4etJywgbDogJ2VuJywgd2Q6IFswLCAxLCAyLCAzLCA0LCA1LCA2XSB9LFxuICBQSzogeyBmOiAn8J+HtfCfh7AnLCBsOiAndXInLCB3ZDogWzAsIDEsIDIsIDMsIDQsIDUsIDZdIH0sXG4gIFBMOiB7IGY6ICfwn4e18J+HsScsIGw6ICdwbCcgfSxcbiAgUE06IHsgZjogJ/Cfh7Xwn4eyJywgbDogJ2ZyJyB9LFxuICBQTjogeyBmOiAn8J+HtfCfh7MnLCBsOiAnZW4nIH0sXG4gIFBSOiB7IGY6ICfwn4e18J+HtycsIGw6ICdlbicsIHdkOiBbMCwgMSwgMiwgMywgNCwgNSwgNl0gfSxcbiAgUFM6IHsgZjogJ/Cfh7Xwn4e4JywgbDogJ2FyJyB9LFxuICBQVDogeyBmOiAn8J+HtfCfh7knLCBsOiAncHQnLCB3ZDogWzAsIDEsIDIsIDMsIDQsIDUsIDZdIH0sXG4gIFBXOiB7IGY6ICfwn4e18J+HvCcsIGw6ICdlbicgfSxcbiAgUFk6IHsgZjogJ/Cfh7Xwn4e+JywgbDogJ2duJywgd2Q6IFswLCAxLCAyLCAzLCA0LCA1LCA2XSB9LFxuICBRQTogeyBmOiAn8J+HtvCfh6YnLCBsOiAnYXInLCB3ZDogWzYsIDAsIDEsIDIsIDMsIDQsIDVdLCB3ZTogWzUsIDZdIH0sXG4gIFJFOiB7IGY6ICfwn4e38J+HqicsIGw6ICdmcicgfSxcbiAgUk86IHsgZjogJ/Cfh7fwn4e0JywgbDogJ3JvJyB9LFxuICBSUzogeyBmOiAn8J+Ht/Cfh7gnLCBsOiAnc3InIH0sXG4gIFJVOiB7IGY6ICfwn4e38J+HuicsIGw6ICdydScgfSxcbiAgUlc6IHsgZjogJ/Cfh7fwn4e8JywgbDogJ3J3JyB9LFxuICBTQTogeyBmOiAn8J+HuPCfh6YnLCBsOiAnYXInLCBjOiAnaXNsYW1pYycsIHdkOiBbMCwgMSwgMiwgMywgNCwgNSwgNl0sIHdlOiBbNSwgNl0gfSxcbiAgU0I6IHsgZjogJ/Cfh7jwn4enJywgbDogJ2VuJyB9LFxuICBTQzogeyBmOiAn8J+HuPCfh6gnLCBsOiAnZnInIH0sXG4gIFNEOiB7IGY6ICfwn4e48J+HqScsIGw6ICdhcicsIHdkOiBbNiwgMCwgMSwgMiwgMywgNCwgNV0sIHdlOiBbNSwgNl0gfSxcbiAgU0U6IHsgZjogJ/Cfh7jwn4eqJywgbDogJ3N2JyB9LFxuICBTRzogeyBmOiAn8J+HuPCfh6wnLCBsOiAnZW4nLCB3ZDogWzAsIDEsIDIsIDMsIDQsIDUsIDZdIH0sXG4gIFNIOiB7IGY6ICfwn4e48J+HrScsIGw6ICdlbicgfSxcbiAgU0k6IHsgZjogJ/Cfh7jwn4euJywgbDogJ3NsJyB9LFxuICBTSjogeyBmOiAn8J+HuPCfh68nLCBsOiAnbmInIH0sXG4gIFNLOiB7IGY6ICfwn4e48J+HsCcsIGw6ICdzaycgfSxcbiAgU0w6IHsgZjogJ/Cfh7jwn4exJywgbDogJ2VuJyB9LFxuICBTTTogeyBmOiAn8J+HuPCfh7InLCBsOiAnaXQnIH0sXG4gIFNOOiB7IGY6ICfwn4e48J+HsycsIGw6ICd3bycgfSxcbiAgU086IHsgZjogJ/Cfh7jwn4e0JywgbDogJ3NvJyB9LFxuICBTUjogeyBmOiAn8J+HuPCfh7cnLCBsOiAnbmwnIH0sXG4gIFNTOiB7IGY6ICfwn4e48J+HuCcsIGw6ICdhcicgfSxcbiAgU1Q6IHsgZjogJ/Cfh7jwn4e5JywgbDogJ3B0JyB9LFxuICBTVjogeyBmOiAn8J+HuPCfh7snLCBsOiAnZXMnLCB3ZDogWzAsIDEsIDIsIDMsIDQsIDUsIDZdIH0sXG4gIFNYOiB7IGY6ICfwn4e48J+HvScsIGw6ICdlbicgfSxcbiAgU1k6IHsgZjogJ/Cfh7jwn4e+JywgbDogJ2FyJywgd2Q6IFs2LCAwLCAxLCAyLCAzLCA0LCA1XSwgd2U6IFs1LCA2XSB9LFxuICBTWjogeyBmOiAn8J+HuPCfh78nLCBsOiAnZW4nIH0sXG4gIFRBOiB7IGY6ICfwn4e58J+HpicsIGw6ICdlbicgfSxcbiAgVEM6IHsgZjogJ/Cfh7nwn4eoJywgbDogJ2VuJyB9LFxuICBURDogeyBmOiAn8J+HufCfh6knLCBsOiAnZnInIH0sXG4gIFRGOiB7IGY6ICfwn4e58J+HqycsIGw6ICdmcicgfSxcbiAgVEc6IHsgZjogJ/Cfh7nwn4esJywgbDogJ2ZyJyB9LFxuICBUSDogeyBmOiAn8J+HufCfh60nLCBsOiAndGgnLCBjOiAnYnVkZGhpc3QnLCB3ZDogWzAsIDEsIDIsIDMsIDQsIDUsIDZdIH0sXG4gIFRKOiB7IGY6ICfwn4e58J+HrycsIGw6ICd0ZycgfSxcbiAgVEs6IHsgZjogJ/Cfh7nwn4ewJywgbDogJ2VuJyB9LFxuICBUTDogeyBmOiAn8J+HufCfh7EnLCBsOiAncHQnIH0sXG4gIFRNOiB7IGY6ICfwn4e58J+HsicsIGw6ICd0aycgfSxcbiAgVE46IHsgZjogJ/Cfh7nwn4ezJywgbDogJ2FyJyB9LFxuICBUTzogeyBmOiAn8J+HufCfh7QnLCBsOiAndG8nIH0sXG4gIFRSOiB7IGY6ICfwn4e58J+HtycsIGw6ICd0cicgfSxcbiAgVFQ6IHsgZjogJ/Cfh7nwn4e5JywgbDogJ2VuJywgd2Q6IFswLCAxLCAyLCAzLCA0LCA1LCA2XSB9LFxuICBUVjogeyBmOiAn8J+HufCfh7snLCBsOiAnZW4nIH0sXG4gIFRXOiB7IGY6ICfwn4e58J+HvCcsIGw6ICd6aCcsIHdkOiBbMCwgMSwgMiwgMywgNCwgNSwgNl0gfSxcbiAgVFo6IHsgZjogJ/Cfh7nwn4e/JywgbDogJ3N3JyB9LFxuICBVQTogeyBmOiAn8J+HuvCfh6YnLCBsOiAncnUnIH0sXG4gIFVHOiB7IGY6ICfwn4e68J+HrCcsIGw6ICdzdycsIHdlOiBbMF0gfSxcbiAgVU06IHsgZjogJ/Cfh7rwn4eyJywgbDogJ2VuJywgd2Q6IFswLCAxLCAyLCAzLCA0LCA1LCA2XSB9LFxuICBVUzogeyBmOiAn8J+HuvCfh7gnLCBsOiAnZW4nLCB3ZDogWzAsIDEsIDIsIDMsIDQsIDUsIDZdIH0sXG4gIFVZOiB7IGY6ICfwn4e68J+HvicsIGw6ICdlcycgfSxcbiAgVVo6IHsgZjogJ/Cfh7rwn4e/JywgbDogJ3V6JyB9LFxuICBWQTogeyBmOiAn8J+Hu/Cfh6YnLCBsOiAnaXQnIH0sXG4gIFZDOiB7IGY6ICfwn4e78J+HqCcsIGw6ICdlbicgfSxcbiAgVkU6IHsgZjogJ/Cfh7vwn4eqJywgbDogJ2VzJywgd2Q6IFswLCAxLCAyLCAzLCA0LCA1LCA2XSB9LFxuICBWRzogeyBmOiAn8J+Hu/Cfh6wnLCBsOiAnZW4nIH0sXG4gIFZJOiB7IGY6ICfwn4e78J+HricsIGw6ICdlbicsIHdkOiBbMCwgMSwgMiwgMywgNCwgNSwgNl0gfSxcbiAgVk46IHsgZjogJ/Cfh7vwn4ezJywgbDogJ3ZpJyB9LFxuICBWVTogeyBmOiAn8J+Hu/Cfh7onLCBsOiAnYmknIH0sXG4gIFdGOiB7IGY6ICfwn4e88J+HqycsIGw6ICdmcicgfSxcbiAgV1M6IHsgZjogJ/Cfh7zwn4e4JywgbDogJ3NtJywgd2Q6IFswLCAxLCAyLCAzLCA0LCA1LCA2XSB9LFxuICBYSzogeyBmOiAn8J+HvfCfh7AnLCBsOiAnc3EnIH0sXG4gIFlFOiB7IGY6ICfwn4e+8J+HqicsIGw6ICdhcicsIHdkOiBbMCwgMSwgMiwgMywgNCwgNSwgNl0sIHdlOiBbNSwgNl0gfSxcbiAgWVQ6IHsgZjogJ/Cfh77wn4e5JywgbDogJ2ZyJyB9LFxuICBaQTogeyBmOiAn8J+Hv/Cfh6YnLCBsOiAnZW4nLCB3ZDogWzAsIDEsIDIsIDMsIDQsIDUsIDZdIH0sXG4gIFpNOiB7IGY6ICfwn4e/8J+HsicsIGw6ICdlbicgfSxcbiAgWlc6IHsgZjogJ/Cfh7/wn4e8JywgbDogJ3NuJywgd2Q6IFswLCAxLCAyLCAzLCA0LCA1LCA2XSB9LFxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gW1xuICAnYWEnLFxuICAnYWYnLFxuICAnYXInLFxuICAnYXonLFxuICAnYmUnLFxuICAnYmcnLFxuICAnYmknLFxuICAnYm0nLFxuICAnYm4nLFxuICAnYnMnLFxuICAnY2EnLFxuICAnY3MnLFxuICAnZGEnLFxuICAnZGUnLFxuICAnZHYnLFxuICAnZHonLFxuICAnZWwnLFxuICAnZW4nLFxuICAnZXMnLFxuICAnZXQnLFxuICAnZmEnLFxuICAnZmknLFxuICAnZm8nLFxuICAnZnInLFxuICAnZ24nLFxuICAnaGEnLFxuICAnaGUnLFxuICAnaGknLFxuICAnaHInLFxuICAnaHQnLFxuICAnaHUnLFxuICAnaHknLFxuICAnaWQnLFxuICAnaXMnLFxuICAnaXQnLFxuICAnamEnLFxuICAna2EnLFxuICAna2wnLFxuICAna20nLFxuICAna28nLFxuICAna3knLFxuICAnbG8nLFxuICAnbHQnLFxuICAnbHYnLFxuICAnbWcnLFxuICAnbWsnLFxuICAnbW4nLFxuICAnbXMnLFxuICAnbXQnLFxuICAnbXknLFxuICAnbmInLFxuICAnbmUnLFxuICAnbmwnLFxuICAncGwnLFxuICAncHQnLFxuICAncm4nLFxuICAncm8nLFxuICAncnUnLFxuICAncncnLFxuICAnc2knLFxuICAnc2snLFxuICAnc2wnLFxuICAnc20nLFxuICAnc24nLFxuICAnc28nLFxuICAnc3EnLFxuICAnc3InLFxuICAnc3QnLFxuICAnc3YnLFxuICAnc3cnLFxuICAndGcnLFxuICAndGgnLFxuICAndGknLFxuICAndGsnLFxuICAndG8nLFxuICAndHInLFxuICAndXInLFxuICAndXonLFxuICAndmknLFxuICAnd28nLFxuICAnemgnLFxuXTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZWNGcm9tVGltZSA9IGV4cG9ydHMuTWluRnJvbVRpbWUgPSBleHBvcnRzLkhvdXJGcm9tVGltZSA9IGV4cG9ydHMuRGF0ZUZyb21UaW1lID0gZXhwb3J0cy5Nb250aEZyb21UaW1lID0gZXhwb3J0cy5JbkxlYXBZZWFyID0gZXhwb3J0cy5EYXlXaXRoaW5ZZWFyID0gZXhwb3J0cy5EYXlzSW5ZZWFyID0gZXhwb3J0cy5ZZWFyRnJvbVRpbWUgPSBleHBvcnRzLlRpbWVGcm9tWWVhciA9IGV4cG9ydHMuRGF5RnJvbVllYXIgPSBleHBvcnRzLldlZWtEYXkgPSBleHBvcnRzLkRheSA9IGV4cG9ydHMuVHlwZSA9IGV4cG9ydHMuSGFzT3duUHJvcGVydHkgPSBleHBvcnRzLkFycmF5Q3JlYXRlID0gZXhwb3J0cy5TYW1lVmFsdWUgPSBleHBvcnRzLlRvT2JqZWN0ID0gZXhwb3J0cy5UaW1lQ2xpcCA9IGV4cG9ydHMuVG9OdW1iZXIgPSBleHBvcnRzLlRvU3RyaW5nID0gdm9pZCAwO1xuLyoqXG4gKiBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIFRvU3RyaW5nKG8pIHtcbiAgICAvLyBPbmx5IHN5bWJvbCBpcyBpcnJlZ3VsYXIuLi5cbiAgICBpZiAodHlwZW9mIG8gPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyhvKTtcbn1cbmV4cG9ydHMuVG9TdHJpbmcgPSBUb1N0cmluZztcbi8qKlxuICogaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b251bWJlclxuICogQHBhcmFtIHZhbFxuICovXG5mdW5jdGlvbiBUb051bWJlcih2YWwpIHtcbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gKzA7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA/IDEgOiArMDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3ltYm9sJyB8fCB0eXBlb2YgdmFsID09PSAnYmlnaW50Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBzeW1ib2wvYmlnaW50IHRvIG51bWJlcicpO1xuICAgIH1cbiAgICByZXR1cm4gTnVtYmVyKHZhbCk7XG59XG5leHBvcnRzLlRvTnVtYmVyID0gVG9OdW1iZXI7XG4vKipcbiAqIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9pbnRlZ2VyXG4gKiBAcGFyYW0gblxuICovXG5mdW5jdGlvbiBUb0ludGVnZXIobikge1xuICAgIHZhciBudW1iZXIgPSBUb051bWJlcihuKTtcbiAgICBpZiAoaXNOYU4obnVtYmVyKSB8fCBTYW1lVmFsdWUobnVtYmVyLCAtMCkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChpc0Zpbml0ZShudW1iZXIpKSB7XG4gICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuICAgIHZhciBpbnRlZ2VyID0gTWF0aC5mbG9vcihNYXRoLmFicyhudW1iZXIpKTtcbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICBpbnRlZ2VyID0gLWludGVnZXI7XG4gICAgfVxuICAgIGlmIChTYW1lVmFsdWUoaW50ZWdlciwgLTApKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gaW50ZWdlcjtcbn1cbi8qKlxuICogaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10aW1lY2xpcFxuICogQHBhcmFtIHRpbWVcbiAqL1xuZnVuY3Rpb24gVGltZUNsaXAodGltZSkge1xuICAgIGlmICghaXNGaW5pdGUodGltZSkpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgaWYgKE1hdGguYWJzKHRpbWUpID4gOC42NCAqIDFlMTYpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIFRvSW50ZWdlcih0aW1lKTtcbn1cbmV4cG9ydHMuVGltZUNsaXAgPSBUaW1lQ2xpcDtcbi8qKlxuICogaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b29iamVjdFxuICogQHBhcmFtIGFyZ1xuICovXG5mdW5jdGlvbiBUb09iamVjdChhcmcpIHtcbiAgICBpZiAoYXJnID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5kZWZpbmVkL251bGwgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBvYmplY3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdChhcmcpO1xufVxuZXhwb3J0cy5Ub09iamVjdCA9IFRvT2JqZWN0O1xuLyoqXG4gKiBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzExLjAvaW5kZXguaHRtbCNzZWMtc2FtZXZhbHVlXG4gKiBAcGFyYW0geFxuICogQHBhcmFtIHlcbiAqL1xuZnVuY3Rpb24gU2FtZVZhbHVlKHgsIHkpIHtcbiAgICBpZiAoT2JqZWN0LmlzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuaXMoeCwgeSk7XG4gICAgfVxuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH1cbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG59XG5leHBvcnRzLlNhbWVWYWx1ZSA9IFNhbWVWYWx1ZTtcbi8qKlxuICogaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi8xMS4wL2luZGV4Lmh0bWwjc2VjLWFycmF5Y3JlYXRlXG4gKiBAcGFyYW0gbGVuXG4gKi9cbmZ1bmN0aW9uIEFycmF5Q3JlYXRlKGxlbikge1xuICAgIHJldHVybiBuZXcgQXJyYXkobGVuKTtcbn1cbmV4cG9ydHMuQXJyYXlDcmVhdGUgPSBBcnJheUNyZWF0ZTtcbi8qKlxuICogaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi8xMS4wL2luZGV4Lmh0bWwjc2VjLWhhc293bnByb3BlcnR5XG4gKiBAcGFyYW0gb1xuICogQHBhcmFtIHByb3BcbiAqL1xuZnVuY3Rpb24gSGFzT3duUHJvcGVydHkobywgcHJvcCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcHJvcCk7XG59XG5leHBvcnRzLkhhc093blByb3BlcnR5ID0gSGFzT3duUHJvcGVydHk7XG4vKipcbiAqIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvMTEuMC9pbmRleC5odG1sI3NlYy10eXBlXG4gKiBAcGFyYW0geFxuICovXG5mdW5jdGlvbiBUeXBlKHgpIHtcbiAgICBpZiAoeCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ051bGwnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAnVW5kZWZpbmVkJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB4ID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gJ09iamVjdCc7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuICdOdW1iZXInO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHggPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gJ0Jvb2xlYW4nO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiAnU3RyaW5nJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB4ID09PSAnc3ltYm9sJykge1xuICAgICAgICByZXR1cm4gJ1N5bWJvbCc7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgeCA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgcmV0dXJuICdCaWdJbnQnO1xuICAgIH1cbn1cbmV4cG9ydHMuVHlwZSA9IFR5cGU7XG52YXIgTVNfUEVSX0RBWSA9IDg2NDAwMDAwO1xuLyoqXG4gKiBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzExLjAvaW5kZXguaHRtbCNlcW4tbW9kdWxvXG4gKiBAcGFyYW0geFxuICogQHBhcmFtIHlcbiAqIEByZXR1cm4gayBvZiB0aGUgc2FtZSBzaWduIGFzIHlcbiAqL1xuZnVuY3Rpb24gbW9kKHgsIHkpIHtcbiAgICByZXR1cm4geCAtIE1hdGguZmxvb3IoeCAvIHkpICogeTtcbn1cbi8qKlxuICogaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI2Vxbi1EYXlcbiAqIEBwYXJhbSB0XG4gKi9cbmZ1bmN0aW9uIERheSh0KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IodCAvIE1TX1BFUl9EQVkpO1xufVxuZXhwb3J0cy5EYXkgPSBEYXk7XG4vKipcbiAqIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vlay1kYXlcbiAqIEBwYXJhbSB0XG4gKi9cbmZ1bmN0aW9uIFdlZWtEYXkodCkge1xuICAgIHJldHVybiBtb2QoRGF5KHQpICsgNCwgNyk7XG59XG5leHBvcnRzLldlZWtEYXkgPSBXZWVrRGF5O1xuLyoqXG4gKiBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXllYXItbnVtYmVyXG4gKiBAcGFyYW0geVxuICovXG5mdW5jdGlvbiBEYXlGcm9tWWVhcih5KSB7XG4gICAgcmV0dXJuICgzNjUgKiAoeSAtIDE5NzApICtcbiAgICAgICAgTWF0aC5mbG9vcigoeSAtIDE5NjkpIC8gNCkgLVxuICAgICAgICBNYXRoLmZsb29yKCh5IC0gMTkwMSkgLyAxMDApICtcbiAgICAgICAgTWF0aC5mbG9vcigoeSAtIDE2MDEpIC8gNDAwKSk7XG59XG5leHBvcnRzLkRheUZyb21ZZWFyID0gRGF5RnJvbVllYXI7XG4vKipcbiAqIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMteWVhci1udW1iZXJcbiAqIEBwYXJhbSB5XG4gKi9cbmZ1bmN0aW9uIFRpbWVGcm9tWWVhcih5KSB7XG4gICAgcmV0dXJuIE1TX1BFUl9EQVkgKiBEYXlGcm9tWWVhcih5KTtcbn1cbmV4cG9ydHMuVGltZUZyb21ZZWFyID0gVGltZUZyb21ZZWFyO1xuLyoqXG4gKiBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXllYXItbnVtYmVyXG4gKiBAcGFyYW0gdFxuICovXG5mdW5jdGlvbiBZZWFyRnJvbVRpbWUodCkge1xuICAgIHZhciBtaW4gPSBNYXRoLmNlaWwodCAvIE1TX1BFUl9EQVkgLyAzNjYpO1xuICAgIHZhciB5ID0gbWluO1xuICAgIHdoaWxlIChUaW1lRnJvbVllYXIoeSkgPD0gdCkge1xuICAgICAgICB5Kys7XG4gICAgfVxuICAgIHJldHVybiB5IC0gMTtcbn1cbmV4cG9ydHMuWWVhckZyb21UaW1lID0gWWVhckZyb21UaW1lO1xuZnVuY3Rpb24gRGF5c0luWWVhcih5KSB7XG4gICAgaWYgKHkgJSA0ICE9PSAwKSB7XG4gICAgICAgIHJldHVybiAzNjU7XG4gICAgfVxuICAgIGlmICh5ICUgMTAwICE9PSAwKSB7XG4gICAgICAgIHJldHVybiAzNjY7XG4gICAgfVxuICAgIGlmICh5ICUgNDAwICE9PSAwKSB7XG4gICAgICAgIHJldHVybiAzNjU7XG4gICAgfVxuICAgIHJldHVybiAzNjY7XG59XG5leHBvcnRzLkRheXNJblllYXIgPSBEYXlzSW5ZZWFyO1xuZnVuY3Rpb24gRGF5V2l0aGluWWVhcih0KSB7XG4gICAgcmV0dXJuIERheSh0KSAtIERheUZyb21ZZWFyKFllYXJGcm9tVGltZSh0KSk7XG59XG5leHBvcnRzLkRheVdpdGhpblllYXIgPSBEYXlXaXRoaW5ZZWFyO1xuZnVuY3Rpb24gSW5MZWFwWWVhcih0KSB7XG4gICAgcmV0dXJuIERheXNJblllYXIoWWVhckZyb21UaW1lKHQpKSA9PT0gMzY1ID8gMCA6IDE7XG59XG5leHBvcnRzLkluTGVhcFllYXIgPSBJbkxlYXBZZWFyO1xuLyoqXG4gKiBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1vbnRoLW51bWJlclxuICogQHBhcmFtIHRcbiAqL1xuZnVuY3Rpb24gTW9udGhGcm9tVGltZSh0KSB7XG4gICAgdmFyIGR3eSA9IERheVdpdGhpblllYXIodCk7XG4gICAgdmFyIGxlYXAgPSBJbkxlYXBZZWFyKHQpO1xuICAgIGlmIChkd3kgPj0gMCAmJiBkd3kgPCAzMSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKGR3eSA8IDU5ICsgbGVhcCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKGR3eSA8IDkwICsgbGVhcCkge1xuICAgICAgICByZXR1cm4gMjtcbiAgICB9XG4gICAgaWYgKGR3eSA8IDEyMCArIGxlYXApIHtcbiAgICAgICAgcmV0dXJuIDM7XG4gICAgfVxuICAgIGlmIChkd3kgPCAxNTEgKyBsZWFwKSB7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbiAgICBpZiAoZHd5IDwgMTgxICsgbGVhcCkge1xuICAgICAgICByZXR1cm4gNTtcbiAgICB9XG4gICAgaWYgKGR3eSA8IDIxMiArIGxlYXApIHtcbiAgICAgICAgcmV0dXJuIDY7XG4gICAgfVxuICAgIGlmIChkd3kgPCAyNDMgKyBsZWFwKSB7XG4gICAgICAgIHJldHVybiA3O1xuICAgIH1cbiAgICBpZiAoZHd5IDwgMjczICsgbGVhcCkge1xuICAgICAgICByZXR1cm4gODtcbiAgICB9XG4gICAgaWYgKGR3eSA8IDMwNCArIGxlYXApIHtcbiAgICAgICAgcmV0dXJuIDk7XG4gICAgfVxuICAgIGlmIChkd3kgPCAzMzQgKyBsZWFwKSB7XG4gICAgICAgIHJldHVybiAxMDtcbiAgICB9XG4gICAgaWYgKGR3eSA8IDM2NSArIGxlYXApIHtcbiAgICAgICAgcmV0dXJuIDExO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGltZScpO1xufVxuZXhwb3J0cy5Nb250aEZyb21UaW1lID0gTW9udGhGcm9tVGltZTtcbmZ1bmN0aW9uIERhdGVGcm9tVGltZSh0KSB7XG4gICAgdmFyIGR3eSA9IERheVdpdGhpblllYXIodCk7XG4gICAgdmFyIG1mdCA9IE1vbnRoRnJvbVRpbWUodCk7XG4gICAgdmFyIGxlYXAgPSBJbkxlYXBZZWFyKHQpO1xuICAgIGlmIChtZnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGR3eSArIDE7XG4gICAgfVxuICAgIGlmIChtZnQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGR3eSAtIDMwO1xuICAgIH1cbiAgICBpZiAobWZ0ID09PSAyKSB7XG4gICAgICAgIHJldHVybiBkd3kgLSA1OCAtIGxlYXA7XG4gICAgfVxuICAgIGlmIChtZnQgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuIGR3eSAtIDg5IC0gbGVhcDtcbiAgICB9XG4gICAgaWYgKG1mdCA9PT0gNCkge1xuICAgICAgICByZXR1cm4gZHd5IC0gMTE5IC0gbGVhcDtcbiAgICB9XG4gICAgaWYgKG1mdCA9PT0gNSkge1xuICAgICAgICByZXR1cm4gZHd5IC0gMTUwIC0gbGVhcDtcbiAgICB9XG4gICAgaWYgKG1mdCA9PT0gNikge1xuICAgICAgICByZXR1cm4gZHd5IC0gMTgwIC0gbGVhcDtcbiAgICB9XG4gICAgaWYgKG1mdCA9PT0gNykge1xuICAgICAgICByZXR1cm4gZHd5IC0gMjExIC0gbGVhcDtcbiAgICB9XG4gICAgaWYgKG1mdCA9PT0gOCkge1xuICAgICAgICByZXR1cm4gZHd5IC0gMjQyIC0gbGVhcDtcbiAgICB9XG4gICAgaWYgKG1mdCA9PT0gOSkge1xuICAgICAgICByZXR1cm4gZHd5IC0gMjcyIC0gbGVhcDtcbiAgICB9XG4gICAgaWYgKG1mdCA9PT0gMTApIHtcbiAgICAgICAgcmV0dXJuIGR3eSAtIDMwMyAtIGxlYXA7XG4gICAgfVxuICAgIGlmIChtZnQgPT09IDExKSB7XG4gICAgICAgIHJldHVybiBkd3kgLSAzMzMgLSBsZWFwO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGltZScpO1xufVxuZXhwb3J0cy5EYXRlRnJvbVRpbWUgPSBEYXRlRnJvbVRpbWU7XG52YXIgSE9VUlNfUEVSX0RBWSA9IDI0O1xudmFyIE1JTlVURVNfUEVSX0hPVVIgPSA2MDtcbnZhciBTRUNPTkRTX1BFUl9NSU5VVEUgPSA2MDtcbnZhciBNU19QRVJfU0VDT05EID0gMWUzO1xudmFyIE1TX1BFUl9NSU5VVEUgPSBNU19QRVJfU0VDT05EICogU0VDT05EU19QRVJfTUlOVVRFO1xudmFyIE1TX1BFUl9IT1VSID0gTVNfUEVSX01JTlVURSAqIE1JTlVURVNfUEVSX0hPVVI7XG5mdW5jdGlvbiBIb3VyRnJvbVRpbWUodCkge1xuICAgIHJldHVybiBtb2QoTWF0aC5mbG9vcih0IC8gTVNfUEVSX0hPVVIpLCBIT1VSU19QRVJfREFZKTtcbn1cbmV4cG9ydHMuSG91ckZyb21UaW1lID0gSG91ckZyb21UaW1lO1xuZnVuY3Rpb24gTWluRnJvbVRpbWUodCkge1xuICAgIHJldHVybiBtb2QoTWF0aC5mbG9vcih0IC8gTVNfUEVSX01JTlVURSksIE1JTlVURVNfUEVSX0hPVVIpO1xufVxuZXhwb3J0cy5NaW5Gcm9tVGltZSA9IE1pbkZyb21UaW1lO1xuZnVuY3Rpb24gU2VjRnJvbVRpbWUodCkge1xuICAgIHJldHVybiBtb2QoTWF0aC5mbG9vcih0IC8gTVNfUEVSX1NFQ09ORCksIFNFQ09ORFNfUEVSX01JTlVURSk7XG59XG5leHBvcnRzLlNlY0Zyb21UaW1lID0gU2VjRnJvbVRpbWU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVzdEF2YWlsYWJsZUxvY2FsZSA9IHZvaWQgMDtcbi8qKlxuICogaHR0cHM6Ly90YzM5LmVzL2VjbWE0MDIvI3NlYy1iZXN0YXZhaWxhYmxlbG9jYWxlXG4gKiBAcGFyYW0gYXZhaWxhYmxlTG9jYWxlc1xuICogQHBhcmFtIGxvY2FsZVxuICovXG5mdW5jdGlvbiBCZXN0QXZhaWxhYmxlTG9jYWxlKGF2YWlsYWJsZUxvY2FsZXMsIGxvY2FsZSkge1xuICAgIHZhciBjYW5kaWRhdGUgPSBsb2NhbGU7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKGF2YWlsYWJsZUxvY2FsZXMuaGFzKGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBvcyA9IGNhbmRpZGF0ZS5sYXN0SW5kZXhPZignLScpO1xuICAgICAgICBpZiAoIX5wb3MpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+PSAyICYmIGNhbmRpZGF0ZVtwb3MgLSAyXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBwb3MgLT0gMjtcbiAgICAgICAgfVxuICAgICAgICBjYW5kaWRhdGUgPSBjYW5kaWRhdGUuc2xpY2UoMCwgcG9zKTtcbiAgICB9XG59XG5leHBvcnRzLkJlc3RBdmFpbGFibGVMb2NhbGUgPSBCZXN0QXZhaWxhYmxlTG9jYWxlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlc3RGaXRNYXRjaGVyID0gdm9pZCAwO1xudmFyIEJlc3RBdmFpbGFibGVMb2NhbGVfMSA9IHJlcXVpcmUoXCIuL0Jlc3RBdmFpbGFibGVMb2NhbGVcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBodHRwczovL3RjMzkuZXMvZWNtYTQwMi8jc2VjLWJlc3RmaXRtYXRjaGVyXG4gKiBAcGFyYW0gYXZhaWxhYmxlTG9jYWxlc1xuICogQHBhcmFtIHJlcXVlc3RlZExvY2FsZXNcbiAqIEBwYXJhbSBnZXREZWZhdWx0TG9jYWxlXG4gKi9cbmZ1bmN0aW9uIEJlc3RGaXRNYXRjaGVyKGF2YWlsYWJsZUxvY2FsZXMsIHJlcXVlc3RlZExvY2FsZXMsIGdldERlZmF1bHRMb2NhbGUpIHtcbiAgICB2YXIgbWluaW1pemVkQXZhaWxhYmxlTG9jYWxlTWFwID0ge307XG4gICAgdmFyIG1pbmltaXplZEF2YWlsYWJsZUxvY2FsZXMgPSBuZXcgU2V0KCk7XG4gICAgYXZhaWxhYmxlTG9jYWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChsb2NhbGUpIHtcbiAgICAgICAgdmFyIG1pbmltaXplZExvY2FsZSA9IG5ldyBJbnRsLkxvY2FsZShsb2NhbGUpXG4gICAgICAgICAgICAubWluaW1pemUoKVxuICAgICAgICAgICAgLnRvU3RyaW5nKCk7XG4gICAgICAgIG1pbmltaXplZEF2YWlsYWJsZUxvY2FsZU1hcFttaW5pbWl6ZWRMb2NhbGVdID0gbG9jYWxlO1xuICAgICAgICBtaW5pbWl6ZWRBdmFpbGFibGVMb2NhbGVzLmFkZChtaW5pbWl6ZWRMb2NhbGUpO1xuICAgIH0pO1xuICAgIHZhciBmb3VuZExvY2FsZTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHJlcXVlc3RlZExvY2FsZXNfMSA9IHJlcXVlc3RlZExvY2FsZXM7IF9pIDwgcmVxdWVzdGVkTG9jYWxlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgbCA9IHJlcXVlc3RlZExvY2FsZXNfMVtfaV07XG4gICAgICAgIGlmIChmb3VuZExvY2FsZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vRXh0ZW5zaW9uTG9jYWxlID0gbC5yZXBsYWNlKHV0aWxzXzEuVU5JQ09ERV9FWFRFTlNJT05fU0VRVUVOQ0VfUkVHRVgsICcnKTtcbiAgICAgICAgaWYgKGF2YWlsYWJsZUxvY2FsZXMuaGFzKG5vRXh0ZW5zaW9uTG9jYWxlKSkge1xuICAgICAgICAgICAgZm91bmRMb2NhbGUgPSBub0V4dGVuc2lvbkxvY2FsZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW5pbWl6ZWRBdmFpbGFibGVMb2NhbGVzLmhhcyhub0V4dGVuc2lvbkxvY2FsZSkpIHtcbiAgICAgICAgICAgIGZvdW5kTG9jYWxlID0gbWluaW1pemVkQXZhaWxhYmxlTG9jYWxlTWFwW25vRXh0ZW5zaW9uTG9jYWxlXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2NhbGUgPSBuZXcgSW50bC5Mb2NhbGUobm9FeHRlbnNpb25Mb2NhbGUpO1xuICAgICAgICB2YXIgbWF4aW1pemVkUmVxdWVzdGVkTG9jYWxlID0gbG9jYWxlLm1heGltaXplKCkudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIG1pbmltaXplZFJlcXVlc3RlZExvY2FsZSA9IGxvY2FsZS5taW5pbWl6ZSgpLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vIENoZWNrIG1pbmltaXplZCBsb2NhbGVcbiAgICAgICAgaWYgKG1pbmltaXplZEF2YWlsYWJsZUxvY2FsZXMuaGFzKG1pbmltaXplZFJlcXVlc3RlZExvY2FsZSkpIHtcbiAgICAgICAgICAgIGZvdW5kTG9jYWxlID0gbWluaW1pemVkQXZhaWxhYmxlTG9jYWxlTWFwW21pbmltaXplZFJlcXVlc3RlZExvY2FsZV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBMb29rdXAgYWxnbyBvbiBtYXhpbWl6ZWQgbG9jYWxlXG4gICAgICAgIGZvdW5kTG9jYWxlID0gQmVzdEF2YWlsYWJsZUxvY2FsZV8xLkJlc3RBdmFpbGFibGVMb2NhbGUobWluaW1pemVkQXZhaWxhYmxlTG9jYWxlcywgbWF4aW1pemVkUmVxdWVzdGVkTG9jYWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbG9jYWxlOiBmb3VuZExvY2FsZSB8fCBnZXREZWZhdWx0TG9jYWxlKCksXG4gICAgfTtcbn1cbmV4cG9ydHMuQmVzdEZpdE1hdGNoZXIgPSBCZXN0Rml0TWF0Y2hlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DYW5vbmljYWxpemVMb2NhbGVMaXN0ID0gdm9pZCAwO1xuLyoqXG4gKiBodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTQwMi83LjAvaW5kZXguaHRtbCNzZWMtY2Fub25pY2FsaXplbG9jYWxlbGlzdFxuICogQHBhcmFtIGxvY2FsZXNcbiAqL1xuZnVuY3Rpb24gQ2Fub25pY2FsaXplTG9jYWxlTGlzdChsb2NhbGVzKSB7XG4gICAgLy8gVE9ET1xuICAgIHJldHVybiBJbnRsLmdldENhbm9uaWNhbExvY2FsZXMobG9jYWxlcyk7XG59XG5leHBvcnRzLkNhbm9uaWNhbGl6ZUxvY2FsZUxpc3QgPSBDYW5vbmljYWxpemVMb2NhbGVMaXN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNhbm9uaWNhbGl6ZVRpbWVab25lTmFtZSA9IHZvaWQgMDtcbi8qKlxuICogaHR0cHM6Ly90YzM5LmVzL2VjbWE0MDIvI3NlYy1jYW5vbmljYWxpemV0aW1lem9uZW5hbWVcbiAqIEBwYXJhbSB0elxuICovXG5mdW5jdGlvbiBDYW5vbmljYWxpemVUaW1lWm9uZU5hbWUodHosIF9hKSB7XG4gICAgdmFyIHR6RGF0YSA9IF9hLnR6RGF0YSwgdXBwZXJjYXNlTGlua3MgPSBfYS51cHBlcmNhc2VMaW5rcztcbiAgICB2YXIgdXBwZXJjYXNlZFR6ID0gdHoudG9VcHBlckNhc2UoKTtcbiAgICB2YXIgdXBwZXJjYXNlZFpvbmVzID0gT2JqZWN0LmtleXModHpEYXRhKS5yZWR1Y2UoZnVuY3Rpb24gKGFsbCwgeikge1xuICAgICAgICBhbGxbei50b1VwcGVyQ2FzZSgpXSA9IHo7XG4gICAgICAgIHJldHVybiBhbGw7XG4gICAgfSwge30pO1xuICAgIHZhciBpYW5hVGltZVpvbmUgPSB1cHBlcmNhc2VMaW5rc1t1cHBlcmNhc2VkVHpdIHx8IHVwcGVyY2FzZWRab25lc1t1cHBlcmNhc2VkVHpdO1xuICAgIGlmIChpYW5hVGltZVpvbmUgPT09ICdFdGMvVVRDJyB8fCBpYW5hVGltZVpvbmUgPT09ICdFdGMvR01UJykge1xuICAgICAgICByZXR1cm4gJ1VUQyc7XG4gICAgfVxuICAgIHJldHVybiBpYW5hVGltZVpvbmU7XG59XG5leHBvcnRzLkNhbm9uaWNhbGl6ZVRpbWVab25lTmFtZSA9IENhbm9uaWNhbGl6ZVRpbWVab25lTmFtZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNpY0Zvcm1hdE1hdGNoZXIgPSB2b2lkIDA7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIHV0aWxzXzIgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogaHR0cHM6Ly90YzM5LmVzL2VjbWE0MDIvI3NlYy1iYXNpY2Zvcm1hdG1hdGNoZXJcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gZm9ybWF0c1xuICovXG5mdW5jdGlvbiBCYXNpY0Zvcm1hdE1hdGNoZXIob3B0aW9ucywgZm9ybWF0cykge1xuICAgIHZhciBiZXN0U2NvcmUgPSAtSW5maW5pdHk7XG4gICAgdmFyIGJlc3RGb3JtYXQgPSBmb3JtYXRzWzBdO1xuICAgIHV0aWxzXzEuaW52YXJpYW50KEFycmF5LmlzQXJyYXkoZm9ybWF0cyksICdmb3JtYXRzIHNob3VsZCBiZSBhIGxpc3Qgb2YgdGhpbmdzJyk7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBmb3JtYXRzXzEgPSBmb3JtYXRzOyBfaSA8IGZvcm1hdHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IGZvcm1hdHNfMVtfaV07XG4gICAgICAgIHZhciBzY29yZSA9IDA7XG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgREFURV9USU1FX1BST1BTXzEgPSB1dGlsc18yLkRBVEVfVElNRV9QUk9QUzsgX2EgPCBEQVRFX1RJTUVfUFJPUFNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgIHZhciBwcm9wID0gREFURV9USU1FX1BST1BTXzFbX2FdO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnNQcm9wID0gb3B0aW9uc1twcm9wXTtcbiAgICAgICAgICAgIHZhciBmb3JtYXRQcm9wID0gZm9ybWF0W3Byb3BdO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnNQcm9wID09PSB1bmRlZmluZWQgJiYgZm9ybWF0UHJvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2NvcmUgLT0gdXRpbHNfMi5hZGRpdGlvblBlbmFsdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zUHJvcCAhPT0gdW5kZWZpbmVkICYmIGZvcm1hdFByb3AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNjb3JlIC09IHV0aWxzXzIucmVtb3ZhbFBlbmFsdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zUHJvcCAhPT0gZm9ybWF0UHJvcCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbJzItZGlnaXQnLCAnbnVtZXJpYycsICduYXJyb3cnLCAnc2hvcnQnLCAnbG9uZyddO1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zUHJvcEluZGV4ID0gdmFsdWVzLmluZGV4T2Yob3B0aW9uc1Byb3ApO1xuICAgICAgICAgICAgICAgIHZhciBmb3JtYXRQcm9wSW5kZXggPSB2YWx1ZXMuaW5kZXhPZihmb3JtYXRQcm9wKTtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSBNYXRoLm1heCgtMiwgTWF0aC5taW4oZm9ybWF0UHJvcEluZGV4IC0gb3B0aW9uc1Byb3BJbmRleCwgMikpO1xuICAgICAgICAgICAgICAgIGlmIChkZWx0YSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBzY29yZSAtPSB1dGlsc18yLmxvbmdNb3JlUGVuYWx0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGVsdGEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmUgLT0gdXRpbHNfMi5zaG9ydE1vcmVQZW5hbHR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkZWx0YSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmUgLT0gdXRpbHNfMi5zaG9ydExlc3NQZW5hbHR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkZWx0YSA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmUgLT0gdXRpbHNfMi5sb25nTGVzc1BlbmFsdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzY29yZSA+IGJlc3RTY29yZSkge1xuICAgICAgICAgICAgYmVzdFNjb3JlID0gc2NvcmU7XG4gICAgICAgICAgICBiZXN0Rm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHt9LCBiZXN0Rm9ybWF0KTtcbn1cbmV4cG9ydHMuQmFzaWNGb3JtYXRNYXRjaGVyID0gQmFzaWNGb3JtYXRNYXRjaGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlc3RGaXRGb3JtYXRNYXRjaGVyID0gZXhwb3J0cy5iZXN0Rml0Rm9ybWF0TWF0Y2hlclNjb3JlID0gdm9pZCAwO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciB1dGlsc18yID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgc2tlbGV0b25fMSA9IHJlcXVpcmUoXCIuL3NrZWxldG9uXCIpO1xuZnVuY3Rpb24gaXNOdW1lcmljVHlwZSh0KSB7XG4gICAgcmV0dXJuIHQgPT09ICdudW1lcmljJyB8fCB0ID09PSAnMi1kaWdpdCc7XG59XG4vKipcbiAqIENyZWRpdDogaHR0cHM6Ly9naXRodWIuY29tL2FuZHllYXJuc2hhdy9JbnRsLmpzL2Jsb2IvMDk1OGRjMWFkODE1M2YxMDU2NjUzZWEyMmI4MjA4ZjBkZjI4OWE0ZS9zcmMvMTIuZGF0ZXRpbWVmb3JtYXQuanMjTDYxMVxuICogd2l0aCBzb21lIG1vZGlmaWNhdGlvbnNcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gZm9ybWF0XG4gKi9cbmZ1bmN0aW9uIGJlc3RGaXRGb3JtYXRNYXRjaGVyU2NvcmUob3B0aW9ucywgZm9ybWF0KSB7XG4gICAgdmFyIHNjb3JlID0gMDtcbiAgICBpZiAob3B0aW9ucy5ob3VyMTIgJiYgIWZvcm1hdC5ob3VyMTIpIHtcbiAgICAgICAgc2NvcmUgLT0gdXRpbHNfMi5yZW1vdmFsUGVuYWx0eTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIW9wdGlvbnMuaG91cjEyICYmIGZvcm1hdC5ob3VyMTIpIHtcbiAgICAgICAgc2NvcmUgLT0gdXRpbHNfMi5hZGRpdGlvblBlbmFsdHk7XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMCwgREFURV9USU1FX1BST1BTXzEgPSB1dGlsc18yLkRBVEVfVElNRV9QUk9QUzsgX2kgPCBEQVRFX1RJTUVfUFJPUFNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBEQVRFX1RJTUVfUFJPUFNfMVtfaV07XG4gICAgICAgIHZhciBvcHRpb25zUHJvcCA9IG9wdGlvbnNbcHJvcF07XG4gICAgICAgIHZhciBmb3JtYXRQcm9wID0gZm9ybWF0W3Byb3BdO1xuICAgICAgICBpZiAob3B0aW9uc1Byb3AgPT09IHVuZGVmaW5lZCAmJiBmb3JtYXRQcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNjb3JlIC09IHV0aWxzXzIuYWRkaXRpb25QZW5hbHR5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnNQcm9wICE9PSB1bmRlZmluZWQgJiYgZm9ybWF0UHJvcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzY29yZSAtPSB1dGlsc18yLnJlbW92YWxQZW5hbHR5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnNQcm9wICE9PSBmb3JtYXRQcm9wKSB7XG4gICAgICAgICAgICAvLyBleHRyYSBwZW5hbHR5IGZvciBudW1lcmljIHZzIG5vbi1udW1lcmljXG4gICAgICAgICAgICBpZiAoaXNOdW1lcmljVHlwZShvcHRpb25zUHJvcCkgIT09XG4gICAgICAgICAgICAgICAgaXNOdW1lcmljVHlwZShmb3JtYXRQcm9wKSkge1xuICAgICAgICAgICAgICAgIHNjb3JlIC09IHV0aWxzXzIuZGlmZmVyZW50TnVtZXJpY1R5cGVQZW5hbHR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFsnMi1kaWdpdCcsICdudW1lcmljJywgJ25hcnJvdycsICdzaG9ydCcsICdsb25nJ107XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnNQcm9wSW5kZXggPSB2YWx1ZXMuaW5kZXhPZihvcHRpb25zUHJvcCk7XG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdFByb3BJbmRleCA9IHZhbHVlcy5pbmRleE9mKGZvcm1hdFByb3ApO1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IE1hdGgubWF4KC0yLCBNYXRoLm1pbihmb3JtYXRQcm9wSW5kZXggLSBvcHRpb25zUHJvcEluZGV4LCAyKSk7XG4gICAgICAgICAgICAgICAgaWYgKGRlbHRhID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3JlIC09IHV0aWxzXzIubG9uZ01vcmVQZW5hbHR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkZWx0YSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBzY29yZSAtPSB1dGlsc18yLnNob3J0TW9yZVBlbmFsdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlbHRhID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzY29yZSAtPSB1dGlsc18yLnNob3J0TGVzc1BlbmFsdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlbHRhID09PSAtMikge1xuICAgICAgICAgICAgICAgICAgICBzY29yZSAtPSB1dGlsc18yLmxvbmdMZXNzUGVuYWx0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNjb3JlO1xufVxuZXhwb3J0cy5iZXN0Rml0Rm9ybWF0TWF0Y2hlclNjb3JlID0gYmVzdEZpdEZvcm1hdE1hdGNoZXJTY29yZTtcbi8qKlxuICogaHR0cHM6Ly90YzM5LmVzL2VjbWE0MDIvI3NlYy1iZXN0Zml0Zm9ybWF0bWF0Y2hlclxuICogSnVzdCBhbGlhcyB0byBiYXNpYyBmb3Igbm93XG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIGZvcm1hdHNcbiAqIEBwYXJhbSBpbXBsRGV0YWlscyBJbXBsZW1lbnRhdGlvbiBkZXRhaWxzXG4gKi9cbmZ1bmN0aW9uIEJlc3RGaXRGb3JtYXRNYXRjaGVyKG9wdGlvbnMsIGZvcm1hdHMpIHtcbiAgICB2YXIgYmVzdFNjb3JlID0gLUluZmluaXR5O1xuICAgIHZhciBiZXN0Rm9ybWF0ID0gZm9ybWF0c1swXTtcbiAgICB1dGlsc18xLmludmFyaWFudChBcnJheS5pc0FycmF5KGZvcm1hdHMpLCAnZm9ybWF0cyBzaG91bGQgYmUgYSBsaXN0IG9mIHRoaW5ncycpO1xuICAgIGZvciAodmFyIF9pID0gMCwgZm9ybWF0c18xID0gZm9ybWF0czsgX2kgPCBmb3JtYXRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSBmb3JtYXRzXzFbX2ldO1xuICAgICAgICB2YXIgc2NvcmUgPSBiZXN0Rml0Rm9ybWF0TWF0Y2hlclNjb3JlKG9wdGlvbnMsIGZvcm1hdCk7XG4gICAgICAgIGlmIChzY29yZSA+IGJlc3RTY29yZSkge1xuICAgICAgICAgICAgYmVzdFNjb3JlID0gc2NvcmU7XG4gICAgICAgICAgICBiZXN0Rm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBza2VsZXRvbkZvcm1hdCA9IHRzbGliXzEuX19hc3NpZ24oe30sIGJlc3RGb3JtYXQpO1xuICAgIHZhciBwYXR0ZXJuRm9ybWF0ID0geyByYXdQYXR0ZXJuOiBiZXN0Rm9ybWF0LnJhd1BhdHRlcm4gfTtcbiAgICBza2VsZXRvbl8xLnByb2Nlc3NEYXRlVGltZVBhdHRlcm4oYmVzdEZvcm1hdC5yYXdQYXR0ZXJuLCBwYXR0ZXJuRm9ybWF0KTtcbiAgICAvLyBLaW5kYSBmb2xsb3dpbmcgaHR0cHM6Ly9naXRodWIuY29tL3VuaWNvZGUtb3JnL2ljdS9ibG9iL2RkNTBlMzhmNDU5ZDg0ZTliZjFiMGM2MThiZTg0ODNkMzE4NDU4YWQvaWN1NGovbWFpbi9jbGFzc2VzL2NvcmUvc3JjL2NvbS9pYm0vaWN1L3RleHQvRGF0ZVRpbWVQYXR0ZXJuR2VuZXJhdG9yLmphdmFcbiAgICAvLyBNZXRob2QgYWRqdXN0RmllbGRUeXBlc1xuICAgIGZvciAodmFyIHByb3AgaW4gc2tlbGV0b25Gb3JtYXQpIHtcbiAgICAgICAgdmFyIHNrZWxldG9uVmFsdWUgPSBza2VsZXRvbkZvcm1hdFtwcm9wXTtcbiAgICAgICAgdmFyIHBhdHRlcm5WYWx1ZSA9IHBhdHRlcm5Gb3JtYXRbcHJvcF07XG4gICAgICAgIHZhciByZXF1ZXN0ZWRWYWx1ZSA9IG9wdGlvbnNbcHJvcF07XG4gICAgICAgIC8vIERvbid0IG1lc3Mgd2l0aCBtaW51dGUvc2Vjb25kIG9yIHdlIGNhbiBnZXQgaW4gdGhlIHNpdHVhdGlvbiBvZlxuICAgICAgICAvLyA3OjA6MCB3aGljaCBpcyB3ZWlyZFxuICAgICAgICBpZiAocHJvcCA9PT0gJ21pbnV0ZScgfHwgcHJvcCA9PT0gJ3NlY29uZCcpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGhpbmcgdG8gZG8gaGVyZVxuICAgICAgICBpZiAoIXJlcXVlc3RlZFZhbHVlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjTWF0Y2hpbmdfU2tlbGV0b25zXG4gICAgICAgIC8vIExvb2tzIGxpa2Ugd2Ugc2hvdWxkIG5vdCBjb252ZXJ0IG51bWVyaWMgdG8gYWxwaGFiZXRpYyBidXQgdGhlIG90aGVyIHdheVxuICAgICAgICAvLyBhcm91bmQgaXMgb2tcbiAgICAgICAgaWYgKGlzTnVtZXJpY1R5cGUocGF0dGVyblZhbHVlKSAmJlxuICAgICAgICAgICAgIWlzTnVtZXJpY1R5cGUocmVxdWVzdGVkVmFsdWUpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tlbGV0b25WYWx1ZSA9PT0gcmVxdWVzdGVkVmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHBhdHRlcm5Gb3JtYXRbcHJvcF0gPSByZXF1ZXN0ZWRWYWx1ZTtcbiAgICB9XG4gICAgLy8gQ29weSB0aG9zZSBvdmVyXG4gICAgcGF0dGVybkZvcm1hdC5wYXR0ZXJuID0gc2tlbGV0b25Gb3JtYXQucGF0dGVybjtcbiAgICBwYXR0ZXJuRm9ybWF0LnBhdHRlcm4xMiA9IHNrZWxldG9uRm9ybWF0LnBhdHRlcm4xMjtcbiAgICBwYXR0ZXJuRm9ybWF0LnNrZWxldG9uID0gc2tlbGV0b25Gb3JtYXQuc2tlbGV0b247XG4gICAgcGF0dGVybkZvcm1hdC5yYW5nZVBhdHRlcm5zID0gc2tlbGV0b25Gb3JtYXQucmFuZ2VQYXR0ZXJucztcbiAgICBwYXR0ZXJuRm9ybWF0LnJhbmdlUGF0dGVybnMxMiA9IHNrZWxldG9uRm9ybWF0LnJhbmdlUGF0dGVybnMxMjtcbiAgICByZXR1cm4gcGF0dGVybkZvcm1hdDtcbn1cbmV4cG9ydHMuQmVzdEZpdEZvcm1hdE1hdGNoZXIgPSBCZXN0Rml0Rm9ybWF0TWF0Y2hlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EYXRlVGltZVN0eWxlRm9ybWF0ID0gdm9pZCAwO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5mdW5jdGlvbiBEYXRlVGltZVN0eWxlRm9ybWF0KGRhdGVTdHlsZSwgdGltZVN0eWxlLCBkYXRhTG9jYWxlRGF0YSkge1xuICAgIHZhciBkYXRlRm9ybWF0LCB0aW1lRm9ybWF0O1xuICAgIGlmICh0aW1lU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1dGlsc18xLmludmFyaWFudCh0aW1lU3R5bGUgPT09ICdmdWxsJyB8fFxuICAgICAgICAgICAgdGltZVN0eWxlID09PSAnbG9uZycgfHxcbiAgICAgICAgICAgIHRpbWVTdHlsZSA9PT0gJ21lZGl1bScgfHxcbiAgICAgICAgICAgIHRpbWVTdHlsZSA9PT0gJ3Nob3J0JywgJ2ludmFsaWQgdGltZVN0eWxlJyk7XG4gICAgICAgIHRpbWVGb3JtYXQgPSBkYXRhTG9jYWxlRGF0YS50aW1lRm9ybWF0W3RpbWVTdHlsZV07XG4gICAgfVxuICAgIGlmIChkYXRlU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1dGlsc18xLmludmFyaWFudChkYXRlU3R5bGUgPT09ICdmdWxsJyB8fFxuICAgICAgICAgICAgZGF0ZVN0eWxlID09PSAnbG9uZycgfHxcbiAgICAgICAgICAgIGRhdGVTdHlsZSA9PT0gJ21lZGl1bScgfHxcbiAgICAgICAgICAgIGRhdGVTdHlsZSA9PT0gJ3Nob3J0JywgJ2ludmFsaWQgZGF0ZVN0eWxlJyk7XG4gICAgICAgIGRhdGVGb3JtYXQgPSBkYXRhTG9jYWxlRGF0YS5kYXRlRm9ybWF0W2RhdGVTdHlsZV07XG4gICAgfVxuICAgIGlmIChkYXRlU3R5bGUgIT09IHVuZGVmaW5lZCAmJiB0aW1lU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0ge307XG4gICAgICAgIGZvciAodmFyIGZpZWxkIGluIGRhdGVGb3JtYXQpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZCAhPT0gJ3BhdHRlcm4nKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGZvcm1hdFtmaWVsZF0gPSBkYXRlRm9ybWF0W2ZpZWxkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBmaWVsZCBpbiB0aW1lRm9ybWF0KSB7XG4gICAgICAgICAgICBpZiAoZmllbGQgIT09ICdwYXR0ZXJuJyAmJiBmaWVsZCAhPT0gJ3BhdHRlcm4xMicpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgZm9ybWF0W2ZpZWxkXSA9IHRpbWVGb3JtYXRbZmllbGRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjb25uZWN0b3IgPSBkYXRhTG9jYWxlRGF0YS5kYXRlVGltZUZvcm1hdFtkYXRlU3R5bGVdO1xuICAgICAgICB2YXIgcGF0dGVybiA9IGNvbm5lY3RvclxuICAgICAgICAgICAgLnJlcGxhY2UoJ3swfScsIHRpbWVGb3JtYXQucGF0dGVybilcbiAgICAgICAgICAgIC5yZXBsYWNlKCd7MX0nLCBkYXRlRm9ybWF0LnBhdHRlcm4pO1xuICAgICAgICBmb3JtYXQucGF0dGVybiA9IHBhdHRlcm47XG4gICAgICAgIGlmICgncGF0dGVybjEyJyBpbiB0aW1lRm9ybWF0KSB7XG4gICAgICAgICAgICB2YXIgcGF0dGVybjEyID0gY29ubmVjdG9yXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3swfScsIHRpbWVGb3JtYXQucGF0dGVybjEyKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCd7MX0nLCBkYXRlRm9ybWF0LnBhdHRlcm4pO1xuICAgICAgICAgICAgZm9ybWF0LnBhdHRlcm4xMiA9IHBhdHRlcm4xMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cbiAgICBpZiAodGltZVN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRpbWVGb3JtYXQ7XG4gICAgfVxuICAgIHV0aWxzXzEuaW52YXJpYW50KGRhdGVTdHlsZSAhPT0gdW5kZWZpbmVkLCAnZGF0ZVN0eWxlIHNob3VsZCBub3QgYmUgdW5kZWZpbmVkJyk7XG4gICAgcmV0dXJuIGRhdGVGb3JtYXQ7XG59XG5leHBvcnRzLkRhdGVUaW1lU3R5bGVGb3JtYXQgPSBEYXRlVGltZVN0eWxlRm9ybWF0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZvcm1hdERhdGVUaW1lID0gdm9pZCAwO1xudmFyIFBhcnRpdGlvbkRhdGVUaW1lUGF0dGVybl8xID0gcmVxdWlyZShcIi4vUGFydGl0aW9uRGF0ZVRpbWVQYXR0ZXJuXCIpO1xuLyoqXG4gKiBodHRwczovL3RjMzkuZXMvZWNtYTQwMi8jc2VjLWZvcm1hdGRhdGV0aW1lXG4gKiBAcGFyYW0gZHRmIERhdGVUaW1lRm9ybWF0XG4gKiBAcGFyYW0geFxuICovXG5mdW5jdGlvbiBGb3JtYXREYXRlVGltZShkdGYsIHgsIGltcGxEZXRhaWxzKSB7XG4gICAgdmFyIHBhcnRzID0gUGFydGl0aW9uRGF0ZVRpbWVQYXR0ZXJuXzEuUGFydGl0aW9uRGF0ZVRpbWVQYXR0ZXJuKGR0ZiwgeCwgaW1wbERldGFpbHMpO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICBmb3IgKHZhciBfaSA9IDAsIHBhcnRzXzEgPSBwYXJ0czsgX2kgPCBwYXJ0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgcGFydCA9IHBhcnRzXzFbX2ldO1xuICAgICAgICByZXN1bHQgKz0gcGFydC52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuRm9ybWF0RGF0ZVRpbWUgPSBGb3JtYXREYXRlVGltZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Gb3JtYXREYXRlVGltZVBhdHRlcm4gPSB2b2lkIDA7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIFRvTG9jYWxUaW1lXzEgPSByZXF1aXJlKFwiLi9Ub0xvY2FsVGltZVwiKTtcbnZhciBfMjYyXzEgPSByZXF1aXJlKFwiLi4vMjYyXCIpO1xuZnVuY3Rpb24gcGFkKG4pIHtcbiAgICBpZiAobiA8IDEwKSB7XG4gICAgICAgIHJldHVybiBcIjBcIiArIG47XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcobik7XG59XG5mdW5jdGlvbiBvZmZzZXRUb0dtdFN0cmluZyhnbXRGb3JtYXQsIGhvdXJGb3JtYXQsIG9mZnNldEluTXMsIHN0eWxlKSB7XG4gICAgdmFyIG9mZnNldEluTWludXRlcyA9IE1hdGguZmxvb3Iob2Zmc2V0SW5NcyAvIDYwMDAwKTtcbiAgICB2YXIgbWlucyA9IE1hdGguYWJzKG9mZnNldEluTWludXRlcykgJSA2MDtcbiAgICB2YXIgaG91cnMgPSBNYXRoLmZsb29yKE1hdGguYWJzKG9mZnNldEluTWludXRlcykgLyA2MCk7XG4gICAgdmFyIF9hID0gaG91ckZvcm1hdC5zcGxpdCgnOycpLCBwb3NpdGl2ZVBhdHRlcm4gPSBfYVswXSwgbmVnYXRpdmVQYXR0ZXJuID0gX2FbMV07XG4gICAgdmFyIG9mZnNldFN0ciA9ICcnO1xuICAgIHZhciBwYXR0ZXJuID0gb2Zmc2V0SW5NcyA8IDAgPyBuZWdhdGl2ZVBhdHRlcm4gOiBwb3NpdGl2ZVBhdHRlcm47XG4gICAgaWYgKHN0eWxlID09PSAnbG9uZycpIHtcbiAgICAgICAgb2Zmc2V0U3RyID0gcGF0dGVyblxuICAgICAgICAgICAgLnJlcGxhY2UoJ0hIJywgcGFkKGhvdXJzKSlcbiAgICAgICAgICAgIC5yZXBsYWNlKCdIJywgU3RyaW5nKGhvdXJzKSlcbiAgICAgICAgICAgIC5yZXBsYWNlKCdtbScsIHBhZChtaW5zKSlcbiAgICAgICAgICAgIC5yZXBsYWNlKCdtJywgU3RyaW5nKG1pbnMpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWlucyB8fCBob3Vycykge1xuICAgICAgICBpZiAoIW1pbnMpIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnJlcGxhY2UoLzo/bSsvLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0U3RyID0gcGF0dGVyblxuICAgICAgICAgICAgLnJlcGxhY2UoL0grLywgU3RyaW5nKGhvdXJzKSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC9tKy8sIFN0cmluZyhtaW5zKSk7XG4gICAgfVxuICAgIHJldHVybiBnbXRGb3JtYXQucmVwbGFjZSgnezB9Jywgb2Zmc2V0U3RyKTtcbn1cbi8qKlxuICogaHR0cHM6Ly90YzM5LmVzL2VjbWE0MDIvI3NlYy1wYXJ0aXRpb25kYXRldGltZXBhdHRlcm5cbiAqIEBwYXJhbSBkdGZcbiAqIEBwYXJhbSB4XG4gKi9cbmZ1bmN0aW9uIEZvcm1hdERhdGVUaW1lUGF0dGVybihkdGYsIHBhdHRlcm5QYXJ0cywgeCwgX2EpIHtcbiAgICB2YXIgZ2V0SW50ZXJuYWxTbG90cyA9IF9hLmdldEludGVybmFsU2xvdHMsIGxvY2FsZURhdGEgPSBfYS5sb2NhbGVEYXRhLCBnZXREZWZhdWx0VGltZVpvbmUgPSBfYS5nZXREZWZhdWx0VGltZVpvbmUsIHR6RGF0YSA9IF9hLnR6RGF0YTtcbiAgICB4ID0gXzI2Ml8xLlRpbWVDbGlwKHgpO1xuICAgIC8qKiBJTVBMIFNUQVJUICovXG4gICAgdmFyIGludGVybmFsU2xvdHMgPSBnZXRJbnRlcm5hbFNsb3RzKGR0Zik7XG4gICAgdmFyIGRhdGFMb2NhbGUgPSBpbnRlcm5hbFNsb3RzLmRhdGFMb2NhbGU7XG4gICAgdmFyIGRhdGFMb2NhbGVEYXRhID0gbG9jYWxlRGF0YVtkYXRhTG9jYWxlXTtcbiAgICAvKiogSU1QTCBFTkQgKi9cbiAgICB2YXIgbG9jYWxlID0gaW50ZXJuYWxTbG90cy5sb2NhbGU7XG4gICAgdmFyIG5mT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbmZPcHRpb25zLnVzZUdyb3VwaW5nID0gZmFsc2U7XG4gICAgdmFyIG5mID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwgbmZPcHRpb25zKTtcbiAgICB2YXIgbmYyT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbmYyT3B0aW9ucy5taW5pbXVtSW50ZWdlckRpZ2l0cyA9IDI7XG4gICAgbmYyT3B0aW9ucy51c2VHcm91cGluZyA9IGZhbHNlO1xuICAgIHZhciBuZjIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBuZjJPcHRpb25zKTtcbiAgICB2YXIgdG0gPSBUb0xvY2FsVGltZV8xLlRvTG9jYWxUaW1lKHgsIFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpbnRlcm5hbFNsb3RzLmNhbGVuZGFyLCBpbnRlcm5hbFNsb3RzLnRpbWVab25lLCB7IHR6RGF0YTogdHpEYXRhIH0pO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHBhdHRlcm5QYXJ0c18xID0gcGF0dGVyblBhcnRzOyBfaSA8IHBhdHRlcm5QYXJ0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgcGF0dGVyblBhcnQgPSBwYXR0ZXJuUGFydHNfMVtfaV07XG4gICAgICAgIHZhciBwID0gcGF0dGVyblBhcnQudHlwZTtcbiAgICAgICAgaWYgKHAgPT09ICdsaXRlcmFsJykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsaXRlcmFsJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGF0dGVyblBhcnQudmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1dGlsc18xLkRBVEVfVElNRV9QUk9QUy5pbmRleE9mKHApID4gLTEpIHtcbiAgICAgICAgICAgIHZhciBmdiA9ICcnO1xuICAgICAgICAgICAgdmFyIGYgPSBpbnRlcm5hbFNsb3RzW3BdO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdmFyIHYgPSB0bVtwXTtcbiAgICAgICAgICAgIGlmIChwID09PSAneWVhcicgJiYgdiA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdiA9IDEgLSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAgPT09ICdtb250aCcpIHtcbiAgICAgICAgICAgICAgICB2Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaG91ckN5Y2xlID0gaW50ZXJuYWxTbG90cy5ob3VyQ3ljbGU7XG4gICAgICAgICAgICBpZiAocCA9PT0gJ2hvdXInICYmIChob3VyQ3ljbGUgPT09ICdoMTEnIHx8IGhvdXJDeWNsZSA9PT0gJ2gxMicpKSB7XG4gICAgICAgICAgICAgICAgdiA9IHYgJSAxMjtcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBob3VyQ3ljbGUgPT09ICdoMTInKSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSAxMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocCA9PT0gJ2hvdXInICYmIGhvdXJDeWNsZSA9PT0gJ2gyNCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2ID0gMjQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGYgPT09ICdudW1lcmljJykge1xuICAgICAgICAgICAgICAgIGZ2ID0gbmYuZm9ybWF0KHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZiA9PT0gJzItZGlnaXQnKSB7XG4gICAgICAgICAgICAgICAgZnYgPSBuZjIuZm9ybWF0KHYpO1xuICAgICAgICAgICAgICAgIGlmIChmdi5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ2ID0gZnYuc2xpY2UoZnYubGVuZ3RoIC0gMiwgZnYubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmID09PSAnbmFycm93JyB8fCBmID09PSAnc2hvcnQnIHx8IGYgPT09ICdsb25nJykge1xuICAgICAgICAgICAgICAgIGlmIChwID09PSAnZXJhJykge1xuICAgICAgICAgICAgICAgICAgICBmdiA9IGRhdGFMb2NhbGVEYXRhW3BdW2ZdW3ZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwID09PSAndGltZVpvbmVOYW1lJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZVpvbmVOYW1lID0gZGF0YUxvY2FsZURhdGEudGltZVpvbmVOYW1lLCBnbXRGb3JtYXQgPSBkYXRhTG9jYWxlRGF0YS5nbXRGb3JtYXQsIGhvdXJGb3JtYXQgPSBkYXRhTG9jYWxlRGF0YS5ob3VyRm9ybWF0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZVpvbmUgPSBpbnRlcm5hbFNsb3RzLnRpbWVab25lIHx8IGdldERlZmF1bHRUaW1lWm9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZVpvbmVEYXRhID0gdGltZVpvbmVOYW1lW3RpbWVab25lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVab25lRGF0YSAmJiB0aW1lWm9uZURhdGFbZl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ2ID0gdGltZVpvbmVEYXRhW2ZdWyt0bS5pbkRTVF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byBnbXRGb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ2ID0gb2Zmc2V0VG9HbXRTdHJpbmcoZ210Rm9ybWF0LCBob3VyRm9ybWF0LCB0bS50aW1lWm9uZU9mZnNldCwgZik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocCA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgICAgICAgICBmdiA9IGRhdGFMb2NhbGVEYXRhLm1vbnRoW2ZdW3YgLSAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZ2ID0gZGF0YUxvY2FsZURhdGFbcF1bZl1bdl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IHAsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ2LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocCA9PT0gJ2FtcG0nKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHRtLmhvdXI7XG4gICAgICAgICAgICB2YXIgZnYgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAodiA+IDExKSB7XG4gICAgICAgICAgICAgICAgZnYgPSBkYXRhTG9jYWxlRGF0YS5wbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZ2ID0gZGF0YUxvY2FsZURhdGEuYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2RheVBlcmlvZCcsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ2LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocCA9PT0gJ3JlbGF0ZWRZZWFyJykge1xuICAgICAgICAgICAgdmFyIHYgPSB0bS5yZWxhdGVkWWVhcjtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHZhciBmdiA9IG5mLmZvcm1hdCh2KTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIFRPRE86IEZpeCBUUyB0eXBlXG4gICAgICAgICAgICAgICAgdHlwZTogJ3JlbGF0ZWRZZWFyJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnYsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwID09PSAneWVhck5hbWUnKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHRtLnllYXJOYW1lO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdmFyIGZ2ID0gbmYuZm9ybWF0KHYpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgVE9ETzogRml4IFRTIHR5cGVcbiAgICAgICAgICAgICAgICB0eXBlOiAneWVhck5hbWUnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLkZvcm1hdERhdGVUaW1lUGF0dGVybiA9IEZvcm1hdERhdGVUaW1lUGF0dGVybjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Gb3JtYXREYXRlVGltZVJhbmdlID0gdm9pZCAwO1xudmFyIFBhcnRpdGlvbkRhdGVUaW1lUmFuZ2VQYXR0ZXJuXzEgPSByZXF1aXJlKFwiLi9QYXJ0aXRpb25EYXRlVGltZVJhbmdlUGF0dGVyblwiKTtcbmZ1bmN0aW9uIEZvcm1hdERhdGVUaW1lUmFuZ2UoZHRmLCB4LCB5LCBpbXBsRGV0YWlscykge1xuICAgIHZhciBwYXJ0cyA9IFBhcnRpdGlvbkRhdGVUaW1lUmFuZ2VQYXR0ZXJuXzEuUGFydGl0aW9uRGF0ZVRpbWVSYW5nZVBhdHRlcm4oZHRmLCB4LCB5LCBpbXBsRGV0YWlscyk7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIGZvciAodmFyIF9pID0gMCwgcGFydHNfMSA9IHBhcnRzOyBfaSA8IHBhcnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcGFydHNfMVtfaV07XG4gICAgICAgIHJlc3VsdCArPSBwYXJ0LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5Gb3JtYXREYXRlVGltZVJhbmdlID0gRm9ybWF0RGF0ZVRpbWVSYW5nZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Gb3JtYXREYXRlVGltZVJhbmdlVG9QYXJ0cyA9IHZvaWQgMDtcbnZhciBQYXJ0aXRpb25EYXRlVGltZVJhbmdlUGF0dGVybl8xID0gcmVxdWlyZShcIi4vUGFydGl0aW9uRGF0ZVRpbWVSYW5nZVBhdHRlcm5cIik7XG5mdW5jdGlvbiBGb3JtYXREYXRlVGltZVJhbmdlVG9QYXJ0cyhkdGYsIHgsIHksIGltcGxEZXRhaWxzKSB7XG4gICAgdmFyIHBhcnRzID0gUGFydGl0aW9uRGF0ZVRpbWVSYW5nZVBhdHRlcm5fMS5QYXJ0aXRpb25EYXRlVGltZVJhbmdlUGF0dGVybihkdGYsIHgsIHksIGltcGxEZXRhaWxzKTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KDApO1xuICAgIGZvciAodmFyIF9pID0gMCwgcGFydHNfMSA9IHBhcnRzOyBfaSA8IHBhcnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcGFydHNfMVtfaV07XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IHBhcnQudHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJ0LnZhbHVlLFxuICAgICAgICAgICAgc291cmNlOiBwYXJ0LnNvdXJjZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLkZvcm1hdERhdGVUaW1lUmFuZ2VUb1BhcnRzID0gRm9ybWF0RGF0ZVRpbWVSYW5nZVRvUGFydHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRm9ybWF0RGF0ZVRpbWVUb1BhcnRzID0gdm9pZCAwO1xudmFyIFBhcnRpdGlvbkRhdGVUaW1lUGF0dGVybl8xID0gcmVxdWlyZShcIi4vUGFydGl0aW9uRGF0ZVRpbWVQYXR0ZXJuXCIpO1xudmFyIF8yNjJfMSA9IHJlcXVpcmUoXCIuLi8yNjJcIik7XG4vKipcbiAqIGh0dHBzOi8vdGMzOS5lcy9lY21hNDAyLyNzZWMtZm9ybWF0ZGF0ZXRpbWV0b3BhcnRzXG4gKlxuICogQHBhcmFtIGR0ZlxuICogQHBhcmFtIHhcbiAqIEBwYXJhbSBpbXBsRGV0YWlsc1xuICovXG5mdW5jdGlvbiBGb3JtYXREYXRlVGltZVRvUGFydHMoZHRmLCB4LCBpbXBsRGV0YWlscykge1xuICAgIHZhciBwYXJ0cyA9IFBhcnRpdGlvbkRhdGVUaW1lUGF0dGVybl8xLlBhcnRpdGlvbkRhdGVUaW1lUGF0dGVybihkdGYsIHgsIGltcGxEZXRhaWxzKTtcbiAgICB2YXIgcmVzdWx0ID0gXzI2Ml8xLkFycmF5Q3JlYXRlKDApO1xuICAgIGZvciAodmFyIF9pID0gMCwgcGFydHNfMSA9IHBhcnRzOyBfaSA8IHBhcnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcGFydHNfMVtfaV07XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IHBhcnQudHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJ0LnZhbHVlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuRm9ybWF0RGF0ZVRpbWVUb1BhcnRzID0gRm9ybWF0RGF0ZVRpbWVUb1BhcnRzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkluaXRpYWxpemVEYXRlVGltZUZvcm1hdCA9IHZvaWQgMDtcbnZhciBDYW5vbmljYWxpemVMb2NhbGVMaXN0XzEgPSByZXF1aXJlKFwiLi4vQ2Fub25pY2FsaXplTG9jYWxlTGlzdFwiKTtcbnZhciBUb0RhdGVUaW1lT3B0aW9uc18xID0gcmVxdWlyZShcIi4vVG9EYXRlVGltZU9wdGlvbnNcIik7XG52YXIgR2V0T3B0aW9uXzEgPSByZXF1aXJlKFwiLi4vR2V0T3B0aW9uXCIpO1xudmFyIFJlc29sdmVMb2NhbGVfMSA9IHJlcXVpcmUoXCIuLi9SZXNvbHZlTG9jYWxlXCIpO1xudmFyIElzVmFsaWRUaW1lWm9uZU5hbWVfMSA9IHJlcXVpcmUoXCIuLi9Jc1ZhbGlkVGltZVpvbmVOYW1lXCIpO1xudmFyIENhbm9uaWNhbGl6ZVRpbWVab25lTmFtZV8xID0gcmVxdWlyZShcIi4uL0Nhbm9uaWNhbGl6ZVRpbWVab25lTmFtZVwiKTtcbnZhciBCYXNpY0Zvcm1hdE1hdGNoZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2ljRm9ybWF0TWF0Y2hlclwiKTtcbnZhciBCZXN0Rml0Rm9ybWF0TWF0Y2hlcl8xID0gcmVxdWlyZShcIi4vQmVzdEZpdEZvcm1hdE1hdGNoZXJcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciB1dGlsc18yID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgRGF0ZVRpbWVTdHlsZUZvcm1hdF8xID0gcmVxdWlyZShcIi4vRGF0ZVRpbWVTdHlsZUZvcm1hdFwiKTtcbmZ1bmN0aW9uIGlzVGltZVJlbGF0ZWQob3B0KSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IFsnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJ107IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBwcm9wID0gX2FbX2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSBvcHRbcHJvcF07XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZXNvbHZlSG91ckN5Y2xlKGhjLCBoY0RlZmF1bHQsIGhvdXIxMikge1xuICAgIGlmIChoYyA9PSBudWxsKSB7XG4gICAgICAgIGhjID0gaGNEZWZhdWx0O1xuICAgIH1cbiAgICBpZiAoaG91cjEyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGhvdXIxMikge1xuICAgICAgICAgICAgaWYgKGhjRGVmYXVsdCA9PT0gJ2gxMScgfHwgaGNEZWZhdWx0ID09PSAnaDIzJykge1xuICAgICAgICAgICAgICAgIGhjID0gJ2gxMSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYyA9ICdoMTInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXRpbHNfMS5pbnZhcmlhbnQoIWhvdXIxMiwgJ2hvdXIxMiBtdXN0IG5vdCBiZSBzZXQnKTtcbiAgICAgICAgICAgIGlmIChoY0RlZmF1bHQgPT09ICdoMTEnIHx8IGhjRGVmYXVsdCA9PT0gJ2gyMycpIHtcbiAgICAgICAgICAgICAgICBoYyA9ICdoMjMnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGMgPSAnaDI0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGM7XG59XG52YXIgVFlQRV9SRUdFWCA9IC9eW2EtejAtOV17Myw4fSQvaTtcbi8qKlxuICogaHR0cHM6Ly90YzM5LmVzL2VjbWE0MDIvI3NlYy1pbml0aWFsaXplZGF0ZXRpbWVmb3JtYXRcbiAqIEBwYXJhbSBkdGYgRGF0ZVRpbWVGb3JtYXRcbiAqIEBwYXJhbSBsb2NhbGVzIGxvY2FsZXNcbiAqIEBwYXJhbSBvcHRzIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gSW5pdGlhbGl6ZURhdGVUaW1lRm9ybWF0KGR0ZiwgbG9jYWxlcywgb3B0cywgX2EpIHtcbiAgICB2YXIgZ2V0SW50ZXJuYWxTbG90cyA9IF9hLmdldEludGVybmFsU2xvdHMsIGF2YWlsYWJsZUxvY2FsZXMgPSBfYS5hdmFpbGFibGVMb2NhbGVzLCBsb2NhbGVEYXRhID0gX2EubG9jYWxlRGF0YSwgZ2V0RGVmYXVsdExvY2FsZSA9IF9hLmdldERlZmF1bHRMb2NhbGUsIGdldERlZmF1bHRUaW1lWm9uZSA9IF9hLmdldERlZmF1bHRUaW1lWm9uZSwgcmVsZXZhbnRFeHRlbnNpb25LZXlzID0gX2EucmVsZXZhbnRFeHRlbnNpb25LZXlzLCB0ekRhdGEgPSBfYS50ekRhdGEsIHVwcGVyY2FzZUxpbmtzID0gX2EudXBwZXJjYXNlTGlua3M7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhciByZXF1ZXN0ZWRMb2NhbGVzID0gQ2Fub25pY2FsaXplTG9jYWxlTGlzdF8xLkNhbm9uaWNhbGl6ZUxvY2FsZUxpc3QobG9jYWxlcyk7XG4gICAgdmFyIG9wdGlvbnMgPSBUb0RhdGVUaW1lT3B0aW9uc18xLlRvRGF0ZVRpbWVPcHRpb25zKG9wdHMsICdhbnknLCAnZGF0ZScpO1xuICAgIHZhciBvcHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBtYXRjaGVyID0gR2V0T3B0aW9uXzEuR2V0T3B0aW9uKG9wdGlvbnMsICdsb2NhbGVNYXRjaGVyJywgJ3N0cmluZycsIFsnbG9va3VwJywgJ2Jlc3QgZml0J10sICdiZXN0IGZpdCcpO1xuICAgIG9wdC5sb2NhbGVNYXRjaGVyID0gbWF0Y2hlcjtcbiAgICB2YXIgY2FsZW5kYXIgPSBHZXRPcHRpb25fMS5HZXRPcHRpb24ob3B0aW9ucywgJ2NhbGVuZGFyJywgJ3N0cmluZycsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICBpZiAoY2FsZW5kYXIgIT09IHVuZGVmaW5lZCAmJiAhVFlQRV9SRUdFWC50ZXN0KGNhbGVuZGFyKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTWFsZm9ybWVkIGNhbGVuZGFyJyk7XG4gICAgfVxuICAgIHZhciBpbnRlcm5hbFNsb3RzID0gZ2V0SW50ZXJuYWxTbG90cyhkdGYpO1xuICAgIG9wdC5jYSA9IGNhbGVuZGFyO1xuICAgIHZhciBudW1iZXJpbmdTeXN0ZW0gPSBHZXRPcHRpb25fMS5HZXRPcHRpb24ob3B0aW9ucywgJ251bWJlcmluZ1N5c3RlbScsICdzdHJpbmcnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgaWYgKG51bWJlcmluZ1N5c3RlbSAhPT0gdW5kZWZpbmVkICYmICFUWVBFX1JFR0VYLnRlc3QobnVtYmVyaW5nU3lzdGVtKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTWFsZm9ybWVkIG51bWJlcmluZyBzeXN0ZW0nKTtcbiAgICB9XG4gICAgb3B0Lm51ID0gbnVtYmVyaW5nU3lzdGVtO1xuICAgIHZhciBob3VyMTIgPSBHZXRPcHRpb25fMS5HZXRPcHRpb24ob3B0aW9ucywgJ2hvdXIxMicsICdib29sZWFuJywgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgIHZhciBob3VyQ3ljbGUgPSBHZXRPcHRpb25fMS5HZXRPcHRpb24ob3B0aW9ucywgJ2hvdXJDeWNsZScsICdzdHJpbmcnLCBbJ2gxMScsICdoMTInLCAnaDIzJywgJ2gyNCddLCB1bmRlZmluZWQpO1xuICAgIGlmIChob3VyMTIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGhvdXJDeWNsZSA9IG51bGw7XG4gICAgfVxuICAgIG9wdC5oYyA9IGhvdXJDeWNsZTtcbiAgICB2YXIgciA9IFJlc29sdmVMb2NhbGVfMS5SZXNvbHZlTG9jYWxlKGF2YWlsYWJsZUxvY2FsZXMsIHJlcXVlc3RlZExvY2FsZXMsIG9wdCwgcmVsZXZhbnRFeHRlbnNpb25LZXlzLCBsb2NhbGVEYXRhLCBnZXREZWZhdWx0TG9jYWxlKTtcbiAgICBpbnRlcm5hbFNsb3RzLmxvY2FsZSA9IHIubG9jYWxlO1xuICAgIGNhbGVuZGFyID0gci5jYTtcbiAgICBpbnRlcm5hbFNsb3RzLmNhbGVuZGFyID0gY2FsZW5kYXI7XG4gICAgaW50ZXJuYWxTbG90cy5ob3VyQ3ljbGUgPSByLmhjO1xuICAgIGludGVybmFsU2xvdHMubnVtYmVyaW5nU3lzdGVtID0gci5udTtcbiAgICB2YXIgZGF0YUxvY2FsZSA9IHIuZGF0YUxvY2FsZTtcbiAgICBpbnRlcm5hbFNsb3RzLmRhdGFMb2NhbGUgPSBkYXRhTG9jYWxlO1xuICAgIHZhciB0aW1lWm9uZSA9IG9wdGlvbnMudGltZVpvbmU7XG4gICAgaWYgKHRpbWVab25lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGltZVpvbmUgPSBTdHJpbmcodGltZVpvbmUpO1xuICAgICAgICBpZiAoIUlzVmFsaWRUaW1lWm9uZU5hbWVfMS5Jc1ZhbGlkVGltZVpvbmVOYW1lKHRpbWVab25lLCB7IHR6RGF0YTogdHpEYXRhLCB1cHBlcmNhc2VMaW5rczogdXBwZXJjYXNlTGlua3MgfSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHRpbWVab25lTmFtZScpO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVab25lID0gQ2Fub25pY2FsaXplVGltZVpvbmVOYW1lXzEuQ2Fub25pY2FsaXplVGltZVpvbmVOYW1lKHRpbWVab25lLCB7IHR6RGF0YTogdHpEYXRhLCB1cHBlcmNhc2VMaW5rczogdXBwZXJjYXNlTGlua3MgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aW1lWm9uZSA9IGdldERlZmF1bHRUaW1lWm9uZSgpO1xuICAgIH1cbiAgICBpbnRlcm5hbFNsb3RzLnRpbWVab25lID0gdGltZVpvbmU7XG4gICAgb3B0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBvcHQud2Vla2RheSA9IEdldE9wdGlvbl8xLkdldE9wdGlvbihvcHRpb25zLCAnd2Vla2RheScsICdzdHJpbmcnLCBbJ25hcnJvdycsICdzaG9ydCcsICdsb25nJ10sIHVuZGVmaW5lZCk7XG4gICAgb3B0LmVyYSA9IEdldE9wdGlvbl8xLkdldE9wdGlvbihvcHRpb25zLCAnZXJhJywgJ3N0cmluZycsIFsnbmFycm93JywgJ3Nob3J0JywgJ2xvbmcnXSwgdW5kZWZpbmVkKTtcbiAgICBvcHQueWVhciA9IEdldE9wdGlvbl8xLkdldE9wdGlvbihvcHRpb25zLCAneWVhcicsICdzdHJpbmcnLCBbJzItZGlnaXQnLCAnbnVtZXJpYyddLCB1bmRlZmluZWQpO1xuICAgIG9wdC5tb250aCA9IEdldE9wdGlvbl8xLkdldE9wdGlvbihvcHRpb25zLCAnbW9udGgnLCAnc3RyaW5nJywgWycyLWRpZ2l0JywgJ251bWVyaWMnLCAnbmFycm93JywgJ3Nob3J0JywgJ2xvbmcnXSwgdW5kZWZpbmVkKTtcbiAgICBvcHQuZGF5ID0gR2V0T3B0aW9uXzEuR2V0T3B0aW9uKG9wdGlvbnMsICdkYXknLCAnc3RyaW5nJywgWycyLWRpZ2l0JywgJ251bWVyaWMnXSwgdW5kZWZpbmVkKTtcbiAgICBvcHQuaG91ciA9IEdldE9wdGlvbl8xLkdldE9wdGlvbihvcHRpb25zLCAnaG91cicsICdzdHJpbmcnLCBbJzItZGlnaXQnLCAnbnVtZXJpYyddLCB1bmRlZmluZWQpO1xuICAgIG9wdC5taW51dGUgPSBHZXRPcHRpb25fMS5HZXRPcHRpb24ob3B0aW9ucywgJ21pbnV0ZScsICdzdHJpbmcnLCBbJzItZGlnaXQnLCAnbnVtZXJpYyddLCB1bmRlZmluZWQpO1xuICAgIG9wdC5zZWNvbmQgPSBHZXRPcHRpb25fMS5HZXRPcHRpb24ob3B0aW9ucywgJ3NlY29uZCcsICdzdHJpbmcnLCBbJzItZGlnaXQnLCAnbnVtZXJpYyddLCB1bmRlZmluZWQpO1xuICAgIG9wdC50aW1lWm9uZU5hbWUgPSBHZXRPcHRpb25fMS5HZXRPcHRpb24ob3B0aW9ucywgJ3RpbWVab25lTmFtZScsICdzdHJpbmcnLCBbJ3Nob3J0JywgJ2xvbmcnXSwgdW5kZWZpbmVkKTtcbiAgICB2YXIgZGF0YUxvY2FsZURhdGEgPSBsb2NhbGVEYXRhW2RhdGFMb2NhbGVdO1xuICAgIHV0aWxzXzEuaW52YXJpYW50KCEhZGF0YUxvY2FsZURhdGEsIFwiTWlzc2luZyBsb2NhbGUgZGF0YSBmb3IgXCIgKyBkYXRhTG9jYWxlKTtcbiAgICB2YXIgZm9ybWF0cyA9IGRhdGFMb2NhbGVEYXRhLmZvcm1hdHNbY2FsZW5kYXJdO1xuICAgIC8vIFVOU1BFQ0NFRDogSU1QTEVNRU5UQVRJT04gREVUQUlMU1xuICAgIGlmICghZm9ybWF0cykge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbGVuZGFyIFxcXCJcIiArIGNhbGVuZGFyICsgXCJcXFwiIGlzIG5vdCBzdXBwb3J0ZWQuIFRyeSBzZXR0aW5nIFxcXCJjYWxlbmRhclxcXCIgdG8gMSBvZiB0aGUgZm9sbG93aW5nOiBcIiArIE9iamVjdC5rZXlzKGRhdGFMb2NhbGVEYXRhLmZvcm1hdHMpLmpvaW4oJywgJykpO1xuICAgIH1cbiAgICBtYXRjaGVyID0gR2V0T3B0aW9uXzEuR2V0T3B0aW9uKG9wdGlvbnMsICdmb3JtYXRNYXRjaGVyJywgJ3N0cmluZycsIFsnYmFzaWMnLCAnYmVzdCBmaXQnXSwgJ2Jlc3QgZml0Jyk7XG4gICAgdmFyIGRhdGVTdHlsZSA9IEdldE9wdGlvbl8xLkdldE9wdGlvbihvcHRpb25zLCAnZGF0ZVN0eWxlJywgJ3N0cmluZycsIFsnZnVsbCcsICdsb25nJywgJ21lZGl1bScsICdzaG9ydCddLCB1bmRlZmluZWQpO1xuICAgIGludGVybmFsU2xvdHMuZGF0ZVN0eWxlID0gZGF0ZVN0eWxlO1xuICAgIHZhciB0aW1lU3R5bGUgPSBHZXRPcHRpb25fMS5HZXRPcHRpb24ob3B0aW9ucywgJ3RpbWVTdHlsZScsICdzdHJpbmcnLCBbJ2Z1bGwnLCAnbG9uZycsICdtZWRpdW0nLCAnc2hvcnQnXSwgdW5kZWZpbmVkKTtcbiAgICBpbnRlcm5hbFNsb3RzLnRpbWVTdHlsZSA9IHRpbWVTdHlsZTtcbiAgICB2YXIgYmVzdEZvcm1hdDtcbiAgICBpZiAoZGF0ZVN0eWxlID09PSB1bmRlZmluZWQgJiYgdGltZVN0eWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG1hdGNoZXIgPT09ICdiYXNpYycpIHtcbiAgICAgICAgICAgIGJlc3RGb3JtYXQgPSBCYXNpY0Zvcm1hdE1hdGNoZXJfMS5CYXNpY0Zvcm1hdE1hdGNoZXIob3B0LCBmb3JtYXRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElNUEwgREVUQUlMUyBTVEFSVFxuICAgICAgICAgICAgaWYgKGlzVGltZVJlbGF0ZWQob3B0KSkge1xuICAgICAgICAgICAgICAgIHZhciBoYyA9IHJlc29sdmVIb3VyQ3ljbGUoaW50ZXJuYWxTbG90cy5ob3VyQ3ljbGUsIGRhdGFMb2NhbGVEYXRhLmhvdXJDeWNsZSwgaG91cjEyKTtcbiAgICAgICAgICAgICAgICBvcHQuaG91cjEyID0gaGMgPT09ICdoMTEnIHx8IGhjID09PSAnaDEyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElNUEwgREVUQUlMUyBFTkRcbiAgICAgICAgICAgIGJlc3RGb3JtYXQgPSBCZXN0Rml0Rm9ybWF0TWF0Y2hlcl8xLkJlc3RGaXRGb3JtYXRNYXRjaGVyKG9wdCwgZm9ybWF0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgREFURV9USU1FX1BST1BTXzEgPSB1dGlsc18yLkRBVEVfVElNRV9QUk9QUzsgX2kgPCBEQVRFX1RJTUVfUFJPUFNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBwcm9wID0gREFURV9USU1FX1BST1BTXzFbX2ldO1xuICAgICAgICAgICAgdmFyIHAgPSBvcHRbcHJvcF07XG4gICAgICAgICAgICBpZiAocCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludGwuRGF0ZVRpbWVGb3JtYXQgY2FuJ3Qgc2V0IG9wdGlvbiBcIiArIHByb3AgKyBcIiB3aGVuIFwiICsgKGRhdGVTdHlsZSA/ICdkYXRlU3R5bGUnIDogJ3RpbWVTdHlsZScpICsgXCIgaXMgdXNlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBiZXN0Rm9ybWF0ID0gRGF0ZVRpbWVTdHlsZUZvcm1hdF8xLkRhdGVUaW1lU3R5bGVGb3JtYXQoZGF0ZVN0eWxlLCB0aW1lU3R5bGUsIGRhdGFMb2NhbGVEYXRhKTtcbiAgICB9XG4gICAgLy8gSU1QTCBERVRBSUwgU1RBUlRcbiAgICAvLyBGb3IgZGVidWdnaW5nXG4gICAgaW50ZXJuYWxTbG90cy5mb3JtYXQgPSBiZXN0Rm9ybWF0O1xuICAgIC8vIElNUEwgREVUQUlMIEVORFxuICAgIGZvciAodmFyIHByb3AgaW4gb3B0KSB7XG4gICAgICAgIHZhciBwID0gYmVzdEZvcm1hdFtwcm9wXTtcbiAgICAgICAgaWYgKHAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW50ZXJuYWxTbG90c1twcm9wXSA9IHA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHBhdHRlcm47XG4gICAgdmFyIHJhbmdlUGF0dGVybnM7XG4gICAgaWYgKGludGVybmFsU2xvdHMuaG91ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBoYyA9IHJlc29sdmVIb3VyQ3ljbGUoaW50ZXJuYWxTbG90cy5ob3VyQ3ljbGUsIGRhdGFMb2NhbGVEYXRhLmhvdXJDeWNsZSwgaG91cjEyKTtcbiAgICAgICAgaW50ZXJuYWxTbG90cy5ob3VyQ3ljbGUgPSBoYztcbiAgICAgICAgaWYgKGhjID09PSAnaDExJyB8fCBoYyA9PT0gJ2gxMicpIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSBiZXN0Rm9ybWF0LnBhdHRlcm4xMjtcbiAgICAgICAgICAgIHJhbmdlUGF0dGVybnMgPSBiZXN0Rm9ybWF0LnJhbmdlUGF0dGVybnMxMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSBiZXN0Rm9ybWF0LnBhdHRlcm47XG4gICAgICAgICAgICByYW5nZVBhdHRlcm5zID0gYmVzdEZvcm1hdC5yYW5nZVBhdHRlcm5zO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGludGVybmFsU2xvdHMuaG91ckN5Y2xlID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXR0ZXJuID0gYmVzdEZvcm1hdC5wYXR0ZXJuO1xuICAgICAgICByYW5nZVBhdHRlcm5zID0gYmVzdEZvcm1hdC5yYW5nZVBhdHRlcm5zO1xuICAgIH1cbiAgICBpbnRlcm5hbFNsb3RzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgIGludGVybmFsU2xvdHMucmFuZ2VQYXR0ZXJucyA9IHJhbmdlUGF0dGVybnM7XG4gICAgcmV0dXJuIGR0Zjtcbn1cbmV4cG9ydHMuSW5pdGlhbGl6ZURhdGVUaW1lRm9ybWF0ID0gSW5pdGlhbGl6ZURhdGVUaW1lRm9ybWF0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBhcnRpdGlvbkRhdGVUaW1lUGF0dGVybiA9IHZvaWQgMDtcbnZhciBfMjYyXzEgPSByZXF1aXJlKFwiLi4vMjYyXCIpO1xudmFyIEZvcm1hdERhdGVUaW1lUGF0dGVybl8xID0gcmVxdWlyZShcIi4vRm9ybWF0RGF0ZVRpbWVQYXR0ZXJuXCIpO1xudmFyIFBhcnRpdGlvblBhdHRlcm5fMSA9IHJlcXVpcmUoXCIuLi9QYXJ0aXRpb25QYXR0ZXJuXCIpO1xuLyoqXG4gKiBodHRwczovL3RjMzkuZXMvZWNtYTQwMi8jc2VjLXBhcnRpdGlvbmRhdGV0aW1lcGF0dGVyblxuICogQHBhcmFtIGR0ZlxuICogQHBhcmFtIHhcbiAqL1xuZnVuY3Rpb24gUGFydGl0aW9uRGF0ZVRpbWVQYXR0ZXJuKGR0ZiwgeCwgaW1wbERldGFpbHMpIHtcbiAgICB4ID0gXzI2Ml8xLlRpbWVDbGlwKHgpO1xuICAgIGlmIChpc05hTih4KSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW52YWxpZCB0aW1lJyk7XG4gICAgfVxuICAgIC8qKiBJTVBMIFNUQVJUICovXG4gICAgdmFyIGdldEludGVybmFsU2xvdHMgPSBpbXBsRGV0YWlscy5nZXRJbnRlcm5hbFNsb3RzO1xuICAgIHZhciBpbnRlcm5hbFNsb3RzID0gZ2V0SW50ZXJuYWxTbG90cyhkdGYpO1xuICAgIC8qKiBJTVBMIEVORCAqL1xuICAgIHZhciBwYXR0ZXJuID0gaW50ZXJuYWxTbG90cy5wYXR0ZXJuO1xuICAgIHJldHVybiBGb3JtYXREYXRlVGltZVBhdHRlcm5fMS5Gb3JtYXREYXRlVGltZVBhdHRlcm4oZHRmLCBQYXJ0aXRpb25QYXR0ZXJuXzEuUGFydGl0aW9uUGF0dGVybihwYXR0ZXJuKSwgeCwgaW1wbERldGFpbHMpO1xufVxuZXhwb3J0cy5QYXJ0aXRpb25EYXRlVGltZVBhdHRlcm4gPSBQYXJ0aXRpb25EYXRlVGltZVBhdHRlcm47XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFydGl0aW9uRGF0ZVRpbWVSYW5nZVBhdHRlcm4gPSB2b2lkIDA7XG52YXIgXzI2Ml8xID0gcmVxdWlyZShcIi4uLzI2MlwiKTtcbnZhciBUb0xvY2FsVGltZV8xID0gcmVxdWlyZShcIi4vVG9Mb2NhbFRpbWVcIik7XG52YXIgRm9ybWF0RGF0ZVRpbWVQYXR0ZXJuXzEgPSByZXF1aXJlKFwiLi9Gb3JtYXREYXRlVGltZVBhdHRlcm5cIik7XG52YXIgUGFydGl0aW9uUGF0dGVybl8xID0gcmVxdWlyZShcIi4uL1BhcnRpdGlvblBhdHRlcm5cIik7XG52YXIgVEFCTEVfMl9GSUVMRFMgPSBbXG4gICAgJ2VyYScsXG4gICAgJ3llYXInLFxuICAgICdtb250aCcsXG4gICAgJ2RheScsXG4gICAgJ2FtcG0nLFxuICAgICdob3VyJyxcbiAgICAnbWludXRlJyxcbiAgICAnc2Vjb25kJyxcbl07XG5mdW5jdGlvbiBQYXJ0aXRpb25EYXRlVGltZVJhbmdlUGF0dGVybihkdGYsIHgsIHksIGltcGxEZXRhaWxzKSB7XG4gICAgeCA9IF8yNjJfMS5UaW1lQ2xpcCh4KTtcbiAgICBpZiAoaXNOYU4oeCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhcnQgdGltZScpO1xuICAgIH1cbiAgICB5ID0gXzI2Ml8xLlRpbWVDbGlwKHkpO1xuICAgIGlmIChpc05hTih5KSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBlbmQgdGltZScpO1xuICAgIH1cbiAgICAvKiogSU1QTCBTVEFSVCAqL1xuICAgIHZhciBnZXRJbnRlcm5hbFNsb3RzID0gaW1wbERldGFpbHMuZ2V0SW50ZXJuYWxTbG90cywgdHpEYXRhID0gaW1wbERldGFpbHMudHpEYXRhO1xuICAgIHZhciBpbnRlcm5hbFNsb3RzID0gZ2V0SW50ZXJuYWxTbG90cyhkdGYpO1xuICAgIC8qKiBJTVBMIEVORCAqL1xuICAgIHZhciB0bTEgPSBUb0xvY2FsVGltZV8xLlRvTG9jYWxUaW1lKHgsIFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpbnRlcm5hbFNsb3RzLmNhbGVuZGFyLCBpbnRlcm5hbFNsb3RzLnRpbWVab25lLCB7IHR6RGF0YTogdHpEYXRhIH0pO1xuICAgIHZhciB0bTIgPSBUb0xvY2FsVGltZV8xLlRvTG9jYWxUaW1lKHksIFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpbnRlcm5hbFNsb3RzLmNhbGVuZGFyLCBpbnRlcm5hbFNsb3RzLnRpbWVab25lLCB7IHR6RGF0YTogdHpEYXRhIH0pO1xuICAgIHZhciBwYXR0ZXJuID0gaW50ZXJuYWxTbG90cy5wYXR0ZXJuLCByYW5nZVBhdHRlcm5zID0gaW50ZXJuYWxTbG90cy5yYW5nZVBhdHRlcm5zO1xuICAgIHZhciByYW5nZVBhdHRlcm47XG4gICAgdmFyIGRhdGVGaWVsZHNQcmFjdGljYWxseUVxdWFsID0gdHJ1ZTtcbiAgICB2YXIgcGF0dGVybkNvbnRhaW5zTGFyZ2VyRGF0ZUZpZWxkID0gZmFsc2U7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBUQUJMRV8yX0ZJRUxEU18xID0gVEFCTEVfMl9GSUVMRFM7IF9pIDwgVEFCTEVfMl9GSUVMRFNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGZpZWxkTmFtZSA9IFRBQkxFXzJfRklFTERTXzFbX2ldO1xuICAgICAgICBpZiAoZGF0ZUZpZWxkc1ByYWN0aWNhbGx5RXF1YWwgJiYgIXBhdHRlcm5Db250YWluc0xhcmdlckRhdGVGaWVsZCkge1xuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSA9PT0gJ2FtcG0nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJwID0gcmFuZ2VQYXR0ZXJucy5hbXBtO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZVBhdHRlcm4gIT09IHVuZGVmaW5lZCAmJiBycCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5Db250YWluc0xhcmdlckRhdGVGaWVsZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdjEgPSB0bTEuaG91cjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYyID0gdG0yLmhvdXI7XG4gICAgICAgICAgICAgICAgICAgIGlmICgodjEgPiAxMSAmJiB2MiA8IDExKSB8fCAodjEgPCAxMSAmJiB2MiA+IDExKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZUZpZWxkc1ByYWN0aWNhbGx5RXF1YWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByYW5nZVBhdHRlcm4gPSBycDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcnAgPSByYW5nZVBhdHRlcm5zW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlUGF0dGVybiAhPT0gdW5kZWZpbmVkICYmIHJwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybkNvbnRhaW5zTGFyZ2VyRGF0ZUZpZWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2MSA9IHRtMVtmaWVsZE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdjIgPSB0bTJbZmllbGROYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfMjYyXzEuU2FtZVZhbHVlKHYxLCB2MikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVGaWVsZHNQcmFjdGljYWxseUVxdWFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VQYXR0ZXJuID0gcnA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRlRmllbGRzUHJhY3RpY2FsbHlFcXVhbCkge1xuICAgICAgICB2YXIgcmVzdWx0XzIgPSBGb3JtYXREYXRlVGltZVBhdHRlcm5fMS5Gb3JtYXREYXRlVGltZVBhdHRlcm4oZHRmLCBQYXJ0aXRpb25QYXR0ZXJuXzEuUGFydGl0aW9uUGF0dGVybihwYXR0ZXJuKSwgeCwgaW1wbERldGFpbHMpO1xuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIHJlc3VsdF8xID0gcmVzdWx0XzI7IF9hIDwgcmVzdWx0XzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICB2YXIgciA9IHJlc3VsdF8xW19hXTtcbiAgICAgICAgICAgIHIuc291cmNlID0gXCJzaGFyZWRcIiAvKiBzaGFyZWQgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdF8yO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgaWYgKHJhbmdlUGF0dGVybiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJhbmdlUGF0dGVybiA9IHJhbmdlUGF0dGVybnMuZGVmYXVsdDtcbiAgICAgICAgLyoqIElNUEwgREVUQUlMUyAqL1xuICAgICAgICAvLyBOb3cgd2UgaGF2ZSB0byByZXBsYWNlIHswfSAmIHsxfSB3aXRoIGFjdHVhbCBwYXR0ZXJuXG4gICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSByYW5nZVBhdHRlcm4ucGF0dGVyblBhcnRzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgdmFyIHBhdHRlcm5QYXJ0ID0gX2NbX2JdO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm5QYXJ0LnBhdHRlcm4gPT09ICd7MH0nIHx8IHBhdHRlcm5QYXJ0LnBhdHRlcm4gPT09ICd7MX0nKSB7XG4gICAgICAgICAgICAgICAgcGF0dGVyblBhcnQucGF0dGVybiA9IHBhdHRlcm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgX2QgPSAwLCBfZSA9IHJhbmdlUGF0dGVybi5wYXR0ZXJuUGFydHM7IF9kIDwgX2UubGVuZ3RoOyBfZCsrKSB7XG4gICAgICAgIHZhciByYW5nZVBhdHRlcm5QYXJ0ID0gX2VbX2RdO1xuICAgICAgICB2YXIgc291cmNlID0gcmFuZ2VQYXR0ZXJuUGFydC5zb3VyY2UsIHBhdHRlcm5fMSA9IHJhbmdlUGF0dGVyblBhcnQucGF0dGVybjtcbiAgICAgICAgdmFyIHogPSB2b2lkIDA7XG4gICAgICAgIGlmIChzb3VyY2UgPT09IFwic3RhcnRSYW5nZVwiIC8qIHN0YXJ0UmFuZ2UgKi8gfHxcbiAgICAgICAgICAgIHNvdXJjZSA9PT0gXCJzaGFyZWRcIiAvKiBzaGFyZWQgKi8pIHtcbiAgICAgICAgICAgIHogPSB4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeiA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhdHRlcm5QYXJ0cyA9IFBhcnRpdGlvblBhdHRlcm5fMS5QYXJ0aXRpb25QYXR0ZXJuKHBhdHRlcm5fMSk7XG4gICAgICAgIHZhciBwYXJ0UmVzdWx0ID0gRm9ybWF0RGF0ZVRpbWVQYXR0ZXJuXzEuRm9ybWF0RGF0ZVRpbWVQYXR0ZXJuKGR0ZiwgcGF0dGVyblBhcnRzLCB6LCBpbXBsRGV0YWlscyk7XG4gICAgICAgIGZvciAodmFyIF9mID0gMCwgcGFydFJlc3VsdF8xID0gcGFydFJlc3VsdDsgX2YgPCBwYXJ0UmVzdWx0XzEubGVuZ3RoOyBfZisrKSB7XG4gICAgICAgICAgICB2YXIgciA9IHBhcnRSZXN1bHRfMVtfZl07XG4gICAgICAgICAgICByLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHBhcnRSZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5QYXJ0aXRpb25EYXRlVGltZVJhbmdlUGF0dGVybiA9IFBhcnRpdGlvbkRhdGVUaW1lUmFuZ2VQYXR0ZXJuO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRvRGF0ZVRpbWVPcHRpb25zID0gdm9pZCAwO1xudmFyIF8yNjJfMSA9IHJlcXVpcmUoXCIuLi8yNjJcIik7XG4vKipcbiAqIGh0dHBzOi8vdGMzOS5lcy9lY21hNDAyLyNzZWMtdG9kYXRldGltZW9wdGlvbnNcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gcmVxdWlyZWRcbiAqIEBwYXJhbSBkZWZhdWx0c1xuICovXG5mdW5jdGlvbiBUb0RhdGVUaW1lT3B0aW9ucyhvcHRpb25zLCByZXF1aXJlZCwgZGVmYXVsdHMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyA9IF8yNjJfMS5Ub09iamVjdChvcHRpb25zKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyk7XG4gICAgdmFyIG5lZWREZWZhdWx0cyA9IHRydWU7XG4gICAgaWYgKHJlcXVpcmVkID09PSAnZGF0ZScgfHwgcmVxdWlyZWQgPT09ICdhbnknKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBbJ3dlZWtkYXknLCAneWVhcicsICdtb250aCcsICdkYXknXTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBwcm9wID0gX2FbX2ldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gb3B0aW9uc1twcm9wXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbmVlZERlZmF1bHRzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlcXVpcmVkID09PSAndGltZScgfHwgcmVxdWlyZWQgPT09ICdhbnknKSB7XG4gICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBbJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCddOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgdmFyIHByb3AgPSBfY1tfYl07XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBvcHRpb25zW3Byb3BdO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBuZWVkRGVmYXVsdHMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kYXRlU3R5bGUgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnRpbWVTdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5lZWREZWZhdWx0cyA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocmVxdWlyZWQgPT09ICdkYXRlJyAmJiBvcHRpb25zLnRpbWVTdHlsZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnRsLkRhdGVUaW1lRm9ybWF0IGRhdGUgd2FzIHJlcXVpcmVkIGJ1dCB0aW1lU3R5bGUgd2FzIGluY2x1ZGVkJyk7XG4gICAgfVxuICAgIGlmIChyZXF1aXJlZCA9PT0gJ3RpbWUnICYmIG9wdGlvbnMuZGF0ZVN0eWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludGwuRGF0ZVRpbWVGb3JtYXQgdGltZSB3YXMgcmVxdWlyZWQgYnV0IGRhdGVTdHlsZSB3YXMgaW5jbHVkZWQnKTtcbiAgICB9XG4gICAgaWYgKG5lZWREZWZhdWx0cyAmJiAoZGVmYXVsdHMgPT09ICdkYXRlJyB8fCBkZWZhdWx0cyA9PT0gJ2FsbCcpKSB7XG4gICAgICAgIGZvciAodmFyIF9kID0gMCwgX2UgPSBbJ3llYXInLCAnbW9udGgnLCAnZGF5J107IF9kIDwgX2UubGVuZ3RoOyBfZCsrKSB7XG4gICAgICAgICAgICB2YXIgcHJvcCA9IF9lW19kXTtcbiAgICAgICAgICAgIG9wdGlvbnNbcHJvcF0gPSAnbnVtZXJpYyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5lZWREZWZhdWx0cyAmJiAoZGVmYXVsdHMgPT09ICd0aW1lJyB8fCBkZWZhdWx0cyA9PT0gJ2FsbCcpKSB7XG4gICAgICAgIGZvciAodmFyIF9mID0gMCwgX2cgPSBbJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCddOyBfZiA8IF9nLmxlbmd0aDsgX2YrKykge1xuICAgICAgICAgICAgdmFyIHByb3AgPSBfZ1tfZl07XG4gICAgICAgICAgICBvcHRpb25zW3Byb3BdID0gJ251bWVyaWMnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZXhwb3J0cy5Ub0RhdGVUaW1lT3B0aW9ucyA9IFRvRGF0ZVRpbWVPcHRpb25zO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRvTG9jYWxUaW1lID0gdm9pZCAwO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgXzI2Ml8xID0gcmVxdWlyZShcIi4uLzI2MlwiKTtcbmZ1bmN0aW9uIGdldEFwcGxpY2FibGVab25lRGF0YSh0LCB0aW1lWm9uZSwgdHpEYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciB6b25lRGF0YSA9IHR6RGF0YVt0aW1lWm9uZV07XG4gICAgLy8gV2UgZG9uJ3QgaGF2ZSBkYXRhIGZvciB0aGlzIHNvIGp1c3Qgc2F5IGl0J3MgVVRDXG4gICAgaWYgKCF6b25lRGF0YSkge1xuICAgICAgICByZXR1cm4gWzAsIGZhbHNlXTtcbiAgICB9XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHZhciBkc3QgPSBmYWxzZTtcbiAgICBmb3IgKDsgaSA8PSB6b25lRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA9PT0gem9uZURhdGEubGVuZ3RoIHx8IHpvbmVEYXRhW2ldWzBdICogMWUzID4gdCkge1xuICAgICAgICAgICAgX2EgPSB6b25lRGF0YVtpIC0gMV0sIG9mZnNldCA9IF9hWzJdLCBkc3QgPSBfYVszXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbb2Zmc2V0ICogMWUzLCBkc3RdO1xufVxuLyoqXG4gKiBodHRwczovL3RjMzkuZXMvZWNtYTQwMi8jc2VjLXRvbG9jYWx0aW1lXG4gKiBAcGFyYW0gdFxuICogQHBhcmFtIGNhbGVuZGFyXG4gKiBAcGFyYW0gdGltZVpvbmVcbiAqL1xuZnVuY3Rpb24gVG9Mb2NhbFRpbWUodCwgY2FsZW5kYXIsIHRpbWVab25lLCBfYSkge1xuICAgIHZhciB0ekRhdGEgPSBfYS50ekRhdGE7XG4gICAgdXRpbHNfMS5pbnZhcmlhbnQoXzI2Ml8xLlR5cGUodCkgPT09ICdOdW1iZXInLCAnaW52YWxpZCB0aW1lJyk7XG4gICAgdXRpbHNfMS5pbnZhcmlhbnQoY2FsZW5kYXIgPT09ICdncmVnb3J5JywgJ1dlIG9ubHkgc3VwcG9ydCBHcmVnb3J5IGNhbGVuZGFyIHJpZ2h0IG5vdycpO1xuICAgIHZhciBfYiA9IGdldEFwcGxpY2FibGVab25lRGF0YSh0LCB0aW1lWm9uZSwgdHpEYXRhKSwgdGltZVpvbmVPZmZzZXQgPSBfYlswXSwgaW5EU1QgPSBfYlsxXTtcbiAgICB2YXIgdHogPSB0ICsgdGltZVpvbmVPZmZzZXQ7XG4gICAgdmFyIHllYXIgPSBfMjYyXzEuWWVhckZyb21UaW1lKHR6KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB3ZWVrZGF5OiBfMjYyXzEuV2Vla0RheSh0eiksXG4gICAgICAgIGVyYTogeWVhciA8IDAgPyAnQkMnIDogJ0FEJyxcbiAgICAgICAgeWVhcjogeWVhcixcbiAgICAgICAgcmVsYXRlZFllYXI6IHVuZGVmaW5lZCxcbiAgICAgICAgeWVhck5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgbW9udGg6IF8yNjJfMS5Nb250aEZyb21UaW1lKHR6KSxcbiAgICAgICAgZGF5OiBfMjYyXzEuRGF0ZUZyb21UaW1lKHR6KSxcbiAgICAgICAgaG91cjogXzI2Ml8xLkhvdXJGcm9tVGltZSh0eiksXG4gICAgICAgIG1pbnV0ZTogXzI2Ml8xLk1pbkZyb21UaW1lKHR6KSxcbiAgICAgICAgc2Vjb25kOiBfMjYyXzEuU2VjRnJvbVRpbWUodHopLFxuICAgICAgICBpbkRTVDogaW5EU1QsXG4gICAgICAgIC8vIElNUE9SVEFOVDogTm90IGluIHNwZWNcbiAgICAgICAgdGltZVpvbmVPZmZzZXQ6IHRpbWVab25lT2Zmc2V0LFxuICAgIH07XG59XG5leHBvcnRzLlRvTG9jYWxUaW1lID0gVG9Mb2NhbFRpbWU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3BsaXRSYW5nZVBhdHRlcm4gPSBleHBvcnRzLnNwbGl0RmFsbGJhY2tSYW5nZVBhdHRlcm4gPSBleHBvcnRzLnBhcnNlRGF0ZVRpbWVTa2VsZXRvbiA9IGV4cG9ydHMucHJvY2Vzc0RhdGVUaW1lUGF0dGVybiA9IHZvaWQgMDtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuLyoqXG4gKiBodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjRGF0ZV9GaWVsZF9TeW1ib2xfVGFibGVcbiAqIENyZWRpdDogaHR0cHM6Ly9naXRodWIuY29tL2NhcmlkeS9pbnRsLWRhdGV0aW1lZm9ybWF0LXBhdHRlcm4vYmxvYi9tYXN0ZXIvaW5kZXguanNcbiAqIHdpdGggc29tZSB0d2Vha3NcbiAqL1xudmFyIERBVEVfVElNRV9SRUdFWCA9IC8oPzpbRWVjXXsxLDZ9fEd7MSw1fXxbUXFdezEsNX18KD86W3lZdXJdK3xVezEsNX0pfFtNTF17MSw1fXxkezEsMn18RHsxLDN9fEZ7MX18W2FiQl17MSw1fXxbaGtIS117MSwyfXx3ezEsMn18V3sxfXxtezEsMn18c3sxLDJ9fFt6Wk92VnhYXXsxLDR9KSg/PShbXiddKidbXiddKicpKlteJ10qJCkvZztcbi8vIHRyaW0gcGF0dGVybnMgYWZ0ZXIgdHJhbnNmb3JtYXRpb25zXG52YXIgZXhwUGF0dGVyblRyaW1tZXIgPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2c7XG5mdW5jdGlvbiBtYXRjaFNrZWxldG9uUGF0dGVybihtYXRjaCwgcmVzdWx0KSB7XG4gICAgdmFyIGxlbiA9IG1hdGNoLmxlbmd0aDtcbiAgICBzd2l0Y2ggKG1hdGNoWzBdKSB7XG4gICAgICAgIC8vIEVyYVxuICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgICAgIHJlc3VsdC5lcmEgPSBsZW4gPT09IDQgPyAnbG9uZycgOiBsZW4gPT09IDUgPyAnbmFycm93JyA6ICdzaG9ydCc7XG4gICAgICAgICAgICByZXR1cm4gJ3tlcmF9JztcbiAgICAgICAgLy8gWWVhclxuICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgY2FzZSAnWSc6XG4gICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICBjYXNlICdVJzpcbiAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICByZXN1bHQueWVhciA9IGxlbiA9PT0gMiA/ICcyLWRpZ2l0JyA6ICdudW1lcmljJztcbiAgICAgICAgICAgIHJldHVybiAne3llYXJ9JztcbiAgICAgICAgLy8gUXVhcnRlclxuICAgICAgICBjYXNlICdxJzpcbiAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYHcvUWAgKHF1YXJ0ZXIpIHBhdHRlcm5zIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIC8vIE1vbnRoXG4gICAgICAgIGNhc2UgJ00nOlxuICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgIHJlc3VsdC5tb250aCA9IFsnbnVtZXJpYycsICcyLWRpZ2l0JywgJ3Nob3J0JywgJ2xvbmcnLCAnbmFycm93J11bbGVuIC0gMV07XG4gICAgICAgICAgICByZXR1cm4gJ3ttb250aH0nO1xuICAgICAgICAvLyBXZWVrXG4gICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICBjYXNlICdXJzpcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdgdy9XYCAod2VlayBvZiB5ZWFyKSBwYXR0ZXJucyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgIHJlc3VsdC5kYXkgPSBbJ251bWVyaWMnLCAnMi1kaWdpdCddW2xlbiAtIDFdO1xuICAgICAgICAgICAgcmV0dXJuICd7ZGF5fSc7XG4gICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICBjYXNlICdGJzpcbiAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgICByZXN1bHQuZGF5ID0gJ251bWVyaWMnO1xuICAgICAgICAgICAgcmV0dXJuICd7ZGF5fSc7XG4gICAgICAgIC8vIFdlZWtkYXlcbiAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICByZXN1bHQud2Vla2RheSA9IGxlbiA9PT0gNCA/ICdsb25nJyA6IGxlbiA9PT0gNSA/ICduYXJyb3cnIDogJ3Nob3J0JztcbiAgICAgICAgICAgIHJldHVybiAne3dlZWtkYXl9JztcbiAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICByZXN1bHQud2Vla2RheSA9IFtcbiAgICAgICAgICAgICAgICAnbnVtZXJpYycsXG4gICAgICAgICAgICAgICAgJzItZGlnaXQnLFxuICAgICAgICAgICAgICAgICdzaG9ydCcsXG4gICAgICAgICAgICAgICAgJ2xvbmcnLFxuICAgICAgICAgICAgICAgICduYXJyb3cnLFxuICAgICAgICAgICAgICAgICdzaG9ydCcsXG4gICAgICAgICAgICBdW2xlbiAtIDFdO1xuICAgICAgICAgICAgcmV0dXJuICd7d2Vla2RheX0nO1xuICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgIHJlc3VsdC53ZWVrZGF5ID0gW1xuICAgICAgICAgICAgICAgICdudW1lcmljJyxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgJ3Nob3J0JyxcbiAgICAgICAgICAgICAgICAnbG9uZycsXG4gICAgICAgICAgICAgICAgJ25hcnJvdycsXG4gICAgICAgICAgICAgICAgJ3Nob3J0JyxcbiAgICAgICAgICAgIF1bbGVuIC0gMV07XG4gICAgICAgICAgICByZXR1cm4gJ3t3ZWVrZGF5fSc7XG4gICAgICAgIC8vIFBlcmlvZFxuICAgICAgICBjYXNlICdhJzogLy8gQU0sIFBNXG4gICAgICAgIGNhc2UgJ2InOiAvLyBhbSwgcG0sIG5vb24sIG1pZG5pZ2h0XG4gICAgICAgIGNhc2UgJ0InOiAvLyBmbGV4aWJsZSBkYXkgcGVyaW9kc1xuICAgICAgICAgICAgcmVzdWx0LmhvdXIxMiA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gJ3thbXBtfSc7XG4gICAgICAgIC8vIEhvdXJcbiAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICByZXN1bHQuaG91ciA9IFsnbnVtZXJpYycsICcyLWRpZ2l0J11bbGVuIC0gMV07XG4gICAgICAgICAgICByZXN1bHQuaG91cjEyID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiAne2hvdXJ9JztcbiAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICByZXN1bHQuaG91ciA9IFsnbnVtZXJpYycsICcyLWRpZ2l0J11bbGVuIC0gMV07XG4gICAgICAgICAgICByZXR1cm4gJ3tob3VyfSc7XG4gICAgICAgIGNhc2UgJ0snOlxuICAgICAgICAgICAgcmVzdWx0LmhvdXIgPSBbJ251bWVyaWMnLCAnMi1kaWdpdCddW2xlbiAtIDFdO1xuICAgICAgICAgICAgcmVzdWx0LmhvdXIxMiA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gJ3tob3VyfSc7XG4gICAgICAgIGNhc2UgJ2snOlxuICAgICAgICAgICAgcmVzdWx0LmhvdXIgPSBbJ251bWVyaWMnLCAnMi1kaWdpdCddW2xlbiAtIDFdO1xuICAgICAgICAgICAgcmV0dXJuICd7aG91cn0nO1xuICAgICAgICBjYXNlICdqJzpcbiAgICAgICAgY2FzZSAnSic6XG4gICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2BqL0ovQ2AgKGhvdXIpIHBhdHRlcm5zIGFyZSBub3Qgc3VwcG9ydGVkLCB1c2UgYGgvSC9LL2tgIGluc3RlYWQnKTtcbiAgICAgICAgLy8gTWludXRlXG4gICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgcmVzdWx0Lm1pbnV0ZSA9IFsnbnVtZXJpYycsICcyLWRpZ2l0J11bbGVuIC0gMV07XG4gICAgICAgICAgICByZXR1cm4gJ3ttaW51dGV9JztcbiAgICAgICAgLy8gU2Vjb25kXG4gICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgcmVzdWx0LnNlY29uZCA9IFsnbnVtZXJpYycsICcyLWRpZ2l0J11bbGVuIC0gMV07XG4gICAgICAgICAgICByZXR1cm4gJ3tzZWNvbmR9JztcbiAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgcmVzdWx0LnNlY29uZCA9ICdudW1lcmljJztcbiAgICAgICAgICAgIHJldHVybiAne3NlY29uZH0nO1xuICAgICAgICAvLyBab25lXG4gICAgICAgIGNhc2UgJ3onOiAvLyAxLi4zLCA0OiBzcGVjaWZpYyBub24tbG9jYXRpb24gZm9ybWF0XG4gICAgICAgIGNhc2UgJ1onOiAvLyAxLi4zLCA0LCA1OiBUaGUgSVNPODYwMSB2YXJpb3MgZm9ybWF0c1xuICAgICAgICBjYXNlICdPJzogLy8gMSwgNDogbWlsaXNlY29uZHMgaW4gZGF5IHNob3J0LCBsb25nXG4gICAgICAgIGNhc2UgJ3YnOiAvLyAxLCA0OiBnZW5lcmljIG5vbi1sb2NhdGlvbiBmb3JtYXRcbiAgICAgICAgY2FzZSAnVic6IC8vIDEsIDIsIDMsIDQ6IHRpbWUgem9uZSBJRCBvciBjaXR5XG4gICAgICAgIGNhc2UgJ1gnOiAvLyAxLCAyLCAzLCA0OiBUaGUgSVNPODYwMSB2YXJpb3MgZm9ybWF0c1xuICAgICAgICBjYXNlICd4JzogLy8gMSwgMiwgMywgNDogVGhlIElTTzg2MDEgdmFyaW9zIGZvcm1hdHNcbiAgICAgICAgICAgIHJlc3VsdC50aW1lWm9uZU5hbWUgPSBsZW4gPCA0ID8gJ3Nob3J0JyA6ICdsb25nJztcbiAgICAgICAgICAgIHJldHVybiAne3RpbWVab25lTmFtZX0nO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5mdW5jdGlvbiBza2VsZXRvblRva2VuVG9UYWJsZTIoYykge1xuICAgIHN3aXRjaCAoYykge1xuICAgICAgICAvLyBFcmFcbiAgICAgICAgY2FzZSAnRyc6XG4gICAgICAgICAgICByZXR1cm4gJ2VyYSc7XG4gICAgICAgIC8vIFllYXJcbiAgICAgICAgY2FzZSAneSc6XG4gICAgICAgIGNhc2UgJ1knOlxuICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgY2FzZSAnVSc6XG4gICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgcmV0dXJuICd5ZWFyJztcbiAgICAgICAgLy8gTW9udGhcbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgcmV0dXJuICdtb250aCc7XG4gICAgICAgIC8vIERheVxuICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgIGNhc2UgJ0YnOlxuICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgIHJldHVybiAnZGF5JztcbiAgICAgICAgLy8gUGVyaW9kXG4gICAgICAgIGNhc2UgJ2EnOiAvLyBBTSwgUE1cbiAgICAgICAgY2FzZSAnYic6IC8vIGFtLCBwbSwgbm9vbiwgbWlkbmlnaHRcbiAgICAgICAgY2FzZSAnQic6IC8vIGZsZXhpYmxlIGRheSBwZXJpb2RzXG4gICAgICAgICAgICByZXR1cm4gJ2FtcG0nO1xuICAgICAgICAvLyBIb3VyXG4gICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgY2FzZSAnSyc6XG4gICAgICAgIGNhc2UgJ2snOlxuICAgICAgICAgICAgcmV0dXJuICdob3VyJztcbiAgICAgICAgLy8gTWludXRlXG4gICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgcmV0dXJuICdtaW51dGUnO1xuICAgICAgICAvLyBTZWNvbmRcbiAgICAgICAgY2FzZSAncyc6XG4gICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgIHJldHVybiAnc2Vjb25kJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHJhbmdlIHBhdHRlcm4gdG9rZW4nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzRGF0ZVRpbWVQYXR0ZXJuKHBhdHRlcm4sIHJlc3VsdCkge1xuICAgIHZhciBsaXRlcmFscyA9IFtdO1xuICAgIC8vIFVzZSBza2VsZXRvbiB0byBwb3B1bGF0ZSByZXN1bHQsIGJ1dCB1c2UgbWFwcGVkIHBhdHRlcm4gdG8gcG9wdWxhdGUgcGF0dGVyblxuICAgIHZhciBwYXR0ZXJuMTIgPSBwYXR0ZXJuXG4gICAgICAgIC8vIERvdWJsZSBhcG9zdHJvcGhlXG4gICAgICAgIC5yZXBsYWNlKC8nezJ9L2csICd7YXBvc3Ryb3BoZX0nKVxuICAgICAgICAvLyBBcG9zdHJvcGhlLWVzY2FwZWRcbiAgICAgICAgLnJlcGxhY2UoLycoLio/KScvZywgZnVuY3Rpb24gKF8sIGxpdGVyYWwpIHtcbiAgICAgICAgbGl0ZXJhbHMucHVzaChsaXRlcmFsKTtcbiAgICAgICAgcmV0dXJuIFwiJCRcIiArIChsaXRlcmFscy5sZW5ndGggLSAxKSArIFwiJCRcIjtcbiAgICB9KVxuICAgICAgICAucmVwbGFjZShEQVRFX1RJTUVfUkVHRVgsIGZ1bmN0aW9uIChtKSB7IHJldHVybiBtYXRjaFNrZWxldG9uUGF0dGVybihtLCByZXN1bHQgfHwge30pOyB9KTtcbiAgICAvL1Jlc3RvcmUgbGl0ZXJhbHNcbiAgICBpZiAobGl0ZXJhbHMubGVuZ3RoKSB7XG4gICAgICAgIHBhdHRlcm4xMiA9IHBhdHRlcm4xMlxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcJFxcJChcXGQrKVxcJFxcJC9nLCBmdW5jdGlvbiAoXywgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWxzWytpXTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHthcG9zdHJvcGhlXFx9L2csIFwiJ1wiKTtcbiAgICB9XG4gICAgLy8gSGFuZGxlIGFwb3N0cm9waGUtZXNjYXBlZCB0aGluZ3NcbiAgICByZXR1cm4gW1xuICAgICAgICBwYXR0ZXJuMTJcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oW1xcc1xcdUZFRkZcXHhBMF0pXFx7YW1wbVxcfShbXFxzXFx1RkVGRlxceEEwXSkvLCAnJDEnKVxuICAgICAgICAgICAgLnJlcGxhY2UoJ3thbXBtfScsICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoZXhwUGF0dGVyblRyaW1tZXIsICcnKSxcbiAgICAgICAgcGF0dGVybjEyLFxuICAgIF07XG59XG5leHBvcnRzLnByb2Nlc3NEYXRlVGltZVBhdHRlcm4gPSBwcm9jZXNzRGF0ZVRpbWVQYXR0ZXJuO1xuLyoqXG4gKiBQYXJzZSBEYXRlIHRpbWUgc2tlbGV0b24gaW50byBJbnRsLkRhdGVUaW1lRm9ybWF0T3B0aW9uc1xuICogUmVmOiBodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjRGF0ZV9GaWVsZF9TeW1ib2xfVGFibGVcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBza2VsZXRvbiBza2VsZXRvbiBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gcGFyc2VEYXRlVGltZVNrZWxldG9uKHNrZWxldG9uLCByYXdQYXR0ZXJuLCByYW5nZVBhdHRlcm5zLCBpbnRlcnZhbEZvcm1hdEZhbGxiYWNrKSB7XG4gICAgaWYgKHJhd1BhdHRlcm4gPT09IHZvaWQgMCkgeyByYXdQYXR0ZXJuID0gc2tlbGV0b247IH1cbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBwYXR0ZXJuOiAnJyxcbiAgICAgICAgcGF0dGVybjEyOiAnJyxcbiAgICAgICAgc2tlbGV0b246IHNrZWxldG9uLFxuICAgICAgICByYXdQYXR0ZXJuOiByYXdQYXR0ZXJuLFxuICAgICAgICByYW5nZVBhdHRlcm5zOiB7fSxcbiAgICAgICAgcmFuZ2VQYXR0ZXJuczEyOiB7fSxcbiAgICB9O1xuICAgIGlmIChyYW5nZVBhdHRlcm5zKSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gcmFuZ2VQYXR0ZXJucykge1xuICAgICAgICAgICAgdmFyIGtleSA9IHNrZWxldG9uVG9rZW5Ub1RhYmxlMihrKTtcbiAgICAgICAgICAgIHZhciByYXdQYXR0ZXJuXzEgPSByYW5nZVBhdHRlcm5zW2tdO1xuICAgICAgICAgICAgdmFyIGludGVydmFsUmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHBhdHRlcm5QYXJ0czogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIF9hID0gcHJvY2Vzc0RhdGVUaW1lUGF0dGVybihyYXdQYXR0ZXJuXzEsIGludGVydmFsUmVzdWx0KSwgcGF0dGVybl8xID0gX2FbMF0sIHBhdHRlcm4xMl8xID0gX2FbMV07XG4gICAgICAgICAgICByZXN1bHQucmFuZ2VQYXR0ZXJuc1trZXldID0gdHNsaWJfMS5fX2Fzc2lnbih0c2xpYl8xLl9fYXNzaWduKHt9LCBpbnRlcnZhbFJlc3VsdCksIHsgcGF0dGVyblBhcnRzOiBzcGxpdFJhbmdlUGF0dGVybihwYXR0ZXJuXzEpIH0pO1xuICAgICAgICAgICAgcmVzdWx0LnJhbmdlUGF0dGVybnMxMltrZXldID0gdHNsaWJfMS5fX2Fzc2lnbih0c2xpYl8xLl9fYXNzaWduKHt9LCBpbnRlcnZhbFJlc3VsdCksIHsgcGF0dGVyblBhcnRzOiBzcGxpdFJhbmdlUGF0dGVybihwYXR0ZXJuMTJfMSkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaW50ZXJ2YWxGb3JtYXRGYWxsYmFjaykge1xuICAgICAgICB2YXIgcGF0dGVyblBhcnRzID0gc3BsaXRGYWxsYmFja1JhbmdlUGF0dGVybihpbnRlcnZhbEZvcm1hdEZhbGxiYWNrKTtcbiAgICAgICAgcmVzdWx0LnJhbmdlUGF0dGVybnMuZGVmYXVsdCA9IHtcbiAgICAgICAgICAgIHBhdHRlcm5QYXJ0czogcGF0dGVyblBhcnRzLFxuICAgICAgICB9O1xuICAgICAgICByZXN1bHQucmFuZ2VQYXR0ZXJuczEyLmRlZmF1bHQgPSB7XG4gICAgICAgICAgICBwYXR0ZXJuUGFydHM6IHBhdHRlcm5QYXJ0cyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gUHJvY2VzcyBza2VsZXRvblxuICAgIHNrZWxldG9uLnJlcGxhY2UoREFURV9USU1FX1JFR0VYLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gbWF0Y2hTa2VsZXRvblBhdHRlcm4obSwgcmVzdWx0KTsgfSk7XG4gICAgdmFyIF9iID0gcHJvY2Vzc0RhdGVUaW1lUGF0dGVybihyYXdQYXR0ZXJuKSwgcGF0dGVybiA9IF9iWzBdLCBwYXR0ZXJuMTIgPSBfYlsxXTtcbiAgICByZXN1bHQucGF0dGVybiA9IHBhdHRlcm47XG4gICAgcmVzdWx0LnBhdHRlcm4xMiA9IHBhdHRlcm4xMjtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5wYXJzZURhdGVUaW1lU2tlbGV0b24gPSBwYXJzZURhdGVUaW1lU2tlbGV0b247XG5mdW5jdGlvbiBzcGxpdEZhbGxiYWNrUmFuZ2VQYXR0ZXJuKHBhdHRlcm4pIHtcbiAgICB2YXIgcGFydHMgPSBwYXR0ZXJuLnNwbGl0KC8oXFx7WzB8MV1cXH0pL2cpLmZpbHRlcihCb29sZWFuKTtcbiAgICByZXR1cm4gcGFydHMubWFwKGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgICAgIHN3aXRjaCAocGF0dGVybikge1xuICAgICAgICAgICAgY2FzZSAnezB9JzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IFwic3RhcnRSYW5nZVwiIC8qIHN0YXJ0UmFuZ2UgKi8sXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IHBhdHRlcm4sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ3sxfSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBcImVuZFJhbmdlXCIgLyogZW5kUmFuZ2UgKi8sXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IHBhdHRlcm4sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBcInNoYXJlZFwiIC8qIHNoYXJlZCAqLyxcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogcGF0dGVybixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLnNwbGl0RmFsbGJhY2tSYW5nZVBhdHRlcm4gPSBzcGxpdEZhbGxiYWNrUmFuZ2VQYXR0ZXJuO1xuZnVuY3Rpb24gc3BsaXRSYW5nZVBhdHRlcm4ocGF0dGVybikge1xuICAgIHZhciBQQVJUX1JFR0VYID0gL1xceyguKj8pXFx9L2c7XG4gICAgLy8gTWFwIG9mIHBhcnQgYW5kIGluZGV4IHdpdGhpbiB0aGUgc3RyaW5nXG4gICAgdmFyIHBhcnRzID0ge307XG4gICAgdmFyIG1hdGNoO1xuICAgIHZhciBzcGxpdEluZGV4ID0gMDtcbiAgICB3aGlsZSAoKG1hdGNoID0gUEFSVF9SRUdFWC5leGVjKHBhdHRlcm4pKSkge1xuICAgICAgICBpZiAoIShtYXRjaFswXSBpbiBwYXJ0cykpIHtcbiAgICAgICAgICAgIHBhcnRzW21hdGNoWzBdXSA9IG1hdGNoLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3BsaXRJbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzcGxpdEluZGV4KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc291cmNlOiBcInN0YXJ0UmFuZ2VcIiAvKiBzdGFydFJhbmdlICovLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IHBhdHRlcm4sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgICBzb3VyY2U6IFwic3RhcnRSYW5nZVwiIC8qIHN0YXJ0UmFuZ2UgKi8sXG4gICAgICAgICAgICBwYXR0ZXJuOiBwYXR0ZXJuLnNsaWNlKDAsIHNwbGl0SW5kZXgpLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBzb3VyY2U6IFwiZW5kUmFuZ2VcIiAvKiBlbmRSYW5nZSAqLyxcbiAgICAgICAgICAgIHBhdHRlcm46IHBhdHRlcm4uc2xpY2Uoc3BsaXRJbmRleCksXG4gICAgICAgIH0sXG4gICAgXTtcbn1cbmV4cG9ydHMuc3BsaXRSYW5nZVBhdHRlcm4gPSBzcGxpdFJhbmdlUGF0dGVybjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaG9ydE1vcmVQZW5hbHR5ID0gZXhwb3J0cy5zaG9ydExlc3NQZW5hbHR5ID0gZXhwb3J0cy5sb25nTW9yZVBlbmFsdHkgPSBleHBvcnRzLmxvbmdMZXNzUGVuYWx0eSA9IGV4cG9ydHMuZGlmZmVyZW50TnVtZXJpY1R5cGVQZW5hbHR5ID0gZXhwb3J0cy5hZGRpdGlvblBlbmFsdHkgPSBleHBvcnRzLnJlbW92YWxQZW5hbHR5ID0gZXhwb3J0cy5EQVRFX1RJTUVfUFJPUFMgPSB2b2lkIDA7XG5leHBvcnRzLkRBVEVfVElNRV9QUk9QUyA9IFtcbiAgICAnd2Vla2RheScsXG4gICAgJ2VyYScsXG4gICAgJ3llYXInLFxuICAgICdtb250aCcsXG4gICAgJ2RheScsXG4gICAgJ2hvdXInLFxuICAgICdtaW51dGUnLFxuICAgICdzZWNvbmQnLFxuICAgICd0aW1lWm9uZU5hbWUnLFxuXTtcbmV4cG9ydHMucmVtb3ZhbFBlbmFsdHkgPSAxMjA7XG5leHBvcnRzLmFkZGl0aW9uUGVuYWx0eSA9IDIwO1xuZXhwb3J0cy5kaWZmZXJlbnROdW1lcmljVHlwZVBlbmFsdHkgPSAxNTtcbmV4cG9ydHMubG9uZ0xlc3NQZW5hbHR5ID0gODtcbmV4cG9ydHMubG9uZ01vcmVQZW5hbHR5ID0gNjtcbmV4cG9ydHMuc2hvcnRMZXNzUGVuYWx0eSA9IDY7XG5leHBvcnRzLnNob3J0TW9yZVBlbmFsdHkgPSAzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlZmF1bHROdW1iZXJPcHRpb24gPSB2b2lkIDA7XG4vKipcbiAqIGh0dHBzOi8vdGMzOS5lcy9lY21hNDAyLyNzZWMtZGVmYXVsdG51bWJlcm9wdGlvblxuICogQHBhcmFtIHZhbFxuICogQHBhcmFtIG1pblxuICogQHBhcmFtIG1heFxuICogQHBhcmFtIGZhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIERlZmF1bHROdW1iZXJPcHRpb24odmFsLCBtaW4sIG1heCwgZmFsbGJhY2spIHtcbiAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsID0gTnVtYmVyKHZhbCk7XG4gICAgICAgIGlmIChpc05hTih2YWwpIHx8IHZhbCA8IG1pbiB8fCB2YWwgPiBtYXgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHZhbCArIFwiIGlzIG91dHNpZGUgb2YgcmFuZ2UgW1wiICsgbWluICsgXCIsIFwiICsgbWF4ICsgXCJdXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHZhbCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxsYmFjaztcbn1cbmV4cG9ydHMuRGVmYXVsdE51bWJlck9wdGlvbiA9IERlZmF1bHROdW1iZXJPcHRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2Fub25pY2FsQ29kZUZvckRpc3BsYXlOYW1lcyA9IHZvaWQgMDtcbnZhciBDYW5vbmljYWxpemVMb2NhbGVMaXN0XzEgPSByZXF1aXJlKFwiLi4vQ2Fub25pY2FsaXplTG9jYWxlTGlzdFwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIElzV2VsbEZvcm1lZEN1cnJlbmN5Q29kZV8xID0gcmVxdWlyZShcIi4uL0lzV2VsbEZvcm1lZEN1cnJlbmN5Q29kZVwiKTtcbnZhciBVTklDT0RFX1JFR0lPTl9TVUJUQUdfUkVHRVggPSAvXihbYS16XXsyfXxbMC05XXszfSkkL2k7XG52YXIgQUxQSEFfNCA9IC9eW2Etel17NH0kL2k7XG5mdW5jdGlvbiBpc1VuaWNvZGVSZWdpb25TdWJ0YWcocmVnaW9uKSB7XG4gICAgcmV0dXJuIFVOSUNPREVfUkVHSU9OX1NVQlRBR19SRUdFWC50ZXN0KHJlZ2lvbik7XG59XG5mdW5jdGlvbiBpc1VuaWNvZGVTY3JpcHRTdWJ0YWcoc2NyaXB0KSB7XG4gICAgcmV0dXJuIEFMUEhBXzQudGVzdChzY3JpcHQpO1xufVxuZnVuY3Rpb24gQ2Fub25pY2FsQ29kZUZvckRpc3BsYXlOYW1lcyh0eXBlLCBjb2RlKSB7XG4gICAgaWYgKHR5cGUgPT09ICdsYW5ndWFnZScpIHtcbiAgICAgICAgcmV0dXJuIENhbm9uaWNhbGl6ZUxvY2FsZUxpc3RfMS5DYW5vbmljYWxpemVMb2NhbGVMaXN0KFtjb2RlXSlbMF07XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAncmVnaW9uJykge1xuICAgICAgICBpZiAoIWlzVW5pY29kZVJlZ2lvblN1YnRhZyhjb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcignaW52YWxpZCByZWdpb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgICAgaWYgKCFpc1VuaWNvZGVTY3JpcHRTdWJ0YWcoY29kZSkpIHtcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ2ludmFsaWQgc2NyaXB0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCIgKyBjb2RlWzBdLnRvVXBwZXJDYXNlKCkgKyBjb2RlLnNsaWNlKDEpO1xuICAgIH1cbiAgICB1dGlsc18xLmludmFyaWFudCh0eXBlID09PSAnY3VycmVuY3knLCAnaW52YWxpZCB0eXBlJyk7XG4gICAgaWYgKCFJc1dlbGxGb3JtZWRDdXJyZW5jeUNvZGVfMS5Jc1dlbGxGb3JtZWRDdXJyZW5jeUNvZGUoY29kZSkpIHtcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcignaW52YWxpZCBjdXJyZW5jeScpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZS50b1VwcGVyQ2FzZSgpO1xufVxuZXhwb3J0cy5DYW5vbmljYWxDb2RlRm9yRGlzcGxheU5hbWVzID0gQ2Fub25pY2FsQ29kZUZvckRpc3BsYXlOYW1lcztcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBodHRwczovL3RjMzkuZXMvZWNtYTQwMi8jc2VjLWdldG51bWJlcm9wdGlvblxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBwcm9wZXJ0eVxuICogQHBhcmFtIG1pblxuICogQHBhcmFtIG1heFxuICogQHBhcmFtIGZhbGxiYWNrXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR2V0TnVtYmVyT3B0aW9uID0gdm9pZCAwO1xudmFyIERlZmF1bHROdW1iZXJPcHRpb25fMSA9IHJlcXVpcmUoXCIuL0RlZmF1bHROdW1iZXJPcHRpb25cIik7XG5mdW5jdGlvbiBHZXROdW1iZXJPcHRpb24ob3B0aW9ucywgcHJvcGVydHksIG1pbmltdW0sIG1heGltdW0sIGZhbGxiYWNrKSB7XG4gICAgdmFyIHZhbCA9IG9wdGlvbnNbcHJvcGVydHldO1xuICAgIHJldHVybiBEZWZhdWx0TnVtYmVyT3B0aW9uXzEuRGVmYXVsdE51bWJlck9wdGlvbih2YWwsIG1pbmltdW0sIG1heGltdW0sIGZhbGxiYWNrKTtcbn1cbmV4cG9ydHMuR2V0TnVtYmVyT3B0aW9uID0gR2V0TnVtYmVyT3B0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdldE9wdGlvbiA9IHZvaWQgMDtcbnZhciBfMjYyXzEgPSByZXF1aXJlKFwiLi8yNjJcIik7XG4vKipcbiAqIGh0dHBzOi8vdGMzOS5lcy9lY21hNDAyLyNzZWMtZ2V0b3B0aW9uXG4gKiBAcGFyYW0gb3B0c1xuICogQHBhcmFtIHByb3BcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcGFyYW0gdmFsdWVzXG4gKiBAcGFyYW0gZmFsbGJhY2tcbiAqL1xuZnVuY3Rpb24gR2V0T3B0aW9uKG9wdHMsIHByb3AsIHR5cGUsIHZhbHVlcywgZmFsbGJhY2spIHtcbiAgICAvLyBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvcHRzLCBwcm9wKTtcbiAgICB2YXIgdmFsdWUgPSBvcHRzW3Byb3BdO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlICE9PSAnYm9vbGVhbicgJiYgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gQm9vbGVhbih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IF8yNjJfMS5Ub1N0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlcyAhPT0gdW5kZWZpbmVkICYmICF2YWx1ZXMuZmlsdGVyKGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbCA9PSB2YWx1ZTsgfSkubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcih2YWx1ZSArIFwiIGlzIG5vdCB3aXRoaW4gXCIgKyB2YWx1ZXMuam9pbignLCAnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsbGJhY2s7XG59XG5leHBvcnRzLkdldE9wdGlvbiA9IEdldE9wdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jc1NhbmN0aW9uZWRTaW1wbGVVbml0SWRlbnRpZmllciA9IGV4cG9ydHMuU0lNUExFX1VOSVRTID0gZXhwb3J0cy5yZW1vdmVVbml0TmFtZXNwYWNlID0gZXhwb3J0cy5TQU5DVElPTkVEX1VOSVRTID0gdm9pZCAwO1xuLyoqXG4gKiBodHRwczovL3RjMzkuZXMvZWNtYTQwMi8jdGFibGUtc2FuY3Rpb25lZC1zaW1wbGUtdW5pdC1pZGVudGlmaWVyc1xuICovXG5leHBvcnRzLlNBTkNUSU9ORURfVU5JVFMgPSBbXG4gICAgJ2FuZ2xlLWRlZ3JlZScsXG4gICAgJ2FyZWEtYWNyZScsXG4gICAgJ2FyZWEtaGVjdGFyZScsXG4gICAgJ2NvbmNlbnRyLXBlcmNlbnQnLFxuICAgICdkaWdpdGFsLWJpdCcsXG4gICAgJ2RpZ2l0YWwtYnl0ZScsXG4gICAgJ2RpZ2l0YWwtZ2lnYWJpdCcsXG4gICAgJ2RpZ2l0YWwtZ2lnYWJ5dGUnLFxuICAgICdkaWdpdGFsLWtpbG9iaXQnLFxuICAgICdkaWdpdGFsLWtpbG9ieXRlJyxcbiAgICAnZGlnaXRhbC1tZWdhYml0JyxcbiAgICAnZGlnaXRhbC1tZWdhYnl0ZScsXG4gICAgJ2RpZ2l0YWwtcGV0YWJ5dGUnLFxuICAgICdkaWdpdGFsLXRlcmFiaXQnLFxuICAgICdkaWdpdGFsLXRlcmFieXRlJyxcbiAgICAnZHVyYXRpb24tZGF5JyxcbiAgICAnZHVyYXRpb24taG91cicsXG4gICAgJ2R1cmF0aW9uLW1pbGxpc2Vjb25kJyxcbiAgICAnZHVyYXRpb24tbWludXRlJyxcbiAgICAnZHVyYXRpb24tbW9udGgnLFxuICAgICdkdXJhdGlvbi1zZWNvbmQnLFxuICAgICdkdXJhdGlvbi13ZWVrJyxcbiAgICAnZHVyYXRpb24teWVhcicsXG4gICAgJ2xlbmd0aC1jZW50aW1ldGVyJyxcbiAgICAnbGVuZ3RoLWZvb3QnLFxuICAgICdsZW5ndGgtaW5jaCcsXG4gICAgJ2xlbmd0aC1raWxvbWV0ZXInLFxuICAgICdsZW5ndGgtbWV0ZXInLFxuICAgICdsZW5ndGgtbWlsZS1zY2FuZGluYXZpYW4nLFxuICAgICdsZW5ndGgtbWlsZScsXG4gICAgJ2xlbmd0aC1taWxsaW1ldGVyJyxcbiAgICAnbGVuZ3RoLXlhcmQnLFxuICAgICdtYXNzLWdyYW0nLFxuICAgICdtYXNzLWtpbG9ncmFtJyxcbiAgICAnbWFzcy1vdW5jZScsXG4gICAgJ21hc3MtcG91bmQnLFxuICAgICdtYXNzLXN0b25lJyxcbiAgICAndGVtcGVyYXR1cmUtY2Vsc2l1cycsXG4gICAgJ3RlbXBlcmF0dXJlLWZhaHJlbmhlaXQnLFxuICAgICd2b2x1bWUtZmx1aWQtb3VuY2UnLFxuICAgICd2b2x1bWUtZ2FsbG9uJyxcbiAgICAndm9sdW1lLWxpdGVyJyxcbiAgICAndm9sdW1lLW1pbGxpbGl0ZXInLFxuXTtcbi8vIEluIENMRFIsIHRoZSB1bml0IG5hbWUgYWx3YXlzIGZvbGxvd3MgdGhlIGZvcm0gYG5hbWVzcGFjZS11bml0YCBwYXR0ZXJuLlxuLy8gRm9yIGV4YW1wbGU6IGBkaWdpdGFsLWJpdGAgaW5zdGVhZCBvZiBgYml0YC4gVGhpcyBmdW5jdGlvbiByZW1vdmVzIHRoZSBuYW1lc3BhY2UgcHJlZml4LlxuZnVuY3Rpb24gcmVtb3ZlVW5pdE5hbWVzcGFjZSh1bml0KSB7XG4gICAgcmV0dXJuIHVuaXQuc2xpY2UodW5pdC5pbmRleE9mKCctJykgKyAxKTtcbn1cbmV4cG9ydHMucmVtb3ZlVW5pdE5hbWVzcGFjZSA9IHJlbW92ZVVuaXROYW1lc3BhY2U7XG4vKipcbiAqIGh0dHBzOi8vdGMzOS5lcy9lY21hNDAyLyN0YWJsZS1zYW5jdGlvbmVkLXNpbXBsZS11bml0LWlkZW50aWZpZXJzXG4gKi9cbmV4cG9ydHMuU0lNUExFX1VOSVRTID0gZXhwb3J0cy5TQU5DVElPTkVEX1VOSVRTLm1hcChyZW1vdmVVbml0TmFtZXNwYWNlKTtcbi8qKlxuICogaHR0cHM6Ly90YzM5LmVzL2VjbWE0MDIvI3NlYy1pc3NhbmN0aW9uZWRzaW1wbGV1bml0aWRlbnRpZmllclxuICovXG5mdW5jdGlvbiBJc1NhbmN0aW9uZWRTaW1wbGVVbml0SWRlbnRpZmllcih1bml0SWRlbnRpZmllcikge1xuICAgIHJldHVybiBleHBvcnRzLlNJTVBMRV9VTklUUy5pbmRleE9mKHVuaXRJZGVudGlmaWVyKSA+IC0xO1xufVxuZXhwb3J0cy5Jc1NhbmN0aW9uZWRTaW1wbGVVbml0SWRlbnRpZmllciA9IElzU2FuY3Rpb25lZFNpbXBsZVVuaXRJZGVudGlmaWVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklzVmFsaWRUaW1lWm9uZU5hbWUgPSB2b2lkIDA7XG4vKipcbiAqIGh0dHBzOi8vdGMzOS5lcy9lY21hNDAyLyNzZWMtaXN2YWxpZHRpbWV6b25lbmFtZVxuICogQHBhcmFtIHR6XG4gKiBAcGFyYW0gaW1wbERldGFpbHMgaW1wbGVtZW50YXRpb24gZGV0YWlsc1xuICovXG5mdW5jdGlvbiBJc1ZhbGlkVGltZVpvbmVOYW1lKHR6LCBfYSkge1xuICAgIHZhciB0ekRhdGEgPSBfYS50ekRhdGEsIHVwcGVyY2FzZUxpbmtzID0gX2EudXBwZXJjYXNlTGlua3M7XG4gICAgdmFyIHVwcGVyY2FzZWRUeiA9IHR6LnRvVXBwZXJDYXNlKCk7XG4gICAgdmFyIHpvbmVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICBPYmplY3Qua2V5cyh0ekRhdGEpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHopIHsgcmV0dXJuIHoudG9VcHBlckNhc2UoKTsgfSlcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHopIHsgcmV0dXJuIHpvbmVOYW1lcy5hZGQoeik7IH0pO1xuICAgIHJldHVybiB6b25lTmFtZXMuaGFzKHVwcGVyY2FzZWRUeikgfHwgdXBwZXJjYXNlZFR6IGluIHVwcGVyY2FzZUxpbmtzO1xufVxuZXhwb3J0cy5Jc1ZhbGlkVGltZVpvbmVOYW1lID0gSXNWYWxpZFRpbWVab25lTmFtZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jc1dlbGxGb3JtZWRDdXJyZW5jeUNvZGUgPSB2b2lkIDA7XG4vKipcbiAqIFRoaXMgZm9sbG93cyBodHRwczovL3RjMzkuZXMvZWNtYTQwMi8jc2VjLWNhc2Utc2Vuc2l0aXZpdHktYW5kLWNhc2UtbWFwcGluZ1xuICogQHBhcmFtIHN0ciBzdHJpbmcgdG8gY29udmVydFxuICovXG5mdW5jdGlvbiB0b1VwcGVyQ2FzZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbYS16XSkvZywgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSk7XG59XG52YXIgTk9UX0FfWl9SRUdFWCA9IC9bXkEtWl0vO1xuLyoqXG4gKiBodHRwczovL3RjMzkuZXMvZWNtYTQwMi8jc2VjLWlzd2VsbGZvcm1lZGN1cnJlbmN5Y29kZVxuICovXG5mdW5jdGlvbiBJc1dlbGxGb3JtZWRDdXJyZW5jeUNvZGUoY3VycmVuY3kpIHtcbiAgICBjdXJyZW5jeSA9IHRvVXBwZXJDYXNlKGN1cnJlbmN5KTtcbiAgICBpZiAoY3VycmVuY3kubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKE5PVF9BX1pfUkVHRVgudGVzdChjdXJyZW5jeSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuSXNXZWxsRm9ybWVkQ3VycmVuY3lDb2RlID0gSXNXZWxsRm9ybWVkQ3VycmVuY3lDb2RlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklzV2VsbEZvcm1lZFVuaXRJZGVudGlmaWVyID0gdm9pZCAwO1xudmFyIElzU2FuY3Rpb25lZFNpbXBsZVVuaXRJZGVudGlmaWVyXzEgPSByZXF1aXJlKFwiLi9Jc1NhbmN0aW9uZWRTaW1wbGVVbml0SWRlbnRpZmllclwiKTtcbi8qKlxuICogVGhpcyBmb2xsb3dzIGh0dHBzOi8vdGMzOS5lcy9lY21hNDAyLyNzZWMtY2FzZS1zZW5zaXRpdml0eS1hbmQtY2FzZS1tYXBwaW5nXG4gKiBAcGFyYW0gc3RyIHN0cmluZyB0byBjb252ZXJ0XG4gKi9cbmZ1bmN0aW9uIHRvTG93ZXJDYXNlKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYy50b0xvd2VyQ2FzZSgpOyB9KTtcbn1cbi8qKlxuICogaHR0cHM6Ly90YzM5LmVzL2VjbWE0MDIvI3NlYy1pc3dlbGxmb3JtZWR1bml0aWRlbnRpZmllclxuICogQHBhcmFtIHVuaXRcbiAqL1xuZnVuY3Rpb24gSXNXZWxsRm9ybWVkVW5pdElkZW50aWZpZXIodW5pdCkge1xuICAgIHVuaXQgPSB0b0xvd2VyQ2FzZSh1bml0KTtcbiAgICBpZiAoSXNTYW5jdGlvbmVkU2ltcGxlVW5pdElkZW50aWZpZXJfMS5Jc1NhbmN0aW9uZWRTaW1wbGVVbml0SWRlbnRpZmllcih1bml0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHVuaXRzID0gdW5pdC5zcGxpdCgnLXBlci0nKTtcbiAgICBpZiAodW5pdHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIG51bWVyYXRvciA9IHVuaXRzWzBdLCBkZW5vbWluYXRvciA9IHVuaXRzWzFdO1xuICAgIGlmICghSXNTYW5jdGlvbmVkU2ltcGxlVW5pdElkZW50aWZpZXJfMS5Jc1NhbmN0aW9uZWRTaW1wbGVVbml0SWRlbnRpZmllcihudW1lcmF0b3IpIHx8XG4gICAgICAgICFJc1NhbmN0aW9uZWRTaW1wbGVVbml0SWRlbnRpZmllcl8xLklzU2FuY3Rpb25lZFNpbXBsZVVuaXRJZGVudGlmaWVyKGRlbm9taW5hdG9yKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5Jc1dlbGxGb3JtZWRVbml0SWRlbnRpZmllciA9IElzV2VsbEZvcm1lZFVuaXRJZGVudGlmaWVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxvb2t1cE1hdGNoZXIgPSB2b2lkIDA7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIEJlc3RBdmFpbGFibGVMb2NhbGVfMSA9IHJlcXVpcmUoXCIuL0Jlc3RBdmFpbGFibGVMb2NhbGVcIik7XG4vKipcbiAqIGh0dHBzOi8vdGMzOS5lcy9lY21hNDAyLyNzZWMtbG9va3VwbWF0Y2hlclxuICogQHBhcmFtIGF2YWlsYWJsZUxvY2FsZXNcbiAqIEBwYXJhbSByZXF1ZXN0ZWRMb2NhbGVzXG4gKiBAcGFyYW0gZ2V0RGVmYXVsdExvY2FsZVxuICovXG5mdW5jdGlvbiBMb29rdXBNYXRjaGVyKGF2YWlsYWJsZUxvY2FsZXMsIHJlcXVlc3RlZExvY2FsZXMsIGdldERlZmF1bHRMb2NhbGUpIHtcbiAgICB2YXIgcmVzdWx0ID0geyBsb2NhbGU6ICcnIH07XG4gICAgZm9yICh2YXIgX2kgPSAwLCByZXF1ZXN0ZWRMb2NhbGVzXzEgPSByZXF1ZXN0ZWRMb2NhbGVzOyBfaSA8IHJlcXVlc3RlZExvY2FsZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGxvY2FsZSA9IHJlcXVlc3RlZExvY2FsZXNfMVtfaV07XG4gICAgICAgIHZhciBub0V4dGVuc2lvbkxvY2FsZSA9IGxvY2FsZS5yZXBsYWNlKHV0aWxzXzEuVU5JQ09ERV9FWFRFTlNJT05fU0VRVUVOQ0VfUkVHRVgsICcnKTtcbiAgICAgICAgdmFyIGF2YWlsYWJsZUxvY2FsZSA9IEJlc3RBdmFpbGFibGVMb2NhbGVfMS5CZXN0QXZhaWxhYmxlTG9jYWxlKGF2YWlsYWJsZUxvY2FsZXMsIG5vRXh0ZW5zaW9uTG9jYWxlKTtcbiAgICAgICAgaWYgKGF2YWlsYWJsZUxvY2FsZSkge1xuICAgICAgICAgICAgcmVzdWx0LmxvY2FsZSA9IGF2YWlsYWJsZUxvY2FsZTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUgIT09IG5vRXh0ZW5zaW9uTG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmV4dGVuc2lvbiA9IGxvY2FsZS5zbGljZShub0V4dGVuc2lvbkxvY2FsZS5sZW5ndGggKyAxLCBsb2NhbGUubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LmxvY2FsZSA9IGdldERlZmF1bHRMb2NhbGUoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5Mb29rdXBNYXRjaGVyID0gTG9va3VwTWF0Y2hlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Mb29rdXBTdXBwb3J0ZWRMb2NhbGVzID0gdm9pZCAwO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBCZXN0QXZhaWxhYmxlTG9jYWxlXzEgPSByZXF1aXJlKFwiLi9CZXN0QXZhaWxhYmxlTG9jYWxlXCIpO1xuLyoqXG4gKiBodHRwczovL3RjMzkuZXMvZWNtYTQwMi8jc2VjLWxvb2t1cHN1cHBvcnRlZGxvY2FsZXNcbiAqIEBwYXJhbSBhdmFpbGFibGVMb2NhbGVzXG4gKiBAcGFyYW0gcmVxdWVzdGVkTG9jYWxlc1xuICovXG5mdW5jdGlvbiBMb29rdXBTdXBwb3J0ZWRMb2NhbGVzKGF2YWlsYWJsZUxvY2FsZXMsIHJlcXVlc3RlZExvY2FsZXMpIHtcbiAgICB2YXIgc3Vic2V0ID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwLCByZXF1ZXN0ZWRMb2NhbGVzXzEgPSByZXF1ZXN0ZWRMb2NhbGVzOyBfaSA8IHJlcXVlc3RlZExvY2FsZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGxvY2FsZSA9IHJlcXVlc3RlZExvY2FsZXNfMVtfaV07XG4gICAgICAgIHZhciBub0V4dGVuc2lvbkxvY2FsZSA9IGxvY2FsZS5yZXBsYWNlKHV0aWxzXzEuVU5JQ09ERV9FWFRFTlNJT05fU0VRVUVOQ0VfUkVHRVgsICcnKTtcbiAgICAgICAgdmFyIGF2YWlsYWJsZUxvY2FsZSA9IEJlc3RBdmFpbGFibGVMb2NhbGVfMS5CZXN0QXZhaWxhYmxlTG9jYWxlKGF2YWlsYWJsZUxvY2FsZXMsIG5vRXh0ZW5zaW9uTG9jYWxlKTtcbiAgICAgICAgaWYgKGF2YWlsYWJsZUxvY2FsZSkge1xuICAgICAgICAgICAgc3Vic2V0LnB1c2goYXZhaWxhYmxlTG9jYWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3Vic2V0O1xufVxuZXhwb3J0cy5Mb29rdXBTdXBwb3J0ZWRMb2NhbGVzID0gTG9va3VwU3VwcG9ydGVkTG9jYWxlcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21wdXRlRXhwb25lbnQgPSB2b2lkIDA7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBDb21wdXRlRXhwb25lbnRGb3JNYWduaXR1ZGVfMSA9IHJlcXVpcmUoXCIuL0NvbXB1dGVFeHBvbmVudEZvck1hZ25pdHVkZVwiKTtcbnZhciBGb3JtYXROdW1lcmljVG9TdHJpbmdfMSA9IHJlcXVpcmUoXCIuL0Zvcm1hdE51bWVyaWNUb1N0cmluZ1wiKTtcbi8qKlxuICogVGhlIGFic3RyYWN0IG9wZXJhdGlvbiBDb21wdXRlRXhwb25lbnQgY29tcHV0ZXMgYW4gZXhwb25lbnQgKHBvd2VyIG9mIHRlbikgYnkgd2hpY2ggdG8gc2NhbGUgeFxuICogYWNjb3JkaW5nIHRvIHRoZSBudW1iZXIgZm9ybWF0dGluZyBzZXR0aW5ncy4gSXQgaGFuZGxlcyBjYXNlcyBzdWNoIGFzIDk5OSByb3VuZGluZyB1cCB0byAxMDAwLFxuICogcmVxdWlyaW5nIGEgZGlmZmVyZW50IGV4cG9uZW50LlxuICpcbiAqIE5PVCBJTiBTUEVDOiBpdCByZXR1cm5zIFtleHBvbmVudCwgbWFnbml0dWRlXS5cbiAqL1xuZnVuY3Rpb24gQ29tcHV0ZUV4cG9uZW50KG51bWJlckZvcm1hdCwgeCwgX2EpIHtcbiAgICB2YXIgZ2V0SW50ZXJuYWxTbG90cyA9IF9hLmdldEludGVybmFsU2xvdHM7XG4gICAgaWYgKHggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICB9XG4gICAgaWYgKHggPCAwKSB7XG4gICAgICAgIHggPSAteDtcbiAgICB9XG4gICAgdmFyIG1hZ25pdHVkZSA9IHV0aWxzXzEuZ2V0TWFnbml0dWRlKHgpO1xuICAgIHZhciBleHBvbmVudCA9IENvbXB1dGVFeHBvbmVudEZvck1hZ25pdHVkZV8xLkNvbXB1dGVFeHBvbmVudEZvck1hZ25pdHVkZShudW1iZXJGb3JtYXQsIG1hZ25pdHVkZSwge1xuICAgICAgICBnZXRJbnRlcm5hbFNsb3RzOiBnZXRJbnRlcm5hbFNsb3RzLFxuICAgIH0pO1xuICAgIC8vIFByZXNlcnZlIG1vcmUgcHJlY2lzaW9uIGJ5IGRvaW5nIG11bHRpcGxpY2F0aW9uIHdoZW4gZXhwb25lbnQgaXMgbmVnYXRpdmUuXG4gICAgeCA9IGV4cG9uZW50IDwgMCA/IHggKiBNYXRoLnBvdygxMCwgLWV4cG9uZW50KSA6IHggLyBNYXRoLnBvdygxMCwgZXhwb25lbnQpO1xuICAgIHZhciBmb3JtYXROdW1iZXJSZXN1bHQgPSBGb3JtYXROdW1lcmljVG9TdHJpbmdfMS5Gb3JtYXROdW1lcmljVG9TdHJpbmcoZ2V0SW50ZXJuYWxTbG90cyhudW1iZXJGb3JtYXQpLCB4KTtcbiAgICBpZiAoZm9ybWF0TnVtYmVyUmVzdWx0LnJvdW5kZWROdW1iZXIgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtleHBvbmVudCwgbWFnbml0dWRlXTtcbiAgICB9XG4gICAgdmFyIG5ld01hZ25pdHVkZSA9IHV0aWxzXzEuZ2V0TWFnbml0dWRlKGZvcm1hdE51bWJlclJlc3VsdC5yb3VuZGVkTnVtYmVyKTtcbiAgICBpZiAobmV3TWFnbml0dWRlID09PSBtYWduaXR1ZGUgLSBleHBvbmVudCkge1xuICAgICAgICByZXR1cm4gW2V4cG9uZW50LCBtYWduaXR1ZGVdO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICBDb21wdXRlRXhwb25lbnRGb3JNYWduaXR1ZGVfMS5Db21wdXRlRXhwb25lbnRGb3JNYWduaXR1ZGUobnVtYmVyRm9ybWF0LCBtYWduaXR1ZGUgKyAxLCB7XG4gICAgICAgICAgICBnZXRJbnRlcm5hbFNsb3RzOiBnZXRJbnRlcm5hbFNsb3RzLFxuICAgICAgICB9KSxcbiAgICAgICAgbWFnbml0dWRlICsgMSxcbiAgICBdO1xufVxuZXhwb3J0cy5Db21wdXRlRXhwb25lbnQgPSBDb21wdXRlRXhwb25lbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tcHV0ZUV4cG9uZW50Rm9yTWFnbml0dWRlID0gdm9pZCAwO1xuLyoqXG4gKiBUaGUgYWJzdHJhY3Qgb3BlcmF0aW9uIENvbXB1dGVFeHBvbmVudEZvck1hZ25pdHVkZSBjb21wdXRlcyBhbiBleHBvbmVudCBieSB3aGljaCB0byBzY2FsZSBhXG4gKiBudW1iZXIgb2YgdGhlIGdpdmVuIG1hZ25pdHVkZSAocG93ZXIgb2YgdGVuIG9mIHRoZSBtb3N0IHNpZ25pZmljYW50IGRpZ2l0KSBhY2NvcmRpbmcgdG8gdGhlXG4gKiBsb2NhbGUgYW5kIHRoZSBkZXNpcmVkIG5vdGF0aW9uIChzY2llbnRpZmljLCBlbmdpbmVlcmluZywgb3IgY29tcGFjdCkuXG4gKi9cbmZ1bmN0aW9uIENvbXB1dGVFeHBvbmVudEZvck1hZ25pdHVkZShudW1iZXJGb3JtYXQsIG1hZ25pdHVkZSwgX2EpIHtcbiAgICB2YXIgZ2V0SW50ZXJuYWxTbG90cyA9IF9hLmdldEludGVybmFsU2xvdHM7XG4gICAgdmFyIGludGVybmFsU2xvdHMgPSBnZXRJbnRlcm5hbFNsb3RzKG51bWJlckZvcm1hdCk7XG4gICAgdmFyIG5vdGF0aW9uID0gaW50ZXJuYWxTbG90cy5ub3RhdGlvbiwgZGF0YUxvY2FsZURhdGEgPSBpbnRlcm5hbFNsb3RzLmRhdGFMb2NhbGVEYXRhLCBudW1iZXJpbmdTeXN0ZW0gPSBpbnRlcm5hbFNsb3RzLm51bWJlcmluZ1N5c3RlbTtcbiAgICBzd2l0Y2ggKG5vdGF0aW9uKSB7XG4gICAgICAgIGNhc2UgJ3N0YW5kYXJkJzpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjYXNlICdzY2llbnRpZmljJzpcbiAgICAgICAgICAgIHJldHVybiBtYWduaXR1ZGU7XG4gICAgICAgIGNhc2UgJ2VuZ2luZWVyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG1hZ25pdHVkZSAvIDMpICogMztcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgLy8gTGV0IGV4cG9uZW50IGJlIGFuIGltcGxlbWVudGF0aW9uLSBhbmQgbG9jYWxlLWRlcGVuZGVudCAoSUxEKSBpbnRlZ2VyIGJ5IHdoaWNoIHRvIHNjYWxlIGFcbiAgICAgICAgICAgIC8vIG51bWJlciBvZiB0aGUgZ2l2ZW4gbWFnbml0dWRlIGluIGNvbXBhY3Qgbm90YXRpb24gZm9yIHRoZSBjdXJyZW50IGxvY2FsZS5cbiAgICAgICAgICAgIHZhciBjb21wYWN0RGlzcGxheSA9IGludGVybmFsU2xvdHMuY29tcGFjdERpc3BsYXksIHN0eWxlID0gaW50ZXJuYWxTbG90cy5zdHlsZSwgY3VycmVuY3lEaXNwbGF5ID0gaW50ZXJuYWxTbG90cy5jdXJyZW5jeURpc3BsYXk7XG4gICAgICAgICAgICB2YXIgdGhyZXNob2xkTWFwID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHN0eWxlID09PSAnY3VycmVuY3knICYmIGN1cnJlbmN5RGlzcGxheSAhPT0gJ25hbWUnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbmN5ID0gZGF0YUxvY2FsZURhdGEubnVtYmVycy5jdXJyZW5jeVtudW1iZXJpbmdTeXN0ZW1dIHx8XG4gICAgICAgICAgICAgICAgICAgIGRhdGFMb2NhbGVEYXRhLm51bWJlcnMuY3VycmVuY3lbZGF0YUxvY2FsZURhdGEubnVtYmVycy5udVswXV07XG4gICAgICAgICAgICAgICAgdGhyZXNob2xkTWFwID0gY3VycmVuY3kuc2hvcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVjaW1hbCA9IGRhdGFMb2NhbGVEYXRhLm51bWJlcnMuZGVjaW1hbFtudW1iZXJpbmdTeXN0ZW1dIHx8XG4gICAgICAgICAgICAgICAgICAgIGRhdGFMb2NhbGVEYXRhLm51bWJlcnMuZGVjaW1hbFtkYXRhTG9jYWxlRGF0YS5udW1iZXJzLm51WzBdXTtcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGRNYXAgPSBjb21wYWN0RGlzcGxheSA9PT0gJ2xvbmcnID8gZGVjaW1hbC5sb25nIDogZGVjaW1hbC5zaG9ydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhyZXNob2xkTWFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbnVtID0gU3RyaW5nKE1hdGgucG93KDEwLCBtYWduaXR1ZGUpKTtcbiAgICAgICAgICAgIHZhciB0aHJlc2hvbGRzID0gT2JqZWN0LmtleXModGhyZXNob2xkTWFwKTsgLy8gVE9ETzogdGhpcyBjYW4gYmUgcHJlLXByb2Nlc3NlZFxuICAgICAgICAgICAgaWYgKG51bSA8IHRocmVzaG9sZHNbMF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChudW0gPiB0aHJlc2hvbGRzW3RocmVzaG9sZHMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyZXNob2xkc1t0aHJlc2hvbGRzLmxlbmd0aCAtIDFdLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaSA9IHRocmVzaG9sZHMuaW5kZXhPZihudW0pO1xuICAgICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1udW1iZXJzLmh0bWwjQ29tcGFjdF9OdW1iZXJfRm9ybWF0c1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBpZiB0aGUgcGF0dGVybiBpcyBwcmVjaXNlbHkgYDBgLlxuICAgICAgICAgICAgdmFyIG1hZ25pdHVkZUtleSA9IHRocmVzaG9sZHNbaV07XG4gICAgICAgICAgICAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRvIGhhbmRsZSBwbHVyYWwgaGVyZT9cbiAgICAgICAgICAgIHZhciBjb21wYWN0UGF0dGVybiA9IHRocmVzaG9sZE1hcFttYWduaXR1ZGVLZXldLm90aGVyO1xuICAgICAgICAgICAgaWYgKGNvbXBhY3RQYXR0ZXJuID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEV4YW1wbGU6IGluIHpoLVRXLCBgMTAwMDAwMDBgIG1hcHMgdG8gYDAwMDDokKxgLiBTbyB3ZSBuZWVkIHRvIHJldHVybiA4IC0gNCA9IDQgaGVyZS5cbiAgICAgICAgICAgIHJldHVybiAobWFnbml0dWRlS2V5Lmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkTWFwW21hZ25pdHVkZUtleV0ub3RoZXIubWF0Y2goLzArLylbMF0ubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ29tcHV0ZUV4cG9uZW50Rm9yTWFnbml0dWRlID0gQ29tcHV0ZUV4cG9uZW50Rm9yTWFnbml0dWRlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkN1cnJlbmN5RGlnaXRzID0gdm9pZCAwO1xudmFyIF8yNjJfMSA9IHJlcXVpcmUoXCIuLi8yNjJcIik7XG4vKipcbiAqIGh0dHBzOi8vdGMzOS5lcy9lY21hNDAyLyNzZWMtY3VycmVuY3lkaWdpdHNcbiAqL1xuZnVuY3Rpb24gQ3VycmVuY3lEaWdpdHMoYywgX2EpIHtcbiAgICB2YXIgY3VycmVuY3lEaWdpdHNEYXRhID0gX2EuY3VycmVuY3lEaWdpdHNEYXRhO1xuICAgIHJldHVybiBfMjYyXzEuSGFzT3duUHJvcGVydHkoY3VycmVuY3lEaWdpdHNEYXRhLCBjKVxuICAgICAgICA/IGN1cnJlbmN5RGlnaXRzRGF0YVtjXVxuICAgICAgICA6IDI7XG59XG5leHBvcnRzLkN1cnJlbmN5RGlnaXRzID0gQ3VycmVuY3lEaWdpdHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRm9ybWF0TnVtZXJpY1RvUGFydHMgPSB2b2lkIDA7XG52YXIgUGFydGl0aW9uTnVtYmVyUGF0dGVybl8xID0gcmVxdWlyZShcIi4vUGFydGl0aW9uTnVtYmVyUGF0dGVyblwiKTtcbnZhciBfMjYyXzEgPSByZXF1aXJlKFwiLi4vMjYyXCIpO1xuZnVuY3Rpb24gRm9ybWF0TnVtZXJpY1RvUGFydHMobmYsIHgsIGltcGxEZXRhaWxzKSB7XG4gICAgdmFyIHBhcnRzID0gUGFydGl0aW9uTnVtYmVyUGF0dGVybl8xLlBhcnRpdGlvbk51bWJlclBhdHRlcm4obmYsIHgsIGltcGxEZXRhaWxzKTtcbiAgICB2YXIgcmVzdWx0ID0gXzI2Ml8xLkFycmF5Q3JlYXRlKDApO1xuICAgIGZvciAodmFyIF9pID0gMCwgcGFydHNfMSA9IHBhcnRzOyBfaSA8IHBhcnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcGFydHNfMVtfaV07XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IHBhcnQudHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJ0LnZhbHVlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuRm9ybWF0TnVtZXJpY1RvUGFydHMgPSBGb3JtYXROdW1lcmljVG9QYXJ0cztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Gb3JtYXROdW1lcmljVG9TdHJpbmcgPSB2b2lkIDA7XG52YXIgXzI2Ml8xID0gcmVxdWlyZShcIi4uLzI2MlwiKTtcbnZhciBUb1Jhd1ByZWNpc2lvbl8xID0gcmVxdWlyZShcIi4vVG9SYXdQcmVjaXNpb25cIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBUb1Jhd0ZpeGVkXzEgPSByZXF1aXJlKFwiLi9Ub1Jhd0ZpeGVkXCIpO1xuLyoqXG4gKiBodHRwczovL3RjMzkuZXMvZWNtYTQwMi8jc2VjLWZvcm1hdG51bWJlcnN0cmluZ1xuICovXG5mdW5jdGlvbiBGb3JtYXROdW1lcmljVG9TdHJpbmcoaW50bE9iamVjdCwgeCkge1xuICAgIHZhciBpc05lZ2F0aXZlID0geCA8IDAgfHwgXzI2Ml8xLlNhbWVWYWx1ZSh4LCAtMCk7XG4gICAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICAgICAgeCA9IC14O1xuICAgIH1cbiAgICB2YXIgcmVzdWx0O1xuICAgIHZhciByb3VybmRpbmdUeXBlID0gaW50bE9iamVjdC5yb3VuZGluZ1R5cGU7XG4gICAgc3dpdGNoIChyb3VybmRpbmdUeXBlKSB7XG4gICAgICAgIGNhc2UgJ3NpZ25pZmljYW50RGlnaXRzJzpcbiAgICAgICAgICAgIHJlc3VsdCA9IFRvUmF3UHJlY2lzaW9uXzEuVG9SYXdQcmVjaXNpb24oeCwgaW50bE9iamVjdC5taW5pbXVtU2lnbmlmaWNhbnREaWdpdHMsIGludGxPYmplY3QubWF4aW11bVNpZ25pZmljYW50RGlnaXRzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmcmFjdGlvbkRpZ2l0cyc6XG4gICAgICAgICAgICByZXN1bHQgPSBUb1Jhd0ZpeGVkXzEuVG9SYXdGaXhlZCh4LCBpbnRsT2JqZWN0Lm1pbmltdW1GcmFjdGlvbkRpZ2l0cywgaW50bE9iamVjdC5tYXhpbXVtRnJhY3Rpb25EaWdpdHMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXN1bHQgPSBUb1Jhd1ByZWNpc2lvbl8xLlRvUmF3UHJlY2lzaW9uKHgsIDEsIDIpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5pbnRlZ2VyRGlnaXRzQ291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gVG9SYXdGaXhlZF8xLlRvUmF3Rml4ZWQoeCwgMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgeCA9IHJlc3VsdC5yb3VuZGVkTnVtYmVyO1xuICAgIHZhciBzdHJpbmcgPSByZXN1bHQuZm9ybWF0dGVkU3RyaW5nO1xuICAgIHZhciBpbnQgPSByZXN1bHQuaW50ZWdlckRpZ2l0c0NvdW50O1xuICAgIHZhciBtaW5JbnRlZ2VyID0gaW50bE9iamVjdC5taW5pbXVtSW50ZWdlckRpZ2l0cztcbiAgICBpZiAoaW50IDwgbWluSW50ZWdlcikge1xuICAgICAgICB2YXIgZm9yd2FyZFplcm9zID0gdXRpbHNfMS5yZXBlYXQoJzAnLCBtaW5JbnRlZ2VyIC0gaW50KTtcbiAgICAgICAgc3RyaW5nID0gZm9yd2FyZFplcm9zICsgc3RyaW5nO1xuICAgIH1cbiAgICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgICAgICB4ID0gLXg7XG4gICAgfVxuICAgIHJldHVybiB7IHJvdW5kZWROdW1iZXI6IHgsIGZvcm1hdHRlZFN0cmluZzogc3RyaW5nIH07XG59XG5leHBvcnRzLkZvcm1hdE51bWVyaWNUb1N0cmluZyA9IEZvcm1hdE51bWVyaWNUb1N0cmluZztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jbml0aWFsaXplTnVtYmVyRm9ybWF0ID0gdm9pZCAwO1xudmFyIENhbm9uaWNhbGl6ZUxvY2FsZUxpc3RfMSA9IHJlcXVpcmUoXCIuLi9DYW5vbmljYWxpemVMb2NhbGVMaXN0XCIpO1xudmFyIF8yNjJfMSA9IHJlcXVpcmUoXCIuLi8yNjJcIik7XG52YXIgR2V0T3B0aW9uXzEgPSByZXF1aXJlKFwiLi4vR2V0T3B0aW9uXCIpO1xudmFyIFJlc29sdmVMb2NhbGVfMSA9IHJlcXVpcmUoXCIuLi9SZXNvbHZlTG9jYWxlXCIpO1xudmFyIFNldE51bWJlckZvcm1hdFVuaXRPcHRpb25zXzEgPSByZXF1aXJlKFwiLi9TZXROdW1iZXJGb3JtYXRVbml0T3B0aW9uc1wiKTtcbnZhciBDdXJyZW5jeURpZ2l0c18xID0gcmVxdWlyZShcIi4vQ3VycmVuY3lEaWdpdHNcIik7XG52YXIgU2V0TnVtYmVyRm9ybWF0RGlnaXRPcHRpb25zXzEgPSByZXF1aXJlKFwiLi9TZXROdW1iZXJGb3JtYXREaWdpdE9wdGlvbnNcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbi8qKlxuICogaHR0cHM6Ly90YzM5LmVzL2VjbWE0MDIvI3NlYy1pbml0aWFsaXplbnVtYmVyZm9ybWF0XG4gKi9cbmZ1bmN0aW9uIEluaXRpYWxpemVOdW1iZXJGb3JtYXQobmYsIGxvY2FsZXMsIG9wdHMsIF9hKSB7XG4gICAgdmFyIGdldEludGVybmFsU2xvdHMgPSBfYS5nZXRJbnRlcm5hbFNsb3RzLCBsb2NhbGVEYXRhID0gX2EubG9jYWxlRGF0YSwgYXZhaWxhYmxlTG9jYWxlcyA9IF9hLmF2YWlsYWJsZUxvY2FsZXMsIG51bWJlcmluZ1N5c3RlbU5hbWVzID0gX2EubnVtYmVyaW5nU3lzdGVtTmFtZXMsIGdldERlZmF1bHRMb2NhbGUgPSBfYS5nZXREZWZhdWx0TG9jYWxlLCBjdXJyZW5jeURpZ2l0c0RhdGEgPSBfYS5jdXJyZW5jeURpZ2l0c0RhdGE7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhciByZXF1ZXN0ZWRMb2NhbGVzID0gQ2Fub25pY2FsaXplTG9jYWxlTGlzdF8xLkNhbm9uaWNhbGl6ZUxvY2FsZUxpc3QobG9jYWxlcyk7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzID09PSB1bmRlZmluZWQgPyBPYmplY3QuY3JlYXRlKG51bGwpIDogXzI2Ml8xLlRvT2JqZWN0KG9wdHMpO1xuICAgIHZhciBvcHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBtYXRjaGVyID0gR2V0T3B0aW9uXzEuR2V0T3B0aW9uKG9wdGlvbnMsICdsb2NhbGVNYXRjaGVyJywgJ3N0cmluZycsIFsnbG9va3VwJywgJ2Jlc3QgZml0J10sICdiZXN0IGZpdCcpO1xuICAgIG9wdC5sb2NhbGVNYXRjaGVyID0gbWF0Y2hlcjtcbiAgICB2YXIgbnVtYmVyaW5nU3lzdGVtID0gR2V0T3B0aW9uXzEuR2V0T3B0aW9uKG9wdGlvbnMsICdudW1iZXJpbmdTeXN0ZW0nLCAnc3RyaW5nJywgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgIGlmIChudW1iZXJpbmdTeXN0ZW0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBudW1iZXJpbmdTeXN0ZW1OYW1lcy5pbmRleE9mKG51bWJlcmluZ1N5c3RlbSkgPCAwKSB7XG4gICAgICAgIC8vIDguYS4gSWYgbnVtYmVyaW5nU3lzdGVtIGRvZXMgbm90IG1hdGNoIHRoZSBVbmljb2RlIExvY2FsZSBJZGVudGlmaWVyIHR5cGUgbm9udGVybWluYWwsXG4gICAgICAgIC8vIHRocm93IGEgUmFuZ2VFcnJvciBleGNlcHRpb24uXG4gICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG51bWJlcmluZ1N5c3RlbXM6IFwiICsgbnVtYmVyaW5nU3lzdGVtKTtcbiAgICB9XG4gICAgb3B0Lm51ID0gbnVtYmVyaW5nU3lzdGVtO1xuICAgIHZhciByID0gUmVzb2x2ZUxvY2FsZV8xLlJlc29sdmVMb2NhbGUoYXZhaWxhYmxlTG9jYWxlcywgcmVxdWVzdGVkTG9jYWxlcywgb3B0LCBcbiAgICAvLyBbW1JlbGV2YW50RXh0ZW5zaW9uS2V5c11dIHNsb3QsIHdoaWNoIGlzIGEgY29uc3RhbnRcbiAgICBbJ251J10sIGxvY2FsZURhdGEsIGdldERlZmF1bHRMb2NhbGUpO1xuICAgIHZhciBkYXRhTG9jYWxlRGF0YSA9IGxvY2FsZURhdGFbci5kYXRhTG9jYWxlXTtcbiAgICB1dGlsc18xLmludmFyaWFudCghIWRhdGFMb2NhbGVEYXRhLCBcIk1pc3NpbmcgbG9jYWxlIGRhdGEgZm9yIFwiICsgci5kYXRhTG9jYWxlKTtcbiAgICB2YXIgaW50ZXJuYWxTbG90cyA9IGdldEludGVybmFsU2xvdHMobmYpO1xuICAgIGludGVybmFsU2xvdHMubG9jYWxlID0gci5sb2NhbGU7XG4gICAgaW50ZXJuYWxTbG90cy5kYXRhTG9jYWxlID0gci5kYXRhTG9jYWxlO1xuICAgIGludGVybmFsU2xvdHMubnVtYmVyaW5nU3lzdGVtID0gci5udTtcbiAgICBpbnRlcm5hbFNsb3RzLmRhdGFMb2NhbGVEYXRhID0gZGF0YUxvY2FsZURhdGE7XG4gICAgU2V0TnVtYmVyRm9ybWF0VW5pdE9wdGlvbnNfMS5TZXROdW1iZXJGb3JtYXRVbml0T3B0aW9ucyhuZiwgb3B0aW9ucywgeyBnZXRJbnRlcm5hbFNsb3RzOiBnZXRJbnRlcm5hbFNsb3RzIH0pO1xuICAgIHZhciBzdHlsZSA9IGludGVybmFsU2xvdHMuc3R5bGU7XG4gICAgdmFyIG1uZmREZWZhdWx0O1xuICAgIHZhciBteGZkRGVmYXVsdDtcbiAgICBpZiAoc3R5bGUgPT09ICdjdXJyZW5jeScpIHtcbiAgICAgICAgdmFyIGN1cnJlbmN5ID0gaW50ZXJuYWxTbG90cy5jdXJyZW5jeTtcbiAgICAgICAgdmFyIGNEaWdpdHMgPSBDdXJyZW5jeURpZ2l0c18xLkN1cnJlbmN5RGlnaXRzKGN1cnJlbmN5LCB7IGN1cnJlbmN5RGlnaXRzRGF0YTogY3VycmVuY3lEaWdpdHNEYXRhIH0pO1xuICAgICAgICBtbmZkRGVmYXVsdCA9IGNEaWdpdHM7XG4gICAgICAgIG14ZmREZWZhdWx0ID0gY0RpZ2l0cztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1uZmREZWZhdWx0ID0gMDtcbiAgICAgICAgbXhmZERlZmF1bHQgPSBzdHlsZSA9PT0gJ3BlcmNlbnQnID8gMCA6IDM7XG4gICAgfVxuICAgIHZhciBub3RhdGlvbiA9IEdldE9wdGlvbl8xLkdldE9wdGlvbihvcHRpb25zLCAnbm90YXRpb24nLCAnc3RyaW5nJywgWydzdGFuZGFyZCcsICdzY2llbnRpZmljJywgJ2VuZ2luZWVyaW5nJywgJ2NvbXBhY3QnXSwgJ3N0YW5kYXJkJyk7XG4gICAgaW50ZXJuYWxTbG90cy5ub3RhdGlvbiA9IG5vdGF0aW9uO1xuICAgIFNldE51bWJlckZvcm1hdERpZ2l0T3B0aW9uc18xLlNldE51bWJlckZvcm1hdERpZ2l0T3B0aW9ucyhpbnRlcm5hbFNsb3RzLCBvcHRpb25zLCBtbmZkRGVmYXVsdCwgbXhmZERlZmF1bHQsIG5vdGF0aW9uKTtcbiAgICB2YXIgY29tcGFjdERpc3BsYXkgPSBHZXRPcHRpb25fMS5HZXRPcHRpb24ob3B0aW9ucywgJ2NvbXBhY3REaXNwbGF5JywgJ3N0cmluZycsIFsnc2hvcnQnLCAnbG9uZyddLCAnc2hvcnQnKTtcbiAgICBpZiAobm90YXRpb24gPT09ICdjb21wYWN0Jykge1xuICAgICAgICBpbnRlcm5hbFNsb3RzLmNvbXBhY3REaXNwbGF5ID0gY29tcGFjdERpc3BsYXk7XG4gICAgfVxuICAgIHZhciB1c2VHcm91cGluZyA9IEdldE9wdGlvbl8xLkdldE9wdGlvbihvcHRpb25zLCAndXNlR3JvdXBpbmcnLCAnYm9vbGVhbicsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgaW50ZXJuYWxTbG90cy51c2VHcm91cGluZyA9IHVzZUdyb3VwaW5nO1xuICAgIHZhciBzaWduRGlzcGxheSA9IEdldE9wdGlvbl8xLkdldE9wdGlvbihvcHRpb25zLCAnc2lnbkRpc3BsYXknLCAnc3RyaW5nJywgWydhdXRvJywgJ25ldmVyJywgJ2Fsd2F5cycsICdleGNlcHRaZXJvJ10sICdhdXRvJyk7XG4gICAgaW50ZXJuYWxTbG90cy5zaWduRGlzcGxheSA9IHNpZ25EaXNwbGF5O1xuICAgIHJldHVybiBuZjtcbn1cbmV4cG9ydHMuSW5pdGlhbGl6ZU51bWJlckZvcm1hdCA9IEluaXRpYWxpemVOdW1iZXJGb3JtYXQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFydGl0aW9uTnVtYmVyUGF0dGVybiA9IHZvaWQgMDtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIEZvcm1hdE51bWVyaWNUb1N0cmluZ18xID0gcmVxdWlyZShcIi4vRm9ybWF0TnVtZXJpY1RvU3RyaW5nXCIpO1xudmFyIF8yNjJfMSA9IHJlcXVpcmUoXCIuLi8yNjJcIik7XG52YXIgQ29tcHV0ZUV4cG9uZW50XzEgPSByZXF1aXJlKFwiLi9Db21wdXRlRXhwb25lbnRcIik7XG52YXIgZm9ybWF0X3RvX3BhcnRzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9mb3JtYXRfdG9fcGFydHNcIikpO1xuLyoqXG4gKiBodHRwczovL3RjMzkuZXMvZWNtYTQwMi8jc2VjLWZvcm1hdG51bWJlcnN0cmluZ1xuICovXG5mdW5jdGlvbiBQYXJ0aXRpb25OdW1iZXJQYXR0ZXJuKG51bWJlckZvcm1hdCwgeCwgX2EpIHtcbiAgICB2YXIgX2I7XG4gICAgdmFyIGdldEludGVybmFsU2xvdHMgPSBfYS5nZXRJbnRlcm5hbFNsb3RzO1xuICAgIHZhciBpbnRlcm5hbFNsb3RzID0gZ2V0SW50ZXJuYWxTbG90cyhudW1iZXJGb3JtYXQpO1xuICAgIHZhciBwbCA9IGludGVybmFsU2xvdHMucGwsIGRhdGFMb2NhbGVEYXRhID0gaW50ZXJuYWxTbG90cy5kYXRhTG9jYWxlRGF0YSwgbnVtYmVyaW5nU3lzdGVtID0gaW50ZXJuYWxTbG90cy5udW1iZXJpbmdTeXN0ZW07XG4gICAgdmFyIHN5bWJvbHMgPSBkYXRhTG9jYWxlRGF0YS5udW1iZXJzLnN5bWJvbHNbbnVtYmVyaW5nU3lzdGVtXSB8fFxuICAgICAgICBkYXRhTG9jYWxlRGF0YS5udW1iZXJzLnN5bWJvbHNbZGF0YUxvY2FsZURhdGEubnVtYmVycy5udVswXV07XG4gICAgdmFyIG1hZ25pdHVkZSA9IDA7XG4gICAgdmFyIGV4cG9uZW50ID0gMDtcbiAgICB2YXIgbjtcbiAgICBpZiAoaXNOYU4oeCkpIHtcbiAgICAgICAgbiA9IHN5bWJvbHMubmFuO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXNGaW5pdGUoeCkpIHtcbiAgICAgICAgbiA9IHN5bWJvbHMuaW5maW5pdHk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoaW50ZXJuYWxTbG90cy5zdHlsZSA9PT0gJ3BlcmNlbnQnKSB7XG4gICAgICAgICAgICB4ICo9IDEwMDtcbiAgICAgICAgfVxuICAgICAgICBfYiA9IENvbXB1dGVFeHBvbmVudF8xLkNvbXB1dGVFeHBvbmVudChudW1iZXJGb3JtYXQsIHgsIHtcbiAgICAgICAgICAgIGdldEludGVybmFsU2xvdHM6IGdldEludGVybmFsU2xvdHMsXG4gICAgICAgIH0pLCBleHBvbmVudCA9IF9iWzBdLCBtYWduaXR1ZGUgPSBfYlsxXTtcbiAgICAgICAgLy8gUHJlc2VydmUgbW9yZSBwcmVjaXNpb24gYnkgZG9pbmcgbXVsdGlwbGljYXRpb24gd2hlbiBleHBvbmVudCBpcyBuZWdhdGl2ZS5cbiAgICAgICAgeCA9IGV4cG9uZW50IDwgMCA/IHggKiBNYXRoLnBvdygxMCwgLWV4cG9uZW50KSA6IHggLyBNYXRoLnBvdygxMCwgZXhwb25lbnQpO1xuICAgICAgICB2YXIgZm9ybWF0TnVtYmVyUmVzdWx0ID0gRm9ybWF0TnVtZXJpY1RvU3RyaW5nXzEuRm9ybWF0TnVtZXJpY1RvU3RyaW5nKGludGVybmFsU2xvdHMsIHgpO1xuICAgICAgICBuID0gZm9ybWF0TnVtYmVyUmVzdWx0LmZvcm1hdHRlZFN0cmluZztcbiAgICAgICAgeCA9IGZvcm1hdE51bWJlclJlc3VsdC5yb3VuZGVkTnVtYmVyO1xuICAgIH1cbiAgICAvLyBCYXNlZCBvbiBodHRwczovL3RjMzkuZXMvZWNtYTQwMi8jc2VjLWdldG51bWJlcmZvcm1hdHBhdHRlcm5cbiAgICAvLyBXZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIGB4YCBpcyByb3VuZGVkLlxuICAgIHZhciBzaWduO1xuICAgIHZhciBzaWduRGlzcGxheSA9IGludGVybmFsU2xvdHMuc2lnbkRpc3BsYXk7XG4gICAgc3dpdGNoIChzaWduRGlzcGxheSkge1xuICAgICAgICBjYXNlICduZXZlcic6XG4gICAgICAgICAgICBzaWduID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhdXRvJzpcbiAgICAgICAgICAgIGlmIChfMjYyXzEuU2FtZVZhbHVlKHgsIDApIHx8IHggPiAwIHx8IGlzTmFOKHgpKSB7XG4gICAgICAgICAgICAgICAgc2lnbiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaWduID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYWx3YXlzJzpcbiAgICAgICAgICAgIGlmIChfMjYyXzEuU2FtZVZhbHVlKHgsIDApIHx8IHggPiAwIHx8IGlzTmFOKHgpKSB7XG4gICAgICAgICAgICAgICAgc2lnbiA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaWduID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIHggPT09IDAgLT4geCBpcyAwIG9yIHggaXMgLTBcbiAgICAgICAgICAgIGlmICh4ID09PSAwIHx8IGlzTmFOKHgpKSB7XG4gICAgICAgICAgICAgICAgc2lnbiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh4ID4gMCkge1xuICAgICAgICAgICAgICAgIHNpZ24gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2lnbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0X3RvX3BhcnRzXzEuZGVmYXVsdCh7IHJvdW5kZWROdW1iZXI6IHgsIGZvcm1hdHRlZFN0cmluZzogbiwgZXhwb25lbnQ6IGV4cG9uZW50LCBtYWduaXR1ZGU6IG1hZ25pdHVkZSwgc2lnbjogc2lnbiB9LCBpbnRlcm5hbFNsb3RzLmRhdGFMb2NhbGVEYXRhLCBwbCwgaW50ZXJuYWxTbG90cyk7XG59XG5leHBvcnRzLlBhcnRpdGlvbk51bWJlclBhdHRlcm4gPSBQYXJ0aXRpb25OdW1iZXJQYXR0ZXJuO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNldE51bWJlckZvcm1hdERpZ2l0T3B0aW9ucyA9IHZvaWQgMDtcbnZhciBHZXROdW1iZXJPcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9HZXROdW1iZXJPcHRpb25cIik7XG52YXIgRGVmYXVsdE51bWJlck9wdGlvbl8xID0gcmVxdWlyZShcIi4uL0RlZmF1bHROdW1iZXJPcHRpb25cIik7XG4vKipcbiAqIGh0dHBzOi8vdGMzOS5lcy9lY21hNDAyLyNzZWMtc2V0bmZkaWdpdG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gU2V0TnVtYmVyRm9ybWF0RGlnaXRPcHRpb25zKGludGVybmFsU2xvdHMsIG9wdHMsIG1uZmREZWZhdWx0LCBteGZkRGVmYXVsdCwgbm90YXRpb24pIHtcbiAgICB2YXIgbW5pZCA9IEdldE51bWJlck9wdGlvbl8xLkdldE51bWJlck9wdGlvbihvcHRzLCAnbWluaW11bUludGVnZXJEaWdpdHMnLCAxLCAyMSwgMSk7XG4gICAgdmFyIG1uZmQgPSBvcHRzLm1pbmltdW1GcmFjdGlvbkRpZ2l0cztcbiAgICB2YXIgbXhmZCA9IG9wdHMubWF4aW11bUZyYWN0aW9uRGlnaXRzO1xuICAgIHZhciBtbnNkID0gb3B0cy5taW5pbXVtU2lnbmlmaWNhbnREaWdpdHM7XG4gICAgdmFyIG14c2QgPSBvcHRzLm1heGltdW1TaWduaWZpY2FudERpZ2l0cztcbiAgICBpbnRlcm5hbFNsb3RzLm1pbmltdW1JbnRlZ2VyRGlnaXRzID0gbW5pZDtcbiAgICBpZiAobW5zZCAhPT0gdW5kZWZpbmVkIHx8IG14c2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbnRlcm5hbFNsb3RzLnJvdW5kaW5nVHlwZSA9ICdzaWduaWZpY2FudERpZ2l0cyc7XG4gICAgICAgIG1uc2QgPSBEZWZhdWx0TnVtYmVyT3B0aW9uXzEuRGVmYXVsdE51bWJlck9wdGlvbihtbnNkLCAxLCAyMSwgMSk7XG4gICAgICAgIG14c2QgPSBEZWZhdWx0TnVtYmVyT3B0aW9uXzEuRGVmYXVsdE51bWJlck9wdGlvbihteHNkLCBtbnNkLCAyMSwgMjEpO1xuICAgICAgICBpbnRlcm5hbFNsb3RzLm1pbmltdW1TaWduaWZpY2FudERpZ2l0cyA9IG1uc2Q7XG4gICAgICAgIGludGVybmFsU2xvdHMubWF4aW11bVNpZ25pZmljYW50RGlnaXRzID0gbXhzZDtcbiAgICB9XG4gICAgZWxzZSBpZiAobW5mZCAhPT0gdW5kZWZpbmVkIHx8IG14ZmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbnRlcm5hbFNsb3RzLnJvdW5kaW5nVHlwZSA9ICdmcmFjdGlvbkRpZ2l0cyc7XG4gICAgICAgIG1uZmQgPSBEZWZhdWx0TnVtYmVyT3B0aW9uXzEuRGVmYXVsdE51bWJlck9wdGlvbihtbmZkLCAwLCAyMCwgbW5mZERlZmF1bHQpO1xuICAgICAgICB2YXIgbXhmZEFjdHVhbERlZmF1bHQgPSBNYXRoLm1heChtbmZkLCBteGZkRGVmYXVsdCk7XG4gICAgICAgIG14ZmQgPSBEZWZhdWx0TnVtYmVyT3B0aW9uXzEuRGVmYXVsdE51bWJlck9wdGlvbihteGZkLCBtbmZkLCAyMCwgbXhmZEFjdHVhbERlZmF1bHQpO1xuICAgICAgICBpbnRlcm5hbFNsb3RzLm1pbmltdW1GcmFjdGlvbkRpZ2l0cyA9IG1uZmQ7XG4gICAgICAgIGludGVybmFsU2xvdHMubWF4aW11bUZyYWN0aW9uRGlnaXRzID0gbXhmZDtcbiAgICB9XG4gICAgZWxzZSBpZiAobm90YXRpb24gPT09ICdjb21wYWN0Jykge1xuICAgICAgICBpbnRlcm5hbFNsb3RzLnJvdW5kaW5nVHlwZSA9ICdjb21wYWN0Um91bmRpbmcnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaW50ZXJuYWxTbG90cy5yb3VuZGluZ1R5cGUgPSAnZnJhY3Rpb25EaWdpdHMnO1xuICAgICAgICBpbnRlcm5hbFNsb3RzLm1pbmltdW1GcmFjdGlvbkRpZ2l0cyA9IG1uZmREZWZhdWx0O1xuICAgICAgICBpbnRlcm5hbFNsb3RzLm1heGltdW1GcmFjdGlvbkRpZ2l0cyA9IG14ZmREZWZhdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuU2V0TnVtYmVyRm9ybWF0RGlnaXRPcHRpb25zID0gU2V0TnVtYmVyRm9ybWF0RGlnaXRPcHRpb25zO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNldE51bWJlckZvcm1hdFVuaXRPcHRpb25zID0gdm9pZCAwO1xudmFyIEdldE9wdGlvbl8xID0gcmVxdWlyZShcIi4uL0dldE9wdGlvblwiKTtcbnZhciBJc1dlbGxGb3JtZWRDdXJyZW5jeUNvZGVfMSA9IHJlcXVpcmUoXCIuLi9Jc1dlbGxGb3JtZWRDdXJyZW5jeUNvZGVcIik7XG52YXIgSXNXZWxsRm9ybWVkVW5pdElkZW50aWZpZXJfMSA9IHJlcXVpcmUoXCIuLi9Jc1dlbGxGb3JtZWRVbml0SWRlbnRpZmllclwiKTtcbi8qKlxuICogaHR0cHM6Ly90YzM5LmVzL2VjbWE0MDIvI3NlYy1zZXRudW1iZXJmb3JtYXR1bml0b3B0aW9uc1xuICovXG5mdW5jdGlvbiBTZXROdW1iZXJGb3JtYXRVbml0T3B0aW9ucyhuZiwgb3B0aW9ucywgX2EpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyB9XG4gICAgdmFyIGdldEludGVybmFsU2xvdHMgPSBfYS5nZXRJbnRlcm5hbFNsb3RzO1xuICAgIHZhciBpbnRlcm5hbFNsb3RzID0gZ2V0SW50ZXJuYWxTbG90cyhuZik7XG4gICAgdmFyIHN0eWxlID0gR2V0T3B0aW9uXzEuR2V0T3B0aW9uKG9wdGlvbnMsICdzdHlsZScsICdzdHJpbmcnLCBbJ2RlY2ltYWwnLCAncGVyY2VudCcsICdjdXJyZW5jeScsICd1bml0J10sICdkZWNpbWFsJyk7XG4gICAgaW50ZXJuYWxTbG90cy5zdHlsZSA9IHN0eWxlO1xuICAgIHZhciBjdXJyZW5jeSA9IEdldE9wdGlvbl8xLkdldE9wdGlvbihvcHRpb25zLCAnY3VycmVuY3knLCAnc3RyaW5nJywgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgIGlmIChjdXJyZW5jeSAhPT0gdW5kZWZpbmVkICYmICFJc1dlbGxGb3JtZWRDdXJyZW5jeUNvZGVfMS5Jc1dlbGxGb3JtZWRDdXJyZW5jeUNvZGUoY3VycmVuY3kpKSB7XG4gICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ01hbGZvcm1lZCBjdXJyZW5jeSBjb2RlJyk7XG4gICAgfVxuICAgIGlmIChzdHlsZSA9PT0gJ2N1cnJlbmN5JyAmJiBjdXJyZW5jeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignY3VycmVuY3kgY2Fubm90IGJlIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICB2YXIgY3VycmVuY3lEaXNwbGF5ID0gR2V0T3B0aW9uXzEuR2V0T3B0aW9uKG9wdGlvbnMsICdjdXJyZW5jeURpc3BsYXknLCAnc3RyaW5nJywgWydjb2RlJywgJ3N5bWJvbCcsICduYXJyb3dTeW1ib2wnLCAnbmFtZSddLCAnc3ltYm9sJyk7XG4gICAgdmFyIGN1cnJlbmN5U2lnbiA9IEdldE9wdGlvbl8xLkdldE9wdGlvbihvcHRpb25zLCAnY3VycmVuY3lTaWduJywgJ3N0cmluZycsIFsnc3RhbmRhcmQnLCAnYWNjb3VudGluZyddLCAnc3RhbmRhcmQnKTtcbiAgICB2YXIgdW5pdCA9IEdldE9wdGlvbl8xLkdldE9wdGlvbihvcHRpb25zLCAndW5pdCcsICdzdHJpbmcnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgaWYgKHVuaXQgIT09IHVuZGVmaW5lZCAmJiAhSXNXZWxsRm9ybWVkVW5pdElkZW50aWZpZXJfMS5Jc1dlbGxGb3JtZWRVbml0SWRlbnRpZmllcih1bml0KSkge1xuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdJbnZhbGlkIHVuaXQgYXJndW1lbnQgZm9yIEludGwuTnVtYmVyRm9ybWF0KCknKTtcbiAgICB9XG4gICAgaWYgKHN0eWxlID09PSAndW5pdCcgJiYgdW5pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcigndW5pdCBjYW5ub3QgYmUgdW5kZWZpbmVkJyk7XG4gICAgfVxuICAgIHZhciB1bml0RGlzcGxheSA9IEdldE9wdGlvbl8xLkdldE9wdGlvbihvcHRpb25zLCAndW5pdERpc3BsYXknLCAnc3RyaW5nJywgWydzaG9ydCcsICduYXJyb3cnLCAnbG9uZyddLCAnc2hvcnQnKTtcbiAgICBpZiAoc3R5bGUgPT09ICdjdXJyZW5jeScpIHtcbiAgICAgICAgaW50ZXJuYWxTbG90cy5jdXJyZW5jeSA9IGN1cnJlbmN5LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGludGVybmFsU2xvdHMuY3VycmVuY3lEaXNwbGF5ID0gY3VycmVuY3lEaXNwbGF5O1xuICAgICAgICBpbnRlcm5hbFNsb3RzLmN1cnJlbmN5U2lnbiA9IGN1cnJlbmN5U2lnbjtcbiAgICB9XG4gICAgaWYgKHN0eWxlID09PSAndW5pdCcpIHtcbiAgICAgICAgaW50ZXJuYWxTbG90cy51bml0ID0gdW5pdDtcbiAgICAgICAgaW50ZXJuYWxTbG90cy51bml0RGlzcGxheSA9IHVuaXREaXNwbGF5O1xuICAgIH1cbn1cbmV4cG9ydHMuU2V0TnVtYmVyRm9ybWF0VW5pdE9wdGlvbnMgPSBTZXROdW1iZXJGb3JtYXRVbml0T3B0aW9ucztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ub1Jhd0ZpeGVkID0gdm9pZCAwO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG4vKipcbiAqIFRPRE86IGRlZHVwIHdpdGggaW50bC1wbHVyYWxydWxlcyBhbmQgc3VwcG9ydCBCaWdJbnRcbiAqIGh0dHBzOi8vdGMzOS5lcy9lY21hNDAyLyNzZWMtdG9yYXdmaXhlZFxuICogQHBhcmFtIHggYSBmaW5pdGUgbm9uLW5lZ2F0aXZlIE51bWJlciBvciBCaWdJbnRcbiAqIEBwYXJhbSBtaW5GcmFjdGlvbiBhbmQgaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDIwXG4gKiBAcGFyYW0gbWF4RnJhY3Rpb24gYW5kIGludGVnZXIgYmV0d2VlbiAwIGFuZCAyMFxuICovXG5mdW5jdGlvbiBUb1Jhd0ZpeGVkKHgsIG1pbkZyYWN0aW9uLCBtYXhGcmFjdGlvbikge1xuICAgIHZhciBmID0gbWF4RnJhY3Rpb247XG4gICAgdmFyIG4gPSBNYXRoLnJvdW5kKHggKiBNYXRoLnBvdygxMCwgZikpO1xuICAgIHZhciB4RmluYWwgPSBuIC8gTWF0aC5wb3coMTAsIGYpO1xuICAgIC8vIG4gaXMgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBidXQgaXQgaXMgcG9zc2libGUgdG8gYmUgZ3JlYXRlciB0aGFuIDFlMjEuXG4gICAgLy8gSW4gc3VjaCBjYXNlIHdlIHdpbGwgZ28gdGhlIHNsb3cgcGF0aC5cbiAgICAvLyBTZWUgYWxzbzogaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1udW1lcmljLXR5cGVzLW51bWJlci10b3N0cmluZ1xuICAgIHZhciBtO1xuICAgIGlmIChuIDwgMWUyMSkge1xuICAgICAgICBtID0gbi50b1N0cmluZygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbSA9IG4udG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIF9hID0gbS5zcGxpdCgnZScpLCBtYW50aXNzYSA9IF9hWzBdLCBleHBvbmVudCA9IF9hWzFdO1xuICAgICAgICBtID0gbWFudGlzc2EucmVwbGFjZSgnLicsICcnKTtcbiAgICAgICAgbSA9IG0gKyB1dGlsc18xLnJlcGVhdCgnMCcsIE1hdGgubWF4KCtleHBvbmVudCAtIG0ubGVuZ3RoICsgMSwgMCkpO1xuICAgIH1cbiAgICB2YXIgaW50O1xuICAgIGlmIChmICE9PSAwKSB7XG4gICAgICAgIHZhciBrID0gbS5sZW5ndGg7XG4gICAgICAgIGlmIChrIDw9IGYpIHtcbiAgICAgICAgICAgIHZhciB6ID0gdXRpbHNfMS5yZXBlYXQoJzAnLCBmICsgMSAtIGspO1xuICAgICAgICAgICAgbSA9IHogKyBtO1xuICAgICAgICAgICAgayA9IGYgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhID0gbS5zbGljZSgwLCBrIC0gZik7XG4gICAgICAgIHZhciBiID0gbS5zbGljZShrIC0gZik7XG4gICAgICAgIG0gPSBhICsgXCIuXCIgKyBiO1xuICAgICAgICBpbnQgPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGludCA9IG0ubGVuZ3RoO1xuICAgIH1cbiAgICB2YXIgY3V0ID0gbWF4RnJhY3Rpb24gLSBtaW5GcmFjdGlvbjtcbiAgICB3aGlsZSAoY3V0ID4gMCAmJiBtW20ubGVuZ3RoIC0gMV0gPT09ICcwJykge1xuICAgICAgICBtID0gbS5zbGljZSgwLCAtMSk7XG4gICAgICAgIGN1dC0tO1xuICAgIH1cbiAgICBpZiAobVttLmxlbmd0aCAtIDFdID09PSAnLicpIHtcbiAgICAgICAgbSA9IG0uc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICByZXR1cm4geyBmb3JtYXR0ZWRTdHJpbmc6IG0sIHJvdW5kZWROdW1iZXI6IHhGaW5hbCwgaW50ZWdlckRpZ2l0c0NvdW50OiBpbnQgfTtcbn1cbmV4cG9ydHMuVG9SYXdGaXhlZCA9IFRvUmF3Rml4ZWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVG9SYXdQcmVjaXNpb24gPSB2b2lkIDA7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmZ1bmN0aW9uIFRvUmF3UHJlY2lzaW9uKHgsIG1pblByZWNpc2lvbiwgbWF4UHJlY2lzaW9uKSB7XG4gICAgdmFyIHAgPSBtYXhQcmVjaXNpb247XG4gICAgdmFyIG07XG4gICAgdmFyIGU7XG4gICAgdmFyIHhGaW5hbDtcbiAgICBpZiAoeCA9PT0gMCkge1xuICAgICAgICBtID0gdXRpbHNfMS5yZXBlYXQoJzAnLCBwKTtcbiAgICAgICAgZSA9IDA7XG4gICAgICAgIHhGaW5hbCA9IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgeFRvU3RyaW5nID0geC50b1N0cmluZygpO1xuICAgICAgICAvLyBJZiB4VG9TdHJpbmcgaXMgZm9ybWF0dGVkIGFzIHNjaWVudGlmaWMgbm90YXRpb24sIHRoZSBudW1iZXIgaXMgZWl0aGVyIHZlcnkgc21hbGwgb3IgdmVyeVxuICAgICAgICAvLyBsYXJnZS4gSWYgdGhlIHByZWNpc2lvbiBvZiB0aGUgZm9ybWF0dGVkIHN0cmluZyBpcyBsb3dlciB0aGF0IHJlcXVlc3RlZCBtYXggcHJlY2lzaW9uLCB3ZVxuICAgICAgICAvLyBzaG91bGQgc3RpbGwgaW5mZXIgdGhlbSBmcm9tIHRoZSBmb3JtYXR0ZWQgc3RyaW5nLCBvdGhlcndpc2UgdGhlIGZvcm1hdHRlZCByZXN1bHQgbWlnaHQgaGF2ZVxuICAgICAgICAvLyBwcmVjaXNpb24gbG9zcyAoZS5nLiAxZTQxIHdpbGwgbm90IGhhdmUgMCBpbiBldmVyeSB0cmFpbGluZyBkaWdpdHMpLlxuICAgICAgICB2YXIgeFRvU3RyaW5nRXhwb25lbnRJbmRleCA9IHhUb1N0cmluZy5pbmRleE9mKCdlJyk7XG4gICAgICAgIHZhciBfYSA9IHhUb1N0cmluZy5zcGxpdCgnZScpLCB4VG9TdHJpbmdNYW50aXNzYSA9IF9hWzBdLCB4VG9TdHJpbmdFeHBvbmVudCA9IF9hWzFdO1xuICAgICAgICB2YXIgeFRvU3RyaW5nTWFudGlzc2FXaXRob3V0RGVjaW1hbFBvaW50ID0geFRvU3RyaW5nTWFudGlzc2EucmVwbGFjZSgnLicsICcnKTtcbiAgICAgICAgaWYgKHhUb1N0cmluZ0V4cG9uZW50SW5kZXggPj0gMCAmJlxuICAgICAgICAgICAgeFRvU3RyaW5nTWFudGlzc2FXaXRob3V0RGVjaW1hbFBvaW50Lmxlbmd0aCA8PSBwKSB7XG4gICAgICAgICAgICBlID0gK3hUb1N0cmluZ0V4cG9uZW50O1xuICAgICAgICAgICAgbSA9XG4gICAgICAgICAgICAgICAgeFRvU3RyaW5nTWFudGlzc2FXaXRob3V0RGVjaW1hbFBvaW50ICtcbiAgICAgICAgICAgICAgICAgICAgdXRpbHNfMS5yZXBlYXQoJzAnLCBwIC0geFRvU3RyaW5nTWFudGlzc2FXaXRob3V0RGVjaW1hbFBvaW50Lmxlbmd0aCk7XG4gICAgICAgICAgICB4RmluYWwgPSB4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZSA9IHV0aWxzXzEuZ2V0TWFnbml0dWRlKHgpO1xuICAgICAgICAgICAgdmFyIGRlY2ltYWxQbGFjZU9mZnNldCA9IGUgLSBwICsgMTtcbiAgICAgICAgICAgIC8vIG4gaXMgdGhlIGludGVnZXIgY29udGFpbmluZyB0aGUgcmVxdWlyZWQgcHJlY2lzaW9uIGRpZ2l0cy4gVG8gZGVyaXZlIHRoZSBmb3JtYXR0ZWQgc3RyaW5nLFxuICAgICAgICAgICAgLy8gd2Ugd2lsbCBhZGp1c3QgaXRzIGRlY2ltYWwgcGxhY2UgaW4gdGhlIGxvZ2ljIGJlbG93LlxuICAgICAgICAgICAgdmFyIG4gPSBNYXRoLnJvdW5kKGFkanVzdERlY2ltYWxQbGFjZSh4LCBkZWNpbWFsUGxhY2VPZmZzZXQpKTtcbiAgICAgICAgICAgIC8vIFRoZSByb3VuZGluZyBjYXVzZWQgdGhlIGNoYW5nZSBvZiBtYWduaXR1ZGUsIHNvIHdlIHNob3VsZCBpbmNyZW1lbnQgYGVgIGJ5IDEuXG4gICAgICAgICAgICBpZiAoYWRqdXN0RGVjaW1hbFBsYWNlKG4sIHAgLSAxKSA+PSAxMCkge1xuICAgICAgICAgICAgICAgIGUgPSBlICsgMTtcbiAgICAgICAgICAgICAgICAvLyBEaXZpZGUgbiBieSAxMCB0byBzd2FsbG93IG9uZSBwcmVjaXNpb24uXG4gICAgICAgICAgICAgICAgbiA9IE1hdGguZmxvb3IobiAvIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG0gPSBuLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAvLyBFcXVpdmFsZW50IG9mIG4gKiAxMCAqKiAoZSAtIHAgKyAxKVxuICAgICAgICAgICAgeEZpbmFsID0gYWRqdXN0RGVjaW1hbFBsYWNlKG4sIHAgLSAxIC0gZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGludDtcbiAgICBpZiAoZSA+PSBwIC0gMSkge1xuICAgICAgICBtID0gbSArIHV0aWxzXzEucmVwZWF0KCcwJywgZSAtIHAgKyAxKTtcbiAgICAgICAgaW50ID0gZSArIDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGUgPj0gMCkge1xuICAgICAgICBtID0gbS5zbGljZSgwLCBlICsgMSkgKyBcIi5cIiArIG0uc2xpY2UoZSArIDEpO1xuICAgICAgICBpbnQgPSBlICsgMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG0gPSBcIjAuXCIgKyB1dGlsc18xLnJlcGVhdCgnMCcsIC1lIC0gMSkgKyBtO1xuICAgICAgICBpbnQgPSAxO1xuICAgIH1cbiAgICBpZiAobS5pbmRleE9mKCcuJykgPj0gMCAmJiBtYXhQcmVjaXNpb24gPiBtaW5QcmVjaXNpb24pIHtcbiAgICAgICAgdmFyIGN1dCA9IG1heFByZWNpc2lvbiAtIG1pblByZWNpc2lvbjtcbiAgICAgICAgd2hpbGUgKGN1dCA+IDAgJiYgbVttLmxlbmd0aCAtIDFdID09PSAnMCcpIHtcbiAgICAgICAgICAgIG0gPSBtLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIGN1dC0tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtW20ubGVuZ3RoIC0gMV0gPT09ICcuJykge1xuICAgICAgICAgICAgbSA9IG0uc2xpY2UoMCwgLTEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGZvcm1hdHRlZFN0cmluZzogbSwgcm91bmRlZE51bWJlcjogeEZpbmFsLCBpbnRlZ2VyRGlnaXRzQ291bnQ6IGludCB9O1xuICAgIC8vIHggLyAoMTAgKiogbWFnbml0dWRlKSwgYnV0IHRyeSB0byBwcmVzZXJ2ZSBhcyBtdWNoIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiBhcyBwb3NzaWJsZS5cbiAgICBmdW5jdGlvbiBhZGp1c3REZWNpbWFsUGxhY2UoeCwgbWFnbml0dWRlKSB7XG4gICAgICAgIHJldHVybiBtYWduaXR1ZGUgPCAwID8geCAqIE1hdGgucG93KDEwLCAtbWFnbml0dWRlKSA6IHggLyBNYXRoLnBvdygxMCwgbWFnbml0dWRlKTtcbiAgICB9XG59XG5leHBvcnRzLlRvUmF3UHJlY2lzaW9uID0gVG9SYXdQcmVjaXNpb247XG4iLCJtb2R1bGUuZXhwb3J0cz17IFwiYWRsbVwiOiBbXCLwnqWQXCIsIFwi8J6lkVwiLCBcIvCepZJcIiwgXCLwnqWTXCIsIFwi8J6llFwiLCBcIvCepZVcIiwgXCLwnqWWXCIsIFwi8J6ll1wiLCBcIvCepZhcIiwgXCLwnqWZXCJdLCBcImFob21cIjogW1wi8JGcsFwiLCBcIvCRnLFcIiwgXCLwkZyyXCIsIFwi8JGcs1wiLCBcIvCRnLRcIiwgXCLwkZy1XCIsIFwi8JGctlwiLCBcIvCRnLdcIiwgXCLwkZy4XCIsIFwi8JGcuVwiXSwgXCJhcmFiXCI6IFtcItmgXCIsIFwi2aFcIiwgXCLZolwiLCBcItmjXCIsIFwi2aRcIiwgXCLZpVwiLCBcItmmXCIsIFwi2adcIiwgXCLZqFwiLCBcItmpXCJdLCBcImFyYWJleHRcIjogW1wi27BcIiwgXCLbsVwiLCBcItuyXCIsIFwi27NcIiwgXCLbtFwiLCBcItu1XCIsIFwi27ZcIiwgXCLbt1wiLCBcItu4XCIsIFwi27lcIl0sIFwiYmFsaVwiOiBbXCLhrZBcIiwgXCLhrZFcIiwgXCLhrZJcIiwgXCLhrZNcIiwgXCLhrZRcIiwgXCLhrZVcIiwgXCLhrZZcIiwgXCLhrZdcIiwgXCLhrZhcIiwgXCLhrZlcIl0sIFwiYmVuZ1wiOiBbXCLgp6ZcIiwgXCLgp6dcIiwgXCLgp6hcIiwgXCLgp6lcIiwgXCLgp6pcIiwgXCLgp6tcIiwgXCLgp6xcIiwgXCLgp61cIiwgXCLgp65cIiwgXCLgp69cIl0sIFwiYmhrc1wiOiBbXCLwkbGQXCIsIFwi8JGxkVwiLCBcIvCRsZJcIiwgXCLwkbGTXCIsIFwi8JGxlFwiLCBcIvCRsZVcIiwgXCLwkbGWXCIsIFwi8JGxl1wiLCBcIvCRsZhcIiwgXCLwkbGZXCJdLCBcImJyYWhcIjogW1wi8JGBplwiLCBcIvCRgadcIiwgXCLwkYGoXCIsIFwi8JGBqVwiLCBcIvCRgapcIiwgXCLwkYGrXCIsIFwi8JGBrFwiLCBcIvCRga1cIiwgXCLwkYGuXCIsIFwi8JGBr1wiXSwgXCJjYWttXCI6IFtcIvCRhLZcIiwgXCLwkYS3XCIsIFwi8JGEuFwiLCBcIvCRhLlcIiwgXCLwkYS6XCIsIFwi8JGEu1wiLCBcIvCRhLxcIiwgXCLwkYS9XCIsIFwi8JGEvlwiLCBcIvCRhL9cIl0sIFwiY2hhbVwiOiBbXCLqqZBcIiwgXCLqqZFcIiwgXCLqqZJcIiwgXCLqqZNcIiwgXCLqqZRcIiwgXCLqqZVcIiwgXCLqqZZcIiwgXCLqqZdcIiwgXCLqqZhcIiwgXCLqqZlcIl0sIFwiZGV2YVwiOiBbXCLgpaZcIiwgXCLgpadcIiwgXCLgpahcIiwgXCLgpalcIiwgXCLgpapcIiwgXCLgpatcIiwgXCLgpaxcIiwgXCLgpa1cIiwgXCLgpa5cIiwgXCLgpa9cIl0sIFwiZGlha1wiOiBbXCLwkaWQXCIsIFwi8JGlkVwiLCBcIvCRpZJcIiwgXCLwkaWTXCIsIFwi8JGllFwiLCBcIvCRpZVcIiwgXCLwkaWWXCIsIFwi8JGll1wiLCBcIvCRpZhcIiwgXCLwkaWZXCJdLCBcImZ1bGx3aWRlXCI6IFtcIu+8kFwiLCBcIu+8kVwiLCBcIu+8klwiLCBcIu+8k1wiLCBcIu+8lFwiLCBcIu+8lVwiLCBcIu+8llwiLCBcIu+8l1wiLCBcIu+8mFwiLCBcIu+8mVwiXSwgXCJnb25nXCI6IFtcIvCRtqBcIiwgXCLwkbahXCIsIFwi8JG2olwiLCBcIvCRtqNcIiwgXCLwkbakXCIsIFwi8JG2pVwiLCBcIvCRtqZcIiwgXCLwkbanXCIsIFwi8JG2qFwiLCBcIvCRtqlcIl0sIFwiZ29ubVwiOiBbXCLwkbWQXCIsIFwi8JG1kVwiLCBcIvCRtZJcIiwgXCLwkbWTXCIsIFwi8JG1lFwiLCBcIvCRtZVcIiwgXCLwkbWWXCIsIFwi8JG1l1wiLCBcIvCRtZhcIiwgXCLwkbWZXCJdLCBcImd1anJcIjogW1wi4KumXCIsIFwi4KunXCIsIFwi4KuoXCIsIFwi4KupXCIsIFwi4KuqXCIsIFwi4KurXCIsIFwi4KusXCIsIFwi4KutXCIsIFwi4KuuXCIsIFwi4KuvXCJdLCBcImd1cnVcIjogW1wi4KmmXCIsIFwi4KmnXCIsIFwi4KmoXCIsIFwi4KmpXCIsIFwi4KmqXCIsIFwi4KmrXCIsIFwi4KmsXCIsIFwi4KmtXCIsIFwi4KmuXCIsIFwi4KmvXCJdLCBcImhhbmlkZWNcIjogW1wi44CHXCIsIFwi5LiAXCIsIFwi5LqMXCIsIFwi5LiJXCIsIFwi5ZubXCIsIFwi5LqUXCIsIFwi5YWtXCIsIFwi5LiDXCIsIFwi5YWrXCIsIFwi5LmdXCJdLCBcImhtbmdcIjogW1wi8JatkFwiLCBcIvCWrZFcIiwgXCLwlq2SXCIsIFwi8Jatk1wiLCBcIvCWrZRcIiwgXCLwlq2VXCIsIFwi8JatllwiLCBcIvCWrZdcIiwgXCLwlq2YXCIsIFwi8JatmVwiXSwgXCJobW5wXCI6IFtcIvCehYBcIiwgXCLwnoWBXCIsIFwi8J6FglwiLCBcIvCehYNcIiwgXCLwnoWEXCIsIFwi8J6FhVwiLCBcIvCehYZcIiwgXCLwnoWHXCIsIFwi8J6FiFwiLCBcIvCehYlcIl0sIFwiamF2YVwiOiBbXCLqp5BcIiwgXCLqp5FcIiwgXCLqp5JcIiwgXCLqp5NcIiwgXCLqp5RcIiwgXCLqp5VcIiwgXCLqp5ZcIiwgXCLqp5dcIiwgXCLqp5hcIiwgXCLqp5lcIl0sIFwia2FsaVwiOiBbXCLqpIBcIiwgXCLqpIFcIiwgXCLqpIJcIiwgXCLqpINcIiwgXCLqpIRcIiwgXCLqpIVcIiwgXCLqpIZcIiwgXCLqpIdcIiwgXCLqpIhcIiwgXCLqpIlcIl0sIFwia2htclwiOiBbXCLhn6BcIiwgXCLhn6FcIiwgXCLhn6JcIiwgXCLhn6NcIiwgXCLhn6RcIiwgXCLhn6VcIiwgXCLhn6ZcIiwgXCLhn6dcIiwgXCLhn6hcIiwgXCLhn6lcIl0sIFwia25kYVwiOiBbXCLgs6ZcIiwgXCLgs6dcIiwgXCLgs6hcIiwgXCLgs6lcIiwgXCLgs6pcIiwgXCLgs6tcIiwgXCLgs6xcIiwgXCLgs61cIiwgXCLgs65cIiwgXCLgs69cIl0sIFwibGFuYVwiOiBbXCLhqoBcIiwgXCLhqoFcIiwgXCLhqoJcIiwgXCLhqoNcIiwgXCLhqoRcIiwgXCLhqoVcIiwgXCLhqoZcIiwgXCLhqodcIiwgXCLhqohcIiwgXCLhqolcIl0sIFwibGFuYXRoYW1cIjogW1wi4aqQXCIsIFwi4aqRXCIsIFwi4aqSXCIsIFwi4aqTXCIsIFwi4aqUXCIsIFwi4aqVXCIsIFwi4aqWXCIsIFwi4aqXXCIsIFwi4aqYXCIsIFwi4aqZXCJdLCBcImxhb29cIjogW1wi4LuQXCIsIFwi4LuRXCIsIFwi4LuSXCIsIFwi4LuTXCIsIFwi4LuUXCIsIFwi4LuVXCIsIFwi4LuWXCIsIFwi4LuXXCIsIFwi4LuYXCIsIFwi4LuZXCJdLCBcImxlcGNcIjogW1wi4aqQXCIsIFwi4aqRXCIsIFwi4aqSXCIsIFwi4aqTXCIsIFwi4aqUXCIsIFwi4aqVXCIsIFwi4aqWXCIsIFwi4aqXXCIsIFwi4aqYXCIsIFwi4aqZXCJdLCBcImxpbWJcIjogW1wi4aWGXCIsIFwi4aWHXCIsIFwi4aWIXCIsIFwi4aWJXCIsIFwi4aWKXCIsIFwi4aWLXCIsIFwi4aWMXCIsIFwi4aWNXCIsIFwi4aWOXCIsIFwi4aWPXCJdLCBcIm1hdGhib2xkXCI6IFtcIvCdn45cIiwgXCLwnZ+PXCIsIFwi8J2fkFwiLCBcIvCdn5FcIiwgXCLwnZ+SXCIsIFwi8J2fk1wiLCBcIvCdn5RcIiwgXCLwnZ+VXCIsIFwi8J2fllwiLCBcIvCdn5dcIl0sIFwibWF0aGRibFwiOiBbXCLwnZ+YXCIsIFwi8J2fmVwiLCBcIvCdn5pcIiwgXCLwnZ+bXCIsIFwi8J2fnFwiLCBcIvCdn51cIiwgXCLwnZ+eXCIsIFwi8J2fn1wiLCBcIvCdn6BcIiwgXCLwnZ+hXCJdLCBcIm1hdGhtb25vXCI6IFtcIvCdn7ZcIiwgXCLwnZ+3XCIsIFwi8J2fuFwiLCBcIvCdn7lcIiwgXCLwnZ+6XCIsIFwi8J2fu1wiLCBcIvCdn7xcIiwgXCLwnZ+9XCIsIFwi8J2fvlwiLCBcIvCdn79cIl0sIFwibWF0aHNhbmJcIjogW1wi8J2frFwiLCBcIvCdn61cIiwgXCLwnZ+uXCIsIFwi8J2fr1wiLCBcIvCdn7BcIiwgXCLwnZ+xXCIsIFwi8J2fslwiLCBcIvCdn7NcIiwgXCLwnZ+0XCIsIFwi8J2ftVwiXSwgXCJtYXRoc2Fuc1wiOiBbXCLwnZ+iXCIsIFwi8J2fo1wiLCBcIvCdn6RcIiwgXCLwnZ+lXCIsIFwi8J2fplwiLCBcIvCdn6dcIiwgXCLwnZ+oXCIsIFwi8J2fqVwiLCBcIvCdn6pcIiwgXCLwnZ+rXCJdLCBcIm1seW1cIjogW1wi4LWmXCIsIFwi4LWnXCIsIFwi4LWoXCIsIFwi4LWpXCIsIFwi4LWqXCIsIFwi4LWrXCIsIFwi4LWsXCIsIFwi4LWtXCIsIFwi4LWuXCIsIFwi4LWvXCJdLCBcIm1vZGlcIjogW1wi8JGZkFwiLCBcIvCRmZFcIiwgXCLwkZmSXCIsIFwi8JGZk1wiLCBcIvCRmZRcIiwgXCLwkZmVXCIsIFwi8JGZllwiLCBcIvCRmZdcIiwgXCLwkZmYXCIsIFwi8JGZmVwiXSwgXCJtb25nXCI6IFtcIuGgkFwiLCBcIuGgkVwiLCBcIuGgklwiLCBcIuGgk1wiLCBcIuGglFwiLCBcIuGglVwiLCBcIuGgllwiLCBcIuGgl1wiLCBcIuGgmFwiLCBcIuGgmVwiXSwgXCJtcm9vXCI6IFtcIvCWqaBcIiwgXCLwlqmhXCIsIFwi8JapolwiLCBcIvCWqaNcIiwgXCLwlqmkXCIsIFwi8JappVwiLCBcIvCWqaZcIiwgXCLwlqmnXCIsIFwi8JapqFwiLCBcIvCWqalcIl0sIFwibXRlaVwiOiBbXCLqr7BcIiwgXCLqr7FcIiwgXCLqr7JcIiwgXCLqr7NcIiwgXCLqr7RcIiwgXCLqr7VcIiwgXCLqr7ZcIiwgXCLqr7dcIiwgXCLqr7hcIiwgXCLqr7lcIl0sIFwibXltclwiOiBbXCLhgYBcIiwgXCLhgYFcIiwgXCLhgYJcIiwgXCLhgYNcIiwgXCLhgYRcIiwgXCLhgYVcIiwgXCLhgYZcIiwgXCLhgYdcIiwgXCLhgYhcIiwgXCLhgYlcIl0sIFwibXltcnNoYW5cIjogW1wi4YKQXCIsIFwi4YKRXCIsIFwi4YKSXCIsIFwi4YKTXCIsIFwi4YKUXCIsIFwi4YKVXCIsIFwi4YKWXCIsIFwi4YKXXCIsIFwi4YKYXCIsIFwi4YKZXCJdLCBcIm15bXJ0bG5nXCI6IFtcIuqnsFwiLCBcIuqnsVwiLCBcIuqnslwiLCBcIuqns1wiLCBcIuqntFwiLCBcIuqntVwiLCBcIuqntlwiLCBcIuqnt1wiLCBcIuqnuFwiLCBcIuqnuVwiXSwgXCJuZXdhXCI6IFtcIvCRkZBcIiwgXCLwkZGRXCIsIFwi8JGRklwiLCBcIvCRkZNcIiwgXCLwkZGUXCIsIFwi8JGRlVwiLCBcIvCRkZZcIiwgXCLwkZGXXCIsIFwi8JGRmFwiLCBcIvCRkZlcIl0sIFwibmtvb1wiOiBbXCLfgFwiLCBcIt+BXCIsIFwi34JcIiwgXCLfg1wiLCBcIt+EXCIsIFwi34VcIiwgXCLfhlwiLCBcIt+HXCIsIFwi34hcIiwgXCLfiVwiXSwgXCJvbGNrXCI6IFtcIuGxkFwiLCBcIuGxkVwiLCBcIuGxklwiLCBcIuGxk1wiLCBcIuGxlFwiLCBcIuGxlVwiLCBcIuGxllwiLCBcIuGxl1wiLCBcIuGxmFwiLCBcIuGxmVwiXSwgXCJvcnlhXCI6IFtcIuCtplwiLCBcIuCtp1wiLCBcIuCtqFwiLCBcIuCtqVwiLCBcIuCtqlwiLCBcIuCtq1wiLCBcIuCtrFwiLCBcIuCtrVwiLCBcIuCtrlwiLCBcIuCtr1wiXSwgXCJvc21hXCI6IFtcIvCQkqBcIiwgXCLwkJKhXCIsIFwi8JCSolwiLCBcIvCQkqNcIiwgXCLwkJKkXCIsIFwi8JCSpVwiLCBcIvCQkqZcIiwgXCLwkJKnXCIsIFwi8JCSqFwiLCBcIvCQkqlcIl0sIFwicm9oZ1wiOiBbXCLwkLSwXCIsIFwi8JC0sVwiLCBcIvCQtLJcIiwgXCLwkLSzXCIsIFwi8JC0tFwiLCBcIvCQtLVcIiwgXCLwkLS2XCIsIFwi8JC0t1wiLCBcIvCQtLhcIiwgXCLwkLS5XCJdLCBcInNhdXJcIjogW1wi6qOQXCIsIFwi6qORXCIsIFwi6qOSXCIsIFwi6qOTXCIsIFwi6qOUXCIsIFwi6qOVXCIsIFwi6qOWXCIsIFwi6qOXXCIsIFwi6qOYXCIsIFwi6qOZXCJdLCBcInNlZ21lbnRcIjogW1wi8J+vsFwiLCBcIvCfr7FcIiwgXCLwn6+yXCIsIFwi8J+vs1wiLCBcIvCfr7RcIiwgXCLwn6+1XCIsIFwi8J+vtlwiLCBcIvCfr7dcIiwgXCLwn6+4XCIsIFwi8J+vuVwiXSwgXCJzaHJkXCI6IFtcIvCRh5BcIiwgXCLwkYeRXCIsIFwi8JGHklwiLCBcIvCRh5NcIiwgXCLwkYeUXCIsIFwi8JGHlVwiLCBcIvCRh5ZcIiwgXCLwkYeXXCIsIFwi8JGHmFwiLCBcIvCRh5lcIl0sIFwic2luZFwiOiBbXCLwkYuwXCIsIFwi8JGLsVwiLCBcIvCRi7JcIiwgXCLwkYuzXCIsIFwi8JGLtFwiLCBcIvCRi7VcIiwgXCLwkYu2XCIsIFwi8JGLt1wiLCBcIvCRi7hcIiwgXCLwkYu5XCJdLCBcInNpbmhcIjogW1wi4LemXCIsIFwi4LenXCIsIFwi4LeoXCIsIFwi4LepXCIsIFwi4LeqXCIsIFwi4LerXCIsIFwi4LesXCIsIFwi4LetXCIsIFwi4LeuXCIsIFwi4LevXCJdLCBcInNvcmFcIjogW1wi8JGDsFwiLCBcIvCRg7FcIiwgXCLwkYOyXCIsIFwi8JGDs1wiLCBcIvCRg7RcIiwgXCLwkYO1XCIsIFwi8JGDtlwiLCBcIvCRg7dcIiwgXCLwkYO4XCIsIFwi8JGDuVwiXSwgXCJzdW5kXCI6IFtcIuGusFwiLCBcIuGusVwiLCBcIuGuslwiLCBcIuGus1wiLCBcIuGutFwiLCBcIuGutVwiLCBcIuGutlwiLCBcIuGut1wiLCBcIuGuuFwiLCBcIuGuuVwiXSwgXCJ0YWtyXCI6IFtcIvCRm4BcIiwgXCLwkZuBXCIsIFwi8JGbglwiLCBcIvCRm4NcIiwgXCLwkZuEXCIsIFwi8JGbhVwiLCBcIvCRm4ZcIiwgXCLwkZuHXCIsIFwi8JGbiFwiLCBcIvCRm4lcIl0sIFwidGFsdVwiOiBbXCLhp5BcIiwgXCLhp5FcIiwgXCLhp5JcIiwgXCLhp5NcIiwgXCLhp5RcIiwgXCLhp5VcIiwgXCLhp5ZcIiwgXCLhp5dcIiwgXCLhp5hcIiwgXCLhp5lcIl0sIFwidGFtbGRlY1wiOiBbXCLgr6ZcIiwgXCLgr6dcIiwgXCLgr6hcIiwgXCLgr6lcIiwgXCLgr6pcIiwgXCLgr6tcIiwgXCLgr6xcIiwgXCLgr61cIiwgXCLgr65cIiwgXCLgr69cIl0sIFwidGVsdVwiOiBbXCLgsaZcIiwgXCLgsadcIiwgXCLgsahcIiwgXCLgsalcIiwgXCLgsapcIiwgXCLgsatcIiwgXCLgsaxcIiwgXCLgsa1cIiwgXCLgsa5cIiwgXCLgsa9cIl0sIFwidGhhaVwiOiBbXCLguZBcIiwgXCLguZFcIiwgXCLguZJcIiwgXCLguZNcIiwgXCLguZRcIiwgXCLguZVcIiwgXCLguZZcIiwgXCLguZdcIiwgXCLguZhcIiwgXCLguZlcIl0sIFwidGlidFwiOiBbXCLgvKBcIiwgXCLgvKFcIiwgXCLgvKJcIiwgXCLgvKNcIiwgXCLgvKRcIiwgXCLgvKVcIiwgXCLgvKZcIiwgXCLgvKdcIiwgXCLgvKhcIiwgXCLgvKlcIl0sIFwidGlyaFwiOiBbXCLwkZOQXCIsIFwi8JGTkVwiLCBcIvCRk5JcIiwgXCLwkZOTXCIsIFwi8JGTlFwiLCBcIvCRk5VcIiwgXCLwkZOWXCIsIFwi8JGTl1wiLCBcIvCRk5hcIiwgXCLwkZOZXCJdLCBcInZhaWlcIjogW1wi4ZigXCIsIFwi4ZihXCIsIFwi4ZiiXCIsIFwi4ZijXCIsIFwi4ZikXCIsIFwi4ZilXCIsIFwi4ZimXCIsIFwi4ZinXCIsIFwi4ZioXCIsIFwi4ZipXCJdLCBcIndhcmFcIjogW1wi8JGjoFwiLCBcIvCRo6FcIiwgXCLwkaOiXCIsIFwi8JGjo1wiLCBcIvCRo6RcIiwgXCLwkaOlXCIsIFwi8JGjplwiLCBcIvCRo6dcIiwgXCLwkaOoXCIsIFwi8JGjqVwiXSwgXCJ3Y2hvXCI6IFtcIvCei7BcIiwgXCLwnouxXCIsIFwi8J6LslwiLCBcIvCei7NcIiwgXCLwnou0XCIsIFwi8J6LtVwiLCBcIvCei7ZcIiwgXCLwnou3XCIsIFwi8J6LuFwiLCBcIvCei7lcIl0gfVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBUb1Jhd0ZpeGVkXzEgPSByZXF1aXJlKFwiLi9Ub1Jhd0ZpeGVkXCIpO1xudmFyIGRpZ2l0TWFwcGluZyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2RpZ2l0LW1hcHBpbmcuanNvblwiKSk7XG4vLyBUaGlzIGlzIGZyb206IHVuaWNvZGUtMTIuMS4wL0dlbmVyYWxfQ2F0ZWdvcnkvU3ltYm9sL3JlZ2V4LmpzXG4vLyBJRTExIGRvZXMgbm90IHN1cHBvcnQgdW5pY29kZSBmbGFnLCBvdGhlcndpc2UgdGhpcyBpcyBqdXN0IC9cXHB7U30vdS5cbnZhciBTX1VOSUNPREVfUkVHRVggPSAvW1xcJFxcKzwtPlxcXmBcXHx+XFx4QTItXFx4QTZcXHhBOFxceEE5XFx4QUNcXHhBRS1cXHhCMVxceEI0XFx4QjhcXHhEN1xceEY3XFx1MDJDMi1cXHUwMkM1XFx1MDJEMi1cXHUwMkRGXFx1MDJFNS1cXHUwMkVCXFx1MDJFRFxcdTAyRUYtXFx1MDJGRlxcdTAzNzVcXHUwMzg0XFx1MDM4NVxcdTAzRjZcXHUwNDgyXFx1MDU4RC1cXHUwNThGXFx1MDYwNi1cXHUwNjA4XFx1MDYwQlxcdTA2MEVcXHUwNjBGXFx1MDZERVxcdTA2RTlcXHUwNkZEXFx1MDZGRVxcdTA3RjZcXHUwN0ZFXFx1MDdGRlxcdTA5RjJcXHUwOUYzXFx1MDlGQVxcdTA5RkJcXHUwQUYxXFx1MEI3MFxcdTBCRjMtXFx1MEJGQVxcdTBDN0ZcXHUwRDRGXFx1MEQ3OVxcdTBFM0ZcXHUwRjAxLVxcdTBGMDNcXHUwRjEzXFx1MEYxNS1cXHUwRjE3XFx1MEYxQS1cXHUwRjFGXFx1MEYzNFxcdTBGMzZcXHUwRjM4XFx1MEZCRS1cXHUwRkM1XFx1MEZDNy1cXHUwRkNDXFx1MEZDRVxcdTBGQ0ZcXHUwRkQ1LVxcdTBGRDhcXHUxMDlFXFx1MTA5RlxcdTEzOTAtXFx1MTM5OVxcdTE2NkRcXHUxN0RCXFx1MTk0MFxcdTE5REUtXFx1MTlGRlxcdTFCNjEtXFx1MUI2QVxcdTFCNzQtXFx1MUI3Q1xcdTFGQkRcXHUxRkJGLVxcdTFGQzFcXHUxRkNELVxcdTFGQ0ZcXHUxRkRELVxcdTFGREZcXHUxRkVELVxcdTFGRUZcXHUxRkZEXFx1MUZGRVxcdTIwNDRcXHUyMDUyXFx1MjA3QS1cXHUyMDdDXFx1MjA4QS1cXHUyMDhDXFx1MjBBMC1cXHUyMEJGXFx1MjEwMFxcdTIxMDFcXHUyMTAzLVxcdTIxMDZcXHUyMTA4XFx1MjEwOVxcdTIxMTRcXHUyMTE2LVxcdTIxMThcXHUyMTFFLVxcdTIxMjNcXHUyMTI1XFx1MjEyN1xcdTIxMjlcXHUyMTJFXFx1MjEzQVxcdTIxM0JcXHUyMTQwLVxcdTIxNDRcXHUyMTRBLVxcdTIxNERcXHUyMTRGXFx1MjE4QVxcdTIxOEJcXHUyMTkwLVxcdTIzMDdcXHUyMzBDLVxcdTIzMjhcXHUyMzJCLVxcdTI0MjZcXHUyNDQwLVxcdTI0NEFcXHUyNDlDLVxcdTI0RTlcXHUyNTAwLVxcdTI3NjdcXHUyNzk0LVxcdTI3QzRcXHUyN0M3LVxcdTI3RTVcXHUyN0YwLVxcdTI5ODJcXHUyOTk5LVxcdTI5RDdcXHUyOURDLVxcdTI5RkJcXHUyOUZFLVxcdTJCNzNcXHUyQjc2LVxcdTJCOTVcXHUyQjk4LVxcdTJCRkZcXHUyQ0U1LVxcdTJDRUFcXHUyRTgwLVxcdTJFOTlcXHUyRTlCLVxcdTJFRjNcXHUyRjAwLVxcdTJGRDVcXHUyRkYwLVxcdTJGRkJcXHUzMDA0XFx1MzAxMlxcdTMwMTNcXHUzMDIwXFx1MzAzNlxcdTMwMzdcXHUzMDNFXFx1MzAzRlxcdTMwOUJcXHUzMDlDXFx1MzE5MFxcdTMxOTFcXHUzMTk2LVxcdTMxOUZcXHUzMUMwLVxcdTMxRTNcXHUzMjAwLVxcdTMyMUVcXHUzMjJBLVxcdTMyNDdcXHUzMjUwXFx1MzI2MC1cXHUzMjdGXFx1MzI4QS1cXHUzMkIwXFx1MzJDMC1cXHUzM0ZGXFx1NERDMC1cXHU0REZGXFx1QTQ5MC1cXHVBNEM2XFx1QTcwMC1cXHVBNzE2XFx1QTcyMFxcdUE3MjFcXHVBNzg5XFx1QTc4QVxcdUE4MjgtXFx1QTgyQlxcdUE4MzYtXFx1QTgzOVxcdUFBNzctXFx1QUE3OVxcdUFCNUJcXHVGQjI5XFx1RkJCMi1cXHVGQkMxXFx1RkRGQ1xcdUZERkRcXHVGRTYyXFx1RkU2NC1cXHVGRTY2XFx1RkU2OVxcdUZGMDRcXHVGRjBCXFx1RkYxQy1cXHVGRjFFXFx1RkYzRVxcdUZGNDBcXHVGRjVDXFx1RkY1RVxcdUZGRTAtXFx1RkZFNlxcdUZGRTgtXFx1RkZFRVxcdUZGRkNcXHVGRkZEXXxcXHVEODAwW1xcdUREMzctXFx1REQzRlxcdURENzktXFx1REQ4OVxcdUREOEMtXFx1REQ4RVxcdUREOTAtXFx1REQ5QlxcdUREQTBcXHVEREQwLVxcdURERkNdfFxcdUQ4MDJbXFx1REM3N1xcdURDNzhcXHVERUM4XXxcXHVEODA1XFx1REYzRnxcXHVEODA3W1xcdURGRDUtXFx1REZGMV18XFx1RDgxQVtcXHVERjNDLVxcdURGM0ZcXHVERjQ1XXxcXHVEODJGXFx1REM5Q3xcXHVEODM0W1xcdURDMDAtXFx1RENGNVxcdUREMDAtXFx1REQyNlxcdUREMjktXFx1REQ2NFxcdURENkEtXFx1REQ2Q1xcdUREODNcXHVERDg0XFx1REQ4Qy1cXHVEREE5XFx1RERBRS1cXHVEREU4XFx1REUwMC1cXHVERTQxXFx1REU0NVxcdURGMDAtXFx1REY1Nl18XFx1RDgzNVtcXHVERUMxXFx1REVEQlxcdURFRkJcXHVERjE1XFx1REYzNVxcdURGNEZcXHVERjZGXFx1REY4OVxcdURGQTlcXHVERkMzXXxcXHVEODM2W1xcdURDMDAtXFx1RERGRlxcdURFMzctXFx1REUzQVxcdURFNkQtXFx1REU3NFxcdURFNzYtXFx1REU4M1xcdURFODVcXHVERTg2XXxcXHVEODM4W1xcdURENEZcXHVERUZGXXxcXHVEODNCW1xcdURDQUNcXHVEQ0IwXFx1REQyRVxcdURFRjBcXHVERUYxXXxcXHVEODNDW1xcdURDMDAtXFx1REMyQlxcdURDMzAtXFx1REM5M1xcdURDQTAtXFx1RENBRVxcdURDQjEtXFx1RENCRlxcdURDQzEtXFx1RENDRlxcdURDRDEtXFx1RENGNVxcdUREMTAtXFx1REQ2Q1xcdURENzAtXFx1RERBQ1xcdURERTYtXFx1REUwMlxcdURFMTAtXFx1REUzQlxcdURFNDAtXFx1REU0OFxcdURFNTBcXHVERTUxXFx1REU2MC1cXHVERTY1XFx1REYwMC1cXHVERkZGXXxcXHVEODNEW1xcdURDMDAtXFx1REVENVxcdURFRTAtXFx1REVFQ1xcdURFRjAtXFx1REVGQVxcdURGMDAtXFx1REY3M1xcdURGODAtXFx1REZEOFxcdURGRTAtXFx1REZFQl18XFx1RDgzRVtcXHVEQzAwLVxcdURDMEJcXHVEQzEwLVxcdURDNDdcXHVEQzUwLVxcdURDNTlcXHVEQzYwLVxcdURDODdcXHVEQzkwLVxcdURDQURcXHVERDAwLVxcdUREMEJcXHVERDBELVxcdURENzFcXHVERDczLVxcdURENzZcXHVERDdBLVxcdUREQTJcXHVEREE1LVxcdUREQUFcXHVEREFFLVxcdUREQ0FcXHVERENELVxcdURFNTNcXHVERTYwLVxcdURFNkRcXHVERTcwLVxcdURFNzNcXHVERTc4LVxcdURFN0FcXHVERTgwLVxcdURFODJcXHVERTkwLVxcdURFOTVdLztcbi8vIC9eXFxwe1N9L3VcbnZhciBDQVJFVF9TX1VOSUNPREVfUkVHRVggPSBuZXcgUmVnRXhwKFwiXlwiICsgU19VTklDT0RFX1JFR0VYLnNvdXJjZSk7XG4vLyAvXFxwe1N9JC91XG52YXIgU19ET0xMQVJfVU5JQ09ERV9SRUdFWCA9IG5ldyBSZWdFeHAoU19VTklDT0RFX1JFR0VYLnNvdXJjZSArIFwiJFwiKTtcbnZhciBDTERSX05VTUJFUl9QQVRURVJOID0gL1sjMF0oPzpbXFwuLF1bIzBdKykqL2c7XG5mdW5jdGlvbiBmb3JtYXRUb1BhcnRzKG51bWJlclJlc3VsdCwgZGF0YSwgcGwsIG9wdGlvbnMpIHtcbiAgICB2YXIgc2lnbiA9IG51bWJlclJlc3VsdC5zaWduLCBleHBvbmVudCA9IG51bWJlclJlc3VsdC5leHBvbmVudCwgbWFnbml0dWRlID0gbnVtYmVyUmVzdWx0Lm1hZ25pdHVkZTtcbiAgICB2YXIgbm90YXRpb24gPSBvcHRpb25zLm5vdGF0aW9uLCBzdHlsZSA9IG9wdGlvbnMuc3R5bGUsIG51bWJlcmluZ1N5c3RlbSA9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtO1xuICAgIHZhciBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtID0gZGF0YS5udW1iZXJzLm51WzBdO1xuICAgIC8vICNyZWdpb24gUGFydCAxOiBwYXJ0aXRpb24gYW5kIGludGVycG9sYXRlIHRoZSBDTERSIG51bWJlciBwYXR0ZXJuLlxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgY29tcGFjdE51bWJlclBhdHRlcm4gPSBudWxsO1xuICAgIGlmIChub3RhdGlvbiA9PT0gJ2NvbXBhY3QnICYmIG1hZ25pdHVkZSkge1xuICAgICAgICBjb21wYWN0TnVtYmVyUGF0dGVybiA9IGdldENvbXBhY3REaXNwbGF5UGF0dGVybihudW1iZXJSZXN1bHQsIHBsLCBkYXRhLCBzdHlsZSwgb3B0aW9ucy5jb21wYWN0RGlzcGxheSwgb3B0aW9ucy5jdXJyZW5jeURpc3BsYXksIG51bWJlcmluZ1N5c3RlbSk7XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgdXNlZCBtdWx0aXBsZSB0aW1lc1xuICAgIHZhciBub25OYW1lQ3VycmVuY3lQYXJ0O1xuICAgIGlmIChzdHlsZSA9PT0gJ2N1cnJlbmN5JyAmJiBvcHRpb25zLmN1cnJlbmN5RGlzcGxheSAhPT0gJ25hbWUnKSB7XG4gICAgICAgIHZhciBieUN1cnJlbmN5RGlzcGxheSA9IGRhdGEuY3VycmVuY2llc1tvcHRpb25zLmN1cnJlbmN5XTtcbiAgICAgICAgaWYgKGJ5Q3VycmVuY3lEaXNwbGF5KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wdGlvbnMuY3VycmVuY3lEaXNwbGF5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29kZSc6XG4gICAgICAgICAgICAgICAgICAgIG5vbk5hbWVDdXJyZW5jeVBhcnQgPSBvcHRpb25zLmN1cnJlbmN5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICAgICAgICAgICAgICBub25OYW1lQ3VycmVuY3lQYXJ0ID0gYnlDdXJyZW5jeURpc3BsYXkuc3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBub25OYW1lQ3VycmVuY3lQYXJ0ID0gYnlDdXJyZW5jeURpc3BsYXkubmFycm93O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIGZvciB1bmtub3duIGN1cnJlbmN5XG4gICAgICAgICAgICBub25OYW1lQ3VycmVuY3lQYXJ0ID0gb3B0aW9ucy5jdXJyZW5jeTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgbnVtYmVyUGF0dGVybjtcbiAgICBpZiAoIWNvbXBhY3ROdW1iZXJQYXR0ZXJuKSB7XG4gICAgICAgIC8vIE5vdGU6IGlmIHRoZSBzdHlsZSBpcyB1bml0LCBvciBpcyBjdXJyZW5jeSBhbmQgdGhlIGN1cnJlbmN5IGRpc3BsYXkgaXMgbmFtZSxcbiAgICAgICAgLy8gaXRzIHVuaXQgcGFydHMgd2lsbCBiZSBpbnRlcnBvbGF0ZWQgaW4gcGFydCAyLiBTbyBoZXJlIHdlIGNhbiBmYWxsYmFjayB0byBkZWNpbWFsLlxuICAgICAgICBpZiAoc3R5bGUgPT09ICdkZWNpbWFsJyB8fFxuICAgICAgICAgICAgc3R5bGUgPT09ICd1bml0JyB8fFxuICAgICAgICAgICAgKHN0eWxlID09PSAnY3VycmVuY3knICYmIG9wdGlvbnMuY3VycmVuY3lEaXNwbGF5ID09PSAnbmFtZScpKSB7XG4gICAgICAgICAgICAvLyBTaG9ydGN1dCBmb3IgZGVjaW1hbFxuICAgICAgICAgICAgdmFyIGRlY2ltYWxEYXRhID0gZGF0YS5udW1iZXJzLmRlY2ltYWxbbnVtYmVyaW5nU3lzdGVtXSB8fFxuICAgICAgICAgICAgICAgIGRhdGEubnVtYmVycy5kZWNpbWFsW2RlZmF1bHROdW1iZXJpbmdTeXN0ZW1dO1xuICAgICAgICAgICAgbnVtYmVyUGF0dGVybiA9IGdldFBhdHRlcm5Gb3JTaWduKGRlY2ltYWxEYXRhLnN0YW5kYXJkLCBzaWduKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHlsZSA9PT0gJ2N1cnJlbmN5Jykge1xuICAgICAgICAgICAgdmFyIGN1cnJlbmN5RGF0YSA9IGRhdGEubnVtYmVycy5jdXJyZW5jeVtudW1iZXJpbmdTeXN0ZW1dIHx8XG4gICAgICAgICAgICAgICAgZGF0YS5udW1iZXJzLmN1cnJlbmN5W2RlZmF1bHROdW1iZXJpbmdTeXN0ZW1dO1xuICAgICAgICAgICAgLy8gV2UgcmVwbGFjZSBudW1iZXIgcGF0dGVybiBwYXJ0IHdpdGggYDBgIGZvciBlYXNpZXIgcG9zdHByb2Nlc3NpbmcuXG4gICAgICAgICAgICBudW1iZXJQYXR0ZXJuID0gZ2V0UGF0dGVybkZvclNpZ24oY3VycmVuY3lEYXRhW29wdGlvbnMuY3VycmVuY3lTaWduXSwgc2lnbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBwZXJjZW50XG4gICAgICAgICAgICB2YXIgcGVyY2VudFBhdHRlcm4gPSBkYXRhLm51bWJlcnMucGVyY2VudFtudW1iZXJpbmdTeXN0ZW1dIHx8XG4gICAgICAgICAgICAgICAgZGF0YS5udW1iZXJzLnBlcmNlbnRbZGVmYXVsdE51bWJlcmluZ1N5c3RlbV07XG4gICAgICAgICAgICBudW1iZXJQYXR0ZXJuID0gZ2V0UGF0dGVybkZvclNpZ24ocGVyY2VudFBhdHRlcm4sIHNpZ24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBudW1iZXJQYXR0ZXJuID0gY29tcGFjdE51bWJlclBhdHRlcm47XG4gICAgfVxuICAgIC8vIEV4dHJhY3QgdGhlIGRlY2ltYWwgbnVtYmVyIHBhdHRlcm4gc3RyaW5nLiBJdCBsb29rcyBsaWtlIFwiIywjIzAsMDBcIiwgd2hpY2ggd2lsbCBsYXRlciBiZVxuICAgIC8vIHVzZWQgdG8gaW5mZXIgZGVjaW1hbCBncm91cCBzaXplcy5cbiAgICB2YXIgZGVjaW1hbE51bWJlclBhdHRlcm4gPSBDTERSX05VTUJFUl9QQVRURVJOLmV4ZWMobnVtYmVyUGF0dGVybilbMF07XG4gICAgLy8gTm93IHdlIHN0YXJ0IHRvIHN1YnN0aXR1dGUgcGF0dGVybnNcbiAgICAvLyAxLiByZXBsYWNlIHN0cmluZ3MgbGlrZSBgMGAgYW5kIGAjLCMjMC4wMGAgd2l0aCBgezB9YFxuICAgIC8vIDIuIHVucXVvdGUgY2hhcmFjdGVycyAoaW52YXJpYW50OiB0aGUgcXVvdGVkIGNoYXJhY3RlcnMgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lhbCB0b2tlbnMpXG4gICAgbnVtYmVyUGF0dGVybiA9IG51bWJlclBhdHRlcm5cbiAgICAgICAgLnJlcGxhY2UoQ0xEUl9OVU1CRVJfUEFUVEVSTiwgJ3swfScpXG4gICAgICAgIC5yZXBsYWNlKC8nKC4pJy9nLCAnJDEnKTtcbiAgICAvLyBIYW5kbGUgY3VycmVuY3kgc3BhY2luZyAoYm90aCBjb21wYWN0IGFuZCBub24tY29tcGFjdCkuXG4gICAgaWYgKHN0eWxlID09PSAnY3VycmVuY3knICYmIG9wdGlvbnMuY3VycmVuY3lEaXNwbGF5ICE9PSAnbmFtZScpIHtcbiAgICAgICAgdmFyIGN1cnJlbmN5RGF0YSA9IGRhdGEubnVtYmVycy5jdXJyZW5jeVtudW1iZXJpbmdTeXN0ZW1dIHx8XG4gICAgICAgICAgICBkYXRhLm51bWJlcnMuY3VycmVuY3lbZGVmYXVsdE51bWJlcmluZ1N5c3RlbV07XG4gICAgICAgIC8vIFNlZSBgY3VycmVuY3lTcGFjaW5nYCBzdWJzdGl0dXRpb24gcnVsZSBpbiBUUi0zNS5cbiAgICAgICAgLy8gSGVyZSB3ZSBhbHdheXMgYXNzdW1lIHRoZSBjdXJyZW5jeU1hdGNoIGlzIFwiWzpeUzpdXCIgYW5kIHN1cnJvdW5kaW5nTWF0Y2ggaXMgXCJbOmRpZ2l0Ol1cIi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRXhhbXBsZSAxOiBmb3IgcGF0dGVybiBcIiMsIyMwLjAwwqRcIiB3aXRoIHN5bWJvbCBcIlVTJFwiLCB3ZSByZXBsYWNlIFwiwqRcIiB3aXRoIHRoZSBzeW1ib2wsXG4gICAgICAgIC8vIGJ1dCBpbnNlcnQgYW4gZXh0cmEgbm9uLWJyZWFrIHNwYWNlIGJlZm9yZSB0aGUgc3ltYm9sLCBiZWNhdXNlIFwiWzpeUzpdXCIgbWF0Y2hlcyBcIlVcIiBpblxuICAgICAgICAvLyBcIlVTJFwiIGFuZCBcIls6ZGlnaXQ6XVwiIG1hdGNoZXMgdGhlIGxhdG4gbnVtYmVyaW5nIHN5c3RlbSBkaWdpdHMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEV4YW1wbGUgMjogZm9yIHBhdHRlcm4gXCLCpCMsIyMwLjAwXCIgd2l0aCBzeW1ib2wgXCJVUyRcIiwgdGhlcmUgaXMgbm8gc3BhY2luZyBiZXR3ZWVuIHN5bWJvbFxuICAgICAgICAvLyBhbmQgbnVtYmVyLCBiZWNhdXNlIGAkYCBkb2VzIG5vdCBtYXRjaCBcIls6XlM6XVwiLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJbXBsZW1lbnRhdGlvbiBub3RlOiBoZXJlIHdlIGRvIHRoZSBiZXN0IGVmZm9ydCB0byBpbmZlciB0aGUgaW5zZXJ0aW9uLlxuICAgICAgICAvLyBXZSBhbHNvIGFzc3VtZSB0aGF0IGBiZWZvcmVJbnNlcnRCZXR3ZWVuYCBhbmQgYGFmdGVySW5zZXJ0QmV0d2VlbmAgd2lsbCBuZXZlciBiZSBgO2AuXG4gICAgICAgIHZhciBhZnRlckN1cnJlbmN5ID0gY3VycmVuY3lEYXRhLmN1cnJlbmN5U3BhY2luZy5hZnRlckluc2VydEJldHdlZW47XG4gICAgICAgIGlmIChhZnRlckN1cnJlbmN5ICYmICFTX0RPTExBUl9VTklDT0RFX1JFR0VYLnRlc3Qobm9uTmFtZUN1cnJlbmN5UGFydCkpIHtcbiAgICAgICAgICAgIG51bWJlclBhdHRlcm4gPSBudW1iZXJQYXR0ZXJuLnJlcGxhY2UoJ8KkezB9JywgXCJcXHUwMEE0XCIgKyBhZnRlckN1cnJlbmN5ICsgXCJ7MH1cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJlZm9yZUN1cnJlbmN5ID0gY3VycmVuY3lEYXRhLmN1cnJlbmN5U3BhY2luZy5iZWZvcmVJbnNlcnRCZXR3ZWVuO1xuICAgICAgICBpZiAoYmVmb3JlQ3VycmVuY3kgJiYgIUNBUkVUX1NfVU5JQ09ERV9SRUdFWC50ZXN0KG5vbk5hbWVDdXJyZW5jeVBhcnQpKSB7XG4gICAgICAgICAgICBudW1iZXJQYXR0ZXJuID0gbnVtYmVyUGF0dGVybi5yZXBsYWNlKCd7MH3CpCcsIFwiezB9XCIgKyBiZWZvcmVDdXJyZW5jeSArIFwiXFx1MDBBNFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGUgZm9sbG93aW5nIHRva2VucyBhcmUgc3BlY2lhbDogYHswfWAsIGDCpGAsIGAlYCwgYC1gLCBgK2AsIGB7YzouLi59LlxuICAgIHZhciBudW1iZXJQYXR0ZXJuUGFydHMgPSBudW1iZXJQYXR0ZXJuLnNwbGl0KC8oe2M6W159XSt9fFxcezBcXH18W8KkJVxcLVxcK10pL2cpO1xuICAgIHZhciBudW1iZXJQYXJ0cyA9IFtdO1xuICAgIHZhciBzeW1ib2xzID0gZGF0YS5udW1iZXJzLnN5bWJvbHNbbnVtYmVyaW5nU3lzdGVtXSB8fFxuICAgICAgICBkYXRhLm51bWJlcnMuc3ltYm9sc1tkZWZhdWx0TnVtYmVyaW5nU3lzdGVtXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIG51bWJlclBhdHRlcm5QYXJ0c18xID0gbnVtYmVyUGF0dGVyblBhcnRzOyBfaSA8IG51bWJlclBhdHRlcm5QYXJ0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgcGFydCA9IG51bWJlclBhdHRlcm5QYXJ0c18xW19pXTtcbiAgICAgICAgaWYgKCFwYXJ0KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHBhcnQpIHtcbiAgICAgICAgICAgIGNhc2UgJ3swfSc6IHtcbiAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IG5lZWQgdG8gaGFuZGxlIHNjaWVudGlmaWMgYW5kIGVuZ2luZWVyaW5nIG5vdGF0aW9uIGhlcmUuXG4gICAgICAgICAgICAgICAgbnVtYmVyUGFydHMucHVzaC5hcHBseShudW1iZXJQYXJ0cywgcGFyaXRpb25OdW1iZXJJbnRvUGFydHMoc3ltYm9scywgbnVtYmVyUmVzdWx0LCBub3RhdGlvbiwgZXhwb25lbnQsIG51bWJlcmluZ1N5c3RlbSwgXG4gICAgICAgICAgICAgICAgLy8gSWYgY29tcGFjdCBudW1iZXIgcGF0dGVybiBleGlzdHMsIGRvIG5vdCBpbnNlcnQgZ3JvdXAgc2VwYXJhdG9ycy5cbiAgICAgICAgICAgICAgICAhY29tcGFjdE51bWJlclBhdHRlcm4gJiYgb3B0aW9ucy51c2VHcm91cGluZywgZGVjaW1hbE51bWJlclBhdHRlcm4pKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgIG51bWJlclBhcnRzLnB1c2goeyB0eXBlOiAnbWludXNTaWduJywgdmFsdWU6IHN5bWJvbHMubWludXNTaWduIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgbnVtYmVyUGFydHMucHVzaCh7IHR5cGU6ICdwbHVzU2lnbicsIHZhbHVlOiBzeW1ib2xzLnBsdXNTaWduIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgbnVtYmVyUGFydHMucHVzaCh7IHR5cGU6ICdwZXJjZW50U2lnbicsIHZhbHVlOiBzeW1ib2xzLnBlcmNlbnRTaWduIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnwqQnOlxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGVkIGFib3ZlIHdoZW4gaGFuZGxpbmcgY3VycmVuY3kgc3BhY2luZy5cbiAgICAgICAgICAgICAgICBudW1iZXJQYXJ0cy5wdXNoKHsgdHlwZTogJ2N1cnJlbmN5JywgdmFsdWU6IG5vbk5hbWVDdXJyZW5jeVBhcnQgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICgvXlxce2M6Ly50ZXN0KHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bWJlclBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbXBhY3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhcnQuc3Vic3RyaW5nKDMsIHBhcnQubGVuZ3RoIC0gMSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGl0ZXJhbFxuICAgICAgICAgICAgICAgICAgICBudW1iZXJQYXJ0cy5wdXNoKHsgdHlwZTogJ2xpdGVyYWwnLCB2YWx1ZTogcGFydCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gI2VuZHJlZ2lvblxuICAgIC8vICNyZWdpb24gUGFydCAyOiBpbnRlcnBvbGF0ZSB1bml0IHBhdHRlcm4gaWYgbmVjZXNzYXJ5LlxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICAgIGNhc2UgJ2N1cnJlbmN5Jzoge1xuICAgICAgICAgICAgLy8gYGN1cnJlbmN5RGlzcGxheTogJ25hbWUnYCBoYXMgc2ltaWxhciBwYXR0ZXJuIGhhbmRsaW5nIGFzIHVuaXRzLlxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY3VycmVuY3lEaXNwbGF5ID09PSAnbmFtZScpIHtcbiAgICAgICAgICAgICAgICB2YXIgdW5pdFBhdHRlcm4gPSAoZGF0YS5udW1iZXJzLmN1cnJlbmN5W251bWJlcmluZ1N5c3RlbV0gfHxcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5udW1iZXJzLmN1cnJlbmN5W2RlZmF1bHROdW1iZXJpbmdTeXN0ZW1dKS51bml0UGF0dGVybjtcbiAgICAgICAgICAgICAgICAvLyBTZWxlY3QgcGx1cmFsXG4gICAgICAgICAgICAgICAgdmFyIHVuaXROYW1lID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW5jeU5hbWVEYXRhID0gZGF0YS5jdXJyZW5jaWVzW29wdGlvbnMuY3VycmVuY3ldO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW5jeU5hbWVEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXROYW1lID0gc2VsZWN0UGx1cmFsKHBsLCBudW1iZXJSZXN1bHQucm91bmRlZE51bWJlciAqIE1hdGgucG93KDEwLCBleHBvbmVudCksIGN1cnJlbmN5TmFtZURhdGEuZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgZm9yIHVua25vd24gY3VycmVuY3lcbiAgICAgICAgICAgICAgICAgICAgdW5pdE5hbWUgPSBvcHRpb25zLmN1cnJlbmN5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBEbyB7MH0gYW5kIHsxfSBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgICAgICB2YXIgdW5pdFBhdHRlcm5QYXJ0cyA9IHVuaXRQYXR0ZXJuLnNwbGl0KC8oXFx7WzAxXVxcfSkvZyk7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgdW5pdFBhdHRlcm5QYXJ0c18xID0gdW5pdFBhdHRlcm5QYXJ0czsgX2EgPCB1bml0UGF0dGVyblBhcnRzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gdW5pdFBhdHRlcm5QYXJ0c18xW19hXTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd7MH0nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgbnVtYmVyUGFydHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnezF9JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IHR5cGU6ICdjdXJyZW5jeScsIHZhbHVlOiB1bml0TmFtZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyB0eXBlOiAnbGl0ZXJhbCcsIHZhbHVlOiBwYXJ0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlclBhcnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3VuaXQnOiB7XG4gICAgICAgICAgICB2YXIgdW5pdCA9IG9wdGlvbnMudW5pdCwgdW5pdERpc3BsYXkgPSBvcHRpb25zLnVuaXREaXNwbGF5O1xuICAgICAgICAgICAgdmFyIHVuaXREYXRhID0gZGF0YS51bml0cy5zaW1wbGVbdW5pdF07XG4gICAgICAgICAgICB2YXIgdW5pdFBhdHRlcm4gPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAodW5pdERhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgdW5pdCBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgdW5pdFBhdHRlcm4gPSBzZWxlY3RQbHVyYWwocGwsIG51bWJlclJlc3VsdC5yb3VuZGVkTnVtYmVyICogTWF0aC5wb3coMTAsIGV4cG9uZW50KSwgZGF0YS51bml0cy5zaW1wbGVbdW5pdF1bdW5pdERpc3BsYXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNlZTogaHR0cDovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWdlbmVyYWwuaHRtbCNwZXJVbml0UGF0dGVybnNcbiAgICAgICAgICAgICAgICAvLyBJZiBjYW5ub3QgZmluZCB1bml0IGluIHRoZSBzaW1wbGUgcGF0dGVybiwgaXQgbXVzdCBiZSBcInBlclwiIGNvbXBvdW5kIHBhdHRlcm4uXG4gICAgICAgICAgICAgICAgLy8gSW1wbGVtZW50YXRpb24gbm90ZTogd2UgYXJlIG5vdCBmb2xsb3dpbmcgVFItMzUgaGVyZSBiZWNhdXNlIHdlIG5lZWQgdG8gZm9ybWF0IHRvIHBhcnRzIVxuICAgICAgICAgICAgICAgIHZhciBfYiA9IHVuaXQuc3BsaXQoJy1wZXItJyksIG51bWVyYXRvclVuaXQgPSBfYlswXSwgZGVub21pbmF0b3JVbml0ID0gX2JbMV07XG4gICAgICAgICAgICAgICAgdW5pdERhdGEgPSBkYXRhLnVuaXRzLnNpbXBsZVtudW1lcmF0b3JVbml0XTtcbiAgICAgICAgICAgICAgICB2YXIgbnVtZXJhdG9yVW5pdFBhdHRlcm4gPSBzZWxlY3RQbHVyYWwocGwsIG51bWJlclJlc3VsdC5yb3VuZGVkTnVtYmVyICogTWF0aC5wb3coMTAsIGV4cG9uZW50KSwgZGF0YS51bml0cy5zaW1wbGVbbnVtZXJhdG9yVW5pdF1bdW5pdERpc3BsYXldKTtcbiAgICAgICAgICAgICAgICB2YXIgcGVyVW5pdFBhdHRlcm4gPSBkYXRhLnVuaXRzLnNpbXBsZVtkZW5vbWluYXRvclVuaXRdLnBlclVuaXRbdW5pdERpc3BsYXldO1xuICAgICAgICAgICAgICAgIGlmIChwZXJVbml0UGF0dGVybikge1xuICAgICAgICAgICAgICAgICAgICAvLyBwZXJVbml0UGF0dGVybiBleGlzdHMsIGNvbWJpbmUgaXQgd2l0aCBudW1lcmF0b3JVbml0UGF0dGVyblxuICAgICAgICAgICAgICAgICAgICB1bml0UGF0dGVybiA9IHBlclVuaXRQYXR0ZXJuLnJlcGxhY2UoJ3swfScsIG51bWVyYXRvclVuaXRQYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCBjb21wb3VuZFVuaXQgcGF0dGVybiAoZS5nLiBcInswfSBwZXIgezF9XCIpLCByZXBhbGNlIHswfSB3aXRoIG51bWVyYXRvciBwYXR0ZXJuIGFuZCB7MX0gd2l0aFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZGVub21pbmF0b3IgcGF0dGVybiBpbiBzaW5ndWxhciBmb3JtLlxuICAgICAgICAgICAgICAgICAgICB2YXIgcGVyUGF0dGVybiA9IGRhdGEudW5pdHMuY29tcG91bmQucGVyW3VuaXREaXNwbGF5XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbm9taW5hdG9yUGF0dGVybiA9IHNlbGVjdFBsdXJhbChwbCwgMSwgZGF0YS51bml0cy5zaW1wbGVbZGVub21pbmF0b3JVbml0XVt1bml0RGlzcGxheV0pO1xuICAgICAgICAgICAgICAgICAgICB1bml0UGF0dGVybiA9IHVuaXRQYXR0ZXJuID0gcGVyUGF0dGVyblxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3swfScsIG51bWVyYXRvclVuaXRQYXR0ZXJuKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3sxfScsIGRlbm9taW5hdG9yUGF0dGVybi5yZXBsYWNlKCd7MH0nLCAnJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgc3BhY2luZyBhcm91bmQgXCJ7MH1cIiBiZWNhdXNlIHRoZXkgYXJlIG5vdCB0cmVhdGVkIGFzIFwidW5pdFwiIHBhcnRzLCBidXQgXCJsaXRlcmFsXCIuXG4gICAgICAgICAgICBmb3IgKHZhciBfYyA9IDAsIF9kID0gdW5pdFBhdHRlcm4uc3BsaXQoLyhcXHMqXFx7MFxcfVxccyopLyk7IF9jIDwgX2QubGVuZ3RoOyBfYysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBfZFtfY107XG4gICAgICAgICAgICAgICAgdmFyIGludGVycG9sYXRlTWF0Y2ggPSAvXihcXHMqKVxcezBcXH0oXFxzKikkLy5leGVjKHBhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcnBvbGF0ZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNwYWNlIGJlZm9yZSBcInswfVwiXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcnBvbGF0ZU1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IHR5cGU6ICdsaXRlcmFsJywgdmFsdWU6IGludGVycG9sYXRlTWF0Y2hbMV0gfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gXCJ7MH1cIiBpdHNlbGZcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBudW1iZXJQYXJ0cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNwYWNlIGFmdGVyIFwiezB9XCJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVycG9sYXRlTWF0Y2hbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgdHlwZTogJ2xpdGVyYWwnLCB2YWx1ZTogaW50ZXJwb2xhdGVNYXRjaFsyXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgdHlwZTogJ3VuaXQnLCB2YWx1ZTogcGFydCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyUGFydHM7XG4gICAgfVxuICAgIC8vICNlbmRyZWdpb25cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGZvcm1hdFRvUGFydHM7XG4vLyBBIHN1YnNldCBvZiBodHRwczovL3RjMzkuZXMvZWNtYTQwMi8jc2VjLXBhcnRpdGlvbm5vdGF0aW9uc3VicGF0dGVyblxuLy8gUGx1cyB0aGUgZXhwb25lbnQgcGFydHMgaGFuZGxpbmcuXG5mdW5jdGlvbiBwYXJpdGlvbk51bWJlckludG9QYXJ0cyhzeW1ib2xzLCBudW1iZXJSZXN1bHQsIG5vdGF0aW9uLCBleHBvbmVudCwgbnVtYmVyaW5nU3lzdGVtLCB1c2VHcm91cGluZywgXG4vKipcbiAqIFRoaXMgaXMgdGhlIGRlY2ltYWwgbnVtYmVyIHBhdHRlcm4gd2l0aG91dCBzaWducyBvciBzeW1ib2xzLlxuICogSXQgaXMgdXNlZCB0byBpbmZlciB0aGUgZ3JvdXAgc2l6ZSB3aGVuIGB1c2VHcm91cGluZ2AgaXMgdHJ1ZS5cbiAqXG4gKiBBIHR5cGljYWwgdmFsdWUgbG9va3MgbGlrZSBcIiMsIyMwLjAwXCIgKHByaW1hcnkgZ3JvdXAgc2l6ZSBpcyAzKS5cbiAqIFNvbWUgbG9jYWxlcyBsaWtlIEhpbmRpIGhhcyBzZWNvbmRhcnkgZ3JvdXAgc2l6ZSBvZiAyIChlLmcuIFwiIywjIywjIzAuMDBcIikuXG4gKi9cbmRlY2ltYWxOdW1iZXJQYXR0ZXJuKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICB2YXIgbiA9IG51bWJlclJlc3VsdC5mb3JtYXR0ZWRTdHJpbmcsIHggPSBudW1iZXJSZXN1bHQucm91bmRlZE51bWJlcjtcbiAgICBpZiAoaXNOYU4oeCkpIHtcbiAgICAgICAgcmV0dXJuIFt7IHR5cGU6ICduYW4nLCB2YWx1ZTogbiB9XTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzRmluaXRlKHgpKSB7XG4gICAgICAgIHJldHVybiBbeyB0eXBlOiAnaW5maW5pdHknLCB2YWx1ZTogbiB9XTtcbiAgICB9XG4gICAgdmFyIGRpZ2l0UmVwbGFjZW1lbnRUYWJsZSA9IGRpZ2l0TWFwcGluZ1tudW1iZXJpbmdTeXN0ZW1dO1xuICAgIGlmIChkaWdpdFJlcGxhY2VtZW50VGFibGUpIHtcbiAgICAgICAgbiA9IG4ucmVwbGFjZSgvXFxkL2csIGZ1bmN0aW9uIChkaWdpdCkgeyByZXR1cm4gZGlnaXRSZXBsYWNlbWVudFRhYmxlWytkaWdpdF0gfHwgZGlnaXQ7IH0pO1xuICAgIH1cbiAgICAvLyBUT0RPOiBFbHNlIHVzZSBhbiBpbXBsZW1lbnRhdGlvbiBkZXBlbmRlbnQgYWxnb3JpdGhtIHRvIG1hcCBuIHRvIHRoZSBhcHByb3ByaWF0ZVxuICAgIC8vIHJlcHJlc2VudGF0aW9uIG9mIG4gaW4gdGhlIGdpdmVuIG51bWJlcmluZyBzeXN0ZW0uXG4gICAgdmFyIGRlY2ltYWxTZXBJbmRleCA9IG4uaW5kZXhPZignLicpO1xuICAgIHZhciBpbnRlZ2VyO1xuICAgIHZhciBmcmFjdGlvbjtcbiAgICBpZiAoZGVjaW1hbFNlcEluZGV4ID4gMCkge1xuICAgICAgICBpbnRlZ2VyID0gbi5zbGljZSgwLCBkZWNpbWFsU2VwSW5kZXgpO1xuICAgICAgICBmcmFjdGlvbiA9IG4uc2xpY2UoZGVjaW1hbFNlcEluZGV4ICsgMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpbnRlZ2VyID0gbjtcbiAgICB9XG4gICAgLy8gI3JlZ2lvbiBHcm91cGluZyBpbnRlZ2VyIGRpZ2l0c1xuICAgIC8vIFRoZSB3ZWlyZCBjb21wYWN0IGFuZCB4ID49IDEwMDAwIGNoZWNrIGlzIHRvIGVuc3VyZSBjb25zaXN0ZW5jeSB3aXRoIE5vZGUuanMgYW5kIENocm9tZS5cbiAgICAvLyBOb3RlIHRoYXQgYGRlYCBkb2VzIG5vdCBoYXZlIGNvbXBhY3QgZm9ybSBmb3IgdGhvdXNhbmRzLCBidXQgTm9kZS5qcyBkb2VzIG5vdCBpbnNlcnQgZ3JvdXBpbmcgc2VwYXJhdG9yXG4gICAgLy8gdW5sZXNzIHRoZSByb3VuZGVkIG51bWJlciBpcyBncmVhdGVyIHRoYW4gMTAwMDA6XG4gICAgLy8gICBOdW1iZXJGb3JtYXQoJ2RlJywge25vdGF0aW9uOiAnY29tcGFjdCcsIGNvbXBhY3REaXNwbGF5OiAnc2hvcnQnfSkuZm9ybWF0KDEyMzQpIC8vPT4gXCIxMjM0XCJcbiAgICAvLyAgIE51bWJlckZvcm1hdCgnZGUnKS5mb3JtYXQoMTIzNCkgLy89PiBcIjEuMjM0XCJcbiAgICBpZiAodXNlR3JvdXBpbmcgJiYgKG5vdGF0aW9uICE9PSAnY29tcGFjdCcgfHwgeCA+PSAxMDAwMCkpIHtcbiAgICAgICAgdmFyIGdyb3VwU2VwU3ltYm9sID0gc3ltYm9scy5ncm91cDtcbiAgICAgICAgdmFyIGdyb3VwcyA9IFtdO1xuICAgICAgICAvLyA+IFRoZXJlIG1heSBiZSB0d28gZGlmZmVyZW50IGdyb3VwaW5nIHNpemVzOiBUaGUgcHJpbWFyeSBncm91cGluZyBzaXplIHVzZWQgZm9yIHRoZSBsZWFzdFxuICAgICAgICAvLyA+IHNpZ25pZmljYW50IGludGVnZXIgZ3JvdXAsIGFuZCB0aGUgc2Vjb25kYXJ5IGdyb3VwaW5nIHNpemUgdXNlZCBmb3IgbW9yZSBzaWduaWZpY2FudCBncm91cHMuXG4gICAgICAgIC8vID4gSWYgYSBwYXR0ZXJuIGNvbnRhaW5zIG11bHRpcGxlIGdyb3VwaW5nIHNlcGFyYXRvcnMsIHRoZSBpbnRlcnZhbCBiZXR3ZWVuIHRoZSBsYXN0IG9uZSBhbmQgdGhlXG4gICAgICAgIC8vID4gZW5kIG9mIHRoZSBpbnRlZ2VyIGRlZmluZXMgdGhlIHByaW1hcnkgZ3JvdXBpbmcgc2l6ZSwgYW5kIHRoZSBpbnRlcnZhbCBiZXR3ZWVuIHRoZSBsYXN0IHR3b1xuICAgICAgICAvLyA+IGRlZmluZXMgdGhlIHNlY29uZGFyeSBncm91cGluZyBzaXplLiBBbGwgb3RoZXJzIGFyZSBpZ25vcmVkLlxuICAgICAgICB2YXIgaW50ZWdlck51bWJlclBhdHRlcm4gPSBkZWNpbWFsTnVtYmVyUGF0dGVybi5zcGxpdCgnLicpWzBdO1xuICAgICAgICB2YXIgcGF0dGVybkdyb3VwcyA9IGludGVnZXJOdW1iZXJQYXR0ZXJuLnNwbGl0KCcsJyk7XG4gICAgICAgIHZhciBwcmltYXJ5R3JvdXBpbmdTaXplID0gMztcbiAgICAgICAgdmFyIHNlY29uZGFyeUdyb3VwaW5nU2l6ZSA9IDM7XG4gICAgICAgIGlmIChwYXR0ZXJuR3JvdXBzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHByaW1hcnlHcm91cGluZ1NpemUgPSBwYXR0ZXJuR3JvdXBzW3BhdHRlcm5Hcm91cHMubGVuZ3RoIC0gMV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXR0ZXJuR3JvdXBzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHNlY29uZGFyeUdyb3VwaW5nU2l6ZSA9IHBhdHRlcm5Hcm91cHNbcGF0dGVybkdyb3Vwcy5sZW5ndGggLSAyXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSBpbnRlZ2VyLmxlbmd0aCAtIHByaW1hcnlHcm91cGluZ1NpemU7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgLy8gU2xpY2UgdGhlIGxlYXN0IHNpZ25pZmljYW50IGludGVnZXIgZ3JvdXBcbiAgICAgICAgICAgIGdyb3Vwcy5wdXNoKGludGVnZXIuc2xpY2UoaSwgaSArIHByaW1hcnlHcm91cGluZ1NpemUpKTtcbiAgICAgICAgICAgIC8vIFRoZW4gaXRlcmF0aXZlbHkgcHVzaCB0aGUgbW9yZSBzaWduaWNhbnQgZ3JvdXBzXG4gICAgICAgICAgICAvLyBUT0RPOiBoYW5kbGUgc3Vycm9nYXRlIHBhaXJzIGluIHNvbWUgbnVtYmVyaW5nIHN5c3RlbSBkaWdpdHNcbiAgICAgICAgICAgIGZvciAoaSAtPSBzZWNvbmRhcnlHcm91cGluZ1NpemU7IGkgPiAwOyBpIC09IHNlY29uZGFyeUdyb3VwaW5nU2l6ZSkge1xuICAgICAgICAgICAgICAgIGdyb3Vwcy5wdXNoKGludGVnZXIuc2xpY2UoaSwgaSArIHNlY29uZGFyeUdyb3VwaW5nU2l6ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JvdXBzLnB1c2goaW50ZWdlci5zbGljZSgwLCBpICsgc2Vjb25kYXJ5R3JvdXBpbmdTaXplKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBncm91cHMucHVzaChpbnRlZ2VyKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoZ3JvdXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBpbnRlZ2VyR3JvdXAgPSBncm91cHMucG9wKCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IHR5cGU6ICdpbnRlZ2VyJywgdmFsdWU6IGludGVnZXJHcm91cCB9KTtcbiAgICAgICAgICAgIGlmIChncm91cHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgdHlwZTogJ2dyb3VwJywgdmFsdWU6IGdyb3VwU2VwU3ltYm9sIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaCh7IHR5cGU6ICdpbnRlZ2VyJywgdmFsdWU6IGludGVnZXIgfSk7XG4gICAgfVxuICAgIC8vICNlbmRyZWdpb25cbiAgICBpZiAoZnJhY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQucHVzaCh7IHR5cGU6ICdkZWNpbWFsJywgdmFsdWU6IHN5bWJvbHMuZGVjaW1hbCB9LCB7IHR5cGU6ICdmcmFjdGlvbicsIHZhbHVlOiBmcmFjdGlvbiB9KTtcbiAgICB9XG4gICAgaWYgKChub3RhdGlvbiA9PT0gJ3NjaWVudGlmaWMnIHx8IG5vdGF0aW9uID09PSAnZW5naW5lZXJpbmcnKSAmJlxuICAgICAgICBpc0Zpbml0ZSh4KSkge1xuICAgICAgICByZXN1bHQucHVzaCh7IHR5cGU6ICdleHBvbmVudFNlcGFyYXRvcicsIHZhbHVlOiBzeW1ib2xzLmV4cG9uZW50aWFsIH0pO1xuICAgICAgICBpZiAoZXhwb25lbnQgPCAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IHR5cGU6ICdleHBvbmVudE1pbnVzU2lnbicsIHZhbHVlOiBzeW1ib2xzLm1pbnVzU2lnbiB9KTtcbiAgICAgICAgICAgIGV4cG9uZW50ID0gLWV4cG9uZW50O1xuICAgICAgICB9XG4gICAgICAgIHZhciBleHBvbmVudFJlc3VsdCA9IFRvUmF3Rml4ZWRfMS5Ub1Jhd0ZpeGVkKGV4cG9uZW50LCAwLCAwKTtcbiAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2V4cG9uZW50SW50ZWdlcicsXG4gICAgICAgICAgICB2YWx1ZTogZXhwb25lbnRSZXN1bHQuZm9ybWF0dGVkU3RyaW5nLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldFBhdHRlcm5Gb3JTaWduKHBhdHRlcm4sIHNpZ24pIHtcbiAgICBpZiAocGF0dGVybi5pbmRleE9mKCc7JykgPCAwKSB7XG4gICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuICsgXCI7LVwiICsgcGF0dGVybjtcbiAgICB9XG4gICAgdmFyIF9hID0gcGF0dGVybi5zcGxpdCgnOycpLCB6ZXJvUGF0dGVybiA9IF9hWzBdLCBuZWdhdGl2ZVBhdHRlcm4gPSBfYVsxXTtcbiAgICBzd2l0Y2ggKHNpZ24pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIHplcm9QYXR0ZXJuO1xuICAgICAgICBjYXNlIC0xOlxuICAgICAgICAgICAgcmV0dXJuIG5lZ2F0aXZlUGF0dGVybjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBuZWdhdGl2ZVBhdHRlcm4uaW5kZXhPZignLScpID49IDBcbiAgICAgICAgICAgICAgICA/IG5lZ2F0aXZlUGF0dGVybi5yZXBsYWNlKC8tL2csICcrJylcbiAgICAgICAgICAgICAgICA6IFwiK1wiICsgemVyb1BhdHRlcm47XG4gICAgfVxufVxuLy8gRmluZCB0aGUgQ0xEUiBwYXR0ZXJuIGZvciBjb21wYWN0IG5vdGF0aW9uIGJhc2VkIG9uIHRoZSBtYWduaXR1ZGUgb2YgZGF0YSBhbmQgc3R5bGUuXG4vL1xuLy8gRXhhbXBsZSByZXR1cm4gdmFsdWU6IFwiwqTCoHtjOmxha2l9MDAwO8Kke2M6bGFraX3CoC0wXCIgKGBzd2AgbG9jYWxlKTpcbi8vIC0gTm90aWNlIHRoZSBge2M6Li4ufWAgdG9rZW4gdGhhdCB3cmFwcyB0aGUgY29tcGFjdCBsaXRlcmFsLlxuLy8gLSBUaGUgY29uc2VjdXRpdmUgemVyb3MgYXJlIG5vcm1hbGl6ZWQgdG8gc2luZ2xlIHplcm8gdG8gbWF0Y2ggQ0xEUl9OVU1CRVJfUEFUVEVSTi5cbi8vXG4vLyBSZXR1cm5pbmcgbnVsbCBtZWFucyB0aGUgY29tcGFjdCBkaXNwbGF5IHBhdHRlcm4gY2Fubm90IGJlIGZvdW5kLlxuZnVuY3Rpb24gZ2V0Q29tcGFjdERpc3BsYXlQYXR0ZXJuKG51bWJlclJlc3VsdCwgcGwsIGRhdGEsIHN0eWxlLCBjb21wYWN0RGlzcGxheSwgY3VycmVuY3lEaXNwbGF5LCBudW1iZXJpbmdTeXN0ZW0pIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIHJvdW5kZWROdW1iZXIgPSBudW1iZXJSZXN1bHQucm91bmRlZE51bWJlciwgc2lnbiA9IG51bWJlclJlc3VsdC5zaWduLCBtYWduaXR1ZGUgPSBudW1iZXJSZXN1bHQubWFnbml0dWRlO1xuICAgIHZhciBtYWduaXR1ZGVLZXkgPSBTdHJpbmcoTWF0aC5wb3coMTAsIG1hZ25pdHVkZSkpO1xuICAgIHZhciBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtID0gZGF0YS5udW1iZXJzLm51WzBdO1xuICAgIHZhciBwYXR0ZXJuO1xuICAgIGlmIChzdHlsZSA9PT0gJ2N1cnJlbmN5JyAmJiBjdXJyZW5jeURpc3BsYXkgIT09ICduYW1lJykge1xuICAgICAgICB2YXIgYnlOdW1iZXJpbmdTeXN0ZW0gPSBkYXRhLm51bWJlcnMuY3VycmVuY3k7XG4gICAgICAgIHZhciBjdXJyZW5jeURhdGEgPSBieU51bWJlcmluZ1N5c3RlbVtudW1iZXJpbmdTeXN0ZW1dIHx8XG4gICAgICAgICAgICBieU51bWJlcmluZ1N5c3RlbVtkZWZhdWx0TnVtYmVyaW5nU3lzdGVtXTtcbiAgICAgICAgLy8gTk9URTogY29tcGFjdCBub3RhdGlvbiBpZ25vcmVzIGN1cnJlbmN5U2lnbiFcbiAgICAgICAgdmFyIGNvbXBhY3RQbHVyYWxSdWxlcyA9IChfYSA9IGN1cnJlbmN5RGF0YS5zaG9ydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW21hZ25pdHVkZUtleV07XG4gICAgICAgIGlmICghY29tcGFjdFBsdXJhbFJ1bGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwYXR0ZXJuID0gc2VsZWN0UGx1cmFsKHBsLCByb3VuZGVkTnVtYmVyLCBjb21wYWN0UGx1cmFsUnVsZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGJ5TnVtYmVyaW5nU3lzdGVtID0gZGF0YS5udW1iZXJzLmRlY2ltYWw7XG4gICAgICAgIHZhciBieUNvbXBhY3REaXNwbGF5ID0gYnlOdW1iZXJpbmdTeXN0ZW1bbnVtYmVyaW5nU3lzdGVtXSB8fFxuICAgICAgICAgICAgYnlOdW1iZXJpbmdTeXN0ZW1bZGVmYXVsdE51bWJlcmluZ1N5c3RlbV07XG4gICAgICAgIHZhciBjb21wYWN0UGxhcmFsUnVsZSA9IGJ5Q29tcGFjdERpc3BsYXlbY29tcGFjdERpc3BsYXldW21hZ25pdHVkZUtleV07XG4gICAgICAgIGlmICghY29tcGFjdFBsYXJhbFJ1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHBhdHRlcm4gPSBzZWxlY3RQbHVyYWwocGwsIHJvdW5kZWROdW1iZXIsIGNvbXBhY3RQbGFyYWxSdWxlKTtcbiAgICB9XG4gICAgLy8gU2VlIGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtbnVtYmVycy5odG1sI0NvbXBhY3RfTnVtYmVyX0Zvcm1hdHNcbiAgICAvLyA+IElmIHRoZSB2YWx1ZSBpcyBwcmVjaXNlbHkg4oCcMOKAnSwgZWl0aGVyIGV4cGxpY2l0IG9yIGRlZmF1bHRlZCwgdGhlbiB0aGUgbm9ybWFsIG51bWJlciBmb3JtYXRcbiAgICAvLyA+IHBhdHRlcm4gZm9yIHRoYXQgc29ydCBvZiBvYmplY3QgaXMgc3VwcGxpZWQuXG4gICAgaWYgKHBhdHRlcm4gPT09ICcwJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcGF0dGVybiA9IGdldFBhdHRlcm5Gb3JTaWduKHBhdHRlcm4sIHNpZ24pXG4gICAgICAgIC8vIEV4dHJhY3QgY29tcGFjdCBsaXRlcmFsIGZyb20gdGhlIHBhdHRlcm5cbiAgICAgICAgLnJlcGxhY2UoLyhbXlxccztcXC1cXCtcXGTCpF0rKS9nLCAne2M6JDF9JylcbiAgICAgICAgLy8gV2UgcmVwbGFjZSBvbmUgb3IgbW9yZSB6ZXJvcyB3aXRoIGEgc2luZ2xlIHplcm8gc28gaXQgbWF0Y2hlcyBgQ0xEUl9OVU1CRVJfUEFUVEVSTmAuXG4gICAgICAgIC5yZXBsYWNlKC8wKy8sICcwJyk7XG4gICAgcmV0dXJuIHBhdHRlcm47XG59XG5mdW5jdGlvbiBzZWxlY3RQbHVyYWwocGwsIHgsIHJ1bGVzKSB7XG4gICAgcmV0dXJuIHJ1bGVzW3BsLnNlbGVjdCh4KV0gfHwgcnVsZXMub3RoZXI7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFydGl0aW9uUGF0dGVybiA9IHZvaWQgMDtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIGh0dHBzOi8vdGMzOS5lcy9lY21hNDAyLyNzZWMtcGFydGl0aW9ucGF0dGVyblxuICogQHBhcmFtIHBhdHRlcm5cbiAqL1xuZnVuY3Rpb24gUGFydGl0aW9uUGF0dGVybihwYXR0ZXJuKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBiZWdpbkluZGV4ID0gcGF0dGVybi5pbmRleE9mKCd7Jyk7XG4gICAgdmFyIGVuZEluZGV4ID0gMDtcbiAgICB2YXIgbmV4dEluZGV4ID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gcGF0dGVybi5sZW5ndGg7XG4gICAgd2hpbGUgKGJlZ2luSW5kZXggPCBwYXR0ZXJuLmxlbmd0aCAmJiBiZWdpbkluZGV4ID4gLTEpIHtcbiAgICAgICAgZW5kSW5kZXggPSBwYXR0ZXJuLmluZGV4T2YoJ30nLCBiZWdpbkluZGV4KTtcbiAgICAgICAgdXRpbHNfMS5pbnZhcmlhbnQoZW5kSW5kZXggPiBiZWdpbkluZGV4LCBcIkludmFsaWQgcGF0dGVybiBcIiArIHBhdHRlcm4pO1xuICAgICAgICBpZiAoYmVnaW5JbmRleCA+IG5leHRJbmRleCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsaXRlcmFsJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGF0dGVybi5zdWJzdHJpbmcobmV4dEluZGV4LCBiZWdpbkluZGV4KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IHBhdHRlcm4uc3Vic3RyaW5nKGJlZ2luSW5kZXggKyAxLCBlbmRJbmRleCksXG4gICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgICAgbmV4dEluZGV4ID0gZW5kSW5kZXggKyAxO1xuICAgICAgICBiZWdpbkluZGV4ID0gcGF0dGVybi5pbmRleE9mKCd7JywgbmV4dEluZGV4KTtcbiAgICB9XG4gICAgaWYgKG5leHRJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgICAgICB2YWx1ZTogcGF0dGVybi5zdWJzdHJpbmcobmV4dEluZGV4LCBsZW5ndGgpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuUGFydGl0aW9uUGF0dGVybiA9IFBhcnRpdGlvblBhdHRlcm47XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR2V0T3BlcmFuZHMgPSB2b2lkIDA7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBfMjYyXzEgPSByZXF1aXJlKFwiLi4vMjYyXCIpO1xuLyoqXG4gKiBodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTQwMi83LjAvaW5kZXguaHRtbCNzZWMtZ2V0b3BlcmFuZHNcbiAqIEBwYXJhbSBzXG4gKi9cbmZ1bmN0aW9uIEdldE9wZXJhbmRzKHMpIHtcbiAgICB1dGlsc18xLmludmFyaWFudCh0eXBlb2YgcyA9PT0gJ3N0cmluZycsIFwiR2V0T3BlcmFuZHMgc2hvdWxkIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCBhIHN0cmluZ1wiKTtcbiAgICB2YXIgbiA9IF8yNjJfMS5Ub051bWJlcihzKTtcbiAgICB1dGlsc18xLmludmFyaWFudChpc0Zpbml0ZShuKSwgJ24gc2hvdWxkIGJlIGZpbml0ZScpO1xuICAgIHZhciBkcCA9IHMuaW5kZXhPZignLicpO1xuICAgIHZhciBpdjtcbiAgICB2YXIgZjtcbiAgICB2YXIgdjtcbiAgICB2YXIgZnYgPSAnJztcbiAgICBpZiAoZHAgPT09IC0xKSB7XG4gICAgICAgIGl2ID0gbjtcbiAgICAgICAgZiA9IDA7XG4gICAgICAgIHYgPSAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaXYgPSBzLnNsaWNlKDAsIGRwKTtcbiAgICAgICAgZnYgPSBzLnNsaWNlKGRwLCBzLmxlbmd0aCk7XG4gICAgICAgIGYgPSBfMjYyXzEuVG9OdW1iZXIoZnYpO1xuICAgICAgICB2ID0gZnYubGVuZ3RoO1xuICAgIH1cbiAgICB2YXIgaSA9IE1hdGguYWJzKF8yNjJfMS5Ub051bWJlcihpdikpO1xuICAgIHZhciB3O1xuICAgIHZhciB0O1xuICAgIGlmIChmICE9PSAwKSB7XG4gICAgICAgIHZhciBmdCA9IGZ2LnJlcGxhY2UoLzArJC8sICcnKTtcbiAgICAgICAgdyA9IGZ0Lmxlbmd0aDtcbiAgICAgICAgdCA9IF8yNjJfMS5Ub051bWJlcihmdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3ID0gMDtcbiAgICAgICAgdCA9IDA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIE51bWJlcjogbixcbiAgICAgICAgSW50ZWdlckRpZ2l0czogaSxcbiAgICAgICAgTnVtYmVyT2ZGcmFjdGlvbkRpZ2l0czogdixcbiAgICAgICAgTnVtYmVyT2ZGcmFjdGlvbkRpZ2l0c1dpdGhvdXRUcmFpbGluZzogdyxcbiAgICAgICAgRnJhY3Rpb25EaWdpdHM6IGYsXG4gICAgICAgIEZyYWN0aW9uRGlnaXRzV2l0aG91dFRyYWlsaW5nOiB0LFxuICAgIH07XG59XG5leHBvcnRzLkdldE9wZXJhbmRzID0gR2V0T3BlcmFuZHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW5pdGlhbGl6ZVBsdXJhbFJ1bGVzID0gdm9pZCAwO1xudmFyIENhbm9uaWNhbGl6ZUxvY2FsZUxpc3RfMSA9IHJlcXVpcmUoXCIuLi9DYW5vbmljYWxpemVMb2NhbGVMaXN0XCIpO1xudmFyIF8yNjJfMSA9IHJlcXVpcmUoXCIuLi8yNjJcIik7XG52YXIgR2V0T3B0aW9uXzEgPSByZXF1aXJlKFwiLi4vR2V0T3B0aW9uXCIpO1xudmFyIFNldE51bWJlckZvcm1hdERpZ2l0T3B0aW9uc18xID0gcmVxdWlyZShcIi4uL051bWJlckZvcm1hdC9TZXROdW1iZXJGb3JtYXREaWdpdE9wdGlvbnNcIik7XG52YXIgUmVzb2x2ZUxvY2FsZV8xID0gcmVxdWlyZShcIi4uL1Jlc29sdmVMb2NhbGVcIik7XG5mdW5jdGlvbiBJbml0aWFsaXplUGx1cmFsUnVsZXMocGwsIGxvY2FsZXMsIG9wdGlvbnMsIF9hKSB7XG4gICAgdmFyIGF2YWlsYWJsZUxvY2FsZXMgPSBfYS5hdmFpbGFibGVMb2NhbGVzLCByZWxldmFudEV4dGVuc2lvbktleXMgPSBfYS5yZWxldmFudEV4dGVuc2lvbktleXMsIGxvY2FsZURhdGEgPSBfYS5sb2NhbGVEYXRhLCBnZXREZWZhdWx0TG9jYWxlID0gX2EuZ2V0RGVmYXVsdExvY2FsZSwgZ2V0SW50ZXJuYWxTbG90cyA9IF9hLmdldEludGVybmFsU2xvdHM7XG4gICAgdmFyIHJlcXVlc3RlZExvY2FsZXMgPSBDYW5vbmljYWxpemVMb2NhbGVMaXN0XzEuQ2Fub25pY2FsaXplTG9jYWxlTGlzdChsb2NhbGVzKTtcbiAgICB2YXIgb3B0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgb3B0cyA9IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBfMjYyXzEuVG9PYmplY3Qob3B0aW9ucyk7XG4gICAgdmFyIGludGVybmFsU2xvdHMgPSBnZXRJbnRlcm5hbFNsb3RzKHBsKTtcbiAgICBpbnRlcm5hbFNsb3RzLmluaXRpYWxpemVkUGx1cmFsUnVsZXMgPSB0cnVlO1xuICAgIHZhciBtYXRjaGVyID0gR2V0T3B0aW9uXzEuR2V0T3B0aW9uKG9wdHMsICdsb2NhbGVNYXRjaGVyJywgJ3N0cmluZycsIFsnYmVzdCBmaXQnLCAnbG9va3VwJ10sICdiZXN0IGZpdCcpO1xuICAgIG9wdC5sb2NhbGVNYXRjaGVyID0gbWF0Y2hlcjtcbiAgICBpbnRlcm5hbFNsb3RzLnR5cGUgPSBHZXRPcHRpb25fMS5HZXRPcHRpb24ob3B0cywgJ3R5cGUnLCAnc3RyaW5nJywgWydjYXJkaW5hbCcsICdvcmRpbmFsJ10sICdjYXJkaW5hbCcpO1xuICAgIFNldE51bWJlckZvcm1hdERpZ2l0T3B0aW9uc18xLlNldE51bWJlckZvcm1hdERpZ2l0T3B0aW9ucyhpbnRlcm5hbFNsb3RzLCBvcHRzLCAwLCAzLCAnc3RhbmRhcmQnKTtcbiAgICB2YXIgciA9IFJlc29sdmVMb2NhbGVfMS5SZXNvbHZlTG9jYWxlKGF2YWlsYWJsZUxvY2FsZXMsIHJlcXVlc3RlZExvY2FsZXMsIG9wdCwgcmVsZXZhbnRFeHRlbnNpb25LZXlzLCBsb2NhbGVEYXRhLCBnZXREZWZhdWx0TG9jYWxlKTtcbiAgICBpbnRlcm5hbFNsb3RzLmxvY2FsZSA9IHIubG9jYWxlO1xuICAgIHJldHVybiBwbDtcbn1cbmV4cG9ydHMuSW5pdGlhbGl6ZVBsdXJhbFJ1bGVzID0gSW5pdGlhbGl6ZVBsdXJhbFJ1bGVzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlc29sdmVQbHVyYWwgPSB2b2lkIDA7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBfMjYyXzEgPSByZXF1aXJlKFwiLi4vMjYyXCIpO1xudmFyIEZvcm1hdE51bWVyaWNUb1N0cmluZ18xID0gcmVxdWlyZShcIi4uL051bWJlckZvcm1hdC9Gb3JtYXROdW1lcmljVG9TdHJpbmdcIik7XG52YXIgR2V0T3BlcmFuZHNfMSA9IHJlcXVpcmUoXCIuL0dldE9wZXJhbmRzXCIpO1xuLyoqXG4gKiBodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTQwMi83LjAvaW5kZXguaHRtbCNzZWMtcmVzb2x2ZXBsdXJhbFxuICogQHBhcmFtIHBsXG4gKiBAcGFyYW0gblxuICogQHBhcmFtIFBsdXJhbFJ1bGVTZWxlY3QgSGFzIHRvIHBhc3MgaW4gYmMgaXQncyBpbXBsZW1lbnRhdGlvbi1zcGVjaWZpY1xuICovXG5mdW5jdGlvbiBSZXNvbHZlUGx1cmFsKHBsLCBuLCBfYSkge1xuICAgIHZhciBnZXRJbnRlcm5hbFNsb3RzID0gX2EuZ2V0SW50ZXJuYWxTbG90cywgUGx1cmFsUnVsZVNlbGVjdCA9IF9hLlBsdXJhbFJ1bGVTZWxlY3Q7XG4gICAgdmFyIGludGVybmFsU2xvdHMgPSBnZXRJbnRlcm5hbFNsb3RzKHBsKTtcbiAgICB1dGlsc18xLmludmFyaWFudChfMjYyXzEuVHlwZShpbnRlcm5hbFNsb3RzKSA9PT0gJ09iamVjdCcsICdwbCBoYXMgdG8gYmUgYW4gb2JqZWN0Jyk7XG4gICAgdXRpbHNfMS5pbnZhcmlhbnQoJ2luaXRpYWxpemVkUGx1cmFsUnVsZXMnIGluIGludGVybmFsU2xvdHMsICdwbHVyYWxydWxlcyBtdXN0IGJlIGluaXRpYWxpemVkJyk7XG4gICAgdXRpbHNfMS5pbnZhcmlhbnQoXzI2Ml8xLlR5cGUobikgPT09ICdOdW1iZXInLCAnbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKCFpc0Zpbml0ZShuKSkge1xuICAgICAgICByZXR1cm4gJ290aGVyJztcbiAgICB9XG4gICAgdmFyIGxvY2FsZSA9IGludGVybmFsU2xvdHMubG9jYWxlLCB0eXBlID0gaW50ZXJuYWxTbG90cy50eXBlO1xuICAgIHZhciByZXMgPSBGb3JtYXROdW1lcmljVG9TdHJpbmdfMS5Gb3JtYXROdW1lcmljVG9TdHJpbmcoaW50ZXJuYWxTbG90cywgbik7XG4gICAgdmFyIHMgPSByZXMuZm9ybWF0dGVkU3RyaW5nO1xuICAgIHZhciBvcGVyYW5kcyA9IEdldE9wZXJhbmRzXzEuR2V0T3BlcmFuZHMocyk7XG4gICAgcmV0dXJuIFBsdXJhbFJ1bGVTZWxlY3QobG9jYWxlLCB0eXBlLCBuLCBvcGVyYW5kcyk7XG59XG5leHBvcnRzLlJlc29sdmVQbHVyYWwgPSBSZXNvbHZlUGx1cmFsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZvcm1hdFJlbGF0aXZlVGltZSA9IHZvaWQgMDtcbnZhciBQYXJ0aXRpb25SZWxhdGl2ZVRpbWVQYXR0ZXJuXzEgPSByZXF1aXJlKFwiLi9QYXJ0aXRpb25SZWxhdGl2ZVRpbWVQYXR0ZXJuXCIpO1xuZnVuY3Rpb24gRm9ybWF0UmVsYXRpdmVUaW1lKHJ0ZiwgdmFsdWUsIHVuaXQsIGltcGxEZXRhaWxzKSB7XG4gICAgdmFyIHBhcnRzID0gUGFydGl0aW9uUmVsYXRpdmVUaW1lUGF0dGVybl8xLlBhcnRpdGlvblJlbGF0aXZlVGltZVBhdHRlcm4ocnRmLCB2YWx1ZSwgdW5pdCwgaW1wbERldGFpbHMpO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICBmb3IgKHZhciBfaSA9IDAsIHBhcnRzXzEgPSBwYXJ0czsgX2kgPCBwYXJ0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgcGFydCA9IHBhcnRzXzFbX2ldO1xuICAgICAgICByZXN1bHQgKz0gcGFydC52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuRm9ybWF0UmVsYXRpdmVUaW1lID0gRm9ybWF0UmVsYXRpdmVUaW1lO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZvcm1hdFJlbGF0aXZlVGltZVRvUGFydHMgPSB2b2lkIDA7XG52YXIgUGFydGl0aW9uUmVsYXRpdmVUaW1lUGF0dGVybl8xID0gcmVxdWlyZShcIi4vUGFydGl0aW9uUmVsYXRpdmVUaW1lUGF0dGVyblwiKTtcbnZhciBfMjYyXzEgPSByZXF1aXJlKFwiLi4vMjYyXCIpO1xuZnVuY3Rpb24gRm9ybWF0UmVsYXRpdmVUaW1lVG9QYXJ0cyhydGYsIHZhbHVlLCB1bml0LCBpbXBsRGV0YWlscykge1xuICAgIHZhciBwYXJ0cyA9IFBhcnRpdGlvblJlbGF0aXZlVGltZVBhdHRlcm5fMS5QYXJ0aXRpb25SZWxhdGl2ZVRpbWVQYXR0ZXJuKHJ0ZiwgdmFsdWUsIHVuaXQsIGltcGxEZXRhaWxzKTtcbiAgICB2YXIgcmVzdWx0ID0gXzI2Ml8xLkFycmF5Q3JlYXRlKDApO1xuICAgIGZvciAodmFyIF9pID0gMCwgcGFydHNfMSA9IHBhcnRzOyBfaSA8IHBhcnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcGFydHNfMVtfaV07XG4gICAgICAgIHZhciBvID0ge1xuICAgICAgICAgICAgdHlwZTogcGFydC50eXBlLFxuICAgICAgICAgICAgdmFsdWU6IHBhcnQudmFsdWUsXG4gICAgICAgIH07XG4gICAgICAgIGlmICgndW5pdCcgaW4gcGFydCkge1xuICAgICAgICAgICAgby51bml0ID0gcGFydC51bml0O1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKG8pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5Gb3JtYXRSZWxhdGl2ZVRpbWVUb1BhcnRzID0gRm9ybWF0UmVsYXRpdmVUaW1lVG9QYXJ0cztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jbml0aWFsaXplUmVsYXRpdmVUaW1lRm9ybWF0ID0gdm9pZCAwO1xudmFyIENhbm9uaWNhbGl6ZUxvY2FsZUxpc3RfMSA9IHJlcXVpcmUoXCIuLi9DYW5vbmljYWxpemVMb2NhbGVMaXN0XCIpO1xudmFyIF8yNjJfMSA9IHJlcXVpcmUoXCIuLi8yNjJcIik7XG52YXIgR2V0T3B0aW9uXzEgPSByZXF1aXJlKFwiLi4vR2V0T3B0aW9uXCIpO1xudmFyIFJlc29sdmVMb2NhbGVfMSA9IHJlcXVpcmUoXCIuLi9SZXNvbHZlTG9jYWxlXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgTlVNQkVSSU5HX1NZU1RFTV9SRUdFWCA9IC9eW2EtejAtOV17Myw4fSgtW2EtejAtOV17Myw4fSkqJC9pO1xuZnVuY3Rpb24gSW5pdGlhbGl6ZVJlbGF0aXZlVGltZUZvcm1hdChydGYsIGxvY2FsZXMsIG9wdGlvbnMsIF9hKSB7XG4gICAgdmFyIGdldEludGVybmFsU2xvdHMgPSBfYS5nZXRJbnRlcm5hbFNsb3RzLCBhdmFpbGFibGVMb2NhbGVzID0gX2EuYXZhaWxhYmxlTG9jYWxlcywgcmVsZXZhbnRFeHRlbnNpb25LZXlzID0gX2EucmVsZXZhbnRFeHRlbnNpb25LZXlzLCBsb2NhbGVEYXRhID0gX2EubG9jYWxlRGF0YSwgZ2V0RGVmYXVsdExvY2FsZSA9IF9hLmdldERlZmF1bHRMb2NhbGU7XG4gICAgdmFyIGludGVybmFsU2xvdHMgPSBnZXRJbnRlcm5hbFNsb3RzKHJ0Zik7XG4gICAgaW50ZXJuYWxTbG90cy5pbml0aWFsaXplZFJlbGF0aXZlVGltZUZvcm1hdCA9IHRydWU7XG4gICAgdmFyIHJlcXVlc3RlZExvY2FsZXMgPSBDYW5vbmljYWxpemVMb2NhbGVMaXN0XzEuQ2Fub25pY2FsaXplTG9jYWxlTGlzdChsb2NhbGVzKTtcbiAgICB2YXIgb3B0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgb3B0cyA9IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBfMjYyXzEuVG9PYmplY3Qob3B0aW9ucyk7XG4gICAgdmFyIG1hdGNoZXIgPSBHZXRPcHRpb25fMS5HZXRPcHRpb24ob3B0cywgJ2xvY2FsZU1hdGNoZXInLCAnc3RyaW5nJywgWydiZXN0IGZpdCcsICdsb29rdXAnXSwgJ2Jlc3QgZml0Jyk7XG4gICAgb3B0LmxvY2FsZU1hdGNoZXIgPSBtYXRjaGVyO1xuICAgIHZhciBudW1iZXJpbmdTeXN0ZW0gPSBHZXRPcHRpb25fMS5HZXRPcHRpb24ob3B0cywgJ251bWJlcmluZ1N5c3RlbScsICdzdHJpbmcnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgaWYgKG51bWJlcmluZ1N5c3RlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghTlVNQkVSSU5HX1NZU1RFTV9SRUdFWC50ZXN0KG51bWJlcmluZ1N5c3RlbSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXJpbmcgc3lzdGVtIFwiICsgbnVtYmVyaW5nU3lzdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvcHQubnUgPSBudW1iZXJpbmdTeXN0ZW07XG4gICAgdmFyIHIgPSBSZXNvbHZlTG9jYWxlXzEuUmVzb2x2ZUxvY2FsZShhdmFpbGFibGVMb2NhbGVzLCByZXF1ZXN0ZWRMb2NhbGVzLCBvcHQsIHJlbGV2YW50RXh0ZW5zaW9uS2V5cywgbG9jYWxlRGF0YSwgZ2V0RGVmYXVsdExvY2FsZSk7XG4gICAgdmFyIGxvY2FsZSA9IHIubG9jYWxlLCBudSA9IHIubnU7XG4gICAgaW50ZXJuYWxTbG90cy5sb2NhbGUgPSBsb2NhbGU7XG4gICAgaW50ZXJuYWxTbG90cy5zdHlsZSA9IEdldE9wdGlvbl8xLkdldE9wdGlvbihvcHRzLCAnc3R5bGUnLCAnc3RyaW5nJywgWydsb25nJywgJ25hcnJvdycsICdzaG9ydCddLCAnbG9uZycpO1xuICAgIGludGVybmFsU2xvdHMubnVtZXJpYyA9IEdldE9wdGlvbl8xLkdldE9wdGlvbihvcHRzLCAnbnVtZXJpYycsICdzdHJpbmcnLCBbJ2Fsd2F5cycsICdhdXRvJ10sICdhbHdheXMnKTtcbiAgICB2YXIgZmllbGRzID0gbG9jYWxlRGF0YVtyLmRhdGFMb2NhbGVdO1xuICAgIHV0aWxzXzEuaW52YXJpYW50KCEhZmllbGRzLCBcIk1pc3NpbmcgbG9jYWxlIGRhdGEgZm9yIFwiICsgci5kYXRhTG9jYWxlKTtcbiAgICBpbnRlcm5hbFNsb3RzLmZpZWxkcyA9IGZpZWxkcztcbiAgICBpbnRlcm5hbFNsb3RzLm51bWJlckZvcm1hdCA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGVzKTtcbiAgICBpbnRlcm5hbFNsb3RzLnBsdXJhbFJ1bGVzID0gbmV3IEludGwuUGx1cmFsUnVsZXMobG9jYWxlcyk7XG4gICAgaW50ZXJuYWxTbG90cy5udW1iZXJpbmdTeXN0ZW0gPSBudTtcbiAgICByZXR1cm4gcnRmO1xufVxuZXhwb3J0cy5Jbml0aWFsaXplUmVsYXRpdmVUaW1lRm9ybWF0ID0gSW5pdGlhbGl6ZVJlbGF0aXZlVGltZUZvcm1hdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWtlUGFydHNMaXN0ID0gdm9pZCAwO1xudmFyIFBhcnRpdGlvblBhdHRlcm5fMSA9IHJlcXVpcmUoXCIuLi9QYXJ0aXRpb25QYXR0ZXJuXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5mdW5jdGlvbiBNYWtlUGFydHNMaXN0KHBhdHRlcm4sIHVuaXQsIHBhcnRzKSB7XG4gICAgdmFyIHBhdHRlcm5QYXJ0cyA9IFBhcnRpdGlvblBhdHRlcm5fMS5QYXJ0aXRpb25QYXR0ZXJuKHBhdHRlcm4pO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHBhdHRlcm5QYXJ0c18xID0gcGF0dGVyblBhcnRzOyBfaSA8IHBhdHRlcm5QYXJ0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgcGF0dGVyblBhcnQgPSBwYXR0ZXJuUGFydHNfMVtfaV07XG4gICAgICAgIGlmIChwYXR0ZXJuUGFydC50eXBlID09PSAnbGl0ZXJhbCcpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHBhdHRlcm5QYXJ0LnZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1dGlsc18xLmludmFyaWFudChwYXR0ZXJuUGFydC50eXBlID09PSAnMCcsIFwiTWFsZm9ybWVkIHBhdHRlcm4gXCIgKyBwYXR0ZXJuKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgcGFydHNfMSA9IHBhcnRzOyBfYSA8IHBhcnRzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c18xW19hXTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHBhcnQudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhcnQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuTWFrZVBhcnRzTGlzdCA9IE1ha2VQYXJ0c0xpc3Q7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFydGl0aW9uUmVsYXRpdmVUaW1lUGF0dGVybiA9IHZvaWQgMDtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIFNpbmd1bGFyUmVsYXRpdmVUaW1lVW5pdF8xID0gcmVxdWlyZShcIi4vU2luZ3VsYXJSZWxhdGl2ZVRpbWVVbml0XCIpO1xudmFyIE1ha2VQYXJ0c0xpc3RfMSA9IHJlcXVpcmUoXCIuL01ha2VQYXJ0c0xpc3RcIik7XG52YXIgXzI2Ml8xID0gcmVxdWlyZShcIi4uLzI2MlwiKTtcbmZ1bmN0aW9uIFBhcnRpdGlvblJlbGF0aXZlVGltZVBhdHRlcm4ocnRmLCB2YWx1ZSwgdW5pdCwgX2EpIHtcbiAgICB2YXIgZ2V0SW50ZXJuYWxTbG90cyA9IF9hLmdldEludGVybmFsU2xvdHM7XG4gICAgdXRpbHNfMS5pbnZhcmlhbnQoXzI2Ml8xLlR5cGUodmFsdWUpID09PSAnTnVtYmVyJywgXCJ2YWx1ZSBtdXN0IGJlIG51bWJlciwgaW5zdGVhZCBnb3QgXCIgKyB0eXBlb2YgdmFsdWUsIFR5cGVFcnJvcik7XG4gICAgdXRpbHNfMS5pbnZhcmlhbnQoXzI2Ml8xLlR5cGUodW5pdCkgPT09ICdTdHJpbmcnLCBcInVuaXQgbXVzdCBiZSBudW1iZXIsIGluc3RlYWQgZ290IFwiICsgdHlwZW9mIHZhbHVlLCBUeXBlRXJyb3IpO1xuICAgIGlmIChpc05hTih2YWx1ZSkgfHwgIWlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdmFsdWUgXCIgKyB2YWx1ZSk7XG4gICAgfVxuICAgIHZhciByZXNvbHZlZFVuaXQgPSBTaW5ndWxhclJlbGF0aXZlVGltZVVuaXRfMS5TaW5ndWxhclJlbGF0aXZlVGltZVVuaXQodW5pdCk7XG4gICAgdmFyIF9iID0gZ2V0SW50ZXJuYWxTbG90cyhydGYpLCBmaWVsZHMgPSBfYi5maWVsZHMsIHN0eWxlID0gX2Iuc3R5bGUsIG51bWVyaWMgPSBfYi5udW1lcmljLCBwbHVyYWxSdWxlcyA9IF9iLnBsdXJhbFJ1bGVzLCBudW1iZXJGb3JtYXQgPSBfYi5udW1iZXJGb3JtYXQ7XG4gICAgdmFyIGVudHJ5ID0gcmVzb2x2ZWRVbml0O1xuICAgIGlmIChzdHlsZSA9PT0gJ3Nob3J0Jykge1xuICAgICAgICBlbnRyeSA9IHJlc29sdmVkVW5pdCArIFwiLXNob3J0XCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0eWxlID09PSAnbmFycm93Jykge1xuICAgICAgICBlbnRyeSA9IHJlc29sdmVkVW5pdCArIFwiLW5hcnJvd1wiO1xuICAgIH1cbiAgICBpZiAoIShlbnRyeSBpbiBmaWVsZHMpKSB7XG4gICAgICAgIGVudHJ5ID0gcmVzb2x2ZWRVbml0O1xuICAgIH1cbiAgICB2YXIgcGF0dGVybnMgPSBmaWVsZHNbZW50cnldO1xuICAgIGlmIChudW1lcmljID09PSAnYXV0bycpIHtcbiAgICAgICAgaWYgKF8yNjJfMS5Ub1N0cmluZyh2YWx1ZSkgaW4gcGF0dGVybnMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXR0ZXJuc1tfMjYyXzEuVG9TdHJpbmcodmFsdWUpXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgdGwgPSAnZnV0dXJlJztcbiAgICBpZiAoXzI2Ml8xLlNhbWVWYWx1ZSh2YWx1ZSwgLTApIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICB0bCA9ICdwYXN0JztcbiAgICB9XG4gICAgdmFyIHBvID0gcGF0dGVybnNbdGxdO1xuICAgIHZhciBmdiA9IHR5cGVvZiBudW1iZXJGb3JtYXQuZm9ybWF0VG9QYXJ0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IG51bWJlckZvcm1hdC5mb3JtYXRUb1BhcnRzKE1hdGguYWJzKHZhbHVlKSlcbiAgICAgICAgOiAvLyBUT0RPOiBJZiBmb3JtYXRUb1BhcnRzIGlzIG5vdCBzdXBwb3J0ZWQsIHdlIGFzc3VtZSB0aGUgd2hvbGUgZm9ybWF0dGVkXG4gICAgICAgICAgICAvLyBudW1iZXIgaXMgYSBwYXJ0XG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBudW1iZXJGb3JtYXQuZm9ybWF0KE1hdGguYWJzKHZhbHVlKSksXG4gICAgICAgICAgICAgICAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgdmFyIHByID0gcGx1cmFsUnVsZXMuc2VsZWN0KHZhbHVlKTtcbiAgICB2YXIgcGF0dGVybiA9IHBvW3ByXTtcbiAgICByZXR1cm4gTWFrZVBhcnRzTGlzdF8xLk1ha2VQYXJ0c0xpc3QocGF0dGVybiwgcmVzb2x2ZWRVbml0LCBmdik7XG59XG5leHBvcnRzLlBhcnRpdGlvblJlbGF0aXZlVGltZVBhdHRlcm4gPSBQYXJ0aXRpb25SZWxhdGl2ZVRpbWVQYXR0ZXJuO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNpbmd1bGFyUmVsYXRpdmVUaW1lVW5pdCA9IHZvaWQgMDtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIF8yNjJfMSA9IHJlcXVpcmUoXCIuLi8yNjJcIik7XG4vKipcbiAqIGh0dHBzOi8vdGMzOS5lcy9wcm9wb3NhbC1pbnRsLXJlbGF0aXZlLXRpbWUvI3NlYy1zaW5ndWxhcnJlbGF0aXZldGltZXVuaXRcbiAqIEBwYXJhbSB1bml0XG4gKi9cbmZ1bmN0aW9uIFNpbmd1bGFyUmVsYXRpdmVUaW1lVW5pdCh1bml0KSB7XG4gICAgdXRpbHNfMS5pbnZhcmlhbnQoXzI2Ml8xLlR5cGUodW5pdCkgPT09ICdTdHJpbmcnLCAndW5pdCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgaWYgKHVuaXQgPT09ICdzZWNvbmRzJylcbiAgICAgICAgcmV0dXJuICdzZWNvbmQnO1xuICAgIGlmICh1bml0ID09PSAnbWludXRlcycpXG4gICAgICAgIHJldHVybiAnbWludXRlJztcbiAgICBpZiAodW5pdCA9PT0gJ2hvdXJzJylcbiAgICAgICAgcmV0dXJuICdob3VyJztcbiAgICBpZiAodW5pdCA9PT0gJ2RheXMnKVxuICAgICAgICByZXR1cm4gJ2RheSc7XG4gICAgaWYgKHVuaXQgPT09ICd3ZWVrcycpXG4gICAgICAgIHJldHVybiAnd2Vlayc7XG4gICAgaWYgKHVuaXQgPT09ICdtb250aHMnKVxuICAgICAgICByZXR1cm4gJ21vbnRoJztcbiAgICBpZiAodW5pdCA9PT0gJ3F1YXJ0ZXJzJylcbiAgICAgICAgcmV0dXJuICdxdWFydGVyJztcbiAgICBpZiAodW5pdCA9PT0gJ3llYXJzJylcbiAgICAgICAgcmV0dXJuICd5ZWFyJztcbiAgICBpZiAodW5pdCAhPT0gJ3NlY29uZCcgJiZcbiAgICAgICAgdW5pdCAhPT0gJ21pbnV0ZScgJiZcbiAgICAgICAgdW5pdCAhPT0gJ2hvdXInICYmXG4gICAgICAgIHVuaXQgIT09ICdkYXknICYmXG4gICAgICAgIHVuaXQgIT09ICd3ZWVrJyAmJlxuICAgICAgICB1bml0ICE9PSAnbW9udGgnICYmXG4gICAgICAgIHVuaXQgIT09ICdxdWFydGVyJyAmJlxuICAgICAgICB1bml0ICE9PSAneWVhcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2ludmFsaWQgdW5pdCcpO1xuICAgIH1cbiAgICByZXR1cm4gdW5pdDtcbn1cbmV4cG9ydHMuU2luZ3VsYXJSZWxhdGl2ZVRpbWVVbml0ID0gU2luZ3VsYXJSZWxhdGl2ZVRpbWVVbml0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlc29sdmVMb2NhbGUgPSB2b2lkIDA7XG52YXIgTG9va3VwTWF0Y2hlcl8xID0gcmVxdWlyZShcIi4vTG9va3VwTWF0Y2hlclwiKTtcbnZhciBCZXN0Rml0TWF0Y2hlcl8xID0gcmVxdWlyZShcIi4vQmVzdEZpdE1hdGNoZXJcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIFVuaWNvZGVFeHRlbnNpb25WYWx1ZV8xID0gcmVxdWlyZShcIi4vVW5pY29kZUV4dGVuc2lvblZhbHVlXCIpO1xuLyoqXG4gKiBodHRwczovL3RjMzkuZXMvZWNtYTQwMi8jc2VjLXJlc29sdmVsb2NhbGVcbiAqL1xuZnVuY3Rpb24gUmVzb2x2ZUxvY2FsZShhdmFpbGFibGVMb2NhbGVzLCByZXF1ZXN0ZWRMb2NhbGVzLCBvcHRpb25zLCByZWxldmFudEV4dGVuc2lvbktleXMsIGxvY2FsZURhdGEsIGdldERlZmF1bHRMb2NhbGUpIHtcbiAgICB2YXIgbWF0Y2hlciA9IG9wdGlvbnMubG9jYWxlTWF0Y2hlcjtcbiAgICB2YXIgcjtcbiAgICBpZiAobWF0Y2hlciA9PT0gJ2xvb2t1cCcpIHtcbiAgICAgICAgciA9IExvb2t1cE1hdGNoZXJfMS5Mb29rdXBNYXRjaGVyKGF2YWlsYWJsZUxvY2FsZXMsIHJlcXVlc3RlZExvY2FsZXMsIGdldERlZmF1bHRMb2NhbGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgciA9IEJlc3RGaXRNYXRjaGVyXzEuQmVzdEZpdE1hdGNoZXIoYXZhaWxhYmxlTG9jYWxlcywgcmVxdWVzdGVkTG9jYWxlcywgZ2V0RGVmYXVsdExvY2FsZSk7XG4gICAgfVxuICAgIHZhciBmb3VuZExvY2FsZSA9IHIubG9jYWxlO1xuICAgIHZhciByZXN1bHQgPSB7IGxvY2FsZTogJycsIGRhdGFMb2NhbGU6IGZvdW5kTG9jYWxlIH07XG4gICAgdmFyIHN1cHBvcnRlZEV4dGVuc2lvbiA9ICctdSc7XG4gICAgZm9yICh2YXIgX2kgPSAwLCByZWxldmFudEV4dGVuc2lvbktleXNfMSA9IHJlbGV2YW50RXh0ZW5zaW9uS2V5czsgX2kgPCByZWxldmFudEV4dGVuc2lvbktleXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHJlbGV2YW50RXh0ZW5zaW9uS2V5c18xW19pXTtcbiAgICAgICAgdXRpbHNfMS5pbnZhcmlhbnQoZm91bmRMb2NhbGUgaW4gbG9jYWxlRGF0YSwgXCJNaXNzaW5nIGxvY2FsZSBkYXRhIGZvciBcIiArIGZvdW5kTG9jYWxlKTtcbiAgICAgICAgdmFyIGZvdW5kTG9jYWxlRGF0YSA9IGxvY2FsZURhdGFbZm91bmRMb2NhbGVdO1xuICAgICAgICB1dGlsc18xLmludmFyaWFudCh0eXBlb2YgZm91bmRMb2NhbGVEYXRhID09PSAnb2JqZWN0JyAmJiBmb3VuZExvY2FsZURhdGEgIT09IG51bGwsIFwibG9jYWxlIGRhdGEgXCIgKyBrZXkgKyBcIiBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgICAgICAgdmFyIGtleUxvY2FsZURhdGEgPSBmb3VuZExvY2FsZURhdGFba2V5XTtcbiAgICAgICAgdXRpbHNfMS5pbnZhcmlhbnQoQXJyYXkuaXNBcnJheShrZXlMb2NhbGVEYXRhKSwgXCJrZXlMb2NhbGVEYXRhIGZvciBcIiArIGtleSArIFwiIG11c3QgYmUgYW4gYXJyYXlcIik7XG4gICAgICAgIHZhciB2YWx1ZSA9IGtleUxvY2FsZURhdGFbMF07XG4gICAgICAgIHV0aWxzXzEuaW52YXJpYW50KHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgPT09IG51bGwsIFwidmFsdWUgbXVzdCBiZSBzdHJpbmcgb3IgbnVsbCBidXQgZ290IFwiICsgdHlwZW9mIHZhbHVlICsgXCIgaW4ga2V5IFwiICsga2V5KTtcbiAgICAgICAgdmFyIHN1cHBvcnRlZEV4dGVuc2lvbkFkZGl0aW9uID0gJyc7XG4gICAgICAgIGlmIChyLmV4dGVuc2lvbikge1xuICAgICAgICAgICAgdmFyIHJlcXVlc3RlZFZhbHVlID0gVW5pY29kZUV4dGVuc2lvblZhbHVlXzEuVW5pY29kZUV4dGVuc2lvblZhbHVlKHIuZXh0ZW5zaW9uLCBrZXkpO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RlZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdGVkVmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh+a2V5TG9jYWxlRGF0YS5pbmRleE9mKHJlcXVlc3RlZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXF1ZXN0ZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZEV4dGVuc2lvbkFkZGl0aW9uID0gXCItXCIgKyBrZXkgKyBcIi1cIiArIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKH5yZXF1ZXN0ZWRWYWx1ZS5pbmRleE9mKCd0cnVlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAndHJ1ZSc7XG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZEV4dGVuc2lvbkFkZGl0aW9uID0gXCItXCIgKyBrZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnNWYWx1ZSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgIHV0aWxzXzEuaW52YXJpYW50KHR5cGVvZiBvcHRpb25zVmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIG9wdGlvbnNWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgICAgICAgICBvcHRpb25zVmFsdWUgPT09IG51bGwsICdvcHRpb25zVmFsdWUgbXVzdCBiZSBTdHJpbmcsIFVuZGVmaW5lZCBvciBOdWxsJyk7XG4gICAgICAgICAgICBpZiAofmtleUxvY2FsZURhdGEuaW5kZXhPZihvcHRpb25zVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvcHRpb25zVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZEV4dGVuc2lvbkFkZGl0aW9uID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgIHN1cHBvcnRlZEV4dGVuc2lvbiArPSBzdXBwb3J0ZWRFeHRlbnNpb25BZGRpdGlvbjtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnRlZEV4dGVuc2lvbi5sZW5ndGggPiAyKSB7XG4gICAgICAgIHZhciBwcml2YXRlSW5kZXggPSBmb3VuZExvY2FsZS5pbmRleE9mKCcteC0nKTtcbiAgICAgICAgaWYgKHByaXZhdGVJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGZvdW5kTG9jYWxlID0gZm91bmRMb2NhbGUgKyBzdXBwb3J0ZWRFeHRlbnNpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJlRXh0ZW5zaW9uID0gZm91bmRMb2NhbGUuc2xpY2UoMCwgcHJpdmF0ZUluZGV4KTtcbiAgICAgICAgICAgIHZhciBwb3N0RXh0ZW5zaW9uID0gZm91bmRMb2NhbGUuc2xpY2UocHJpdmF0ZUluZGV4LCBmb3VuZExvY2FsZS5sZW5ndGgpO1xuICAgICAgICAgICAgZm91bmRMb2NhbGUgPSBwcmVFeHRlbnNpb24gKyBzdXBwb3J0ZWRFeHRlbnNpb24gKyBwb3N0RXh0ZW5zaW9uO1xuICAgICAgICB9XG4gICAgICAgIGZvdW5kTG9jYWxlID0gSW50bC5nZXRDYW5vbmljYWxMb2NhbGVzKGZvdW5kTG9jYWxlKVswXTtcbiAgICB9XG4gICAgcmVzdWx0LmxvY2FsZSA9IGZvdW5kTG9jYWxlO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLlJlc29sdmVMb2NhbGUgPSBSZXNvbHZlTG9jYWxlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN1cHBvcnRlZExvY2FsZXMgPSB2b2lkIDA7XG52YXIgXzI2Ml8xID0gcmVxdWlyZShcIi4vMjYyXCIpO1xudmFyIEdldE9wdGlvbl8xID0gcmVxdWlyZShcIi4vR2V0T3B0aW9uXCIpO1xudmFyIExvb2t1cFN1cHBvcnRlZExvY2FsZXNfMSA9IHJlcXVpcmUoXCIuL0xvb2t1cFN1cHBvcnRlZExvY2FsZXNcIik7XG4vKipcbiAqIGh0dHBzOi8vdGMzOS5lcy9lY21hNDAyLyNzZWMtc3VwcG9ydGVkbG9jYWxlc1xuICogQHBhcmFtIGF2YWlsYWJsZUxvY2FsZXNcbiAqIEBwYXJhbSByZXF1ZXN0ZWRMb2NhbGVzXG4gKiBAcGFyYW0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBTdXBwb3J0ZWRMb2NhbGVzKGF2YWlsYWJsZUxvY2FsZXMsIHJlcXVlc3RlZExvY2FsZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgbWF0Y2hlciA9ICdiZXN0IGZpdCc7XG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zID0gXzI2Ml8xLlRvT2JqZWN0KG9wdGlvbnMpO1xuICAgICAgICBtYXRjaGVyID0gR2V0T3B0aW9uXzEuR2V0T3B0aW9uKG9wdGlvbnMsICdsb2NhbGVNYXRjaGVyJywgJ3N0cmluZycsIFsnbG9va3VwJywgJ2Jlc3QgZml0J10sICdiZXN0IGZpdCcpO1xuICAgIH1cbiAgICBpZiAobWF0Y2hlciA9PT0gJ2Jlc3QgZml0Jykge1xuICAgICAgICByZXR1cm4gTG9va3VwU3VwcG9ydGVkTG9jYWxlc18xLkxvb2t1cFN1cHBvcnRlZExvY2FsZXMoYXZhaWxhYmxlTG9jYWxlcywgcmVxdWVzdGVkTG9jYWxlcyk7XG4gICAgfVxuICAgIHJldHVybiBMb29rdXBTdXBwb3J0ZWRMb2NhbGVzXzEuTG9va3VwU3VwcG9ydGVkTG9jYWxlcyhhdmFpbGFibGVMb2NhbGVzLCByZXF1ZXN0ZWRMb2NhbGVzKTtcbn1cbmV4cG9ydHMuU3VwcG9ydGVkTG9jYWxlcyA9IFN1cHBvcnRlZExvY2FsZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVW5pY29kZUV4dGVuc2lvblZhbHVlID0gdm9pZCAwO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogaHR0cHM6Ly90YzM5LmVzL2VjbWE0MDIvI3NlYy11bmljb2RlZXh0ZW5zaW9udmFsdWVcbiAqIEBwYXJhbSBleHRlbnNpb25cbiAqIEBwYXJhbSBrZXlcbiAqL1xuZnVuY3Rpb24gVW5pY29kZUV4dGVuc2lvblZhbHVlKGV4dGVuc2lvbiwga2V5KSB7XG4gICAgdXRpbHNfMS5pbnZhcmlhbnQoa2V5Lmxlbmd0aCA9PT0gMiwgJ2tleSBtdXN0IGhhdmUgMiBlbGVtZW50cycpO1xuICAgIHZhciBzaXplID0gZXh0ZW5zaW9uLmxlbmd0aDtcbiAgICB2YXIgc2VhcmNoVmFsdWUgPSBcIi1cIiArIGtleSArIFwiLVwiO1xuICAgIHZhciBwb3MgPSBleHRlbnNpb24uaW5kZXhPZihzZWFyY2hWYWx1ZSk7XG4gICAgaWYgKHBvcyAhPT0gLTEpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcG9zICsgNDtcbiAgICAgICAgdmFyIGVuZCA9IHN0YXJ0O1xuICAgICAgICB2YXIgayA9IHN0YXJ0O1xuICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgICAgIHZhciBlID0gZXh0ZW5zaW9uLmluZGV4T2YoJy0nLCBrKTtcbiAgICAgICAgICAgIHZhciBsZW4gPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoZSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsZW4gPSBzaXplIC0gaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlbiA9IGUgLSBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbiA9PT0gMikge1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBzaXplO1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kID0gZTtcbiAgICAgICAgICAgICAgICBrID0gZSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbi5zbGljZShzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgc2VhcmNoVmFsdWUgPSBcIi1cIiArIGtleTtcbiAgICBwb3MgPSBleHRlbnNpb24uaW5kZXhPZihzZWFyY2hWYWx1ZSk7XG4gICAgaWYgKHBvcyAhPT0gLTEgJiYgcG9zICsgMyA9PT0gc2l6ZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnRzLlVuaWNvZGVFeHRlbnNpb25WYWx1ZSA9IFVuaWNvZGVFeHRlbnNpb25WYWx1ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc01pc3NpbmdMb2NhbGVEYXRhRXJyb3IgPSB2b2lkIDA7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBNaXNzaW5nTG9jYWxlRGF0YUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE1pc3NpbmdMb2NhbGVEYXRhRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWlzc2luZ0xvY2FsZURhdGFFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSAnTUlTU0lOR19MT0NBTEVfREFUQSc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1pc3NpbmdMb2NhbGVEYXRhRXJyb3I7XG59KEVycm9yKSk7XG5mdW5jdGlvbiBpc01pc3NpbmdMb2NhbGVEYXRhRXJyb3IoZSkge1xuICAgIHJldHVybiBlLnR5cGUgPT09ICdNSVNTSU5HX0xPQ0FMRV9EQVRBJztcbn1cbmV4cG9ydHMuaXNNaXNzaW5nTG9jYWxlRGF0YUVycm9yID0gaXNNaXNzaW5nTG9jYWxlRGF0YUVycm9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmludmFyaWFudCA9IGV4cG9ydHMuaXNNaXNzaW5nTG9jYWxlRGF0YUVycm9yID0gZXhwb3J0cy5kZWZpbmVQcm9wZXJ0eSA9IGV4cG9ydHMuZ2V0TWFnbml0dWRlID0gZXhwb3J0cy5zZXRNdWx0aUludGVybmFsU2xvdHMgPSBleHBvcnRzLnNldEludGVybmFsU2xvdCA9IGV4cG9ydHMuaXNMaXRlcmFsUGFydCA9IGV4cG9ydHMuZ2V0TXVsdGlJbnRlcm5hbFNsb3RzID0gZXhwb3J0cy5nZXRJbnRlcm5hbFNsb3QgPSBleHBvcnRzLnBhcnNlRGF0ZVRpbWVTa2VsZXRvbiA9IGV4cG9ydHMuREFURV9USU1FX1BST1BTID0gZXhwb3J0cy5fZm9ybWF0VG9QYXJ0cyA9IGV4cG9ydHMuQmVzdEZpdEZvcm1hdE1hdGNoZXIgPSB2b2lkIDA7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBCZXN0Rml0Rm9ybWF0TWF0Y2hlcl8xID0gcmVxdWlyZShcIi4vRGF0ZVRpbWVGb3JtYXQvQmVzdEZpdEZvcm1hdE1hdGNoZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCZXN0Rml0Rm9ybWF0TWF0Y2hlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQmVzdEZpdEZvcm1hdE1hdGNoZXJfMS5CZXN0Rml0Rm9ybWF0TWF0Y2hlcjsgfSB9KTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0Nhbm9uaWNhbGl6ZUxvY2FsZUxpc3RcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ2Fub25pY2FsaXplVGltZVpvbmVOYW1lXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0RhdGVUaW1lRm9ybWF0L0Jhc2ljRm9ybWF0TWF0Y2hlclwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9EYXRlVGltZUZvcm1hdC9EYXRlVGltZVN0eWxlRm9ybWF0XCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0RhdGVUaW1lRm9ybWF0L0Zvcm1hdERhdGVUaW1lXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0RhdGVUaW1lRm9ybWF0L0Zvcm1hdERhdGVUaW1lUmFuZ2VcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRGF0ZVRpbWVGb3JtYXQvRm9ybWF0RGF0ZVRpbWVSYW5nZVRvUGFydHNcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRGF0ZVRpbWVGb3JtYXQvRm9ybWF0RGF0ZVRpbWVUb1BhcnRzXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0RhdGVUaW1lRm9ybWF0L0luaXRpYWxpemVEYXRlVGltZUZvcm1hdFwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9EYXRlVGltZUZvcm1hdC9QYXJ0aXRpb25EYXRlVGltZVBhdHRlcm5cIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRGF0ZVRpbWVGb3JtYXQvVG9EYXRlVGltZU9wdGlvbnNcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRGlzcGxheU5hbWVzL0Nhbm9uaWNhbENvZGVGb3JEaXNwbGF5TmFtZXNcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vR2V0TnVtYmVyT3B0aW9uXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0dldE9wdGlvblwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9Jc1NhbmN0aW9uZWRTaW1wbGVVbml0SWRlbnRpZmllclwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9Jc1ZhbGlkVGltZVpvbmVOYW1lXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0lzV2VsbEZvcm1lZEN1cnJlbmN5Q29kZVwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9Jc1dlbGxGb3JtZWRVbml0SWRlbnRpZmllclwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9OdW1iZXJGb3JtYXQvQ29tcHV0ZUV4cG9uZW50XCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL051bWJlckZvcm1hdC9Db21wdXRlRXhwb25lbnRGb3JNYWduaXR1ZGVcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vTnVtYmVyRm9ybWF0L0N1cnJlbmN5RGlnaXRzXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL051bWJlckZvcm1hdC9Gb3JtYXROdW1lcmljVG9QYXJ0c1wiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9OdW1iZXJGb3JtYXQvRm9ybWF0TnVtZXJpY1RvU3RyaW5nXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL051bWJlckZvcm1hdC9Jbml0aWFsaXplTnVtYmVyRm9ybWF0XCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL051bWJlckZvcm1hdC9QYXJ0aXRpb25OdW1iZXJQYXR0ZXJuXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL051bWJlckZvcm1hdC9TZXROdW1iZXJGb3JtYXREaWdpdE9wdGlvbnNcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vTnVtYmVyRm9ybWF0L1NldE51bWJlckZvcm1hdFVuaXRPcHRpb25zXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL051bWJlckZvcm1hdC9Ub1Jhd0ZpeGVkXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL051bWJlckZvcm1hdC9Ub1Jhd1ByZWNpc2lvblwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9QYXJ0aXRpb25QYXR0ZXJuXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1BsdXJhbFJ1bGVzL0dldE9wZXJhbmRzXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1BsdXJhbFJ1bGVzL0luaXRpYWxpemVQbHVyYWxSdWxlc1wiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9QbHVyYWxSdWxlcy9SZXNvbHZlUGx1cmFsXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1JlbGF0aXZlVGltZUZvcm1hdC9Gb3JtYXRSZWxhdGl2ZVRpbWVcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUmVsYXRpdmVUaW1lRm9ybWF0L0Zvcm1hdFJlbGF0aXZlVGltZVRvUGFydHNcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUmVsYXRpdmVUaW1lRm9ybWF0L0luaXRpYWxpemVSZWxhdGl2ZVRpbWVGb3JtYXRcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUmVsYXRpdmVUaW1lRm9ybWF0L01ha2VQYXJ0c0xpc3RcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUmVsYXRpdmVUaW1lRm9ybWF0L1BhcnRpdGlvblJlbGF0aXZlVGltZVBhdHRlcm5cIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUmVsYXRpdmVUaW1lRm9ybWF0L1Npbmd1bGFyUmVsYXRpdmVUaW1lVW5pdFwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9SZXNvbHZlTG9jYWxlXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1N1cHBvcnRlZExvY2FsZXNcIiksIGV4cG9ydHMpO1xudmFyIGZvcm1hdF90b19wYXJ0c18xID0gcmVxdWlyZShcIi4vTnVtYmVyRm9ybWF0L2Zvcm1hdF90b19wYXJ0c1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9mb3JtYXRUb1BhcnRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChmb3JtYXRfdG9fcGFydHNfMSkuZGVmYXVsdDsgfSB9KTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vRGF0ZVRpbWVGb3JtYXQvdXRpbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEQVRFX1RJTUVfUFJPUFNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuREFURV9USU1FX1BST1BTOyB9IH0pO1xudmFyIHNrZWxldG9uXzEgPSByZXF1aXJlKFwiLi9EYXRlVGltZUZvcm1hdC9za2VsZXRvblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlRGF0ZVRpbWVTa2VsZXRvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2tlbGV0b25fMS5wYXJzZURhdGVUaW1lU2tlbGV0b247IH0gfSk7XG52YXIgdXRpbHNfMiA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0SW50ZXJuYWxTbG90XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18yLmdldEludGVybmFsU2xvdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldE11bHRpSW50ZXJuYWxTbG90c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMi5nZXRNdWx0aUludGVybmFsU2xvdHM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0xpdGVyYWxQYXJ0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18yLmlzTGl0ZXJhbFBhcnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZXRJbnRlcm5hbFNsb3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzIuc2V0SW50ZXJuYWxTbG90OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2V0TXVsdGlJbnRlcm5hbFNsb3RzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18yLnNldE11bHRpSW50ZXJuYWxTbG90czsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldE1hZ25pdHVkZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMi5nZXRNYWduaXR1ZGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZpbmVQcm9wZXJ0eVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMi5kZWZpbmVQcm9wZXJ0eTsgfSB9KTtcbnZhciBkYXRhXzEgPSByZXF1aXJlKFwiLi9kYXRhXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNNaXNzaW5nTG9jYWxlRGF0YUVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkYXRhXzEuaXNNaXNzaW5nTG9jYWxlRGF0YUVycm9yOyB9IH0pO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvcmVsYXRpdmUtdGltZVwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlcy9kYXRlLXRpbWVcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvbGlzdFwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlcy9wbHVyYWwtcnVsZXNcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvbnVtYmVyXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVzL2Rpc3BsYXluYW1lc1wiKSwgZXhwb3J0cyk7XG52YXIgdXRpbHNfMyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaW52YXJpYW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18zLmludmFyaWFudDsgfSB9KTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuLzI2MlwiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmFuZ2VQYXR0ZXJuVHlwZSA9IHZvaWQgMDtcbnZhciBSYW5nZVBhdHRlcm5UeXBlO1xuKGZ1bmN0aW9uIChSYW5nZVBhdHRlcm5UeXBlKSB7XG4gICAgUmFuZ2VQYXR0ZXJuVHlwZVtcInN0YXJ0UmFuZ2VcIl0gPSBcInN0YXJ0UmFuZ2VcIjtcbiAgICBSYW5nZVBhdHRlcm5UeXBlW1wic2hhcmVkXCJdID0gXCJzaGFyZWRcIjtcbiAgICBSYW5nZVBhdHRlcm5UeXBlW1wiZW5kUmFuZ2VcIl0gPSBcImVuZFJhbmdlXCI7XG59KShSYW5nZVBhdHRlcm5UeXBlID0gZXhwb3J0cy5SYW5nZVBhdHRlcm5UeXBlIHx8IChleHBvcnRzLlJhbmdlUGF0dGVyblR5cGUgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW52YXJpYW50ID0gZXhwb3J0cy5VTklDT0RFX0VYVEVOU0lPTl9TRVFVRU5DRV9SRUdFWCA9IGV4cG9ydHMuZGVmaW5lUHJvcGVydHkgPSBleHBvcnRzLmlzTGl0ZXJhbFBhcnQgPSBleHBvcnRzLmdldE11bHRpSW50ZXJuYWxTbG90cyA9IGV4cG9ydHMuZ2V0SW50ZXJuYWxTbG90ID0gZXhwb3J0cy5zZXRNdWx0aUludGVybmFsU2xvdHMgPSBleHBvcnRzLnNldEludGVybmFsU2xvdCA9IGV4cG9ydHMucmVwZWF0ID0gZXhwb3J0cy5nZXRNYWduaXR1ZGUgPSB2b2lkIDA7XG4vKipcbiAqIENhbm5vdCBkbyBNYXRoLmxvZyh4KSAvIE1hdGgubG9nKDEwKSBiYyBpZiBJRUVFIGZsb2F0aW5nIHBvaW50IGlzc3VlXG4gKiBAcGFyYW0geCBudW1iZXJcbiAqL1xuZnVuY3Rpb24gZ2V0TWFnbml0dWRlKHgpIHtcbiAgICAvLyBDYW5ub3QgY291bnQgc3RyaW5nIGxlbmd0aCB2aWEgTnVtYmVyLnRvU3RyaW5nIGJlY2F1c2UgaXQgbWF5IHVzZSBzY2llbnRpZmljIG5vdGF0aW9uXG4gICAgLy8gZm9yIHZlcnkgc21hbGwgb3IgdmVyeSBsYXJnZSBudW1iZXJzLlxuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgubG9nKHgpICogTWF0aC5MT0cxMEUpO1xufVxuZXhwb3J0cy5nZXRNYWduaXR1ZGUgPSBnZXRNYWduaXR1ZGU7XG5mdW5jdGlvbiByZXBlYXQocywgdGltZXMpIHtcbiAgICBpZiAodHlwZW9mIHMucmVwZWF0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGVhdCh0aW1lcyk7XG4gICAgfVxuICAgIHZhciBhcnIgPSBuZXcgQXJyYXkodGltZXMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IHM7XG4gICAgfVxuICAgIHJldHVybiBhcnIuam9pbignJyk7XG59XG5leHBvcnRzLnJlcGVhdCA9IHJlcGVhdDtcbmZ1bmN0aW9uIHNldEludGVybmFsU2xvdChtYXAsIHBsLCBmaWVsZCwgdmFsdWUpIHtcbiAgICBpZiAoIW1hcC5nZXQocGwpKSB7XG4gICAgICAgIG1hcC5zZXQocGwsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgIH1cbiAgICB2YXIgc2xvdHMgPSBtYXAuZ2V0KHBsKTtcbiAgICBzbG90c1tmaWVsZF0gPSB2YWx1ZTtcbn1cbmV4cG9ydHMuc2V0SW50ZXJuYWxTbG90ID0gc2V0SW50ZXJuYWxTbG90O1xuZnVuY3Rpb24gc2V0TXVsdGlJbnRlcm5hbFNsb3RzKG1hcCwgcGwsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKHByb3BzKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGsgPSBfYVtfaV07XG4gICAgICAgIHNldEludGVybmFsU2xvdChtYXAsIHBsLCBrLCBwcm9wc1trXSk7XG4gICAgfVxufVxuZXhwb3J0cy5zZXRNdWx0aUludGVybmFsU2xvdHMgPSBzZXRNdWx0aUludGVybmFsU2xvdHM7XG5mdW5jdGlvbiBnZXRJbnRlcm5hbFNsb3QobWFwLCBwbCwgZmllbGQpIHtcbiAgICByZXR1cm4gZ2V0TXVsdGlJbnRlcm5hbFNsb3RzKG1hcCwgcGwsIGZpZWxkKVtmaWVsZF07XG59XG5leHBvcnRzLmdldEludGVybmFsU2xvdCA9IGdldEludGVybmFsU2xvdDtcbmZ1bmN0aW9uIGdldE11bHRpSW50ZXJuYWxTbG90cyhtYXAsIHBsKSB7XG4gICAgdmFyIGZpZWxkcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGZpZWxkc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHNsb3RzID0gbWFwLmdldChwbCk7XG4gICAgaWYgKCFzbG90cykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHBsICsgXCIgSW50ZXJuYWxTbG90IGhhcyBub3QgYmVlbiBpbml0aWFsaXplZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24gKGFsbCwgZikge1xuICAgICAgICBhbGxbZl0gPSBzbG90c1tmXTtcbiAgICAgICAgcmV0dXJuIGFsbDtcbiAgICB9LCBPYmplY3QuY3JlYXRlKG51bGwpKTtcbn1cbmV4cG9ydHMuZ2V0TXVsdGlJbnRlcm5hbFNsb3RzID0gZ2V0TXVsdGlJbnRlcm5hbFNsb3RzO1xuZnVuY3Rpb24gaXNMaXRlcmFsUGFydChwYXR0ZXJuUGFydCkge1xuICAgIHJldHVybiBwYXR0ZXJuUGFydC50eXBlID09PSAnbGl0ZXJhbCc7XG59XG5leHBvcnRzLmlzTGl0ZXJhbFBhcnQgPSBpc0xpdGVyYWxQYXJ0O1xuLypcbiAgMTcgRUNNQVNjcmlwdCBTdGFuZGFyZCBCdWlsdC1pbiBPYmplY3RzOlxuICAgIEV2ZXJ5IGJ1aWx0LWluIEZ1bmN0aW9uIG9iamVjdCwgaW5jbHVkaW5nIGNvbnN0cnVjdG9ycywgdGhhdCBpcyBub3RcbiAgICBpZGVudGlmaWVkIGFzIGFuIGFub255bW91cyBmdW5jdGlvbiBoYXMgYSBuYW1lIHByb3BlcnR5IHdob3NlIHZhbHVlXG4gICAgaXMgYSBTdHJpbmcuXG5cbiAgICBVbmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZCwgdGhlIG5hbWUgcHJvcGVydHkgb2YgYSBidWlsdC1pbiBGdW5jdGlvblxuICAgIG9iamVjdCwgaWYgaXQgZXhpc3RzLCBoYXMgdGhlIGF0dHJpYnV0ZXMgeyBbW1dyaXRhYmxlXV06IGZhbHNlLFxuICAgIFtbRW51bWVyYWJsZV1dOiBmYWxzZSwgW1tDb25maWd1cmFibGVdXTogdHJ1ZSB9LlxuKi9cbmZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwgX2EpIHtcbiAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgfSk7XG59XG5leHBvcnRzLmRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHk7XG5leHBvcnRzLlVOSUNPREVfRVhURU5TSU9OX1NFUVVFTkNFX1JFR0VYID0gLy11KD86LVswLTlhLXpdezIsOH0pKy9naTtcbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIG1lc3NhZ2UsIEVycikge1xuICAgIGlmIChFcnIgPT09IHZvaWQgMCkgeyBFcnIgPSBFcnJvcjsgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnIobWVzc2FnZSk7XG4gICAgfVxufVxuZXhwb3J0cy5pbnZhcmlhbnQgPSBpbnZhcmlhbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGlzcGxheU5hbWVzID0gdm9pZCAwO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgZWNtYTQwMl9hYnN0cmFjdF8xID0gcmVxdWlyZShcIkBmb3JtYXRqcy9lY21hNDAyLWFic3RyYWN0XCIpO1xudmFyIERpc3BsYXlOYW1lcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEaXNwbGF5TmFtZXMobG9jYWxlcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIGlmIChfbmV3VGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIkNvbnN0cnVjdG9yIEludGwuRGlzcGxheU5hbWVzIHJlcXVpcmVzICduZXcnXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXF1ZXN0ZWRMb2NhbGVzID0gZWNtYTQwMl9hYnN0cmFjdF8xLkNhbm9uaWNhbGl6ZUxvY2FsZUxpc3QobG9jYWxlcyk7XG4gICAgICAgIG9wdGlvbnMgPSBlY21hNDAyX2Fic3RyYWN0XzEuVG9PYmplY3Qob3B0aW9ucyk7XG4gICAgICAgIHZhciBvcHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB2YXIgbG9jYWxlRGF0YSA9IERpc3BsYXlOYW1lcy5sb2NhbGVEYXRhO1xuICAgICAgICB2YXIgbWF0Y2hlciA9IGVjbWE0MDJfYWJzdHJhY3RfMS5HZXRPcHRpb24ob3B0aW9ucywgJ2xvY2FsZU1hdGNoZXInLCAnc3RyaW5nJywgWydsb29rdXAnLCAnYmVzdCBmaXQnXSwgJ2Jlc3QgZml0Jyk7XG4gICAgICAgIG9wdC5sb2NhbGVNYXRjaGVyID0gbWF0Y2hlcjtcbiAgICAgICAgdmFyIHIgPSBlY21hNDAyX2Fic3RyYWN0XzEuUmVzb2x2ZUxvY2FsZShEaXNwbGF5TmFtZXMuYXZhaWxhYmxlTG9jYWxlcywgcmVxdWVzdGVkTG9jYWxlcywgb3B0LCBbXSwgLy8gdGhlcmUgaXMgbm8gcmVsZXZhbnRFeHRlbnNpb25LZXlzXG4gICAgICAgIERpc3BsYXlOYW1lcy5sb2NhbGVEYXRhLCBEaXNwbGF5TmFtZXMuZ2V0RGVmYXVsdExvY2FsZSk7XG4gICAgICAgIHZhciBzdHlsZSA9IGVjbWE0MDJfYWJzdHJhY3RfMS5HZXRPcHRpb24ob3B0aW9ucywgJ3N0eWxlJywgJ3N0cmluZycsIFsnbmFycm93JywgJ3Nob3J0JywgJ2xvbmcnXSwgJ2xvbmcnKTtcbiAgICAgICAgc2V0U2xvdCh0aGlzLCAnc3R5bGUnLCBzdHlsZSk7XG4gICAgICAgIHZhciB0eXBlID0gZWNtYTQwMl9hYnN0cmFjdF8xLkdldE9wdGlvbihvcHRpb25zLCAndHlwZScsICdzdHJpbmcnLCBbJ2xhbmd1YWdlJywgJ2N1cnJlbmN5JywgJ3JlZ2lvbicsICdzY3JpcHQnXSwgdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSW50bC5EaXNwbGF5TmFtZXMgY29uc3RydWN0b3IgcmVxdWlyZXMgXFxcInR5cGVcXFwiIG9wdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRTbG90KHRoaXMsICd0eXBlJywgdHlwZSk7XG4gICAgICAgIHZhciBmYWxsYmFjayA9IGVjbWE0MDJfYWJzdHJhY3RfMS5HZXRPcHRpb24ob3B0aW9ucywgJ2ZhbGxiYWNrJywgJ3N0cmluZycsIFsnY29kZScsICdub25lJ10sICdjb2RlJyk7XG4gICAgICAgIHNldFNsb3QodGhpcywgJ2ZhbGxiYWNrJywgZmFsbGJhY2spO1xuICAgICAgICBzZXRTbG90KHRoaXMsICdsb2NhbGUnLCByLmxvY2FsZSk7XG4gICAgICAgIHZhciBkYXRhTG9jYWxlID0gci5kYXRhTG9jYWxlO1xuICAgICAgICB2YXIgZGF0YUxvY2FsZURhdGEgPSBsb2NhbGVEYXRhW2RhdGFMb2NhbGVdO1xuICAgICAgICBlY21hNDAyX2Fic3RyYWN0XzEuaW52YXJpYW50KCEhZGF0YUxvY2FsZURhdGEsIFwiTWlzc2luZyBsb2NhbGUgZGF0YSBmb3IgXCIgKyBkYXRhTG9jYWxlKTtcbiAgICAgICAgc2V0U2xvdCh0aGlzLCAnbG9jYWxlRGF0YScsIGRhdGFMb2NhbGVEYXRhKTtcbiAgICAgICAgZWNtYTQwMl9hYnN0cmFjdF8xLmludmFyaWFudChkYXRhTG9jYWxlRGF0YSAhPT0gdW5kZWZpbmVkLCBcImxvY2FsZSBkYXRhIGZvciBcIiArIHIubG9jYWxlICsgXCIgZG9lcyBub3QgZXhpc3QuXCIpO1xuICAgICAgICB2YXIgdHlwZXMgPSBkYXRhTG9jYWxlRGF0YS50eXBlcztcbiAgICAgICAgZWNtYTQwMl9hYnN0cmFjdF8xLmludmFyaWFudCh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnICYmIHR5cGVzICE9IG51bGwsICdpbnZhbGlkIHR5cGVzIGRhdGEnKTtcbiAgICAgICAgdmFyIHR5cGVGaWVsZHMgPSB0eXBlc1t0eXBlXTtcbiAgICAgICAgZWNtYTQwMl9hYnN0cmFjdF8xLmludmFyaWFudCh0eXBlb2YgdHlwZUZpZWxkcyA9PT0gJ29iamVjdCcgJiYgdHlwZUZpZWxkcyAhPSBudWxsLCAnaW52YWxpZCB0eXBlRmllbGRzIGRhdGEnKTtcbiAgICAgICAgdmFyIHN0eWxlRmllbGRzID0gdHlwZUZpZWxkc1tzdHlsZV07XG4gICAgICAgIGVjbWE0MDJfYWJzdHJhY3RfMS5pbnZhcmlhbnQodHlwZW9mIHN0eWxlRmllbGRzID09PSAnb2JqZWN0JyAmJiBzdHlsZUZpZWxkcyAhPSBudWxsLCAnaW52YWxpZCBzdHlsZUZpZWxkcyBkYXRhJyk7XG4gICAgICAgIHNldFNsb3QodGhpcywgJ2ZpZWxkcycsIHN0eWxlRmllbGRzKTtcbiAgICB9XG4gICAgRGlzcGxheU5hbWVzLnN1cHBvcnRlZExvY2FsZXNPZiA9IGZ1bmN0aW9uIChsb2NhbGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBlY21hNDAyX2Fic3RyYWN0XzEuU3VwcG9ydGVkTG9jYWxlcyhEaXNwbGF5TmFtZXMuYXZhaWxhYmxlTG9jYWxlcywgZWNtYTQwMl9hYnN0cmFjdF8xLkNhbm9uaWNhbGl6ZUxvY2FsZUxpc3QobG9jYWxlcyksIG9wdGlvbnMpO1xuICAgIH07XG4gICAgRGlzcGxheU5hbWVzLl9fYWRkTG9jYWxlRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGRhdGFbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIGRhdGFfMSA9IGRhdGE7IF9hIDwgZGF0YV8xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgdmFyIF9iID0gZGF0YV8xW19hXSwgZCA9IF9iLmRhdGEsIGxvY2FsZSA9IF9iLmxvY2FsZTtcbiAgICAgICAgICAgIHZhciBtaW5pbWl6ZWRMb2NhbGUgPSBuZXcgSW50bC5Mb2NhbGUobG9jYWxlKVxuICAgICAgICAgICAgICAgIC5taW5pbWl6ZSgpXG4gICAgICAgICAgICAgICAgLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBEaXNwbGF5TmFtZXMubG9jYWxlRGF0YVtsb2NhbGVdID0gRGlzcGxheU5hbWVzLmxvY2FsZURhdGFbbWluaW1pemVkTG9jYWxlXSA9IGQ7XG4gICAgICAgICAgICBEaXNwbGF5TmFtZXMuYXZhaWxhYmxlTG9jYWxlcy5hZGQobWluaW1pemVkTG9jYWxlKTtcbiAgICAgICAgICAgIERpc3BsYXlOYW1lcy5hdmFpbGFibGVMb2NhbGVzLmFkZChsb2NhbGUpO1xuICAgICAgICAgICAgaWYgKCFEaXNwbGF5TmFtZXMuX19kZWZhdWx0TG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgRGlzcGxheU5hbWVzLl9fZGVmYXVsdExvY2FsZSA9IG1pbmltaXplZExvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRGlzcGxheU5hbWVzLnByb3RvdHlwZS5vZiA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgIGNoZWNrUmVjZWl2ZXIodGhpcywgJ29mJyk7XG4gICAgICAgIHZhciB0eXBlID0gZ2V0U2xvdCh0aGlzLCAndHlwZScpO1xuICAgICAgICB2YXIgY29kZUFzU3RyaW5nID0gZWNtYTQwMl9hYnN0cmFjdF8xLlRvU3RyaW5nKGNvZGUpO1xuICAgICAgICBpZiAoIWlzVmFsaWRDb2RlRm9yRGlzcGxheU5hbWVzKHR5cGUsIGNvZGVBc1N0cmluZykpIHtcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ2ludmFsaWQgY29kZSBmb3IgSW50bC5EaXNwbGF5TmFtZXMucHJvdG90eXBlLm9mJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gZWNtYTQwMl9hYnN0cmFjdF8xLmdldE11bHRpSW50ZXJuYWxTbG90cyhfX0lOVEVSTkFMX1NMT1RfTUFQX18sIHRoaXMsICdsb2NhbGVEYXRhJywgJ3N0eWxlJywgJ2ZhbGxiYWNrJyksIGxvY2FsZURhdGEgPSBfYS5sb2NhbGVEYXRhLCBzdHlsZSA9IF9hLnN0eWxlLCBmYWxsYmFjayA9IF9hLmZhbGxiYWNrO1xuICAgICAgICAvLyBDYW5vbmljYWxpemUgdGhlIGNhc2UuXG4gICAgICAgIHZhciBjYW5vbmljYWxDb2RlO1xuICAgICAgICAvLyBUaGlzIGlzIG9ubHkgdXNlZCB0byBzdG9yZSBleHRyYWN0ZWQgbGFuZ3VhZ2UgcmVnaW9uLlxuICAgICAgICB2YXIgcmVnaW9uU3ViVGFnO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgbG9jYWxlIGlkIGFuZCByZW1vdmUgdGhlIHJlZ2lvbi5cbiAgICAgICAgICAgIGNhc2UgJ2xhbmd1YWdlJzoge1xuICAgICAgICAgICAgICAgIGNhbm9uaWNhbENvZGUgPSBlY21hNDAyX2Fic3RyYWN0XzEuQ2Fub25pY2FsaXplTG9jYWxlTGlzdChjb2RlQXNTdHJpbmcpWzBdO1xuICAgICAgICAgICAgICAgIHZhciByZWdpb25NYXRjaCA9IC8tKFthLXpdezJ9fFxcZHszfSlcXGIvaS5leGVjKGNhbm9uaWNhbENvZGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWdpb25NYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgcmVnaW9uIHN1YnRhZ1xuICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxDb2RlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbENvZGUuc3Vic3RyaW5nKDAsIHJlZ2lvbk1hdGNoLmluZGV4KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsQ29kZS5zdWJzdHJpbmcocmVnaW9uTWF0Y2guaW5kZXggKyByZWdpb25NYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICByZWdpb25TdWJUYWcgPSByZWdpb25NYXRjaFsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjdXJyZW5jeSBjb2RlIHNob3VsZCBiZSBhbGwgdXBwZXItY2FzZS5cbiAgICAgICAgICAgIGNhc2UgJ2N1cnJlbmN5JzpcbiAgICAgICAgICAgICAgICBjYW5vbmljYWxDb2RlID0gY29kZUFzU3RyaW5nLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBzY3JpcHQgY29kZSBzaG91bGQgYmUgdGl0bGUgY2FzZVxuICAgICAgICAgICAgY2FzZSAnc2NyaXB0JzpcbiAgICAgICAgICAgICAgICBjYW5vbmljYWxDb2RlID1cbiAgICAgICAgICAgICAgICAgICAgY29kZUFzU3RyaW5nWzBdICsgY29kZUFzU3RyaW5nLnN1YnN0cmluZygxKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gcmVnaW9uIHNob2xkIGJlIGFsbCB1cHBlci1jYXNlXG4gICAgICAgICAgICBjYXNlICdyZWdpb24nOlxuICAgICAgICAgICAgICAgIGNhbm9uaWNhbENvZGUgPSBjb2RlQXNTdHJpbmcudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHlwZXNEYXRhID0gbG9jYWxlRGF0YS50eXBlc1t0eXBlXTtcbiAgICAgICAgLy8gSWYgdGhlIHN0eWxlIG9mIGNob2ljZSBkb2VzIG5vdCBleGlzdCwgZmFsbGJhY2sgdG8gXCJsb25nXCIuXG4gICAgICAgIHZhciBuYW1lID0gdHlwZXNEYXRhW3N0eWxlXVtjYW5vbmljYWxDb2RlXSB8fCB0eXBlc0RhdGEubG9uZ1tjYW5vbmljYWxDb2RlXTtcbiAgICAgICAgaWYgKG5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSByZWdpb24gc3VidGFnIGluIHRoZSBsYW5ndWFnZSBpZCwgdXNlIGxvY2FsZSBwYXR0ZXJuIHRvIGludGVycG9sYXRlIHRoZSByZWdpb25cbiAgICAgICAgICAgIGlmIChyZWdpb25TdWJUYWcpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXRyaWV2ZSByZWdpb24gZGlzcGxheSBuYW1lc1xuICAgICAgICAgICAgICAgIHZhciByZWdpb25zRGF0YSA9IGxvY2FsZURhdGEudHlwZXMucmVnaW9uO1xuICAgICAgICAgICAgICAgIHZhciByZWdpb25EaXNwbGF5TmFtZSA9IHJlZ2lvbnNEYXRhW3N0eWxlXVtyZWdpb25TdWJUYWddIHx8IHJlZ2lvbnNEYXRhLmxvbmdbcmVnaW9uU3ViVGFnXTtcbiAgICAgICAgICAgICAgICBpZiAocmVnaW9uRGlzcGxheU5hbWUgfHwgZmFsbGJhY2sgPT09ICdjb2RlJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnRlcnBvbGF0ZSBpbnRvIGxvY2FsZS1zcGVjaWZpYyBwYXR0ZXJuLlxuICAgICAgICAgICAgICAgICAgICB2YXIgcGF0dGVybiA9IGxvY2FsZURhdGEucGF0dGVybnMubG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3swfScsIG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnezF9JywgcmVnaW9uRGlzcGxheU5hbWUgfHwgcmVnaW9uU3ViVGFnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmFsbGJhY2sgPT09ICdjb2RlJykge1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVBc1N0cmluZztcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGlzcGxheU5hbWVzLnByb3RvdHlwZS5yZXNvbHZlZE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoZWNrUmVjZWl2ZXIodGhpcywgJ3Jlc29sdmVkT3B0aW9ucycpO1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2Fzc2lnbih7fSwgZWNtYTQwMl9hYnN0cmFjdF8xLmdldE11bHRpSW50ZXJuYWxTbG90cyhfX0lOVEVSTkFMX1NMT1RfTUFQX18sIHRoaXMsICdsb2NhbGUnLCAnc3R5bGUnLCAndHlwZScsICdmYWxsYmFjaycpKTtcbiAgICB9O1xuICAgIERpc3BsYXlOYW1lcy5nZXREZWZhdWx0TG9jYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gRGlzcGxheU5hbWVzLl9fZGVmYXVsdExvY2FsZTtcbiAgICB9O1xuICAgIERpc3BsYXlOYW1lcy5sb2NhbGVEYXRhID0ge307XG4gICAgRGlzcGxheU5hbWVzLmF2YWlsYWJsZUxvY2FsZXMgPSBuZXcgU2V0KCk7XG4gICAgRGlzcGxheU5hbWVzLl9fZGVmYXVsdExvY2FsZSA9ICcnO1xuICAgIERpc3BsYXlOYW1lcy5wb2x5ZmlsbGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gRGlzcGxheU5hbWVzO1xufSgpKTtcbmV4cG9ydHMuRGlzcGxheU5hbWVzID0gRGlzcGxheU5hbWVzO1xuLy8gaHR0cHM6Ly90YzM5LmVzL3Byb3Bvc2FsLWludGwtZGlzcGxheW5hbWVzLyNzZWMtaXN2YWxpZGNvZGVmb3JkaXNwbGF5bmFtZXNcbmZ1bmN0aW9uIGlzVmFsaWRDb2RlRm9yRGlzcGxheU5hbWVzKHR5cGUsIGNvZGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnbGFuZ3VhZ2UnOlxuICAgICAgICAgICAgLy8gc3Vic2V0IG9mIHVuaWNvZGVfbGFuZ3VhZ2VfaWRcbiAgICAgICAgICAgIC8vIGxhbmd1YWdlQ29kZSBbXCItXCIgc2NyaXB0Q29kZV0gW1wiLVwiIHJlZ2lvbkNvZGVdICooXCItXCIgdmFyaWFudClcbiAgICAgICAgICAgIC8vIHdoZXJlOlxuICAgICAgICAgICAgLy8gLSBsYW5ndWFnZUNvZGUgaXMgZWl0aGVyIGEgdHdvIGxldHRlcnMgSVNPIDYzOS0xIGxhbmd1YWdlIGNvZGUgb3IgYSB0aHJlZSBsZXR0ZXJzIElTTyA2MzktMiBsYW5ndWFnZSBjb2RlLlxuICAgICAgICAgICAgLy8gLSBzY3JpcHRDb2RlIGlzIHNob3VsZCBiZSBhbiBJU08tMTU5MjQgZm91ciBsZXR0ZXJzIHNjcmlwdCBjb2RlXG4gICAgICAgICAgICAvLyAtIHJlZ2lvbkNvZGUgaXMgZWl0aGVyIGFuIElTTy0zMTY2IHR3byBsZXR0ZXJzIHJlZ2lvbiBjb2RlLCBvciBhIHRocmVlIGRpZ2l0cyBVTiBNNDkgR2VvZ3JhcGhpYyBSZWdpb25zLlxuICAgICAgICAgICAgcmV0dXJuIC9eW2Etel17MiwzfSgtW2Etel17NH0pPygtKFthLXpdezJ9fFxcZHszfSkpPygtKFthLXpcXGRdezUsOH18XFxkW2EtelxcZF17M30pKSokL2kudGVzdChjb2RlKTtcbiAgICAgICAgY2FzZSAncmVnaW9uJzpcbiAgICAgICAgICAgIC8vIHVuaWNvZGVfcmVnaW9uX3N1YnRhZ1xuICAgICAgICAgICAgcmV0dXJuIC9eKFthLXpdezJ9fFxcZHszfSkkL2kudGVzdChjb2RlKTtcbiAgICAgICAgY2FzZSAnc2NyaXB0JzpcbiAgICAgICAgICAgIC8vIHVuaWNvZGVfc2NyaXB0X3N1YnRhZ1xuICAgICAgICAgICAgcmV0dXJuIC9eW2Etel17NH0kL2kudGVzdChjb2RlKTtcbiAgICAgICAgY2FzZSAnY3VycmVuY3knOlxuICAgICAgICAgICAgcmV0dXJuIGVjbWE0MDJfYWJzdHJhY3RfMS5Jc1dlbGxGb3JtZWRDdXJyZW5jeUNvZGUoY29kZSk7XG4gICAgfVxufVxudHJ5IHtcbiAgICAvLyBJRTExIGRvZXMgbm90IGhhdmUgU3ltYm9sXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlzcGxheU5hbWVzLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICB2YWx1ZTogJ0ludGwuRGlzcGxheU5hbWVzJyxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpc3BsYXlOYW1lcywgJ2xlbmd0aCcsIHtcbiAgICAgICAgdmFsdWU6IDIsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB9KTtcbn1cbmNhdGNoIChlKSB7XG4gICAgLy8gTWFrZSB0ZXN0IDI2MiBjb21wbGlhbnRcbn1cbnZhciBfX0lOVEVSTkFMX1NMT1RfTUFQX18gPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gZ2V0U2xvdChpbnN0YW5jZSwga2V5KSB7XG4gICAgcmV0dXJuIGVjbWE0MDJfYWJzdHJhY3RfMS5nZXRJbnRlcm5hbFNsb3QoX19JTlRFUk5BTF9TTE9UX01BUF9fLCBpbnN0YW5jZSwga2V5KTtcbn1cbmZ1bmN0aW9uIHNldFNsb3QoaW5zdGFuY2UsIGtleSwgdmFsdWUpIHtcbiAgICBlY21hNDAyX2Fic3RyYWN0XzEuc2V0SW50ZXJuYWxTbG90KF9fSU5URVJOQUxfU0xPVF9NQVBfXywgaW5zdGFuY2UsIGtleSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gY2hlY2tSZWNlaXZlcihyZWNlaXZlciwgbWV0aG9kTmFtZSkge1xuICAgIGlmICghKHJlY2VpdmVyIGluc3RhbmNlb2YgRGlzcGxheU5hbWVzKSkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJNZXRob2QgSW50bC5EaXNwbGF5TmFtZXMucHJvdG90eXBlLlwiICsgbWV0aG9kTmFtZSArIFwiIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgcmVjZWl2ZXJcIik7XG4gICAgfVxufVxuIiwiLyogQGdlbmVyYXRlZCAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5pZiAoSW50bC5EaXNwbGF5TmFtZXMgJiYgdHlwZW9mIEludGwuRGlzcGxheU5hbWVzLl9fYWRkTG9jYWxlRGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICBJbnRsLkRpc3BsYXlOYW1lcy5fX2FkZExvY2FsZURhdGEoe1wiZGF0YVwiOntcInR5cGVzXCI6e1wibGFuZ3VhZ2VcIjp7XCJsb25nXCI6e1wiYWFcIjpcIkFmYXJcIixcImFiXCI6XCJBYmtoYXppYW5cIixcImFjZVwiOlwiQWNoaW5lc2VcIixcImFjaFwiOlwiQWNvbGlcIixcImFkYVwiOlwiQWRhbmdtZVwiLFwiYWR5XCI6XCJBZHlnaGVcIixcImFlXCI6XCJBdmVzdGFuXCIsXCJhZWJcIjpcIlR1bmlzaWFuIEFyYWJpY1wiLFwiYWZcIjpcIkFmcmlrYWFuc1wiLFwiYWZoXCI6XCJBZnJpaGlsaVwiLFwiYWdxXCI6XCJBZ2hlbVwiLFwiYWluXCI6XCJBaW51XCIsXCJha1wiOlwiQWthblwiLFwiYWtrXCI6XCJBa2thZGlhblwiLFwiYWt6XCI6XCJBbGFiYW1hXCIsXCJhbGVcIjpcIkFsZXV0XCIsXCJhbG5cIjpcIkdoZWcgQWxiYW5pYW5cIixcImFsdFwiOlwiU291dGhlcm4gQWx0YWlcIixcImFtXCI6XCJBbWhhcmljXCIsXCJhblwiOlwiQXJhZ29uZXNlXCIsXCJhbmdcIjpcIk9sZCBFbmdsaXNoXCIsXCJhbnBcIjpcIkFuZ2lrYVwiLFwiYXJcIjpcIkFyYWJpY1wiLFwiYXItMDAxXCI6XCJNb2Rlcm4gU3RhbmRhcmQgQXJhYmljXCIsXCJhcmNcIjpcIkFyYW1haWNcIixcImFyblwiOlwiTWFwdWNoZVwiLFwiYXJvXCI6XCJBcmFvbmFcIixcImFycFwiOlwiQXJhcGFob1wiLFwiYXJxXCI6XCJBbGdlcmlhbiBBcmFiaWNcIixcImFyc1wiOlwiTmFqZGkgQXJhYmljXCIsXCJhcndcIjpcIkFyYXdha1wiLFwiYXJ5XCI6XCJNb3JvY2NhbiBBcmFiaWNcIixcImFyelwiOlwiRWd5cHRpYW4gQXJhYmljXCIsXCJhc1wiOlwiQXNzYW1lc2VcIixcImFzYVwiOlwiQXN1XCIsXCJhc2VcIjpcIkFtZXJpY2FuIFNpZ24gTGFuZ3VhZ2VcIixcImFzdFwiOlwiQXN0dXJpYW5cIixcImF2XCI6XCJBdmFyaWNcIixcImF2a1wiOlwiS290YXZhXCIsXCJhd2FcIjpcIkF3YWRoaVwiLFwiYXlcIjpcIkF5bWFyYVwiLFwiYXpcIjpcIkF6ZXJiYWlqYW5pXCIsXCJiYVwiOlwiQmFzaGtpclwiLFwiYmFsXCI6XCJCYWx1Y2hpXCIsXCJiYW5cIjpcIkJhbGluZXNlXCIsXCJiYXJcIjpcIkJhdmFyaWFuXCIsXCJiYXNcIjpcIkJhc2FhXCIsXCJiYXhcIjpcIkJhbXVuXCIsXCJiYmNcIjpcIkJhdGFrIFRvYmFcIixcImJialwiOlwiR2hvbWFsYVwiLFwiYmVcIjpcIkJlbGFydXNpYW5cIixcImJlalwiOlwiQmVqYVwiLFwiYmVtXCI6XCJCZW1iYVwiLFwiYmV3XCI6XCJCZXRhd2lcIixcImJlelwiOlwiQmVuYVwiLFwiYmZkXCI6XCJCYWZ1dFwiLFwiYmZxXCI6XCJCYWRhZ2FcIixcImJnXCI6XCJCdWxnYXJpYW5cIixcImJnblwiOlwiV2VzdGVybiBCYWxvY2hpXCIsXCJiaG9cIjpcIkJob2pwdXJpXCIsXCJiaVwiOlwiQmlzbGFtYVwiLFwiYmlrXCI6XCJCaWtvbFwiLFwiYmluXCI6XCJCaW5pXCIsXCJiam5cIjpcIkJhbmphclwiLFwiYmttXCI6XCJLb21cIixcImJsYVwiOlwiU2lrc2lrYVwiLFwiYm1cIjpcIkJhbWJhcmFcIixcImJuXCI6XCJCYW5nbGFcIixcImJvXCI6XCJUaWJldGFuXCIsXCJicHlcIjpcIkJpc2hudXByaXlhXCIsXCJicWlcIjpcIkJha2h0aWFyaVwiLFwiYnJcIjpcIkJyZXRvblwiLFwiYnJhXCI6XCJCcmFqXCIsXCJicmhcIjpcIkJyYWh1aVwiLFwiYnJ4XCI6XCJCb2RvXCIsXCJic1wiOlwiQm9zbmlhblwiLFwiYnNzXCI6XCJBa29vc2VcIixcImJ1YVwiOlwiQnVyaWF0XCIsXCJidWdcIjpcIkJ1Z2luZXNlXCIsXCJidW1cIjpcIkJ1bHVcIixcImJ5blwiOlwiQmxpblwiLFwiYnl2XCI6XCJNZWR1bWJhXCIsXCJjYVwiOlwiQ2F0YWxhblwiLFwiY2FkXCI6XCJDYWRkb1wiLFwiY2FyXCI6XCJDYXJpYlwiLFwiY2F5XCI6XCJDYXl1Z2FcIixcImNjaFwiOlwiQXRzYW1cIixcImNjcFwiOlwiQ2hha21hXCIsXCJjZVwiOlwiQ2hlY2hlblwiLFwiY2ViXCI6XCJDZWJ1YW5vXCIsXCJjZ2dcIjpcIkNoaWdhXCIsXCJjaFwiOlwiQ2hhbW9ycm9cIixcImNoYlwiOlwiQ2hpYmNoYVwiLFwiY2hnXCI6XCJDaGFnYXRhaVwiLFwiY2hrXCI6XCJDaHV1a2VzZVwiLFwiY2htXCI6XCJNYXJpXCIsXCJjaG5cIjpcIkNoaW5vb2sgSmFyZ29uXCIsXCJjaG9cIjpcIkNob2N0YXdcIixcImNocFwiOlwiQ2hpcGV3eWFuXCIsXCJjaHJcIjpcIkNoZXJva2VlXCIsXCJjaHlcIjpcIkNoZXllbm5lXCIsXCJjaWNcIjpcIkNoaWNrYXNhd1wiLFwiY2tiXCI6XCJDZW50cmFsIEt1cmRpc2hcIixcImNvXCI6XCJDb3JzaWNhblwiLFwiY29wXCI6XCJDb3B0aWNcIixcImNwc1wiOlwiQ2FwaXpub25cIixcImNyXCI6XCJDcmVlXCIsXCJjcmhcIjpcIkNyaW1lYW4gVHVya2lzaFwiLFwiY3JzXCI6XCJTZXNlbHdhIENyZW9sZSBGcmVuY2hcIixcImNzXCI6XCJDemVjaFwiLFwiY3NiXCI6XCJLYXNodWJpYW5cIixcImN1XCI6XCJDaHVyY2ggU2xhdmljXCIsXCJjdlwiOlwiQ2h1dmFzaFwiLFwiY3lcIjpcIldlbHNoXCIsXCJkYVwiOlwiRGFuaXNoXCIsXCJkYWtcIjpcIkRha290YVwiLFwiZGFyXCI6XCJEYXJnd2FcIixcImRhdlwiOlwiVGFpdGFcIixcImRlXCI6XCJHZXJtYW5cIixcImRlLUFUXCI6XCJBdXN0cmlhbiBHZXJtYW5cIixcImRlLUNIXCI6XCJTd2lzcyBIaWdoIEdlcm1hblwiLFwiZGVsXCI6XCJEZWxhd2FyZVwiLFwiZGVuXCI6XCJTbGF2ZVwiLFwiZGdyXCI6XCJEb2dyaWJcIixcImRpblwiOlwiRGlua2FcIixcImRqZVwiOlwiWmFybWFcIixcImRvaVwiOlwiRG9ncmlcIixcImRzYlwiOlwiTG93ZXIgU29yYmlhblwiLFwiZHRwXCI6XCJDZW50cmFsIER1c3VuXCIsXCJkdWFcIjpcIkR1YWxhXCIsXCJkdW1cIjpcIk1pZGRsZSBEdXRjaFwiLFwiZHZcIjpcIkRpdmVoaVwiLFwiZHlvXCI6XCJKb2xhLUZvbnlpXCIsXCJkeXVcIjpcIkR5dWxhXCIsXCJkelwiOlwiRHpvbmdraGFcIixcImR6Z1wiOlwiRGF6YWdhXCIsXCJlYnVcIjpcIkVtYnVcIixcImVlXCI6XCJFd2VcIixcImVmaVwiOlwiRWZpa1wiLFwiZWdsXCI6XCJFbWlsaWFuXCIsXCJlZ3lcIjpcIkFuY2llbnQgRWd5cHRpYW5cIixcImVrYVwiOlwiRWthanVrXCIsXCJlbFwiOlwiR3JlZWtcIixcImVseFwiOlwiRWxhbWl0ZVwiLFwiZW5cIjpcIkVuZ2xpc2hcIixcImVuLUFVXCI6XCJBdXN0cmFsaWFuIEVuZ2xpc2hcIixcImVuLUNBXCI6XCJDYW5hZGlhbiBFbmdsaXNoXCIsXCJlbi1HQlwiOlwiQnJpdGlzaCBFbmdsaXNoXCIsXCJlbi1VU1wiOlwiQW1lcmljYW4gRW5nbGlzaFwiLFwiZW5tXCI6XCJNaWRkbGUgRW5nbGlzaFwiLFwiZW9cIjpcIkVzcGVyYW50b1wiLFwiZXNcIjpcIlNwYW5pc2hcIixcImVzLTQxOVwiOlwiTGF0aW4gQW1lcmljYW4gU3BhbmlzaFwiLFwiZXMtRVNcIjpcIkV1cm9wZWFuIFNwYW5pc2hcIixcImVzLU1YXCI6XCJNZXhpY2FuIFNwYW5pc2hcIixcImVzdVwiOlwiQ2VudHJhbCBZdXBpa1wiLFwiZXRcIjpcIkVzdG9uaWFuXCIsXCJldVwiOlwiQmFzcXVlXCIsXCJld29cIjpcIkV3b25kb1wiLFwiZXh0XCI6XCJFeHRyZW1hZHVyYW5cIixcImZhXCI6XCJQZXJzaWFuXCIsXCJmYS1BRlwiOlwiRGFyaVwiLFwiZmFuXCI6XCJGYW5nXCIsXCJmYXRcIjpcIkZhbnRpXCIsXCJmZlwiOlwiRnVsYWhcIixcImZpXCI6XCJGaW5uaXNoXCIsXCJmaWxcIjpcIkZpbGlwaW5vXCIsXCJmaXRcIjpcIlRvcm5lZGFsZW4gRmlubmlzaFwiLFwiZmpcIjpcIkZpamlhblwiLFwiZm9cIjpcIkZhcm9lc2VcIixcImZvblwiOlwiRm9uXCIsXCJmclwiOlwiRnJlbmNoXCIsXCJmci1DQVwiOlwiQ2FuYWRpYW4gRnJlbmNoXCIsXCJmci1DSFwiOlwiU3dpc3MgRnJlbmNoXCIsXCJmcmNcIjpcIkNhanVuIEZyZW5jaFwiLFwiZnJtXCI6XCJNaWRkbGUgRnJlbmNoXCIsXCJmcm9cIjpcIk9sZCBGcmVuY2hcIixcImZycFwiOlwiQXJwaXRhblwiLFwiZnJyXCI6XCJOb3J0aGVybiBGcmlzaWFuXCIsXCJmcnNcIjpcIkVhc3Rlcm4gRnJpc2lhblwiLFwiZnVyXCI6XCJGcml1bGlhblwiLFwiZnlcIjpcIldlc3Rlcm4gRnJpc2lhblwiLFwiZ2FcIjpcIklyaXNoXCIsXCJnYWFcIjpcIkdhXCIsXCJnYWdcIjpcIkdhZ2F1elwiLFwiZ2FuXCI6XCJHYW4gQ2hpbmVzZVwiLFwiZ2F5XCI6XCJHYXlvXCIsXCJnYmFcIjpcIkdiYXlhXCIsXCJnYnpcIjpcIlpvcm9hc3RyaWFuIERhcmlcIixcImdkXCI6XCJTY290dGlzaCBHYWVsaWNcIixcImdlelwiOlwiR2VlelwiLFwiZ2lsXCI6XCJHaWxiZXJ0ZXNlXCIsXCJnbFwiOlwiR2FsaWNpYW5cIixcImdsa1wiOlwiR2lsYWtpXCIsXCJnbWhcIjpcIk1pZGRsZSBIaWdoIEdlcm1hblwiLFwiZ25cIjpcIkd1YXJhbmlcIixcImdvaFwiOlwiT2xkIEhpZ2ggR2VybWFuXCIsXCJnb21cIjpcIkdvYW4gS29ua2FuaVwiLFwiZ29uXCI6XCJHb25kaVwiLFwiZ29yXCI6XCJHb3JvbnRhbG9cIixcImdvdFwiOlwiR290aGljXCIsXCJncmJcIjpcIkdyZWJvXCIsXCJncmNcIjpcIkFuY2llbnQgR3JlZWtcIixcImdzd1wiOlwiU3dpc3MgR2VybWFuXCIsXCJndVwiOlwiR3VqYXJhdGlcIixcImd1Y1wiOlwiV2F5dXVcIixcImd1clwiOlwiRnJhZnJhXCIsXCJndXpcIjpcIkd1c2lpXCIsXCJndlwiOlwiTWFueFwiLFwiZ3dpXCI6XCJHd2ljaMq8aW5cIixcImhhXCI6XCJIYXVzYVwiLFwiaGFpXCI6XCJIYWlkYVwiLFwiaGFrXCI6XCJIYWtrYSBDaGluZXNlXCIsXCJoYXdcIjpcIkhhd2FpaWFuXCIsXCJoZVwiOlwiSGVicmV3XCIsXCJoaVwiOlwiSGluZGlcIixcImhpZlwiOlwiRmlqaSBIaW5kaVwiLFwiaGlsXCI6XCJIaWxpZ2F5bm9uXCIsXCJoaXRcIjpcIkhpdHRpdGVcIixcImhtblwiOlwiSG1vbmdcIixcImhvXCI6XCJIaXJpIE1vdHVcIixcImhyXCI6XCJDcm9hdGlhblwiLFwiaHNiXCI6XCJVcHBlciBTb3JiaWFuXCIsXCJoc25cIjpcIlhpYW5nIENoaW5lc2VcIixcImh0XCI6XCJIYWl0aWFuIENyZW9sZVwiLFwiaHVcIjpcIkh1bmdhcmlhblwiLFwiaHVwXCI6XCJIdXBhXCIsXCJoeVwiOlwiQXJtZW5pYW5cIixcImh6XCI6XCJIZXJlcm9cIixcImlhXCI6XCJJbnRlcmxpbmd1YVwiLFwiaWJhXCI6XCJJYmFuXCIsXCJpYmJcIjpcIkliaWJpb1wiLFwiaWRcIjpcIkluZG9uZXNpYW5cIixcImllXCI6XCJJbnRlcmxpbmd1ZVwiLFwiaWdcIjpcIklnYm9cIixcImlpXCI6XCJTaWNodWFuIFlpXCIsXCJpa1wiOlwiSW51cGlhcVwiLFwiaWxvXCI6XCJJbG9rb1wiLFwiaW5oXCI6XCJJbmd1c2hcIixcImlvXCI6XCJJZG9cIixcImlzXCI6XCJJY2VsYW5kaWNcIixcIml0XCI6XCJJdGFsaWFuXCIsXCJpdVwiOlwiSW51a3RpdHV0XCIsXCJpemhcIjpcIkluZ3JpYW5cIixcImphXCI6XCJKYXBhbmVzZVwiLFwiamFtXCI6XCJKYW1haWNhbiBDcmVvbGUgRW5nbGlzaFwiLFwiamJvXCI6XCJMb2piYW5cIixcImpnb1wiOlwiTmdvbWJhXCIsXCJqbWNcIjpcIk1hY2hhbWVcIixcImpwclwiOlwiSnVkZW8tUGVyc2lhblwiLFwianJiXCI6XCJKdWRlby1BcmFiaWNcIixcImp1dFwiOlwiSnV0aXNoXCIsXCJqdlwiOlwiSmF2YW5lc2VcIixcImthXCI6XCJHZW9yZ2lhblwiLFwia2FhXCI6XCJLYXJhLUthbHBha1wiLFwia2FiXCI6XCJLYWJ5bGVcIixcImthY1wiOlwiS2FjaGluXCIsXCJrYWpcIjpcIkpqdVwiLFwia2FtXCI6XCJLYW1iYVwiLFwia2F3XCI6XCJLYXdpXCIsXCJrYmRcIjpcIkthYmFyZGlhblwiLFwia2JsXCI6XCJLYW5lbWJ1XCIsXCJrY2dcIjpcIlR5YXBcIixcImtkZVwiOlwiTWFrb25kZVwiLFwia2VhXCI6XCJLYWJ1dmVyZGlhbnVcIixcImtlblwiOlwiS2VueWFuZ1wiLFwia2ZvXCI6XCJLb3JvXCIsXCJrZ1wiOlwiS29uZ29cIixcImtncFwiOlwiS2FpbmdhbmdcIixcImtoYVwiOlwiS2hhc2lcIixcImtob1wiOlwiS2hvdGFuZXNlXCIsXCJraHFcIjpcIktveXJhIENoaWluaVwiLFwia2h3XCI6XCJLaG93YXJcIixcImtpXCI6XCJLaWt1eXVcIixcImtpdVwiOlwiS2lybWFuamtpXCIsXCJralwiOlwiS3VhbnlhbWFcIixcImtrXCI6XCJLYXpha2hcIixcImtralwiOlwiS2Frb1wiLFwia2xcIjpcIkthbGFhbGxpc3V0XCIsXCJrbG5cIjpcIkthbGVuamluXCIsXCJrbVwiOlwiS2htZXJcIixcImttYlwiOlwiS2ltYnVuZHVcIixcImtuXCI6XCJLYW5uYWRhXCIsXCJrb1wiOlwiS29yZWFuXCIsXCJrb2lcIjpcIktvbWktUGVybXlha1wiLFwia29rXCI6XCJLb25rYW5pXCIsXCJrb3NcIjpcIktvc3JhZWFuXCIsXCJrcGVcIjpcIktwZWxsZVwiLFwia3JcIjpcIkthbnVyaVwiLFwia3JjXCI6XCJLYXJhY2hheS1CYWxrYXJcIixcImtyaVwiOlwiS3Jpb1wiLFwia3JqXCI6XCJLaW5hcmF5LWFcIixcImtybFwiOlwiS2FyZWxpYW5cIixcImtydVwiOlwiS3VydWtoXCIsXCJrc1wiOlwiS2FzaG1pcmlcIixcImtzYlwiOlwiU2hhbWJhbGFcIixcImtzZlwiOlwiQmFmaWFcIixcImtzaFwiOlwiQ29sb2duaWFuXCIsXCJrdVwiOlwiS3VyZGlzaFwiLFwia3VtXCI6XCJLdW15a1wiLFwia3V0XCI6XCJLdXRlbmFpXCIsXCJrdlwiOlwiS29taVwiLFwia3dcIjpcIkNvcm5pc2hcIixcImt5XCI6XCJLeXJneXpcIixcImxhXCI6XCJMYXRpblwiLFwibGFkXCI6XCJMYWRpbm9cIixcImxhZ1wiOlwiTGFuZ2lcIixcImxhaFwiOlwiTGFobmRhXCIsXCJsYW1cIjpcIkxhbWJhXCIsXCJsYlwiOlwiTHV4ZW1ib3VyZ2lzaFwiLFwibGV6XCI6XCJMZXpnaGlhblwiLFwibGZuXCI6XCJMaW5ndWEgRnJhbmNhIE5vdmFcIixcImxnXCI6XCJHYW5kYVwiLFwibGlcIjpcIkxpbWJ1cmdpc2hcIixcImxpalwiOlwiTGlndXJpYW5cIixcImxpdlwiOlwiTGl2b25pYW5cIixcImxrdFwiOlwiTGFrb3RhXCIsXCJsbW9cIjpcIkxvbWJhcmRcIixcImxuXCI6XCJMaW5nYWxhXCIsXCJsb1wiOlwiTGFvXCIsXCJsb2xcIjpcIk1vbmdvXCIsXCJsb3VcIjpcIkxvdWlzaWFuYSBDcmVvbGVcIixcImxvelwiOlwiTG96aVwiLFwibHJjXCI6XCJOb3J0aGVybiBMdXJpXCIsXCJsdFwiOlwiTGl0aHVhbmlhblwiLFwibHRnXCI6XCJMYXRnYWxpYW5cIixcImx1XCI6XCJMdWJhLUthdGFuZ2FcIixcImx1YVwiOlwiTHViYS1MdWx1YVwiLFwibHVpXCI6XCJMdWlzZW5vXCIsXCJsdW5cIjpcIkx1bmRhXCIsXCJsdW9cIjpcIkx1b1wiLFwibHVzXCI6XCJNaXpvXCIsXCJsdXlcIjpcIkx1eWlhXCIsXCJsdlwiOlwiTGF0dmlhblwiLFwibHpoXCI6XCJMaXRlcmFyeSBDaGluZXNlXCIsXCJsenpcIjpcIkxhelwiLFwibWFkXCI6XCJNYWR1cmVzZVwiLFwibWFmXCI6XCJNYWZhXCIsXCJtYWdcIjpcIk1hZ2FoaVwiLFwibWFpXCI6XCJNYWl0aGlsaVwiLFwibWFrXCI6XCJNYWthc2FyXCIsXCJtYW5cIjpcIk1hbmRpbmdvXCIsXCJtYXNcIjpcIk1hc2FpXCIsXCJtZGVcIjpcIk1hYmFcIixcIm1kZlwiOlwiTW9rc2hhXCIsXCJtZHJcIjpcIk1hbmRhclwiLFwibWVuXCI6XCJNZW5kZVwiLFwibWVyXCI6XCJNZXJ1XCIsXCJtZmVcIjpcIk1vcmlzeWVuXCIsXCJtZ1wiOlwiTWFsYWdhc3lcIixcIm1nYVwiOlwiTWlkZGxlIElyaXNoXCIsXCJtZ2hcIjpcIk1ha2h1d2EtTWVldHRvXCIsXCJtZ29cIjpcIk1ldGHKvFwiLFwibWhcIjpcIk1hcnNoYWxsZXNlXCIsXCJtaVwiOlwiTWFvcmlcIixcIm1pY1wiOlwiTWkna21hcVwiLFwibWluXCI6XCJNaW5hbmdrYWJhdVwiLFwibWtcIjpcIk1hY2Vkb25pYW5cIixcIm1sXCI6XCJNYWxheWFsYW1cIixcIm1uXCI6XCJNb25nb2xpYW5cIixcIm1uY1wiOlwiTWFuY2h1XCIsXCJtbmlcIjpcIk1hbmlwdXJpXCIsXCJtb2hcIjpcIk1vaGF3a1wiLFwibW9zXCI6XCJNb3NzaVwiLFwibXJcIjpcIk1hcmF0aGlcIixcIm1yalwiOlwiV2VzdGVybiBNYXJpXCIsXCJtc1wiOlwiTWFsYXlcIixcIm10XCI6XCJNYWx0ZXNlXCIsXCJtdWFcIjpcIk11bmRhbmdcIixcIm11bFwiOlwiTXVsdGlwbGUgbGFuZ3VhZ2VzXCIsXCJtdXNcIjpcIk11c2NvZ2VlXCIsXCJtd2xcIjpcIk1pcmFuZGVzZVwiLFwibXdyXCI6XCJNYXJ3YXJpXCIsXCJtd3ZcIjpcIk1lbnRhd2FpXCIsXCJteVwiOlwiQnVybWVzZVwiLFwibXllXCI6XCJNeWVuZVwiLFwibXl2XCI6XCJFcnp5YVwiLFwibXpuXCI6XCJNYXphbmRlcmFuaVwiLFwibmFcIjpcIk5hdXJ1XCIsXCJuYW5cIjpcIk1pbiBOYW4gQ2hpbmVzZVwiLFwibmFwXCI6XCJOZWFwb2xpdGFuXCIsXCJuYXFcIjpcIk5hbWFcIixcIm5iXCI6XCJOb3J3ZWdpYW4gQm9rbcOlbFwiLFwibmRcIjpcIk5vcnRoIE5kZWJlbGVcIixcIm5kc1wiOlwiTG93IEdlcm1hblwiLFwibmRzLU5MXCI6XCJMb3cgU2F4b25cIixcIm5lXCI6XCJOZXBhbGlcIixcIm5ld1wiOlwiTmV3YXJpXCIsXCJuZ1wiOlwiTmRvbmdhXCIsXCJuaWFcIjpcIk5pYXNcIixcIm5pdVwiOlwiTml1ZWFuXCIsXCJuam9cIjpcIkFvIE5hZ2FcIixcIm5sXCI6XCJEdXRjaFwiLFwibmwtQkVcIjpcIkZsZW1pc2hcIixcIm5tZ1wiOlwiS3dhc2lvXCIsXCJublwiOlwiTm9yd2VnaWFuIE55bm9yc2tcIixcIm5uaFwiOlwiTmdpZW1ib29uXCIsXCJub1wiOlwiTm9yd2VnaWFuXCIsXCJub2dcIjpcIk5vZ2FpXCIsXCJub25cIjpcIk9sZCBOb3JzZVwiLFwibm92XCI6XCJOb3ZpYWxcIixcIm5xb1wiOlwiTuKAmUtvXCIsXCJuclwiOlwiU291dGggTmRlYmVsZVwiLFwibnNvXCI6XCJOb3J0aGVybiBTb3Rob1wiLFwibnVzXCI6XCJOdWVyXCIsXCJudlwiOlwiTmF2YWpvXCIsXCJud2NcIjpcIkNsYXNzaWNhbCBOZXdhcmlcIixcIm55XCI6XCJOeWFuamFcIixcIm55bVwiOlwiTnlhbXdlemlcIixcIm55blwiOlwiTnlhbmtvbGVcIixcIm55b1wiOlwiTnlvcm9cIixcIm56aVwiOlwiTnppbWFcIixcIm9jXCI6XCJPY2NpdGFuXCIsXCJvalwiOlwiT2ppYndhXCIsXCJvbVwiOlwiT3JvbW9cIixcIm9yXCI6XCJPZGlhXCIsXCJvc1wiOlwiT3NzZXRpY1wiLFwib3NhXCI6XCJPc2FnZVwiLFwib3RhXCI6XCJPdHRvbWFuIFR1cmtpc2hcIixcInBhXCI6XCJQdW5qYWJpXCIsXCJwYWdcIjpcIlBhbmdhc2luYW5cIixcInBhbFwiOlwiUGFobGF2aVwiLFwicGFtXCI6XCJQYW1wYW5nYVwiLFwicGFwXCI6XCJQYXBpYW1lbnRvXCIsXCJwYXVcIjpcIlBhbGF1YW5cIixcInBjZFwiOlwiUGljYXJkXCIsXCJwY21cIjpcIk5pZ2VyaWFuIFBpZGdpblwiLFwicGRjXCI6XCJQZW5uc3lsdmFuaWEgR2VybWFuXCIsXCJwZHRcIjpcIlBsYXV0ZGlldHNjaFwiLFwicGVvXCI6XCJPbGQgUGVyc2lhblwiLFwicGZsXCI6XCJQYWxhdGluZSBHZXJtYW5cIixcInBoblwiOlwiUGhvZW5pY2lhblwiLFwicGlcIjpcIlBhbGlcIixcInBsXCI6XCJQb2xpc2hcIixcInBtc1wiOlwiUGllZG1vbnRlc2VcIixcInBudFwiOlwiUG9udGljXCIsXCJwb25cIjpcIlBvaG5wZWlhblwiLFwicHJnXCI6XCJQcnVzc2lhblwiLFwicHJvXCI6XCJPbGQgUHJvdmVuw6dhbFwiLFwicHNcIjpcIlBhc2h0b1wiLFwicHRcIjpcIlBvcnR1Z3Vlc2VcIixcInB0LUJSXCI6XCJCcmF6aWxpYW4gUG9ydHVndWVzZVwiLFwicHQtUFRcIjpcIkV1cm9wZWFuIFBvcnR1Z3Vlc2VcIixcInF1XCI6XCJRdWVjaHVhXCIsXCJxdWNcIjpcIkvKvGljaGXKvFwiLFwicXVnXCI6XCJDaGltYm9yYXpvIEhpZ2hsYW5kIFF1aWNodWFcIixcInJhalwiOlwiUmFqYXN0aGFuaVwiLFwicmFwXCI6XCJSYXBhbnVpXCIsXCJyYXJcIjpcIlJhcm90b25nYW5cIixcInJnblwiOlwiUm9tYWdub2xcIixcInJpZlwiOlwiUmlmZmlhblwiLFwicm1cIjpcIlJvbWFuc2hcIixcInJuXCI6XCJSdW5kaVwiLFwicm9cIjpcIlJvbWFuaWFuXCIsXCJyby1NRFwiOlwiTW9sZGF2aWFuXCIsXCJyb2ZcIjpcIlJvbWJvXCIsXCJyb21cIjpcIlJvbWFueVwiLFwicm9vdFwiOlwiUm9vdFwiLFwicnRtXCI6XCJSb3R1bWFuXCIsXCJydVwiOlwiUnVzc2lhblwiLFwicnVlXCI6XCJSdXN5blwiLFwicnVnXCI6XCJSb3ZpYW5hXCIsXCJydXBcIjpcIkFyb21hbmlhblwiLFwicndcIjpcIktpbnlhcndhbmRhXCIsXCJyd2tcIjpcIlJ3YVwiLFwic2FcIjpcIlNhbnNrcml0XCIsXCJzYWRcIjpcIlNhbmRhd2VcIixcInNhaFwiOlwiU2FraGFcIixcInNhbVwiOlwiU2FtYXJpdGFuIEFyYW1haWNcIixcInNhcVwiOlwiU2FtYnVydVwiLFwic2FzXCI6XCJTYXNha1wiLFwic2F0XCI6XCJTYW50YWxpXCIsXCJzYXpcIjpcIlNhdXJhc2h0cmFcIixcInNiYVwiOlwiTmdhbWJheVwiLFwic2JwXCI6XCJTYW5ndVwiLFwic2NcIjpcIlNhcmRpbmlhblwiLFwic2NuXCI6XCJTaWNpbGlhblwiLFwic2NvXCI6XCJTY290c1wiLFwic2RcIjpcIlNpbmRoaVwiLFwic2RjXCI6XCJTYXNzYXJlc2UgU2FyZGluaWFuXCIsXCJzZGhcIjpcIlNvdXRoZXJuIEt1cmRpc2hcIixcInNlXCI6XCJOb3J0aGVybiBTYW1pXCIsXCJzZWVcIjpcIlNlbmVjYVwiLFwic2VoXCI6XCJTZW5hXCIsXCJzZWlcIjpcIlNlcmlcIixcInNlbFwiOlwiU2Vsa3VwXCIsXCJzZXNcIjpcIktveXJhYm9ybyBTZW5uaVwiLFwic2dcIjpcIlNhbmdvXCIsXCJzZ2FcIjpcIk9sZCBJcmlzaFwiLFwic2dzXCI6XCJTYW1vZ2l0aWFuXCIsXCJzaFwiOlwiU2VyYm8tQ3JvYXRpYW5cIixcInNoaVwiOlwiVGFjaGVsaGl0XCIsXCJzaG5cIjpcIlNoYW5cIixcInNodVwiOlwiQ2hhZGlhbiBBcmFiaWNcIixcInNpXCI6XCJTaW5oYWxhXCIsXCJzaWRcIjpcIlNpZGFtb1wiLFwic2tcIjpcIlNsb3Zha1wiLFwic2xcIjpcIlNsb3ZlbmlhblwiLFwic2xpXCI6XCJMb3dlciBTaWxlc2lhblwiLFwic2x5XCI6XCJTZWxheWFyXCIsXCJzbVwiOlwiU2Ftb2FuXCIsXCJzbWFcIjpcIlNvdXRoZXJuIFNhbWlcIixcInNtalwiOlwiTHVsZSBTYW1pXCIsXCJzbW5cIjpcIkluYXJpIFNhbWlcIixcInNtc1wiOlwiU2tvbHQgU2FtaVwiLFwic25cIjpcIlNob25hXCIsXCJzbmtcIjpcIlNvbmlua2VcIixcInNvXCI6XCJTb21hbGlcIixcInNvZ1wiOlwiU29nZGllblwiLFwic3FcIjpcIkFsYmFuaWFuXCIsXCJzclwiOlwiU2VyYmlhblwiLFwic3ItTUVcIjpcIk1vbnRlbmVncmluXCIsXCJzcm5cIjpcIlNyYW5hbiBUb25nb1wiLFwic3JyXCI6XCJTZXJlclwiLFwic3NcIjpcIlN3YXRpXCIsXCJzc3lcIjpcIlNhaG9cIixcInN0XCI6XCJTb3V0aGVybiBTb3Rob1wiLFwic3RxXCI6XCJTYXRlcmxhbmQgRnJpc2lhblwiLFwic3VcIjpcIlN1bmRhbmVzZVwiLFwic3VrXCI6XCJTdWt1bWFcIixcInN1c1wiOlwiU3VzdVwiLFwic3V4XCI6XCJTdW1lcmlhblwiLFwic3ZcIjpcIlN3ZWRpc2hcIixcInN3XCI6XCJTd2FoaWxpXCIsXCJzdy1DRFwiOlwiQ29uZ28gU3dhaGlsaVwiLFwic3diXCI6XCJDb21vcmlhblwiLFwic3ljXCI6XCJDbGFzc2ljYWwgU3lyaWFjXCIsXCJzeXJcIjpcIlN5cmlhY1wiLFwic3psXCI6XCJTaWxlc2lhblwiLFwidGFcIjpcIlRhbWlsXCIsXCJ0Y3lcIjpcIlR1bHVcIixcInRlXCI6XCJUZWx1Z3VcIixcInRlbVwiOlwiVGltbmVcIixcInRlb1wiOlwiVGVzb1wiLFwidGVyXCI6XCJUZXJlbm9cIixcInRldFwiOlwiVGV0dW1cIixcInRnXCI6XCJUYWppa1wiLFwidGhcIjpcIlRoYWlcIixcInRpXCI6XCJUaWdyaW55YVwiLFwidGlnXCI6XCJUaWdyZVwiLFwidGl2XCI6XCJUaXZcIixcInRrXCI6XCJUdXJrbWVuXCIsXCJ0a2xcIjpcIlRva2VsYXVcIixcInRrclwiOlwiVHNha2h1clwiLFwidGxcIjpcIlRhZ2Fsb2dcIixcInRsaFwiOlwiS2xpbmdvblwiLFwidGxpXCI6XCJUbGluZ2l0XCIsXCJ0bHlcIjpcIlRhbHlzaFwiLFwidG1oXCI6XCJUYW1hc2hla1wiLFwidG5cIjpcIlRzd2FuYVwiLFwidG9cIjpcIlRvbmdhblwiLFwidG9nXCI6XCJOeWFzYSBUb25nYVwiLFwidHBpXCI6XCJUb2sgUGlzaW5cIixcInRyXCI6XCJUdXJraXNoXCIsXCJ0cnVcIjpcIlR1cm95b1wiLFwidHJ2XCI6XCJUYXJva29cIixcInRzXCI6XCJUc29uZ2FcIixcInRzZFwiOlwiVHNha29uaWFuXCIsXCJ0c2lcIjpcIlRzaW1zaGlhblwiLFwidHRcIjpcIlRhdGFyXCIsXCJ0dHRcIjpcIk11c2xpbSBUYXRcIixcInR1bVwiOlwiVHVtYnVrYVwiLFwidHZsXCI6XCJUdXZhbHVcIixcInR3XCI6XCJUd2lcIixcInR3cVwiOlwiVGFzYXdhcVwiLFwidHlcIjpcIlRhaGl0aWFuXCIsXCJ0eXZcIjpcIlR1dmluaWFuXCIsXCJ0em1cIjpcIkNlbnRyYWwgQXRsYXMgVGFtYXppZ2h0XCIsXCJ1ZG1cIjpcIlVkbXVydFwiLFwidWdcIjpcIlV5Z2h1clwiLFwidWdhXCI6XCJVZ2FyaXRpY1wiLFwidWtcIjpcIlVrcmFpbmlhblwiLFwidW1iXCI6XCJVbWJ1bmR1XCIsXCJ1bmRcIjpcIlVua25vd24gbGFuZ3VhZ2VcIixcInVyXCI6XCJVcmR1XCIsXCJ1elwiOlwiVXpiZWtcIixcInZhaVwiOlwiVmFpXCIsXCJ2ZVwiOlwiVmVuZGFcIixcInZlY1wiOlwiVmVuZXRpYW5cIixcInZlcFwiOlwiVmVwc1wiLFwidmlcIjpcIlZpZXRuYW1lc2VcIixcInZsc1wiOlwiV2VzdCBGbGVtaXNoXCIsXCJ2bWZcIjpcIk1haW4tRnJhbmNvbmlhblwiLFwidm9cIjpcIlZvbGFww7xrXCIsXCJ2b3RcIjpcIlZvdGljXCIsXCJ2cm9cIjpcIlbDtXJvXCIsXCJ2dW5cIjpcIlZ1bmpvXCIsXCJ3YVwiOlwiV2FsbG9vblwiLFwid2FlXCI6XCJXYWxzZXJcIixcIndhbFwiOlwiV29sYXl0dGFcIixcIndhclwiOlwiV2FyYXlcIixcIndhc1wiOlwiV2FzaG9cIixcIndicFwiOlwiV2FybHBpcmlcIixcIndvXCI6XCJXb2xvZlwiLFwid3V1XCI6XCJXdSBDaGluZXNlXCIsXCJ4YWxcIjpcIkthbG15a1wiLFwieGhcIjpcIlhob3NhXCIsXCJ4bWZcIjpcIk1pbmdyZWxpYW5cIixcInhvZ1wiOlwiU29nYVwiLFwieWFvXCI6XCJZYW9cIixcInlhcFwiOlwiWWFwZXNlXCIsXCJ5YXZcIjpcIllhbmdiZW5cIixcInliYlwiOlwiWWVtYmFcIixcInlpXCI6XCJZaWRkaXNoXCIsXCJ5b1wiOlwiWW9ydWJhXCIsXCJ5cmxcIjpcIk5oZWVuZ2F0dVwiLFwieXVlXCI6XCJDYW50b25lc2VcIixcInphXCI6XCJaaHVhbmdcIixcInphcFwiOlwiWmFwb3RlY1wiLFwiemJsXCI6XCJCbGlzc3ltYm9sc1wiLFwiemVhXCI6XCJaZWVsYW5kaWNcIixcInplblwiOlwiWmVuYWdhXCIsXCJ6Z2hcIjpcIlN0YW5kYXJkIE1vcm9jY2FuIFRhbWF6aWdodFwiLFwiemhcIjpcIkNoaW5lc2VcIixcInpoLUhhbnNcIjpcIlNpbXBsaWZpZWQgQ2hpbmVzZVwiLFwiemgtSGFudFwiOlwiVHJhZGl0aW9uYWwgQ2hpbmVzZVwiLFwienVcIjpcIlp1bHVcIixcInp1blwiOlwiWnVuaVwiLFwienh4XCI6XCJObyBsaW5ndWlzdGljIGNvbnRlbnRcIixcInp6YVwiOlwiWmF6YVwifSxcInNob3J0XCI6e1wiYXpcIjpcIkF6ZXJpXCIsXCJlbi1HQlwiOlwiVUsgRW5nbGlzaFwiLFwiZW4tVVNcIjpcIlVTIEVuZ2xpc2hcIn0sXCJuYXJyb3dcIjp7fX0sXCJyZWdpb25cIjp7XCJsb25nXCI6e1wiMTQyXCI6XCJBc2lhXCIsXCIxNDNcIjpcIkNlbnRyYWwgQXNpYVwiLFwiMTQ1XCI6XCJXZXN0ZXJuIEFzaWFcIixcIjE1MFwiOlwiRXVyb3BlXCIsXCIxNTFcIjpcIkVhc3Rlcm4gRXVyb3BlXCIsXCIxNTRcIjpcIk5vcnRoZXJuIEV1cm9wZVwiLFwiMTU1XCI6XCJXZXN0ZXJuIEV1cm9wZVwiLFwiMjAyXCI6XCJTdWItU2FoYXJhbiBBZnJpY2FcIixcIjQxOVwiOlwiTGF0aW4gQW1lcmljYVwiLFwiMDAxXCI6XCJXb3JsZFwiLFwiMDAyXCI6XCJBZnJpY2FcIixcIjAwM1wiOlwiTm9ydGggQW1lcmljYVwiLFwiMDA1XCI6XCJTb3V0aCBBbWVyaWNhXCIsXCIwMDlcIjpcIk9jZWFuaWFcIixcIjAxMVwiOlwiV2VzdGVybiBBZnJpY2FcIixcIjAxM1wiOlwiQ2VudHJhbCBBbWVyaWNhXCIsXCIwMTRcIjpcIkVhc3Rlcm4gQWZyaWNhXCIsXCIwMTVcIjpcIk5vcnRoZXJuIEFmcmljYVwiLFwiMDE3XCI6XCJNaWRkbGUgQWZyaWNhXCIsXCIwMThcIjpcIlNvdXRoZXJuIEFmcmljYVwiLFwiMDE5XCI6XCJBbWVyaWNhc1wiLFwiMDIxXCI6XCJOb3J0aGVybiBBbWVyaWNhXCIsXCIwMjlcIjpcIkNhcmliYmVhblwiLFwiMDMwXCI6XCJFYXN0ZXJuIEFzaWFcIixcIjAzNFwiOlwiU291dGhlcm4gQXNpYVwiLFwiMDM1XCI6XCJTb3V0aGVhc3QgQXNpYVwiLFwiMDM5XCI6XCJTb3V0aGVybiBFdXJvcGVcIixcIjA1M1wiOlwiQXVzdHJhbGFzaWFcIixcIjA1NFwiOlwiTWVsYW5lc2lhXCIsXCIwNTdcIjpcIk1pY3JvbmVzaWFuIFJlZ2lvblwiLFwiMDYxXCI6XCJQb2x5bmVzaWFcIixcIkFDXCI6XCJBc2NlbnNpb24gSXNsYW5kXCIsXCJBRFwiOlwiQW5kb3JyYVwiLFwiQUVcIjpcIlVuaXRlZCBBcmFiIEVtaXJhdGVzXCIsXCJBRlwiOlwiQWZnaGFuaXN0YW5cIixcIkFHXCI6XCJBbnRpZ3VhICYgQmFyYnVkYVwiLFwiQUlcIjpcIkFuZ3VpbGxhXCIsXCJBTFwiOlwiQWxiYW5pYVwiLFwiQU1cIjpcIkFybWVuaWFcIixcIkFPXCI6XCJBbmdvbGFcIixcIkFRXCI6XCJBbnRhcmN0aWNhXCIsXCJBUlwiOlwiQXJnZW50aW5hXCIsXCJBU1wiOlwiQW1lcmljYW4gU2Ftb2FcIixcIkFUXCI6XCJBdXN0cmlhXCIsXCJBVVwiOlwiQXVzdHJhbGlhXCIsXCJBV1wiOlwiQXJ1YmFcIixcIkFYXCI6XCLDhWxhbmQgSXNsYW5kc1wiLFwiQVpcIjpcIkF6ZXJiYWlqYW5cIixcIkJBXCI6XCJCb3NuaWEgJiBIZXJ6ZWdvdmluYVwiLFwiQkJcIjpcIkJhcmJhZG9zXCIsXCJCRFwiOlwiQmFuZ2xhZGVzaFwiLFwiQkVcIjpcIkJlbGdpdW1cIixcIkJGXCI6XCJCdXJraW5hIEZhc29cIixcIkJHXCI6XCJCdWxnYXJpYVwiLFwiQkhcIjpcIkJhaHJhaW5cIixcIkJJXCI6XCJCdXJ1bmRpXCIsXCJCSlwiOlwiQmVuaW5cIixcIkJMXCI6XCJTdC4gQmFydGjDqWxlbXlcIixcIkJNXCI6XCJCZXJtdWRhXCIsXCJCTlwiOlwiQnJ1bmVpXCIsXCJCT1wiOlwiQm9saXZpYVwiLFwiQlFcIjpcIkNhcmliYmVhbiBOZXRoZXJsYW5kc1wiLFwiQlJcIjpcIkJyYXppbFwiLFwiQlNcIjpcIkJhaGFtYXNcIixcIkJUXCI6XCJCaHV0YW5cIixcIkJWXCI6XCJCb3V2ZXQgSXNsYW5kXCIsXCJCV1wiOlwiQm90c3dhbmFcIixcIkJZXCI6XCJCZWxhcnVzXCIsXCJCWlwiOlwiQmVsaXplXCIsXCJDQVwiOlwiQ2FuYWRhXCIsXCJDQ1wiOlwiQ29jb3MgKEtlZWxpbmcpIElzbGFuZHNcIixcIkNEXCI6XCJDb25nbyAtIEtpbnNoYXNhXCIsXCJDRlwiOlwiQ2VudHJhbCBBZnJpY2FuIFJlcHVibGljXCIsXCJDR1wiOlwiQ29uZ28gLSBCcmF6emF2aWxsZVwiLFwiQ0hcIjpcIlN3aXR6ZXJsYW5kXCIsXCJDSVwiOlwiQ8O0dGUgZOKAmUl2b2lyZVwiLFwiQ0tcIjpcIkNvb2sgSXNsYW5kc1wiLFwiQ0xcIjpcIkNoaWxlXCIsXCJDTVwiOlwiQ2FtZXJvb25cIixcIkNOXCI6XCJDaGluYVwiLFwiQ09cIjpcIkNvbG9tYmlhXCIsXCJDUFwiOlwiQ2xpcHBlcnRvbiBJc2xhbmRcIixcIkNSXCI6XCJDb3N0YSBSaWNhXCIsXCJDVVwiOlwiQ3ViYVwiLFwiQ1ZcIjpcIkNhcGUgVmVyZGVcIixcIkNXXCI6XCJDdXJhw6dhb1wiLFwiQ1hcIjpcIkNocmlzdG1hcyBJc2xhbmRcIixcIkNZXCI6XCJDeXBydXNcIixcIkNaXCI6XCJDemVjaGlhXCIsXCJERVwiOlwiR2VybWFueVwiLFwiREdcIjpcIkRpZWdvIEdhcmNpYVwiLFwiREpcIjpcIkRqaWJvdXRpXCIsXCJES1wiOlwiRGVubWFya1wiLFwiRE1cIjpcIkRvbWluaWNhXCIsXCJET1wiOlwiRG9taW5pY2FuIFJlcHVibGljXCIsXCJEWlwiOlwiQWxnZXJpYVwiLFwiRUFcIjpcIkNldXRhICYgTWVsaWxsYVwiLFwiRUNcIjpcIkVjdWFkb3JcIixcIkVFXCI6XCJFc3RvbmlhXCIsXCJFR1wiOlwiRWd5cHRcIixcIkVIXCI6XCJXZXN0ZXJuIFNhaGFyYVwiLFwiRVJcIjpcIkVyaXRyZWFcIixcIkVTXCI6XCJTcGFpblwiLFwiRVRcIjpcIkV0aGlvcGlhXCIsXCJFVVwiOlwiRXVyb3BlYW4gVW5pb25cIixcIkVaXCI6XCJFdXJvem9uZVwiLFwiRklcIjpcIkZpbmxhbmRcIixcIkZKXCI6XCJGaWppXCIsXCJGS1wiOlwiRmFsa2xhbmQgSXNsYW5kc1wiLFwiRk1cIjpcIk1pY3JvbmVzaWFcIixcIkZPXCI6XCJGYXJvZSBJc2xhbmRzXCIsXCJGUlwiOlwiRnJhbmNlXCIsXCJHQVwiOlwiR2Fib25cIixcIkdCXCI6XCJVbml0ZWQgS2luZ2RvbVwiLFwiR0RcIjpcIkdyZW5hZGFcIixcIkdFXCI6XCJHZW9yZ2lhXCIsXCJHRlwiOlwiRnJlbmNoIEd1aWFuYVwiLFwiR0dcIjpcIkd1ZXJuc2V5XCIsXCJHSFwiOlwiR2hhbmFcIixcIkdJXCI6XCJHaWJyYWx0YXJcIixcIkdMXCI6XCJHcmVlbmxhbmRcIixcIkdNXCI6XCJHYW1iaWFcIixcIkdOXCI6XCJHdWluZWFcIixcIkdQXCI6XCJHdWFkZWxvdXBlXCIsXCJHUVwiOlwiRXF1YXRvcmlhbCBHdWluZWFcIixcIkdSXCI6XCJHcmVlY2VcIixcIkdTXCI6XCJTb3V0aCBHZW9yZ2lhICYgU291dGggU2FuZHdpY2ggSXNsYW5kc1wiLFwiR1RcIjpcIkd1YXRlbWFsYVwiLFwiR1VcIjpcIkd1YW1cIixcIkdXXCI6XCJHdWluZWEtQmlzc2F1XCIsXCJHWVwiOlwiR3V5YW5hXCIsXCJIS1wiOlwiSG9uZyBLb25nIFNBUiBDaGluYVwiLFwiSE1cIjpcIkhlYXJkICYgTWNEb25hbGQgSXNsYW5kc1wiLFwiSE5cIjpcIkhvbmR1cmFzXCIsXCJIUlwiOlwiQ3JvYXRpYVwiLFwiSFRcIjpcIkhhaXRpXCIsXCJIVVwiOlwiSHVuZ2FyeVwiLFwiSUNcIjpcIkNhbmFyeSBJc2xhbmRzXCIsXCJJRFwiOlwiSW5kb25lc2lhXCIsXCJJRVwiOlwiSXJlbGFuZFwiLFwiSUxcIjpcIklzcmFlbFwiLFwiSU1cIjpcIklzbGUgb2YgTWFuXCIsXCJJTlwiOlwiSW5kaWFcIixcIklPXCI6XCJCcml0aXNoIEluZGlhbiBPY2VhbiBUZXJyaXRvcnlcIixcIklRXCI6XCJJcmFxXCIsXCJJUlwiOlwiSXJhblwiLFwiSVNcIjpcIkljZWxhbmRcIixcIklUXCI6XCJJdGFseVwiLFwiSkVcIjpcIkplcnNleVwiLFwiSk1cIjpcIkphbWFpY2FcIixcIkpPXCI6XCJKb3JkYW5cIixcIkpQXCI6XCJKYXBhblwiLFwiS0VcIjpcIktlbnlhXCIsXCJLR1wiOlwiS3lyZ3l6c3RhblwiLFwiS0hcIjpcIkNhbWJvZGlhXCIsXCJLSVwiOlwiS2lyaWJhdGlcIixcIktNXCI6XCJDb21vcm9zXCIsXCJLTlwiOlwiU3QuIEtpdHRzICYgTmV2aXNcIixcIktQXCI6XCJOb3J0aCBLb3JlYVwiLFwiS1JcIjpcIlNvdXRoIEtvcmVhXCIsXCJLV1wiOlwiS3V3YWl0XCIsXCJLWVwiOlwiQ2F5bWFuIElzbGFuZHNcIixcIktaXCI6XCJLYXpha2hzdGFuXCIsXCJMQVwiOlwiTGFvc1wiLFwiTEJcIjpcIkxlYmFub25cIixcIkxDXCI6XCJTdC4gTHVjaWFcIixcIkxJXCI6XCJMaWVjaHRlbnN0ZWluXCIsXCJMS1wiOlwiU3JpIExhbmthXCIsXCJMUlwiOlwiTGliZXJpYVwiLFwiTFNcIjpcIkxlc290aG9cIixcIkxUXCI6XCJMaXRodWFuaWFcIixcIkxVXCI6XCJMdXhlbWJvdXJnXCIsXCJMVlwiOlwiTGF0dmlhXCIsXCJMWVwiOlwiTGlieWFcIixcIk1BXCI6XCJNb3JvY2NvXCIsXCJNQ1wiOlwiTW9uYWNvXCIsXCJNRFwiOlwiTW9sZG92YVwiLFwiTUVcIjpcIk1vbnRlbmVncm9cIixcIk1GXCI6XCJTdC4gTWFydGluXCIsXCJNR1wiOlwiTWFkYWdhc2NhclwiLFwiTUhcIjpcIk1hcnNoYWxsIElzbGFuZHNcIixcIk1LXCI6XCJOb3J0aCBNYWNlZG9uaWFcIixcIk1MXCI6XCJNYWxpXCIsXCJNTVwiOlwiTXlhbm1hciAoQnVybWEpXCIsXCJNTlwiOlwiTW9uZ29saWFcIixcIk1PXCI6XCJNYWNhbyBTQVIgQ2hpbmFcIixcIk1QXCI6XCJOb3J0aGVybiBNYXJpYW5hIElzbGFuZHNcIixcIk1RXCI6XCJNYXJ0aW5pcXVlXCIsXCJNUlwiOlwiTWF1cml0YW5pYVwiLFwiTVNcIjpcIk1vbnRzZXJyYXRcIixcIk1UXCI6XCJNYWx0YVwiLFwiTVVcIjpcIk1hdXJpdGl1c1wiLFwiTVZcIjpcIk1hbGRpdmVzXCIsXCJNV1wiOlwiTWFsYXdpXCIsXCJNWFwiOlwiTWV4aWNvXCIsXCJNWVwiOlwiTWFsYXlzaWFcIixcIk1aXCI6XCJNb3phbWJpcXVlXCIsXCJOQVwiOlwiTmFtaWJpYVwiLFwiTkNcIjpcIk5ldyBDYWxlZG9uaWFcIixcIk5FXCI6XCJOaWdlclwiLFwiTkZcIjpcIk5vcmZvbGsgSXNsYW5kXCIsXCJOR1wiOlwiTmlnZXJpYVwiLFwiTklcIjpcIk5pY2FyYWd1YVwiLFwiTkxcIjpcIk5ldGhlcmxhbmRzXCIsXCJOT1wiOlwiTm9yd2F5XCIsXCJOUFwiOlwiTmVwYWxcIixcIk5SXCI6XCJOYXVydVwiLFwiTlVcIjpcIk5pdWVcIixcIk5aXCI6XCJOZXcgWmVhbGFuZFwiLFwiT01cIjpcIk9tYW5cIixcIlBBXCI6XCJQYW5hbWFcIixcIlBFXCI6XCJQZXJ1XCIsXCJQRlwiOlwiRnJlbmNoIFBvbHluZXNpYVwiLFwiUEdcIjpcIlBhcHVhIE5ldyBHdWluZWFcIixcIlBIXCI6XCJQaGlsaXBwaW5lc1wiLFwiUEtcIjpcIlBha2lzdGFuXCIsXCJQTFwiOlwiUG9sYW5kXCIsXCJQTVwiOlwiU3QuIFBpZXJyZSAmIE1pcXVlbG9uXCIsXCJQTlwiOlwiUGl0Y2Fpcm4gSXNsYW5kc1wiLFwiUFJcIjpcIlB1ZXJ0byBSaWNvXCIsXCJQU1wiOlwiUGFsZXN0aW5pYW4gVGVycml0b3JpZXNcIixcIlBUXCI6XCJQb3J0dWdhbFwiLFwiUFdcIjpcIlBhbGF1XCIsXCJQWVwiOlwiUGFyYWd1YXlcIixcIlFBXCI6XCJRYXRhclwiLFwiUU9cIjpcIk91dGx5aW5nIE9jZWFuaWFcIixcIlJFXCI6XCJSw6l1bmlvblwiLFwiUk9cIjpcIlJvbWFuaWFcIixcIlJTXCI6XCJTZXJiaWFcIixcIlJVXCI6XCJSdXNzaWFcIixcIlJXXCI6XCJSd2FuZGFcIixcIlNBXCI6XCJTYXVkaSBBcmFiaWFcIixcIlNCXCI6XCJTb2xvbW9uIElzbGFuZHNcIixcIlNDXCI6XCJTZXljaGVsbGVzXCIsXCJTRFwiOlwiU3VkYW5cIixcIlNFXCI6XCJTd2VkZW5cIixcIlNHXCI6XCJTaW5nYXBvcmVcIixcIlNIXCI6XCJTdC4gSGVsZW5hXCIsXCJTSVwiOlwiU2xvdmVuaWFcIixcIlNKXCI6XCJTdmFsYmFyZCAmIEphbiBNYXllblwiLFwiU0tcIjpcIlNsb3Zha2lhXCIsXCJTTFwiOlwiU2llcnJhIExlb25lXCIsXCJTTVwiOlwiU2FuIE1hcmlub1wiLFwiU05cIjpcIlNlbmVnYWxcIixcIlNPXCI6XCJTb21hbGlhXCIsXCJTUlwiOlwiU3VyaW5hbWVcIixcIlNTXCI6XCJTb3V0aCBTdWRhblwiLFwiU1RcIjpcIlPDo28gVG9tw6kgJiBQcsOtbmNpcGVcIixcIlNWXCI6XCJFbCBTYWx2YWRvclwiLFwiU1hcIjpcIlNpbnQgTWFhcnRlblwiLFwiU1lcIjpcIlN5cmlhXCIsXCJTWlwiOlwiRXN3YXRpbmlcIixcIlRBXCI6XCJUcmlzdGFuIGRhIEN1bmhhXCIsXCJUQ1wiOlwiVHVya3MgJiBDYWljb3MgSXNsYW5kc1wiLFwiVERcIjpcIkNoYWRcIixcIlRGXCI6XCJGcmVuY2ggU291dGhlcm4gVGVycml0b3JpZXNcIixcIlRHXCI6XCJUb2dvXCIsXCJUSFwiOlwiVGhhaWxhbmRcIixcIlRKXCI6XCJUYWppa2lzdGFuXCIsXCJUS1wiOlwiVG9rZWxhdVwiLFwiVExcIjpcIlRpbW9yLUxlc3RlXCIsXCJUTVwiOlwiVHVya21lbmlzdGFuXCIsXCJUTlwiOlwiVHVuaXNpYVwiLFwiVE9cIjpcIlRvbmdhXCIsXCJUUlwiOlwiVHVya2V5XCIsXCJUVFwiOlwiVHJpbmlkYWQgJiBUb2JhZ29cIixcIlRWXCI6XCJUdXZhbHVcIixcIlRXXCI6XCJUYWl3YW5cIixcIlRaXCI6XCJUYW56YW5pYVwiLFwiVUFcIjpcIlVrcmFpbmVcIixcIlVHXCI6XCJVZ2FuZGFcIixcIlVNXCI6XCJVLlMuIE91dGx5aW5nIElzbGFuZHNcIixcIlVOXCI6XCJVbml0ZWQgTmF0aW9uc1wiLFwiVVNcIjpcIlVuaXRlZCBTdGF0ZXNcIixcIlVZXCI6XCJVcnVndWF5XCIsXCJVWlwiOlwiVXpiZWtpc3RhblwiLFwiVkFcIjpcIlZhdGljYW4gQ2l0eVwiLFwiVkNcIjpcIlN0LiBWaW5jZW50ICYgR3JlbmFkaW5lc1wiLFwiVkVcIjpcIlZlbmV6dWVsYVwiLFwiVkdcIjpcIkJyaXRpc2ggVmlyZ2luIElzbGFuZHNcIixcIlZJXCI6XCJVLlMuIFZpcmdpbiBJc2xhbmRzXCIsXCJWTlwiOlwiVmlldG5hbVwiLFwiVlVcIjpcIlZhbnVhdHVcIixcIldGXCI6XCJXYWxsaXMgJiBGdXR1bmFcIixcIldTXCI6XCJTYW1vYVwiLFwiWEFcIjpcIlBzZXVkby1BY2NlbnRzXCIsXCJYQlwiOlwiUHNldWRvLUJpZGlcIixcIlhLXCI6XCJLb3Nvdm9cIixcIllFXCI6XCJZZW1lblwiLFwiWVRcIjpcIk1heW90dGVcIixcIlpBXCI6XCJTb3V0aCBBZnJpY2FcIixcIlpNXCI6XCJaYW1iaWFcIixcIlpXXCI6XCJaaW1iYWJ3ZVwiLFwiWlpcIjpcIlVua25vd24gUmVnaW9uXCJ9LFwic2hvcnRcIjp7XCJCQVwiOlwiQm9zbmlhXCIsXCJHQlwiOlwiVUtcIixcIkhLXCI6XCJIb25nIEtvbmdcIixcIk1NXCI6XCJNeWFubWFyXCIsXCJNT1wiOlwiTWFjYW9cIixcIlBTXCI6XCJQYWxlc3RpbmVcIixcIlVOXCI6XCJVTlwiLFwiVVNcIjpcIlVTXCJ9LFwibmFycm93XCI6e319LFwic2NyaXB0XCI6e1wibG9uZ1wiOntcIkFkbG1cIjpcIkFkbGFtXCIsXCJBZmFrXCI6XCJBZmFrYVwiLFwiQWdoYlwiOlwiQ2F1Y2FzaWFuIEFsYmFuaWFuXCIsXCJBaG9tXCI6XCJBaG9tXCIsXCJBcmFiXCI6XCJBcmFiaWNcIixcIkFyYW5cIjpcIk5hc3RhbGlxXCIsXCJBcm1pXCI6XCJJbXBlcmlhbCBBcmFtYWljXCIsXCJBcm1uXCI6XCJBcm1lbmlhblwiLFwiQXZzdFwiOlwiQXZlc3RhblwiLFwiQmFsaVwiOlwiQmFsaW5lc2VcIixcIkJhbXVcIjpcIkJhbXVtXCIsXCJCYXNzXCI6XCJCYXNzYSBWYWhcIixcIkJhdGtcIjpcIkJhdGFrXCIsXCJCZW5nXCI6XCJCYW5nbGFcIixcIkJoa3NcIjpcIkJoYWlrc3VraVwiLFwiQmxpc1wiOlwiQmxpc3N5bWJvbHNcIixcIkJvcG9cIjpcIkJvcG9tb2ZvXCIsXCJCcmFoXCI6XCJCcmFobWlcIixcIkJyYWlcIjpcIkJyYWlsbGVcIixcIkJ1Z2lcIjpcIkJ1Z2luZXNlXCIsXCJCdWhkXCI6XCJCdWhpZFwiLFwiQ2FrbVwiOlwiQ2hha21hXCIsXCJDYW5zXCI6XCJVbmlmaWVkIENhbmFkaWFuIEFib3JpZ2luYWwgU3lsbGFiaWNzXCIsXCJDYXJpXCI6XCJDYXJpYW5cIixcIkNoYW1cIjpcIkNoYW1cIixcIkNoZXJcIjpcIkNoZXJva2VlXCIsXCJDaHJzXCI6XCJDaG9yYXNtaWFuXCIsXCJDaXJ0XCI6XCJDaXJ0aFwiLFwiQ29wdFwiOlwiQ29wdGljXCIsXCJDcHJ0XCI6XCJDeXByaW90XCIsXCJDeXJsXCI6XCJDeXJpbGxpY1wiLFwiQ3lyc1wiOlwiT2xkIENodXJjaCBTbGF2b25pYyBDeXJpbGxpY1wiLFwiRGV2YVwiOlwiRGV2YW5hZ2FyaVwiLFwiRGlha1wiOlwiRGl2ZXMgQWt1cnVcIixcIkRvZ3JcIjpcIkRvZ3JhXCIsXCJEc3J0XCI6XCJEZXNlcmV0XCIsXCJEdXBsXCI6XCJEdXBsb3lhbiBzaG9ydGhhbmRcIixcIkVneWRcIjpcIkVneXB0aWFuIGRlbW90aWNcIixcIkVneWhcIjpcIkVneXB0aWFuIGhpZXJhdGljXCIsXCJFZ3lwXCI6XCJFZ3lwdGlhbiBoaWVyb2dseXBoc1wiLFwiRWxiYVwiOlwiRWxiYXNhblwiLFwiRWx5bVwiOlwiRWx5bWFpY1wiLFwiRXRoaVwiOlwiRXRoaW9waWNcIixcIkdlb2tcIjpcIkdlb3JnaWFuIEtodXRzdXJpXCIsXCJHZW9yXCI6XCJHZW9yZ2lhblwiLFwiR2xhZ1wiOlwiR2xhZ29saXRpY1wiLFwiR29uZ1wiOlwiR3VuamFsYSBHb25kaVwiLFwiR29ubVwiOlwiTWFzYXJhbSBHb25kaVwiLFwiR290aFwiOlwiR290aGljXCIsXCJHcmFuXCI6XCJHcmFudGhhXCIsXCJHcmVrXCI6XCJHcmVla1wiLFwiR3VqclwiOlwiR3VqYXJhdGlcIixcIkd1cnVcIjpcIkd1cm11a2hpXCIsXCJIYW5iXCI6XCJIYW4gd2l0aCBCb3BvbW9mb1wiLFwiSGFuZ1wiOlwiSGFuZ3VsXCIsXCJIYW5pXCI6XCJIYW5cIixcIkhhbm9cIjpcIkhhbnVub29cIixcIkhhbnNcIjpcIlNpbXBsaWZpZWRcIixcIkhhbnRcIjpcIlRyYWRpdGlvbmFsXCIsXCJIYXRyXCI6XCJIYXRyYW5cIixcIkhlYnJcIjpcIkhlYnJld1wiLFwiSGlyYVwiOlwiSGlyYWdhbmFcIixcIkhsdXdcIjpcIkFuYXRvbGlhbiBIaWVyb2dseXBoc1wiLFwiSG1uZ1wiOlwiUGFoYXdoIEhtb25nXCIsXCJIbW5wXCI6XCJOeWlha2VuZyBQdWFjaHVlIEhtb25nXCIsXCJIcmt0XCI6XCJKYXBhbmVzZSBzeWxsYWJhcmllc1wiLFwiSHVuZ1wiOlwiT2xkIEh1bmdhcmlhblwiLFwiSW5kc1wiOlwiSW5kdXNcIixcIkl0YWxcIjpcIk9sZCBJdGFsaWNcIixcIkphbW9cIjpcIkphbW9cIixcIkphdmFcIjpcIkphdmFuZXNlXCIsXCJKcGFuXCI6XCJKYXBhbmVzZVwiLFwiSnVyY1wiOlwiSnVyY2hlblwiLFwiS2FsaVwiOlwiS2F5YWggTGlcIixcIkthbmFcIjpcIkthdGFrYW5hXCIsXCJLaGFyXCI6XCJLaGFyb3NodGhpXCIsXCJLaG1yXCI6XCJLaG1lclwiLFwiS2hvalwiOlwiS2hvamtpXCIsXCJLaXRzXCI6XCJLaGl0YW4gc21hbGwgc2NyaXB0XCIsXCJLbmRhXCI6XCJLYW5uYWRhXCIsXCJLb3JlXCI6XCJLb3JlYW5cIixcIktwZWxcIjpcIktwZWxsZVwiLFwiS3RoaVwiOlwiS2FpdGhpXCIsXCJMYW5hXCI6XCJMYW5uYVwiLFwiTGFvb1wiOlwiTGFvXCIsXCJMYXRmXCI6XCJGcmFrdHVyIExhdGluXCIsXCJMYXRnXCI6XCJHYWVsaWMgTGF0aW5cIixcIkxhdG5cIjpcIkxhdGluXCIsXCJMZXBjXCI6XCJMZXBjaGFcIixcIkxpbWJcIjpcIkxpbWJ1XCIsXCJMaW5hXCI6XCJMaW5lYXIgQVwiLFwiTGluYlwiOlwiTGluZWFyIEJcIixcIkxpc3VcIjpcIkZyYXNlclwiLFwiTG9tYVwiOlwiTG9tYVwiLFwiTHljaVwiOlwiTHljaWFuXCIsXCJMeWRpXCI6XCJMeWRpYW5cIixcIk1haGpcIjpcIk1haGFqYW5pXCIsXCJNYWthXCI6XCJNYWthc2FyXCIsXCJNYW5kXCI6XCJNYW5kYWVhblwiLFwiTWFuaVwiOlwiTWFuaWNoYWVhblwiLFwiTWFyY1wiOlwiTWFyY2hlblwiLFwiTWF5YVwiOlwiTWF5YW4gaGllcm9nbHlwaHNcIixcIk1lZGZcIjpcIk1lZGVmYWlkcmluXCIsXCJNZW5kXCI6XCJNZW5kZVwiLFwiTWVyY1wiOlwiTWVyb2l0aWMgQ3Vyc2l2ZVwiLFwiTWVyb1wiOlwiTWVyb2l0aWNcIixcIk1seW1cIjpcIk1hbGF5YWxhbVwiLFwiTW9kaVwiOlwiTW9kaVwiLFwiTW9uZ1wiOlwiTW9uZ29saWFuXCIsXCJNb29uXCI6XCJNb29uXCIsXCJNcm9vXCI6XCJNcm9cIixcIk10ZWlcIjpcIk1laXRlaSBNYXlla1wiLFwiTXVsdFwiOlwiTXVsdGFuaVwiLFwiTXltclwiOlwiTXlhbm1hclwiLFwiTmFuZFwiOlwiTmFuZGluYWdhcmlcIixcIk5hcmJcIjpcIk9sZCBOb3J0aCBBcmFiaWFuXCIsXCJOYmF0XCI6XCJOYWJhdGFlYW5cIixcIk5ld2FcIjpcIk5ld2FcIixcIk5rZ2JcIjpcIk5heGkgR2ViYVwiLFwiTmtvb1wiOlwiTuKAmUtvXCIsXCJOc2h1XCI6XCJOw7xzaHVcIixcIk9nYW1cIjpcIk9naGFtXCIsXCJPbGNrXCI6XCJPbCBDaGlraVwiLFwiT3JraFwiOlwiT3JraG9uXCIsXCJPcnlhXCI6XCJPZGlhXCIsXCJPc2dlXCI6XCJPc2FnZVwiLFwiT3NtYVwiOlwiT3NtYW55YVwiLFwiUGFsbVwiOlwiUGFsbXlyZW5lXCIsXCJQYXVjXCI6XCJQYXUgQ2luIEhhdVwiLFwiUGVybVwiOlwiT2xkIFBlcm1pY1wiLFwiUGhhZ1wiOlwiUGhhZ3MtcGFcIixcIlBobGlcIjpcIkluc2NyaXB0aW9uYWwgUGFobGF2aVwiLFwiUGhscFwiOlwiUHNhbHRlciBQYWhsYXZpXCIsXCJQaGx2XCI6XCJCb29rIFBhaGxhdmlcIixcIlBobnhcIjpcIlBob2VuaWNpYW5cIixcIlBscmRcIjpcIlBvbGxhcmQgUGhvbmV0aWNcIixcIlBydGlcIjpcIkluc2NyaXB0aW9uYWwgUGFydGhpYW5cIixcIlFhYWdcIjpcIlphd2d5aVwiLFwiUmpuZ1wiOlwiUmVqYW5nXCIsXCJSb2hnXCI6XCJIYW5pZmkgUm9oaW5neWFcIixcIlJvcm9cIjpcIlJvbmdvcm9uZ29cIixcIlJ1bnJcIjpcIlJ1bmljXCIsXCJTYW1yXCI6XCJTYW1hcml0YW5cIixcIlNhcmFcIjpcIlNhcmF0aVwiLFwiU2FyYlwiOlwiT2xkIFNvdXRoIEFyYWJpYW5cIixcIlNhdXJcIjpcIlNhdXJhc2h0cmFcIixcIlNnbndcIjpcIlNpZ25Xcml0aW5nXCIsXCJTaGF3XCI6XCJTaGF2aWFuXCIsXCJTaHJkXCI6XCJTaGFyYWRhXCIsXCJTaWRkXCI6XCJTaWRkaGFtXCIsXCJTaW5kXCI6XCJLaHVkYXdhZGlcIixcIlNpbmhcIjpcIlNpbmhhbGFcIixcIlNvZ2RcIjpcIlNvZ2RpYW5cIixcIlNvZ29cIjpcIk9sZCBTb2dkaWFuXCIsXCJTb3JhXCI6XCJTb3JhIFNvbXBlbmdcIixcIlNveW9cIjpcIlNveW9tYm9cIixcIlN1bmRcIjpcIlN1bmRhbmVzZVwiLFwiU3lsb1wiOlwiU3lsb3RpIE5hZ3JpXCIsXCJTeXJjXCI6XCJTeXJpYWNcIixcIlN5cmVcIjpcIkVzdHJhbmdlbG8gU3lyaWFjXCIsXCJTeXJqXCI6XCJXZXN0ZXJuIFN5cmlhY1wiLFwiU3lyblwiOlwiRWFzdGVybiBTeXJpYWNcIixcIlRhZ2JcIjpcIlRhZ2JhbndhXCIsXCJUYWtyXCI6XCJUYWtyaVwiLFwiVGFsZVwiOlwiVGFpIExlXCIsXCJUYWx1XCI6XCJOZXcgVGFpIEx1ZVwiLFwiVGFtbFwiOlwiVGFtaWxcIixcIlRhbmdcIjpcIlRhbmd1dFwiLFwiVGF2dFwiOlwiVGFpIFZpZXRcIixcIlRlbHVcIjpcIlRlbHVndVwiLFwiVGVuZ1wiOlwiVGVuZ3dhclwiLFwiVGZuZ1wiOlwiVGlmaW5hZ2hcIixcIlRnbGdcIjpcIlRhZ2Fsb2dcIixcIlRoYWFcIjpcIlRoYWFuYVwiLFwiVGhhaVwiOlwiVGhhaVwiLFwiVGlidFwiOlwiVGliZXRhblwiLFwiVGlyaFwiOlwiVGlyaHV0YVwiLFwiVWdhclwiOlwiVWdhcml0aWNcIixcIlZhaWlcIjpcIlZhaVwiLFwiVmlzcFwiOlwiVmlzaWJsZSBTcGVlY2hcIixcIldhcmFcIjpcIlZhcmFuZyBLc2hpdGlcIixcIldjaG9cIjpcIldhbmNob1wiLFwiV29sZVwiOlwiV29sZWFpXCIsXCJYcGVvXCI6XCJPbGQgUGVyc2lhblwiLFwiWHN1eFwiOlwiU3VtZXJvLUFra2FkaWFuIEN1bmVpZm9ybVwiLFwiWWV6aVwiOlwiWWV6aWRpXCIsXCJZaWlpXCI6XCJZaVwiLFwiWmFuYlwiOlwiWmFuYWJhemFyIFNxdWFyZVwiLFwiWmluaFwiOlwiSW5oZXJpdGVkXCIsXCJabXRoXCI6XCJNYXRoZW1hdGljYWwgTm90YXRpb25cIixcIlpzeWVcIjpcIkVtb2ppXCIsXCJac3ltXCI6XCJTeW1ib2xzXCIsXCJaeHh4XCI6XCJVbndyaXR0ZW5cIixcIlp5eXlcIjpcIkNvbW1vblwiLFwiWnp6elwiOlwiVW5rbm93biBTY3JpcHRcIn0sXCJzaG9ydFwiOntcIkNhbnNcIjpcIlVDQVNcIixcIlhzdXhcIjpcIlMtQSBDdW5laWZvcm1cIn0sXCJuYXJyb3dcIjp7fX0sXCJjdXJyZW5jeVwiOntcImxvbmdcIjp7XCJBRFBcIjpcIkFuZG9ycmFuIFBlc2V0YVwiLFwiQUVEXCI6XCJVbml0ZWQgQXJhYiBFbWlyYXRlcyBEaXJoYW1cIixcIkFGQVwiOlwiQWZnaGFuIEFmZ2hhbmkgKDE5MjfigJMyMDAyKVwiLFwiQUZOXCI6XCJBZmdoYW4gQWZnaGFuaVwiLFwiQUxLXCI6XCJBbGJhbmlhbiBMZWsgKDE5NDbigJMxOTY1KVwiLFwiQUxMXCI6XCJBbGJhbmlhbiBMZWtcIixcIkFNRFwiOlwiQXJtZW5pYW4gRHJhbVwiLFwiQU5HXCI6XCJOZXRoZXJsYW5kcyBBbnRpbGxlYW4gR3VpbGRlclwiLFwiQU9BXCI6XCJBbmdvbGFuIEt3YW56YVwiLFwiQU9LXCI6XCJBbmdvbGFuIEt3YW56YSAoMTk3N+KAkzE5OTEpXCIsXCJBT05cIjpcIkFuZ29sYW4gTmV3IEt3YW56YSAoMTk5MOKAkzIwMDApXCIsXCJBT1JcIjpcIkFuZ29sYW4gUmVhZGp1c3RlZCBLd2FuemEgKDE5OTXigJMxOTk5KVwiLFwiQVJBXCI6XCJBcmdlbnRpbmUgQXVzdHJhbFwiLFwiQVJMXCI6XCJBcmdlbnRpbmUgUGVzbyBMZXkgKDE5NzDigJMxOTgzKVwiLFwiQVJNXCI6XCJBcmdlbnRpbmUgUGVzbyAoMTg4MeKAkzE5NzApXCIsXCJBUlBcIjpcIkFyZ2VudGluZSBQZXNvICgxOTgz4oCTMTk4NSlcIixcIkFSU1wiOlwiQXJnZW50aW5lIFBlc29cIixcIkFUU1wiOlwiQXVzdHJpYW4gU2NoaWxsaW5nXCIsXCJBVURcIjpcIkF1c3RyYWxpYW4gRG9sbGFyXCIsXCJBV0dcIjpcIkFydWJhbiBGbG9yaW5cIixcIkFaTVwiOlwiQXplcmJhaWphbmkgTWFuYXQgKDE5OTPigJMyMDA2KVwiLFwiQVpOXCI6XCJBemVyYmFpamFuaSBNYW5hdFwiLFwiQkFEXCI6XCJCb3NuaWEtSGVyemVnb3ZpbmEgRGluYXIgKDE5OTLigJMxOTk0KVwiLFwiQkFNXCI6XCJCb3NuaWEtSGVyemVnb3ZpbmEgQ29udmVydGlibGUgTWFya1wiLFwiQkFOXCI6XCJCb3NuaWEtSGVyemVnb3ZpbmEgTmV3IERpbmFyICgxOTk04oCTMTk5NylcIixcIkJCRFwiOlwiQmFyYmFkaWFuIERvbGxhclwiLFwiQkRUXCI6XCJCYW5nbGFkZXNoaSBUYWthXCIsXCJCRUNcIjpcIkJlbGdpYW4gRnJhbmMgKGNvbnZlcnRpYmxlKVwiLFwiQkVGXCI6XCJCZWxnaWFuIEZyYW5jXCIsXCJCRUxcIjpcIkJlbGdpYW4gRnJhbmMgKGZpbmFuY2lhbClcIixcIkJHTFwiOlwiQnVsZ2FyaWFuIEhhcmQgTGV2XCIsXCJCR01cIjpcIkJ1bGdhcmlhbiBTb2NpYWxpc3QgTGV2XCIsXCJCR05cIjpcIkJ1bGdhcmlhbiBMZXZcIixcIkJHT1wiOlwiQnVsZ2FyaWFuIExldiAoMTg3OeKAkzE5NTIpXCIsXCJCSERcIjpcIkJhaHJhaW5pIERpbmFyXCIsXCJCSUZcIjpcIkJ1cnVuZGlhbiBGcmFuY1wiLFwiQk1EXCI6XCJCZXJtdWRhbiBEb2xsYXJcIixcIkJORFwiOlwiQnJ1bmVpIERvbGxhclwiLFwiQk9CXCI6XCJCb2xpdmlhbiBCb2xpdmlhbm9cIixcIkJPTFwiOlwiQm9saXZpYW4gQm9saXZpYW5vICgxODYz4oCTMTk2MylcIixcIkJPUFwiOlwiQm9saXZpYW4gUGVzb1wiLFwiQk9WXCI6XCJCb2xpdmlhbiBNdmRvbFwiLFwiQlJCXCI6XCJCcmF6aWxpYW4gTmV3IENydXplaXJvICgxOTY34oCTMTk4NilcIixcIkJSQ1wiOlwiQnJhemlsaWFuIENydXphZG8gKDE5ODbigJMxOTg5KVwiLFwiQlJFXCI6XCJCcmF6aWxpYW4gQ3J1emVpcm8gKDE5OTDigJMxOTkzKVwiLFwiQlJMXCI6XCJCcmF6aWxpYW4gUmVhbFwiLFwiQlJOXCI6XCJCcmF6aWxpYW4gTmV3IENydXphZG8gKDE5ODnigJMxOTkwKVwiLFwiQlJSXCI6XCJCcmF6aWxpYW4gQ3J1emVpcm8gKDE5OTPigJMxOTk0KVwiLFwiQlJaXCI6XCJCcmF6aWxpYW4gQ3J1emVpcm8gKDE5NDLigJMxOTY3KVwiLFwiQlNEXCI6XCJCYWhhbWlhbiBEb2xsYXJcIixcIkJUTlwiOlwiQmh1dGFuZXNlIE5ndWx0cnVtXCIsXCJCVUtcIjpcIkJ1cm1lc2UgS3lhdFwiLFwiQldQXCI6XCJCb3Rzd2FuYW4gUHVsYVwiLFwiQllCXCI6XCJCZWxhcnVzaWFuIFJ1YmxlICgxOTk04oCTMTk5OSlcIixcIkJZTlwiOlwiQmVsYXJ1c2lhbiBSdWJsZVwiLFwiQllSXCI6XCJCZWxhcnVzaWFuIFJ1YmxlICgyMDAw4oCTMjAxNilcIixcIkJaRFwiOlwiQmVsaXplIERvbGxhclwiLFwiQ0FEXCI6XCJDYW5hZGlhbiBEb2xsYXJcIixcIkNERlwiOlwiQ29uZ29sZXNlIEZyYW5jXCIsXCJDSEVcIjpcIldJUiBFdXJvXCIsXCJDSEZcIjpcIlN3aXNzIEZyYW5jXCIsXCJDSFdcIjpcIldJUiBGcmFuY1wiLFwiQ0xFXCI6XCJDaGlsZWFuIEVzY3Vkb1wiLFwiQ0xGXCI6XCJDaGlsZWFuIFVuaXQgb2YgQWNjb3VudCAoVUYpXCIsXCJDTFBcIjpcIkNoaWxlYW4gUGVzb1wiLFwiQ05IXCI6XCJDaGluZXNlIFl1YW4gKG9mZnNob3JlKVwiLFwiQ05YXCI6XCJDaGluZXNlIFBlb3BsZeKAmXMgQmFuayBEb2xsYXJcIixcIkNOWVwiOlwiQ2hpbmVzZSBZdWFuXCIsXCJDT1BcIjpcIkNvbG9tYmlhbiBQZXNvXCIsXCJDT1VcIjpcIkNvbG9tYmlhbiBSZWFsIFZhbHVlIFVuaXRcIixcIkNSQ1wiOlwiQ29zdGEgUmljYW4gQ29sw7NuXCIsXCJDU0RcIjpcIlNlcmJpYW4gRGluYXIgKDIwMDLigJMyMDA2KVwiLFwiQ1NLXCI6XCJDemVjaG9zbG92YWsgSGFyZCBLb3J1bmFcIixcIkNVQ1wiOlwiQ3ViYW4gQ29udmVydGlibGUgUGVzb1wiLFwiQ1VQXCI6XCJDdWJhbiBQZXNvXCIsXCJDVkVcIjpcIkNhcGUgVmVyZGVhbiBFc2N1ZG9cIixcIkNZUFwiOlwiQ3lwcmlvdCBQb3VuZFwiLFwiQ1pLXCI6XCJDemVjaCBLb3J1bmFcIixcIkRETVwiOlwiRWFzdCBHZXJtYW4gTWFya1wiLFwiREVNXCI6XCJHZXJtYW4gTWFya1wiLFwiREpGXCI6XCJEamlib3V0aWFuIEZyYW5jXCIsXCJES0tcIjpcIkRhbmlzaCBLcm9uZVwiLFwiRE9QXCI6XCJEb21pbmljYW4gUGVzb1wiLFwiRFpEXCI6XCJBbGdlcmlhbiBEaW5hclwiLFwiRUNTXCI6XCJFY3VhZG9yaWFuIFN1Y3JlXCIsXCJFQ1ZcIjpcIkVjdWFkb3JpYW4gVW5pdCBvZiBDb25zdGFudCBWYWx1ZVwiLFwiRUVLXCI6XCJFc3RvbmlhbiBLcm9vblwiLFwiRUdQXCI6XCJFZ3lwdGlhbiBQb3VuZFwiLFwiRVJOXCI6XCJFcml0cmVhbiBOYWtmYVwiLFwiRVNBXCI6XCJTcGFuaXNoIFBlc2V0YSAoQSBhY2NvdW50KVwiLFwiRVNCXCI6XCJTcGFuaXNoIFBlc2V0YSAoY29udmVydGlibGUgYWNjb3VudClcIixcIkVTUFwiOlwiU3BhbmlzaCBQZXNldGFcIixcIkVUQlwiOlwiRXRoaW9waWFuIEJpcnJcIixcIkVVUlwiOlwiRXVyb1wiLFwiRklNXCI6XCJGaW5uaXNoIE1hcmtrYVwiLFwiRkpEXCI6XCJGaWppYW4gRG9sbGFyXCIsXCJGS1BcIjpcIkZhbGtsYW5kIElzbGFuZHMgUG91bmRcIixcIkZSRlwiOlwiRnJlbmNoIEZyYW5jXCIsXCJHQlBcIjpcIkJyaXRpc2ggUG91bmRcIixcIkdFS1wiOlwiR2VvcmdpYW4gS3Vwb24gTGFyaXRcIixcIkdFTFwiOlwiR2VvcmdpYW4gTGFyaVwiLFwiR0hDXCI6XCJHaGFuYWlhbiBDZWRpICgxOTc54oCTMjAwNylcIixcIkdIU1wiOlwiR2hhbmFpYW4gQ2VkaVwiLFwiR0lQXCI6XCJHaWJyYWx0YXIgUG91bmRcIixcIkdNRFwiOlwiR2FtYmlhbiBEYWxhc2lcIixcIkdORlwiOlwiR3VpbmVhbiBGcmFuY1wiLFwiR05TXCI6XCJHdWluZWFuIFN5bGlcIixcIkdRRVwiOlwiRXF1YXRvcmlhbCBHdWluZWFuIEVrd2VsZVwiLFwiR1JEXCI6XCJHcmVlayBEcmFjaG1hXCIsXCJHVFFcIjpcIkd1YXRlbWFsYW4gUXVldHphbFwiLFwiR1dFXCI6XCJQb3J0dWd1ZXNlIEd1aW5lYSBFc2N1ZG9cIixcIkdXUFwiOlwiR3VpbmVhLUJpc3NhdSBQZXNvXCIsXCJHWURcIjpcIkd1eWFuYWVzZSBEb2xsYXJcIixcIkhLRFwiOlwiSG9uZyBLb25nIERvbGxhclwiLFwiSE5MXCI6XCJIb25kdXJhbiBMZW1waXJhXCIsXCJIUkRcIjpcIkNyb2F0aWFuIERpbmFyXCIsXCJIUktcIjpcIkNyb2F0aWFuIEt1bmFcIixcIkhUR1wiOlwiSGFpdGlhbiBHb3VyZGVcIixcIkhVRlwiOlwiSHVuZ2FyaWFuIEZvcmludFwiLFwiSURSXCI6XCJJbmRvbmVzaWFuIFJ1cGlhaFwiLFwiSUVQXCI6XCJJcmlzaCBQb3VuZFwiLFwiSUxQXCI6XCJJc3JhZWxpIFBvdW5kXCIsXCJJTFJcIjpcIklzcmFlbGkgU2hla2VsICgxOTgw4oCTMTk4NSlcIixcIklMU1wiOlwiSXNyYWVsaSBOZXcgU2hla2VsXCIsXCJJTlJcIjpcIkluZGlhbiBSdXBlZVwiLFwiSVFEXCI6XCJJcmFxaSBEaW5hclwiLFwiSVJSXCI6XCJJcmFuaWFuIFJpYWxcIixcIklTSlwiOlwiSWNlbGFuZGljIEtyw7NuYSAoMTkxOOKAkzE5ODEpXCIsXCJJU0tcIjpcIkljZWxhbmRpYyBLcsOzbmFcIixcIklUTFwiOlwiSXRhbGlhbiBMaXJhXCIsXCJKTURcIjpcIkphbWFpY2FuIERvbGxhclwiLFwiSk9EXCI6XCJKb3JkYW5pYW4gRGluYXJcIixcIkpQWVwiOlwiSmFwYW5lc2UgWWVuXCIsXCJLRVNcIjpcIktlbnlhbiBTaGlsbGluZ1wiLFwiS0dTXCI6XCJLeXJneXN0YW5pIFNvbVwiLFwiS0hSXCI6XCJDYW1ib2RpYW4gUmllbFwiLFwiS01GXCI6XCJDb21vcmlhbiBGcmFuY1wiLFwiS1BXXCI6XCJOb3J0aCBLb3JlYW4gV29uXCIsXCJLUkhcIjpcIlNvdXRoIEtvcmVhbiBId2FuICgxOTUz4oCTMTk2MilcIixcIktST1wiOlwiU291dGggS29yZWFuIFdvbiAoMTk0NeKAkzE5NTMpXCIsXCJLUldcIjpcIlNvdXRoIEtvcmVhbiBXb25cIixcIktXRFwiOlwiS3V3YWl0aSBEaW5hclwiLFwiS1lEXCI6XCJDYXltYW4gSXNsYW5kcyBEb2xsYXJcIixcIktaVFwiOlwiS2F6YWtoc3RhbmkgVGVuZ2VcIixcIkxBS1wiOlwiTGFvdGlhbiBLaXBcIixcIkxCUFwiOlwiTGViYW5lc2UgUG91bmRcIixcIkxLUlwiOlwiU3JpIExhbmthbiBSdXBlZVwiLFwiTFJEXCI6XCJMaWJlcmlhbiBEb2xsYXJcIixcIkxTTFwiOlwiTGVzb3RobyBMb3RpXCIsXCJMVExcIjpcIkxpdGh1YW5pYW4gTGl0YXNcIixcIkxUVFwiOlwiTGl0aHVhbmlhbiBUYWxvbmFzXCIsXCJMVUNcIjpcIkx1eGVtYm91cmdpYW4gQ29udmVydGlibGUgRnJhbmNcIixcIkxVRlwiOlwiTHV4ZW1ib3VyZ2lhbiBGcmFuY1wiLFwiTFVMXCI6XCJMdXhlbWJvdXJnIEZpbmFuY2lhbCBGcmFuY1wiLFwiTFZMXCI6XCJMYXR2aWFuIExhdHNcIixcIkxWUlwiOlwiTGF0dmlhbiBSdWJsZVwiLFwiTFlEXCI6XCJMaWJ5YW4gRGluYXJcIixcIk1BRFwiOlwiTW9yb2NjYW4gRGlyaGFtXCIsXCJNQUZcIjpcIk1vcm9jY2FuIEZyYW5jXCIsXCJNQ0ZcIjpcIk1vbmVnYXNxdWUgRnJhbmNcIixcIk1EQ1wiOlwiTW9sZG92YW4gQ3Vwb25cIixcIk1ETFwiOlwiTW9sZG92YW4gTGV1XCIsXCJNR0FcIjpcIk1hbGFnYXN5IEFyaWFyeVwiLFwiTUdGXCI6XCJNYWxhZ2FzeSBGcmFuY1wiLFwiTUtEXCI6XCJNYWNlZG9uaWFuIERlbmFyXCIsXCJNS05cIjpcIk1hY2Vkb25pYW4gRGVuYXIgKDE5OTLigJMxOTkzKVwiLFwiTUxGXCI6XCJNYWxpYW4gRnJhbmNcIixcIk1NS1wiOlwiTXlhbm1hciBLeWF0XCIsXCJNTlRcIjpcIk1vbmdvbGlhbiBUdWdyaWtcIixcIk1PUFwiOlwiTWFjYW5lc2UgUGF0YWNhXCIsXCJNUk9cIjpcIk1hdXJpdGFuaWFuIE91Z3VpeWEgKDE5NzPigJMyMDE3KVwiLFwiTVJVXCI6XCJNYXVyaXRhbmlhbiBPdWd1aXlhXCIsXCJNVExcIjpcIk1hbHRlc2UgTGlyYVwiLFwiTVRQXCI6XCJNYWx0ZXNlIFBvdW5kXCIsXCJNVVJcIjpcIk1hdXJpdGlhbiBSdXBlZVwiLFwiTVZQXCI6XCJNYWxkaXZpYW4gUnVwZWUgKDE5NDfigJMxOTgxKVwiLFwiTVZSXCI6XCJNYWxkaXZpYW4gUnVmaXlhYVwiLFwiTVdLXCI6XCJNYWxhd2lhbiBLd2FjaGFcIixcIk1YTlwiOlwiTWV4aWNhbiBQZXNvXCIsXCJNWFBcIjpcIk1leGljYW4gU2lsdmVyIFBlc28gKDE4NjHigJMxOTkyKVwiLFwiTVhWXCI6XCJNZXhpY2FuIEludmVzdG1lbnQgVW5pdFwiLFwiTVlSXCI6XCJNYWxheXNpYW4gUmluZ2dpdFwiLFwiTVpFXCI6XCJNb3phbWJpY2FuIEVzY3Vkb1wiLFwiTVpNXCI6XCJNb3phbWJpY2FuIE1ldGljYWwgKDE5ODDigJMyMDA2KVwiLFwiTVpOXCI6XCJNb3phbWJpY2FuIE1ldGljYWxcIixcIk5BRFwiOlwiTmFtaWJpYW4gRG9sbGFyXCIsXCJOR05cIjpcIk5pZ2VyaWFuIE5haXJhXCIsXCJOSUNcIjpcIk5pY2FyYWd1YW4gQ8OzcmRvYmEgKDE5ODjigJMxOTkxKVwiLFwiTklPXCI6XCJOaWNhcmFndWFuIEPDs3Jkb2JhXCIsXCJOTEdcIjpcIkR1dGNoIEd1aWxkZXJcIixcIk5PS1wiOlwiTm9yd2VnaWFuIEtyb25lXCIsXCJOUFJcIjpcIk5lcGFsZXNlIFJ1cGVlXCIsXCJOWkRcIjpcIk5ldyBaZWFsYW5kIERvbGxhclwiLFwiT01SXCI6XCJPbWFuaSBSaWFsXCIsXCJQQUJcIjpcIlBhbmFtYW5pYW4gQmFsYm9hXCIsXCJQRUlcIjpcIlBlcnV2aWFuIEludGlcIixcIlBFTlwiOlwiUGVydXZpYW4gU29sXCIsXCJQRVNcIjpcIlBlcnV2aWFuIFNvbCAoMTg2M+KAkzE5NjUpXCIsXCJQR0tcIjpcIlBhcHVhIE5ldyBHdWluZWFuIEtpbmFcIixcIlBIUFwiOlwiUGhpbGlwcGluZSBQaXNvXCIsXCJQS1JcIjpcIlBha2lzdGFuaSBSdXBlZVwiLFwiUExOXCI6XCJQb2xpc2ggWmxvdHlcIixcIlBMWlwiOlwiUG9saXNoIFpsb3R5ICgxOTUw4oCTMTk5NSlcIixcIlBURVwiOlwiUG9ydHVndWVzZSBFc2N1ZG9cIixcIlBZR1wiOlwiUGFyYWd1YXlhbiBHdWFyYW5pXCIsXCJRQVJcIjpcIlFhdGFyaSBSaWFsXCIsXCJSSERcIjpcIlJob2Rlc2lhbiBEb2xsYXJcIixcIlJPTFwiOlwiUm9tYW5pYW4gTGV1ICgxOTUy4oCTMjAwNilcIixcIlJPTlwiOlwiUm9tYW5pYW4gTGV1XCIsXCJSU0RcIjpcIlNlcmJpYW4gRGluYXJcIixcIlJVQlwiOlwiUnVzc2lhbiBSdWJsZVwiLFwiUlVSXCI6XCJSdXNzaWFuIFJ1YmxlICgxOTkx4oCTMTk5OClcIixcIlJXRlwiOlwiUndhbmRhbiBGcmFuY1wiLFwiU0FSXCI6XCJTYXVkaSBSaXlhbFwiLFwiU0JEXCI6XCJTb2xvbW9uIElzbGFuZHMgRG9sbGFyXCIsXCJTQ1JcIjpcIlNleWNoZWxsb2lzIFJ1cGVlXCIsXCJTRERcIjpcIlN1ZGFuZXNlIERpbmFyICgxOTky4oCTMjAwNylcIixcIlNER1wiOlwiU3VkYW5lc2UgUG91bmRcIixcIlNEUFwiOlwiU3VkYW5lc2UgUG91bmQgKDE5NTfigJMxOTk4KVwiLFwiU0VLXCI6XCJTd2VkaXNoIEtyb25hXCIsXCJTR0RcIjpcIlNpbmdhcG9yZSBEb2xsYXJcIixcIlNIUFwiOlwiU3QuIEhlbGVuYSBQb3VuZFwiLFwiU0lUXCI6XCJTbG92ZW5pYW4gVG9sYXJcIixcIlNLS1wiOlwiU2xvdmFrIEtvcnVuYVwiLFwiU0xMXCI6XCJTaWVycmEgTGVvbmVhbiBMZW9uZVwiLFwiU09TXCI6XCJTb21hbGkgU2hpbGxpbmdcIixcIlNSRFwiOlwiU3VyaW5hbWVzZSBEb2xsYXJcIixcIlNSR1wiOlwiU3VyaW5hbWVzZSBHdWlsZGVyXCIsXCJTU1BcIjpcIlNvdXRoIFN1ZGFuZXNlIFBvdW5kXCIsXCJTVERcIjpcIlPDo28gVG9tw6kgJiBQcsOtbmNpcGUgRG9icmEgKDE5NzfigJMyMDE3KVwiLFwiU1ROXCI6XCJTw6NvIFRvbcOpICYgUHLDrW5jaXBlIERvYnJhXCIsXCJTVVJcIjpcIlNvdmlldCBSb3VibGVcIixcIlNWQ1wiOlwiU2FsdmFkb3JhbiBDb2zDs25cIixcIlNZUFwiOlwiU3lyaWFuIFBvdW5kXCIsXCJTWkxcIjpcIlN3YXppIExpbGFuZ2VuaVwiLFwiVEhCXCI6XCJUaGFpIEJhaHRcIixcIlRKUlwiOlwiVGFqaWtpc3RhbmkgUnVibGVcIixcIlRKU1wiOlwiVGFqaWtpc3RhbmkgU29tb25pXCIsXCJUTU1cIjpcIlR1cmttZW5pc3RhbmkgTWFuYXQgKDE5OTPigJMyMDA5KVwiLFwiVE1UXCI6XCJUdXJrbWVuaXN0YW5pIE1hbmF0XCIsXCJUTkRcIjpcIlR1bmlzaWFuIERpbmFyXCIsXCJUT1BcIjpcIlRvbmdhbiBQYcq7YW5nYVwiLFwiVFBFXCI6XCJUaW1vcmVzZSBFc2N1ZG9cIixcIlRSTFwiOlwiVHVya2lzaCBMaXJhICgxOTIy4oCTMjAwNSlcIixcIlRSWVwiOlwiVHVya2lzaCBMaXJhXCIsXCJUVERcIjpcIlRyaW5pZGFkICYgVG9iYWdvIERvbGxhclwiLFwiVFdEXCI6XCJOZXcgVGFpd2FuIERvbGxhclwiLFwiVFpTXCI6XCJUYW56YW5pYW4gU2hpbGxpbmdcIixcIlVBSFwiOlwiVWtyYWluaWFuIEhyeXZuaWFcIixcIlVBS1wiOlwiVWtyYWluaWFuIEthcmJvdmFuZXRzXCIsXCJVR1NcIjpcIlVnYW5kYW4gU2hpbGxpbmcgKDE5NjbigJMxOTg3KVwiLFwiVUdYXCI6XCJVZ2FuZGFuIFNoaWxsaW5nXCIsXCJVU0RcIjpcIlVTIERvbGxhclwiLFwiVVNOXCI6XCJVUyBEb2xsYXIgKE5leHQgZGF5KVwiLFwiVVNTXCI6XCJVUyBEb2xsYXIgKFNhbWUgZGF5KVwiLFwiVVlJXCI6XCJVcnVndWF5YW4gUGVzbyAoSW5kZXhlZCBVbml0cylcIixcIlVZUFwiOlwiVXJ1Z3VheWFuIFBlc28gKDE5NzXigJMxOTkzKVwiLFwiVVlVXCI6XCJVcnVndWF5YW4gUGVzb1wiLFwiVVlXXCI6XCJVcnVndWF5YW4gTm9taW5hbCBXYWdlIEluZGV4IFVuaXRcIixcIlVaU1wiOlwiVXpiZWtpc3RhbmkgU29tXCIsXCJWRUJcIjpcIlZlbmV6dWVsYW4gQm9sw612YXIgKDE4NzHigJMyMDA4KVwiLFwiVkVGXCI6XCJWZW5lenVlbGFuIEJvbMOtdmFyICgyMDA44oCTMjAxOClcIixcIlZFU1wiOlwiVmVuZXp1ZWxhbiBCb2zDrXZhclwiLFwiVk5EXCI6XCJWaWV0bmFtZXNlIERvbmdcIixcIlZOTlwiOlwiVmlldG5hbWVzZSBEb25nICgxOTc44oCTMTk4NSlcIixcIlZVVlwiOlwiVmFudWF0dSBWYXR1XCIsXCJXU1RcIjpcIlNhbW9hbiBUYWxhXCIsXCJYQUZcIjpcIkNlbnRyYWwgQWZyaWNhbiBDRkEgRnJhbmNcIixcIlhBR1wiOlwiU2lsdmVyXCIsXCJYQVVcIjpcIkdvbGRcIixcIlhCQVwiOlwiRXVyb3BlYW4gQ29tcG9zaXRlIFVuaXRcIixcIlhCQlwiOlwiRXVyb3BlYW4gTW9uZXRhcnkgVW5pdFwiLFwiWEJDXCI6XCJFdXJvcGVhbiBVbml0IG9mIEFjY291bnQgKFhCQylcIixcIlhCRFwiOlwiRXVyb3BlYW4gVW5pdCBvZiBBY2NvdW50IChYQkQpXCIsXCJYQ0RcIjpcIkVhc3QgQ2FyaWJiZWFuIERvbGxhclwiLFwiWERSXCI6XCJTcGVjaWFsIERyYXdpbmcgUmlnaHRzXCIsXCJYRVVcIjpcIkV1cm9wZWFuIEN1cnJlbmN5IFVuaXRcIixcIlhGT1wiOlwiRnJlbmNoIEdvbGQgRnJhbmNcIixcIlhGVVwiOlwiRnJlbmNoIFVJQy1GcmFuY1wiLFwiWE9GXCI6XCJXZXN0IEFmcmljYW4gQ0ZBIEZyYW5jXCIsXCJYUERcIjpcIlBhbGxhZGl1bVwiLFwiWFBGXCI6XCJDRlAgRnJhbmNcIixcIlhQVFwiOlwiUGxhdGludW1cIixcIlhSRVwiOlwiUklORVQgRnVuZHNcIixcIlhTVVwiOlwiU3VjcmVcIixcIlhUU1wiOlwiVGVzdGluZyBDdXJyZW5jeSBDb2RlXCIsXCJYVUFcIjpcIkFEQiBVbml0IG9mIEFjY291bnRcIixcIlhYWFwiOlwiVW5rbm93biBDdXJyZW5jeVwiLFwiWUREXCI6XCJZZW1lbmkgRGluYXJcIixcIllFUlwiOlwiWWVtZW5pIFJpYWxcIixcIllVRFwiOlwiWXVnb3NsYXZpYW4gSGFyZCBEaW5hciAoMTk2NuKAkzE5OTApXCIsXCJZVU1cIjpcIll1Z29zbGF2aWFuIE5ldyBEaW5hciAoMTk5NOKAkzIwMDIpXCIsXCJZVU5cIjpcIll1Z29zbGF2aWFuIENvbnZlcnRpYmxlIERpbmFyICgxOTkw4oCTMTk5MilcIixcIllVUlwiOlwiWXVnb3NsYXZpYW4gUmVmb3JtZWQgRGluYXIgKDE5OTLigJMxOTkzKVwiLFwiWkFMXCI6XCJTb3V0aCBBZnJpY2FuIFJhbmQgKGZpbmFuY2lhbClcIixcIlpBUlwiOlwiU291dGggQWZyaWNhbiBSYW5kXCIsXCJaTUtcIjpcIlphbWJpYW4gS3dhY2hhICgxOTY44oCTMjAxMilcIixcIlpNV1wiOlwiWmFtYmlhbiBLd2FjaGFcIixcIlpSTlwiOlwiWmFpcmVhbiBOZXcgWmFpcmUgKDE5OTPigJMxOTk4KVwiLFwiWlJaXCI6XCJaYWlyZWFuIFphaXJlICgxOTcx4oCTMTk5MylcIixcIlpXRFwiOlwiWmltYmFid2VhbiBEb2xsYXIgKDE5ODDigJMyMDA4KVwiLFwiWldMXCI6XCJaaW1iYWJ3ZWFuIERvbGxhciAoMjAwOSlcIixcIlpXUlwiOlwiWmltYmFid2VhbiBEb2xsYXIgKDIwMDgpXCJ9LFwic2hvcnRcIjp7fSxcIm5hcnJvd1wiOnt9fX0sXCJwYXR0ZXJuc1wiOntcImxvY2FsZVwiOlwiezB9ICh7MX0pXCJ9fSxcImxvY2FsZVwiOlwiZW5cIn1cbilcbn0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfMSA9IHJlcXVpcmUoXCIuL1wiKTtcbnZhciBzaG91bGRfcG9seWZpbGxfMSA9IHJlcXVpcmUoXCIuL3Nob3VsZC1wb2x5ZmlsbFwiKTtcbmlmIChzaG91bGRfcG9seWZpbGxfMS5zaG91bGRQb2x5ZmlsbCgpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEludGwsICdEaXNwbGF5TmFtZXMnLCB7XG4gICAgICAgIHZhbHVlOiBfMS5EaXNwbGF5TmFtZXMsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIH0pO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNob3VsZFBvbHlmaWxsID0gdm9pZCAwO1xuLyoqXG4gKiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDk3NDMyXG4gKi9cbmZ1bmN0aW9uIGhhc01pc3NpbmdJQ1VCdWcoKSB7XG4gICAgaWYgKEludGwuRGlzcGxheU5hbWVzKSB7XG4gICAgICAgIHZhciByZWdpb25OYW1lcyA9IG5ldyBJbnRsLkRpc3BsYXlOYW1lcyhbJ2VuJ10sIHtcbiAgICAgICAgICAgIHR5cGU6ICdyZWdpb24nLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlZ2lvbk5hbWVzLm9mKCdDQScpID09PSAnQ0EnO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzaG91bGRQb2x5ZmlsbCgpIHtcbiAgICByZXR1cm4gIUludGwuRGlzcGxheU5hbWVzIHx8IGhhc01pc3NpbmdJQ1VCdWcoKTtcbn1cbmV4cG9ydHMuc2hvdWxkUG9seWZpbGwgPSBzaG91bGRQb2x5ZmlsbDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1VuaWNvZGVMYW5ndWFnZVN1YnRhZyA9IGV4cG9ydHMuaXNVbmljb2RlU2NyaXB0U3VidGFnID0gZXhwb3J0cy5pc1VuaWNvZGVSZWdpb25TdWJ0YWcgPSBleHBvcnRzLmlzU3RydWN0dXJhbGx5VmFsaWRMYW5ndWFnZVRhZyA9IGV4cG9ydHMucGFyc2VVbmljb2RlTGFuZ3VhZ2VJZCA9IGV4cG9ydHMucGFyc2VVbmljb2RlTG9jYWxlSWQgPSBleHBvcnRzLmdldENhbm9uaWNhbExvY2FsZXMgPSB2b2lkIDA7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBwYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3NyYy9wYXJzZXJcIik7XG52YXIgZW1pdHRlcl8xID0gcmVxdWlyZShcIi4vc3JjL2VtaXR0ZXJcIik7XG52YXIgY2Fub25pY2FsaXplcl8xID0gcmVxdWlyZShcIi4vc3JjL2Nhbm9uaWNhbGl6ZXJcIik7XG4vKipcbiAqIGh0dHBzOi8vdGMzOS5lcy9lY21hNDAyLyNzZWMtY2Fub25pY2FsaXplbG9jYWxlbGlzdFxuICogQHBhcmFtIGxvY2FsZXNcbiAqL1xuZnVuY3Rpb24gQ2Fub25pY2FsaXplTG9jYWxlTGlzdChsb2NhbGVzKSB7XG4gICAgaWYgKGxvY2FsZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHZhciBzZWVuID0gW107XG4gICAgaWYgKHR5cGVvZiBsb2NhbGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICBsb2NhbGVzID0gW2xvY2FsZXNdO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDAsIGxvY2FsZXNfMSA9IGxvY2FsZXM7IF9pIDwgbG9jYWxlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgbG9jYWxlID0gbG9jYWxlc18xW19pXTtcbiAgICAgICAgdmFyIGNhbm9uaWNhbGl6ZWRUYWcgPSBlbWl0dGVyXzEuZW1pdFVuaWNvZGVMb2NhbGVJZChjYW5vbmljYWxpemVyXzEuY2Fub25pY2FsaXplVW5pY29kZUxvY2FsZUlkKHBhcnNlcl8xLnBhcnNlVW5pY29kZUxvY2FsZUlkKGxvY2FsZSkpKTtcbiAgICAgICAgaWYgKHNlZW4uaW5kZXhPZihjYW5vbmljYWxpemVkVGFnKSA8IDApIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjYW5vbmljYWxpemVkVGFnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2Vlbjtcbn1cbmZ1bmN0aW9uIGdldENhbm9uaWNhbExvY2FsZXMobG9jYWxlcykge1xuICAgIHJldHVybiBDYW5vbmljYWxpemVMb2NhbGVMaXN0KGxvY2FsZXMpO1xufVxuZXhwb3J0cy5nZXRDYW5vbmljYWxMb2NhbGVzID0gZ2V0Q2Fub25pY2FsTG9jYWxlcztcbnZhciBwYXJzZXJfMiA9IHJlcXVpcmUoXCIuL3NyYy9wYXJzZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZVVuaWNvZGVMb2NhbGVJZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFyc2VyXzIucGFyc2VVbmljb2RlTG9jYWxlSWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZVVuaWNvZGVMYW5ndWFnZUlkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXJzZXJfMi5wYXJzZVVuaWNvZGVMYW5ndWFnZUlkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNTdHJ1Y3R1cmFsbHlWYWxpZExhbmd1YWdlVGFnXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXJzZXJfMi5pc1N0cnVjdHVyYWxseVZhbGlkTGFuZ3VhZ2VUYWc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1VuaWNvZGVSZWdpb25TdWJ0YWdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhcnNlcl8yLmlzVW5pY29kZVJlZ2lvblN1YnRhZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzVW5pY29kZVNjcmlwdFN1YnRhZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFyc2VyXzIuaXNVbmljb2RlU2NyaXB0U3VidGFnOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNVbmljb2RlTGFuZ3VhZ2VTdWJ0YWdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhcnNlcl8yLmlzVW5pY29kZUxhbmd1YWdlU3VidGFnOyB9IH0pO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3JjL3R5cGVzXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NyYy9lbWl0dGVyXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYW5vbmljYWxpemVVbmljb2RlTG9jYWxlSWQgPSBleHBvcnRzLmNhbm9uaWNhbGl6ZVVuaWNvZGVMYW5ndWFnZUlkID0gdm9pZCAwO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgYWxpYXNlc18xID0gcmVxdWlyZShcIi4vZGF0YS9hbGlhc2VzXCIpO1xudmFyIHBhcnNlcl8xID0gcmVxdWlyZShcIi4vcGFyc2VyXCIpO1xudmFyIGxpa2VseVN1YnRhZ3MgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihyZXF1aXJlKFwiY2xkci1jb3JlL3N1cHBsZW1lbnRhbC9saWtlbHlTdWJ0YWdzLmpzb25cIikpO1xudmFyIGVtaXR0ZXJfMSA9IHJlcXVpcmUoXCIuL2VtaXR0ZXJcIik7XG5mdW5jdGlvbiBjYW5vbmljYWxpemVBdHRycyhzdHJzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHN0cnMucmVkdWNlKGZ1bmN0aW9uIChhbGwsIHN0cikge1xuICAgICAgICBhbGxbc3RyLnRvTG93ZXJDYXNlKCldID0gMTtcbiAgICAgICAgcmV0dXJuIGFsbDtcbiAgICB9LCB7fSkpLnNvcnQoKTtcbn1cbmZ1bmN0aW9uIGNhbm9uaWNhbGl6ZUtWcyhhcnIpIHtcbiAgICB2YXIgYWxsID0ge307XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMCwgYXJyXzEgPSBhcnI7IF9pIDwgYXJyXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBrdiA9IGFycl8xW19pXTtcbiAgICAgICAgaWYgKGt2WzBdIGluIGFsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYWxsW2t2WzBdXSA9IDE7XG4gICAgICAgIGlmICgha3ZbMV0gfHwga3ZbMV0gPT09ICd0cnVlJykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW2t2WzBdLnRvTG93ZXJDYXNlKCldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtrdlswXS50b0xvd2VyQ2FzZSgpLCBrdlsxXS50b0xvd2VyQ2FzZSgpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5zb3J0KGNvbXBhcmVLVik7XG59XG5mdW5jdGlvbiBjb21wYXJlS1YodDEsIHQyKSB7XG4gICAgcmV0dXJuIHQxWzBdIDwgdDJbMF0gPyAtMSA6IHQxWzBdID4gdDJbMF0gPyAxIDogMDtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVFeHRlbnNpb24oZTEsIGUyKSB7XG4gICAgcmV0dXJuIGUxLnR5cGUgPCBlMi50eXBlID8gLTEgOiBlMS50eXBlID4gZTIudHlwZSA/IDEgOiAwO1xufVxuZnVuY3Rpb24gbWVyZ2VWYXJpYW50cyh2MSwgdjIpIHtcbiAgICB2YXIgcmVzdWx0ID0gdHNsaWJfMS5fX3NwcmVhZEFycmF5cyh2MSk7XG4gICAgZm9yICh2YXIgX2kgPSAwLCB2Ml8xID0gdjI7IF9pIDwgdjJfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHYgPSB2Ml8xW19pXTtcbiAgICAgICAgaWYgKHYxLmluZGV4T2YodikgPCAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDQVZFQVQ6IFdlIGRvbid0IGRvIHRoaXMgc2VjdGlvbiBpbiB0aGUgc3BlYyBiYyB0aGV5IGhhdmUgbm8gSlNPTiBkYXRhXG4gKiBVc2UgdGhlIGJjcDQ3IGRhdGEgdG8gcmVwbGFjZSBrZXlzLCB0eXBlcywgdGZpZWxkcywgYW5kIHR2YWx1ZXMgYnkgdGhlaXIgY2Fub25pY2FsIGZvcm1zLiBTZWUgU2VjdGlvbiAzLjYuNCBVIEV4dGVuc2lvbiBEYXRhIEZpbGVzKSBhbmQgU2VjdGlvbiAzLjcuMSBUIEV4dGVuc2lvbiBEYXRhIEZpbGVzLiBUaGUgYWxpYXNlcyBhcmUgaW4gdGhlIGFsaWFzIGF0dHJpYnV0ZSB2YWx1ZSwgd2hpbGUgdGhlIGNhbm9uaWNhbCBpcyBpbiB0aGUgbmFtZSBhdHRyaWJ1dGUgdmFsdWUuIEZvciBleGFtcGxlLFxuQmVjYXVzZSBvZiB0aGUgZm9sbG93aW5nIGJjcDQ3IGRhdGE6XG48a2V5IG5hbWU9XCJtc1wi4oCmPuKApjx0eXBlIG5hbWU9XCJ1a3N5c3RlbVwiIOKApiBhbGlhcz1cImltcGVyaWFsXCIg4oCmIC8+4oCmPC9rZXk+XG5XZSBnZXQgdGhlIGZvbGxvd2luZyB0cmFuc2Zvcm1hdGlvbjpcbmVuLXUtbXMtaW1wZXJpYWwg4oeSIGVuLXUtbXMtdWtzeXN0ZW1cbiAqIEBwYXJhbSBsYW5nXG4gKi9cbmZ1bmN0aW9uIGNhbm9uaWNhbGl6ZVVuaWNvZGVMYW5ndWFnZUlkKHVuaWNvZGVMYW5ndWFnZUlkKSB7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGxhbmd1YWdlIHN1YnRhZyBtYXRjaGVzIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBhIGxhbmd1YWdlQWxpYXMgZWxlbWVudCBpbiBTdXBwbGVtZW50YWwgRGF0YSwgcmVwbGFjZSB0aGUgbGFuZ3VhZ2Ugc3VidGFnIHdpdGggdGhlIHJlcGxhY2VtZW50IHZhbHVlLlxuICAgICAqICAxLiBJZiB0aGVyZSBhcmUgYWRkaXRpb25hbCBzdWJ0YWdzIGluIHRoZSByZXBsYWNlbWVudCB2YWx1ZSwgYWRkIHRoZW0gdG8gdGhlIHJlc3VsdCwgYnV0IG9ubHkgaWYgdGhlcmUgaXMgbm8gY29ycmVzcG9uZGluZyBzdWJ0YWcgYWxyZWFkeSBpbiB0aGUgdGFnLlxuICAgICAqICAyLiBGaXZlIHNwZWNpYWwgZGVwcmVjYXRlZCBncmFuZGZhdGhlcmVkIGNvZGVzIChzdWNoIGFzIGktZGVmYXVsdCkgYXJlIGluIHR5cGUgYXR0cmlidXRlcywgYW5kIGFyZSBhbHNvIHJlcGxhY2VkLlxuICAgICAqL1xuICAgIC8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL3VuaWNvZGUtb3JnL2ljdS9ibG9iL21hc3Rlci9pY3U0ai9tYWluL2NsYXNzZXMvY29yZS9zcmMvY29tL2libS9pY3UvdXRpbC9VTG9jYWxlLmphdmEjTDEyNDZcbiAgICAvLyBUcnkgbGFuZ3VhZ2UgXyB2YXJpYW50XG4gICAgdmFyIGZpbmFsTGFuZ0FzdCA9IHVuaWNvZGVMYW5ndWFnZUlkO1xuICAgIGlmICh1bmljb2RlTGFuZ3VhZ2VJZC52YXJpYW50cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlcGxhY2VkTGFuZ18xID0gJyc7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB1bmljb2RlTGFuZ3VhZ2VJZC52YXJpYW50czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciB2YXJpYW50ID0gX2FbX2ldO1xuICAgICAgICAgICAgaWYgKChyZXBsYWNlZExhbmdfMSA9XG4gICAgICAgICAgICAgICAgYWxpYXNlc18xLmxhbmd1YWdlQWxpYXNbZW1pdHRlcl8xLmVtaXRVbmljb2RlTGFuZ3VhZ2VJZCh7XG4gICAgICAgICAgICAgICAgICAgIGxhbmc6IHVuaWNvZGVMYW5ndWFnZUlkLmxhbmcsXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhbnRzOiBbdmFyaWFudF0sXG4gICAgICAgICAgICAgICAgfSldKSkge1xuICAgICAgICAgICAgICAgIHZhciByZXBsYWNlZExhbmdBc3QgPSBwYXJzZXJfMS5wYXJzZVVuaWNvZGVMYW5ndWFnZUlkKHJlcGxhY2VkTGFuZ18xLnNwbGl0KHBhcnNlcl8xLlNFUEFSQVRPUikpO1xuICAgICAgICAgICAgICAgIGZpbmFsTGFuZ0FzdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGFuZzogcmVwbGFjZWRMYW5nQXN0LmxhbmcsXG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdDogZmluYWxMYW5nQXN0LnNjcmlwdCB8fCByZXBsYWNlZExhbmdBc3Quc2NyaXB0LFxuICAgICAgICAgICAgICAgICAgICByZWdpb246IGZpbmFsTGFuZ0FzdC5yZWdpb24gfHwgcmVwbGFjZWRMYW5nQXN0LnJlZ2lvbixcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFudHM6IG1lcmdlVmFyaWFudHMoZmluYWxMYW5nQXN0LnZhcmlhbnRzLCByZXBsYWNlZExhbmdBc3QudmFyaWFudHMpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gbGFuZ3VhZ2UgXyBzY3JpcHQgXyBjb3VudHJ5XG4gICAgLy8gdWctQXJhYi1DTiAtPiB1Zy1DTlxuICAgIGlmIChmaW5hbExhbmdBc3Quc2NyaXB0ICYmIGZpbmFsTGFuZ0FzdC5yZWdpb24pIHtcbiAgICAgICAgdmFyIHJlcGxhY2VkTGFuZ18yID0gYWxpYXNlc18xLmxhbmd1YWdlQWxpYXNbZW1pdHRlcl8xLmVtaXRVbmljb2RlTGFuZ3VhZ2VJZCh7XG4gICAgICAgICAgICBsYW5nOiBmaW5hbExhbmdBc3QubGFuZyxcbiAgICAgICAgICAgIHNjcmlwdDogZmluYWxMYW5nQXN0LnNjcmlwdCxcbiAgICAgICAgICAgIHJlZ2lvbjogZmluYWxMYW5nQXN0LnJlZ2lvbixcbiAgICAgICAgICAgIHZhcmlhbnRzOiBbXSxcbiAgICAgICAgfSldO1xuICAgICAgICBpZiAocmVwbGFjZWRMYW5nXzIpIHtcbiAgICAgICAgICAgIHZhciByZXBsYWNlZExhbmdBc3QgPSBwYXJzZXJfMS5wYXJzZVVuaWNvZGVMYW5ndWFnZUlkKHJlcGxhY2VkTGFuZ18yLnNwbGl0KHBhcnNlcl8xLlNFUEFSQVRPUikpO1xuICAgICAgICAgICAgZmluYWxMYW5nQXN0ID0ge1xuICAgICAgICAgICAgICAgIGxhbmc6IHJlcGxhY2VkTGFuZ0FzdC5sYW5nLFxuICAgICAgICAgICAgICAgIHNjcmlwdDogcmVwbGFjZWRMYW5nQXN0LnNjcmlwdCxcbiAgICAgICAgICAgICAgICByZWdpb246IHJlcGxhY2VkTGFuZ0FzdC5yZWdpb24sXG4gICAgICAgICAgICAgICAgdmFyaWFudHM6IGZpbmFsTGFuZ0FzdC52YXJpYW50cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gbGFuZ3VhZ2UgXyBjb3VudHJ5XG4gICAgLy8gZWcuIGF6X0FaIC0+IGF6X0xhdG5fQVxuICAgIGlmIChmaW5hbExhbmdBc3QucmVnaW9uKSB7XG4gICAgICAgIHZhciByZXBsYWNlZExhbmdfMyA9IGFsaWFzZXNfMS5sYW5ndWFnZUFsaWFzW2VtaXR0ZXJfMS5lbWl0VW5pY29kZUxhbmd1YWdlSWQoe1xuICAgICAgICAgICAgbGFuZzogZmluYWxMYW5nQXN0LmxhbmcsXG4gICAgICAgICAgICByZWdpb246IGZpbmFsTGFuZ0FzdC5yZWdpb24sXG4gICAgICAgICAgICB2YXJpYW50czogW10sXG4gICAgICAgIH0pXTtcbiAgICAgICAgaWYgKHJlcGxhY2VkTGFuZ18zKSB7XG4gICAgICAgICAgICB2YXIgcmVwbGFjZWRMYW5nQXN0ID0gcGFyc2VyXzEucGFyc2VVbmljb2RlTGFuZ3VhZ2VJZChyZXBsYWNlZExhbmdfMy5zcGxpdChwYXJzZXJfMS5TRVBBUkFUT1IpKTtcbiAgICAgICAgICAgIGZpbmFsTGFuZ0FzdCA9IHtcbiAgICAgICAgICAgICAgICBsYW5nOiByZXBsYWNlZExhbmdBc3QubGFuZyxcbiAgICAgICAgICAgICAgICBzY3JpcHQ6IGZpbmFsTGFuZ0FzdC5zY3JpcHQgfHwgcmVwbGFjZWRMYW5nQXN0LnNjcmlwdCxcbiAgICAgICAgICAgICAgICByZWdpb246IHJlcGxhY2VkTGFuZ0FzdC5yZWdpb24sXG4gICAgICAgICAgICAgICAgdmFyaWFudHM6IGZpbmFsTGFuZ0FzdC52YXJpYW50cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gb25seSBsYW5ndWFnZVxuICAgIC8vIGUuZy4gdHdpIC0+IGFrXG4gICAgdmFyIHJlcGxhY2VkTGFuZyA9IGFsaWFzZXNfMS5sYW5ndWFnZUFsaWFzW2VtaXR0ZXJfMS5lbWl0VW5pY29kZUxhbmd1YWdlSWQoe1xuICAgICAgICBsYW5nOiBmaW5hbExhbmdBc3QubGFuZyxcbiAgICAgICAgdmFyaWFudHM6IFtdLFxuICAgIH0pXTtcbiAgICBpZiAocmVwbGFjZWRMYW5nKSB7XG4gICAgICAgIHZhciByZXBsYWNlZExhbmdBc3QgPSBwYXJzZXJfMS5wYXJzZVVuaWNvZGVMYW5ndWFnZUlkKHJlcGxhY2VkTGFuZy5zcGxpdChwYXJzZXJfMS5TRVBBUkFUT1IpKTtcbiAgICAgICAgZmluYWxMYW5nQXN0ID0ge1xuICAgICAgICAgICAgbGFuZzogcmVwbGFjZWRMYW5nQXN0LmxhbmcsXG4gICAgICAgICAgICBzY3JpcHQ6IGZpbmFsTGFuZ0FzdC5zY3JpcHQgfHwgcmVwbGFjZWRMYW5nQXN0LnNjcmlwdCxcbiAgICAgICAgICAgIHJlZ2lvbjogZmluYWxMYW5nQXN0LnJlZ2lvbiB8fCByZXBsYWNlZExhbmdBc3QucmVnaW9uLFxuICAgICAgICAgICAgdmFyaWFudHM6IGZpbmFsTGFuZ0FzdC52YXJpYW50cyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGZpbmFsTGFuZ0FzdC5yZWdpb24pIHtcbiAgICAgICAgdmFyIHJlZ2lvbiA9IGZpbmFsTGFuZ0FzdC5yZWdpb24udG9VcHBlckNhc2UoKTtcbiAgICAgICAgdmFyIHJlZ2lvbkFsaWFzID0gYWxpYXNlc18xLnRlcnJpdG9yeUFsaWFzW3JlZ2lvbl07XG4gICAgICAgIHZhciByZXBsYWNlZFJlZ2lvbiA9IHZvaWQgMDtcbiAgICAgICAgaWYgKHJlZ2lvbkFsaWFzKSB7XG4gICAgICAgICAgICB2YXIgcmVnaW9ucyA9IHJlZ2lvbkFsaWFzLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICByZXBsYWNlZFJlZ2lvbiA9IHJlZ2lvbnNbMF07XG4gICAgICAgICAgICB2YXIgbGlrZWx5U3VidGFnID0gbGlrZWx5U3VidGFncy5zdXBwbGVtZW50YWwubGlrZWx5U3VidGFnc1tlbWl0dGVyXzEuZW1pdFVuaWNvZGVMYW5ndWFnZUlkKHtcbiAgICAgICAgICAgICAgICBsYW5nOiBmaW5hbExhbmdBc3QubGFuZyxcbiAgICAgICAgICAgICAgICBzY3JpcHQ6IGZpbmFsTGFuZ0FzdC5zY3JpcHQsXG4gICAgICAgICAgICAgICAgdmFyaWFudHM6IFtdLFxuICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgaWYgKGxpa2VseVN1YnRhZykge1xuICAgICAgICAgICAgICAgIHZhciBsaWtlbHlSZWdpb24gPSBwYXJzZXJfMS5wYXJzZVVuaWNvZGVMYW5ndWFnZUlkKGxpa2VseVN1YnRhZy5zcGxpdChwYXJzZXJfMS5TRVBBUkFUT1IpKS5yZWdpb247XG4gICAgICAgICAgICAgICAgaWYgKGxpa2VseVJlZ2lvbiAmJiByZWdpb25zLmluZGV4T2YobGlrZWx5UmVnaW9uKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VkUmVnaW9uID0gbGlrZWx5UmVnaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVwbGFjZWRSZWdpb24pIHtcbiAgICAgICAgICAgIGZpbmFsTGFuZ0FzdC5yZWdpb24gPSByZXBsYWNlZFJlZ2lvbjtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbExhbmdBc3QucmVnaW9uID0gZmluYWxMYW5nQXN0LnJlZ2lvbi50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgICBpZiAoZmluYWxMYW5nQXN0LnNjcmlwdCkge1xuICAgICAgICBmaW5hbExhbmdBc3Quc2NyaXB0ID1cbiAgICAgICAgICAgIGZpbmFsTGFuZ0FzdC5zY3JpcHRbMF0udG9VcHBlckNhc2UoKSArXG4gICAgICAgICAgICAgICAgZmluYWxMYW5nQXN0LnNjcmlwdC5zbGljZSgxKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoYWxpYXNlc18xLnNjcmlwdEFsaWFzW2ZpbmFsTGFuZ0FzdC5zY3JpcHRdKSB7XG4gICAgICAgICAgICBmaW5hbExhbmdBc3Quc2NyaXB0ID0gYWxpYXNlc18xLnNjcmlwdEFsaWFzW2ZpbmFsTGFuZ0FzdC5zY3JpcHRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmaW5hbExhbmdBc3QudmFyaWFudHMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmluYWxMYW5nQXN0LnZhcmlhbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmFyaWFudCA9IGZpbmFsTGFuZ0FzdC52YXJpYW50c1tpXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKGFsaWFzZXNfMS52YXJpYW50QWxpYXNbdmFyaWFudF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgYWxpYXMgPSBhbGlhc2VzXzEudmFyaWFudEFsaWFzW3ZhcmlhbnRdO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZXJfMS5pc1VuaWNvZGVWYXJpYW50U3VidGFnKGFsaWFzKSkge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbExhbmdBc3QudmFyaWFudHNbaV0gPSBhbGlhcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyc2VyXzEuaXNVbmljb2RlTGFuZ3VhZ2VTdWJ0YWcoYWxpYXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFllcyB0aGlzIGNhbiBoYXBwZW4gcGVyIHRoZSBzcGVjXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsTGFuZ0FzdC5sYW5nID0gYWxpYXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsTGFuZ0FzdC52YXJpYW50cy5zb3J0KCk7XG4gICAgfVxuICAgIHJldHVybiBmaW5hbExhbmdBc3Q7XG59XG5leHBvcnRzLmNhbm9uaWNhbGl6ZVVuaWNvZGVMYW5ndWFnZUlkID0gY2Fub25pY2FsaXplVW5pY29kZUxhbmd1YWdlSWQ7XG4vKipcbiAqIENhbm9uaWNhbGl6ZSBiYXNlZCBvblxuICogaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUuaHRtbCNDYW5vbmljYWxfVW5pY29kZV9Mb2NhbGVfSWRlbnRpZmllcnNcbiAqIGh0dHBzOi8vdGMzOS5lcy9lY21hNDAyLyNzZWMtY2Fub25pY2FsaXpldW5pY29kZWxvY2FsZWlkXG4gKiBJTVBPUlRBTlQ6IFRoaXMgbW9kaWZpZXMgdGhlIG9iamVjdCBpbmxpbmVcbiAqIEBwYXJhbSBsb2NhbGVcbiAqL1xuZnVuY3Rpb24gY2Fub25pY2FsaXplVW5pY29kZUxvY2FsZUlkKGxvY2FsZSkge1xuICAgIGxvY2FsZS5sYW5nID0gY2Fub25pY2FsaXplVW5pY29kZUxhbmd1YWdlSWQobG9jYWxlLmxhbmcpO1xuICAgIGlmIChsb2NhbGUuZXh0ZW5zaW9ucykge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gbG9jYWxlLmV4dGVuc2lvbnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZXh0ZW5zaW9uID0gX2FbX2ldO1xuICAgICAgICAgICAgc3dpdGNoIChleHRlbnNpb24udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24ua2V5d29yZHMgPSBjYW5vbmljYWxpemVLVnMoZXh0ZW5zaW9uLmtleXdvcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbi5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24uYXR0cmlidXRlcyA9IGNhbm9uaWNhbGl6ZUF0dHJzKGV4dGVuc2lvbi5hdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbi5sYW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24ubGFuZyA9IGNhbm9uaWNhbGl6ZVVuaWNvZGVMYW5ndWFnZUlkKGV4dGVuc2lvbi5sYW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24uZmllbGRzID0gY2Fub25pY2FsaXplS1ZzKGV4dGVuc2lvbi5maWVsZHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24udmFsdWUgPSBleHRlbnNpb24udmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbG9jYWxlLmV4dGVuc2lvbnMuc29ydChjb21wYXJlRXh0ZW5zaW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZTtcbn1cbmV4cG9ydHMuY2Fub25pY2FsaXplVW5pY29kZUxvY2FsZUlkID0gY2Fub25pY2FsaXplVW5pY29kZUxvY2FsZUlkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhcmlhbnRBbGlhcyA9IGV4cG9ydHMuc2NyaXB0QWxpYXMgPSBleHBvcnRzLnRlcnJpdG9yeUFsaWFzID0gZXhwb3J0cy5sYW5ndWFnZUFsaWFzID0gdm9pZCAwO1xuLyogQGdlbmVyYXRlZCAqL1xuLy8gcHJldHRpZXItaWdub3JlICBcbmV4cG9ydHMubGFuZ3VhZ2VBbGlhcyA9IHtcbiAgICBcImFhLXNhYWhvXCI6IFwic3N5XCIsXG4gICAgXCJhYW1cIjogXCJhYXNcIixcbiAgICBcImFhclwiOiBcImFhXCIsXG4gICAgXCJhYmtcIjogXCJhYlwiLFxuICAgIFwiYWRwXCI6IFwiZHpcIixcbiAgICBcImFmclwiOiBcImFmXCIsXG4gICAgXCJhZ3BcIjogXCJhcGZcIixcbiAgICBcImFpc1wiOiBcImFtaVwiLFxuICAgIFwiYWp1XCI6IFwianJiXCIsXG4gICAgXCJha2FcIjogXCJha1wiLFxuICAgIFwiYWxiXCI6IFwic3FcIixcbiAgICBcImFsc1wiOiBcInNxXCIsXG4gICAgXCJhbWhcIjogXCJhbVwiLFxuICAgIFwiYXJhXCI6IFwiYXJcIixcbiAgICBcImFyYlwiOiBcImFyXCIsXG4gICAgXCJhcmdcIjogXCJhblwiLFxuICAgIFwiYXJtXCI6IFwiaHlcIixcbiAgICBcImFydC1sb2piYW5cIjogXCJqYm9cIixcbiAgICBcImFzZFwiOiBcInNuelwiLFxuICAgIFwiYXNtXCI6IFwiYXNcIixcbiAgICBcImF1ZVwiOiBcImt0elwiLFxuICAgIFwiYXZhXCI6IFwiYXZcIixcbiAgICBcImF2ZVwiOiBcImFlXCIsXG4gICAgXCJheW1cIjogXCJheVwiLFxuICAgIFwiYXlyXCI6IFwiYXlcIixcbiAgICBcImF5eFwiOiBcIm51blwiLFxuICAgIFwiYXplXCI6IFwiYXpcIixcbiAgICBcImF6alwiOiBcImF6XCIsXG4gICAgXCJiYWtcIjogXCJiYVwiLFxuICAgIFwiYmFtXCI6IFwiYm1cIixcbiAgICBcImJhcVwiOiBcImV1XCIsXG4gICAgXCJiYXpcIjogXCJudm9cIixcbiAgICBcImJjY1wiOiBcImJhbFwiLFxuICAgIFwiYmNsXCI6IFwiYmlrXCIsXG4gICAgXCJiZWxcIjogXCJiZVwiLFxuICAgIFwiYmVuXCI6IFwiYm5cIixcbiAgICBcImJnbVwiOiBcImJjZ1wiLFxuICAgIFwiYmhcIjogXCJiaG9cIixcbiAgICBcImJoa1wiOiBcImZibFwiLFxuICAgIFwiYmloXCI6IFwiYmhvXCIsXG4gICAgXCJiaXNcIjogXCJiaVwiLFxuICAgIFwiYmpkXCI6IFwiZHJsXCIsXG4gICAgXCJianFcIjogXCJiemNcIixcbiAgICBcImJrYlwiOiBcImVia1wiLFxuICAgIFwiYm9kXCI6IFwiYm9cIixcbiAgICBcImJvc1wiOiBcImJzXCIsXG4gICAgXCJicmVcIjogXCJiclwiLFxuICAgIFwiYnRiXCI6IFwiYmViXCIsXG4gICAgXCJidWxcIjogXCJiZ1wiLFxuICAgIFwiYnVyXCI6IFwibXlcIixcbiAgICBcImJ4a1wiOiBcImx1eVwiLFxuICAgIFwiYnhyXCI6IFwiYnVhXCIsXG4gICAgXCJjYXRcIjogXCJjYVwiLFxuICAgIFwiY2NxXCI6IFwicmtpXCIsXG4gICAgXCJjZWwtZ2F1bGlzaFwiOiBcInh0Z1wiLFxuICAgIFwiY2VzXCI6IFwiY3NcIixcbiAgICBcImNoYVwiOiBcImNoXCIsXG4gICAgXCJjaGVcIjogXCJjZVwiLFxuICAgIFwiY2hpXCI6IFwiemhcIixcbiAgICBcImNodVwiOiBcImN1XCIsXG4gICAgXCJjaHZcIjogXCJjdlwiLFxuICAgIFwiY2pyXCI6IFwibW9tXCIsXG4gICAgXCJja2FcIjogXCJjbXJcIixcbiAgICBcImNsZFwiOiBcInN5clwiLFxuICAgIFwiY21rXCI6IFwieGNoXCIsXG4gICAgXCJjbW5cIjogXCJ6aFwiLFxuICAgIFwiY25yXCI6IFwic3ItTUVcIixcbiAgICBcImNvclwiOiBcImt3XCIsXG4gICAgXCJjb3NcIjogXCJjb1wiLFxuICAgIFwiY295XCI6IFwicGlqXCIsXG4gICAgXCJjcXVcIjogXCJxdWhcIixcbiAgICBcImNyZVwiOiBcImNyXCIsXG4gICAgXCJjd2RcIjogXCJjclwiLFxuICAgIFwiY3ltXCI6IFwiY3lcIixcbiAgICBcImN6ZVwiOiBcImNzXCIsXG4gICAgXCJkYWZcIjogXCJkbmpcIixcbiAgICBcImRhblwiOiBcImRhXCIsXG4gICAgXCJkYXBcIjogXCJuanpcIixcbiAgICBcImRldVwiOiBcImRlXCIsXG4gICAgXCJkZ29cIjogXCJkb2lcIixcbiAgICBcImRoZFwiOiBcIm13clwiLFxuICAgIFwiZGlrXCI6IFwiZGluXCIsXG4gICAgXCJkaXFcIjogXCJ6emFcIixcbiAgICBcImRpdFwiOiBcImRpZlwiLFxuICAgIFwiZGl2XCI6IFwiZHZcIixcbiAgICBcImRqbFwiOiBcImR6ZVwiLFxuICAgIFwiZGtsXCI6IFwiYXFkXCIsXG4gICAgXCJkcmhcIjogXCJtblwiLFxuICAgIFwiZHJyXCI6IFwia3prXCIsXG4gICAgXCJkcndcIjogXCJmYS1BRlwiLFxuICAgIFwiZHVkXCI6IFwidXRoXCIsXG4gICAgXCJkdWpcIjogXCJkd3VcIixcbiAgICBcImR1dFwiOiBcIm5sXCIsXG4gICAgXCJkd2xcIjogXCJkYnRcIixcbiAgICBcImR6b1wiOiBcImR6XCIsXG4gICAgXCJla2tcIjogXCJldFwiLFxuICAgIFwiZWxsXCI6IFwiZWxcIixcbiAgICBcImVscFwiOiBcImFtcVwiLFxuICAgIFwiZW1rXCI6IFwibWFuXCIsXG4gICAgXCJlbi1HQi1vZWRcIjogXCJlbi1HQi1veGVuZGljdFwiLFxuICAgIFwiZW5nXCI6IFwiZW5cIixcbiAgICBcImVwb1wiOiBcImVvXCIsXG4gICAgXCJlc2tcIjogXCJpa1wiLFxuICAgIFwiZXN0XCI6IFwiZXRcIixcbiAgICBcImV1c1wiOiBcImV1XCIsXG4gICAgXCJld2VcIjogXCJlZVwiLFxuICAgIFwiZmFvXCI6IFwiZm9cIixcbiAgICBcImZhc1wiOiBcImZhXCIsXG4gICAgXCJmYXRcIjogXCJha1wiLFxuICAgIFwiZmlqXCI6IFwiZmpcIixcbiAgICBcImZpblwiOiBcImZpXCIsXG4gICAgXCJmcmFcIjogXCJmclwiLFxuICAgIFwiZnJlXCI6IFwiZnJcIixcbiAgICBcImZyeVwiOiBcImZ5XCIsXG4gICAgXCJmdWNcIjogXCJmZlwiLFxuICAgIFwiZnVsXCI6IFwiZmZcIixcbiAgICBcImdhdlwiOiBcImRldlwiLFxuICAgIFwiZ2F6XCI6IFwib21cIixcbiAgICBcImdiY1wiOiBcIndueVwiLFxuICAgIFwiZ2JvXCI6IFwiZ3JiXCIsXG4gICAgXCJnZW9cIjogXCJrYVwiLFxuICAgIFwiZ2VyXCI6IFwiZGVcIixcbiAgICBcImdmeFwiOiBcInZhalwiLFxuICAgIFwiZ2duXCI6IFwiZ3ZyXCIsXG4gICAgXCJnZ29cIjogXCJlc2dcIixcbiAgICBcImdnclwiOiBcImd0dVwiLFxuICAgIFwiZ2lvXCI6IFwiYW91XCIsXG4gICAgXCJnbGFcIjogXCJnZFwiLFxuICAgIFwiZ2xlXCI6IFwiZ2FcIixcbiAgICBcImdsZ1wiOiBcImdsXCIsXG4gICAgXCJnbGlcIjogXCJremtcIixcbiAgICBcImdsdlwiOiBcImd2XCIsXG4gICAgXCJnbm9cIjogXCJnb25cIixcbiAgICBcImdyZVwiOiBcImVsXCIsXG4gICAgXCJncm5cIjogXCJnblwiLFxuICAgIFwiZ3RpXCI6IFwibnljXCIsXG4gICAgXCJndWdcIjogXCJnblwiLFxuICAgIFwiZ3VqXCI6IFwiZ3VcIixcbiAgICBcImd1dlwiOiBcImR1elwiLFxuICAgIFwiZ3lhXCI6IFwiZ2JhXCIsXG4gICAgXCJoYXRcIjogXCJodFwiLFxuICAgIFwiaGF1XCI6IFwiaGFcIixcbiAgICBcImhic1wiOiBcInNyLUxhdG5cIixcbiAgICBcImhkblwiOiBcImhhaVwiLFxuICAgIFwiaGVhXCI6IFwiaG1uXCIsXG4gICAgXCJoZWJcIjogXCJoZVwiLFxuICAgIFwiaGVyXCI6IFwiaHpcIixcbiAgICBcImhpbVwiOiBcInNyeFwiLFxuICAgIFwiaGluXCI6IFwiaGlcIixcbiAgICBcImhtb1wiOiBcImhvXCIsXG4gICAgXCJocnJcIjogXCJqYWxcIixcbiAgICBcImhydlwiOiBcImhyXCIsXG4gICAgXCJodW5cIjogXCJodVwiLFxuICAgIFwiaHktYXJldm1kYVwiOiBcImh5d1wiLFxuICAgIFwiaHllXCI6IFwiaHlcIixcbiAgICBcImktYW1pXCI6IFwiYW1pXCIsXG4gICAgXCJpLWJublwiOiBcImJublwiLFxuICAgIFwiaS1kZWZhdWx0XCI6IFwiZW4teC1pLWRlZmF1bHRcIixcbiAgICBcImktZW5vY2hpYW5cIjogXCJ1bmQteC1pLWVub2NoaWFuXCIsXG4gICAgXCJpLWhha1wiOiBcImhha1wiLFxuICAgIFwiaS1rbGluZ29uXCI6IFwidGxoXCIsXG4gICAgXCJpLWx1eFwiOiBcImxiXCIsXG4gICAgXCJpLW1pbmdvXCI6IFwic2VlLXgtaS1taW5nb1wiLFxuICAgIFwiaS1uYXZham9cIjogXCJudlwiLFxuICAgIFwiaS1wd25cIjogXCJwd25cIixcbiAgICBcImktdGFvXCI6IFwidGFvXCIsXG4gICAgXCJpLXRheVwiOiBcInRheVwiLFxuICAgIFwiaS10c3VcIjogXCJ0c3VcIixcbiAgICBcImliaVwiOiBcIm9wYVwiLFxuICAgIFwiaWJvXCI6IFwiaWdcIixcbiAgICBcImljZVwiOiBcImlzXCIsXG4gICAgXCJpZG9cIjogXCJpb1wiLFxuICAgIFwiaWlpXCI6IFwiaWlcIixcbiAgICBcImlrZVwiOiBcIml1XCIsXG4gICAgXCJpa3VcIjogXCJpdVwiLFxuICAgIFwiaWxlXCI6IFwiaWVcIixcbiAgICBcImlsbFwiOiBcImlsbVwiLFxuICAgIFwiaWx3XCI6IFwiZ2FsXCIsXG4gICAgXCJpblwiOiBcImlkXCIsXG4gICAgXCJpbmFcIjogXCJpYVwiLFxuICAgIFwiaW5kXCI6IFwiaWRcIixcbiAgICBcImlwa1wiOiBcImlrXCIsXG4gICAgXCJpc2xcIjogXCJpc1wiLFxuICAgIFwiaXRhXCI6IFwiaXRcIixcbiAgICBcIml3XCI6IFwiaGVcIixcbiAgICBcIml6aVwiOiBcImV6YVwiLFxuICAgIFwiamFyXCI6IFwiamdrXCIsXG4gICAgXCJqYXZcIjogXCJqdlwiLFxuICAgIFwiamVnXCI6IFwib3liXCIsXG4gICAgXCJqaVwiOiBcInlpXCIsXG4gICAgXCJqcG5cIjogXCJqYVwiLFxuICAgIFwiandcIjogXCJqdlwiLFxuICAgIFwia2FsXCI6IFwia2xcIixcbiAgICBcImthblwiOiBcImtuXCIsXG4gICAgXCJrYXNcIjogXCJrc1wiLFxuICAgIFwia2F0XCI6IFwia2FcIixcbiAgICBcImthdVwiOiBcImtyXCIsXG4gICAgXCJrYXpcIjogXCJra1wiLFxuICAgIFwia2R2XCI6IFwiemtkXCIsXG4gICAgXCJrZ2NcIjogXCJ0ZGZcIixcbiAgICBcImtnZFwiOiBcIm5jcVwiLFxuICAgIFwia2doXCI6IFwia21sXCIsXG4gICAgXCJraGtcIjogXCJtblwiLFxuICAgIFwia2htXCI6IFwia21cIixcbiAgICBcImtpa1wiOiBcImtpXCIsXG4gICAgXCJraW5cIjogXCJyd1wiLFxuICAgIFwia2lyXCI6IFwia3lcIixcbiAgICBcImttclwiOiBcImt1XCIsXG4gICAgXCJrbmNcIjogXCJrclwiLFxuICAgIFwia25nXCI6IFwia2dcIixcbiAgICBcImtublwiOiBcImtva1wiLFxuICAgIFwia29qXCI6IFwia3d2XCIsXG4gICAgXCJrb21cIjogXCJrdlwiLFxuICAgIFwia29uXCI6IFwia2dcIixcbiAgICBcImtvclwiOiBcImtvXCIsXG4gICAgXCJrcHBcIjogXCJqa21cIixcbiAgICBcImtwdlwiOiBcImt2XCIsXG4gICAgXCJrcm1cIjogXCJibWZcIixcbiAgICBcImt0clwiOiBcImR0cFwiLFxuICAgIFwia3VhXCI6IFwia2pcIixcbiAgICBcImt1clwiOiBcImt1XCIsXG4gICAgXCJrdnNcIjogXCJnZGpcIixcbiAgICBcImt3cVwiOiBcInlhbVwiLFxuICAgIFwia3hlXCI6IFwidHZkXCIsXG4gICAgXCJreGxcIjogXCJrcnVcIixcbiAgICBcImt6aFwiOiBcImRnbFwiLFxuICAgIFwia3pqXCI6IFwiZHRwXCIsXG4gICAgXCJrenRcIjogXCJkdHBcIixcbiAgICBcImxhb1wiOiBcImxvXCIsXG4gICAgXCJsYXRcIjogXCJsYVwiLFxuICAgIFwibGF2XCI6IFwibHZcIixcbiAgICBcImxia1wiOiBcImJuY1wiLFxuICAgIFwibGVnXCI6IFwiZW5sXCIsXG4gICAgXCJsaWlcIjogXCJyYXFcIixcbiAgICBcImxpbVwiOiBcImxpXCIsXG4gICAgXCJsaW5cIjogXCJsblwiLFxuICAgIFwibGl0XCI6IFwibHRcIixcbiAgICBcImxsb1wiOiBcIm5ndFwiLFxuICAgIFwibG1tXCI6IFwicm14XCIsXG4gICAgXCJsdHpcIjogXCJsYlwiLFxuICAgIFwibHViXCI6IFwibHVcIixcbiAgICBcImx1Z1wiOiBcImxnXCIsXG4gICAgXCJsdnNcIjogXCJsdlwiLFxuICAgIFwibWFjXCI6IFwibWtcIixcbiAgICBcIm1haFwiOiBcIm1oXCIsXG4gICAgXCJtYWxcIjogXCJtbFwiLFxuICAgIFwibWFvXCI6IFwibWlcIixcbiAgICBcIm1hclwiOiBcIm1yXCIsXG4gICAgXCJtYXlcIjogXCJtc1wiLFxuICAgIFwibWVnXCI6IFwiY2lyXCIsXG4gICAgXCJtZ3hcIjogXCJqYmtcIixcbiAgICBcIm1oclwiOiBcImNobVwiLFxuICAgIFwibWtkXCI6IFwibWtcIixcbiAgICBcIm1sZ1wiOiBcIm1nXCIsXG4gICAgXCJtbHRcIjogXCJtdFwiLFxuICAgIFwibW5rXCI6IFwibWFuXCIsXG4gICAgXCJtbnRcIjogXCJ3bm5cIixcbiAgICBcIm1vXCI6IFwicm9cIixcbiAgICBcIm1vZlwiOiBcInhudFwiLFxuICAgIFwibW9sXCI6IFwicm9cIixcbiAgICBcIm1vblwiOiBcIm1uXCIsXG4gICAgXCJtcmlcIjogXCJtaVwiLFxuICAgIFwibXNhXCI6IFwibXNcIixcbiAgICBcIm1zdFwiOiBcIm1yeVwiLFxuICAgIFwibXVwXCI6IFwicmFqXCIsXG4gICAgXCJtd2RcIjogXCJkbXdcIixcbiAgICBcIm13alwiOiBcInZhalwiLFxuICAgIFwibXlhXCI6IFwibXlcIixcbiAgICBcIm15ZFwiOiBcImFvZ1wiLFxuICAgIFwibXl0XCI6IFwibXJ5XCIsXG4gICAgXCJuYWRcIjogXCJ4bnlcIixcbiAgICBcIm5hdVwiOiBcIm5hXCIsXG4gICAgXCJuYXZcIjogXCJudlwiLFxuICAgIFwibmJmXCI6IFwibnJ1XCIsXG4gICAgXCJuYmxcIjogXCJuclwiLFxuICAgIFwibmJ4XCI6IFwiZWtjXCIsXG4gICAgXCJuY3BcIjogXCJrZHpcIixcbiAgICBcIm5kZVwiOiBcIm5kXCIsXG4gICAgXCJuZG9cIjogXCJuZ1wiLFxuICAgIFwibmVwXCI6IFwibmVcIixcbiAgICBcIm5sZFwiOiBcIm5sXCIsXG4gICAgXCJubG5cIjogXCJhemRcIixcbiAgICBcIm5sclwiOiBcIm5ya1wiLFxuICAgIFwibm5vXCI6IFwibm5cIixcbiAgICBcIm5uc1wiOiBcIm5iclwiLFxuICAgIFwibm54XCI6IFwibmd2XCIsXG4gICAgXCJub1wiOiBcIm5iXCIsXG4gICAgXCJuby1ib2tcIjogXCJuYlwiLFxuICAgIFwibm8tYm9rbWFsXCI6IFwibmJcIixcbiAgICBcIm5vLW55blwiOiBcIm5uXCIsXG4gICAgXCJuby1ueW5vcnNrXCI6IFwibm5cIixcbiAgICBcIm5vYlwiOiBcIm5iXCIsXG4gICAgXCJub29cIjogXCJkdGRcIixcbiAgICBcIm5vclwiOiBcIm5iXCIsXG4gICAgXCJucGlcIjogXCJuZVwiLFxuICAgIFwibnRzXCI6IFwicGlqXCIsXG4gICAgXCJueHVcIjogXCJicHBcIixcbiAgICBcIm55YVwiOiBcIm55XCIsXG4gICAgXCJvY2lcIjogXCJvY1wiLFxuICAgIFwib2pnXCI6IFwib2pcIixcbiAgICBcIm9qaVwiOiBcIm9qXCIsXG4gICAgXCJvcmlcIjogXCJvclwiLFxuICAgIFwib3JtXCI6IFwib21cIixcbiAgICBcIm9yeVwiOiBcIm9yXCIsXG4gICAgXCJvc3NcIjogXCJvc1wiLFxuICAgIFwib3VuXCI6IFwidmFqXCIsXG4gICAgXCJwYW5cIjogXCJwYVwiLFxuICAgIFwicGJ1XCI6IFwicHNcIixcbiAgICBcInBjclwiOiBcImFkeFwiLFxuICAgIFwicGVyXCI6IFwiZmFcIixcbiAgICBcInBlc1wiOiBcImZhXCIsXG4gICAgXCJwbGlcIjogXCJwaVwiLFxuICAgIFwicGx0XCI6IFwibWdcIixcbiAgICBcInBtY1wiOiBcImh1d1wiLFxuICAgIFwicG11XCI6IFwicGhyXCIsXG4gICAgXCJwbmJcIjogXCJsYWhcIixcbiAgICBcInBvbFwiOiBcInBsXCIsXG4gICAgXCJwb3JcIjogXCJwdFwiLFxuICAgIFwicHBhXCI6IFwiYmZ5XCIsXG4gICAgXCJwcHJcIjogXCJsY3FcIixcbiAgICBcInByc1wiOiBcImZhLUFGXCIsXG4gICAgXCJwcnlcIjogXCJwcnRcIixcbiAgICBcInB1c1wiOiBcInBzXCIsXG4gICAgXCJwdXpcIjogXCJwdWJcIixcbiAgICBcInF1ZVwiOiBcInF1XCIsXG4gICAgXCJxdXpcIjogXCJxdVwiLFxuICAgIFwicm1yXCI6IFwiZW14XCIsXG4gICAgXCJybXlcIjogXCJyb21cIixcbiAgICBcInJvaFwiOiBcInJtXCIsXG4gICAgXCJyb25cIjogXCJyb1wiLFxuICAgIFwicnVtXCI6IFwicm9cIixcbiAgICBcInJ1blwiOiBcInJuXCIsXG4gICAgXCJydXNcIjogXCJydVwiLFxuICAgIFwic2FnXCI6IFwic2dcIixcbiAgICBcInNhblwiOiBcInNhXCIsXG4gICAgXCJzYXBcIjogXCJhcXRcIixcbiAgICBcInNjYVwiOiBcImhsZVwiLFxuICAgIFwic2NjXCI6IFwic3JcIixcbiAgICBcInNjclwiOiBcImhyXCIsXG4gICAgXCJzZ2xcIjogXCJpc2tcIixcbiAgICBcInNnbi1CRS1GUlwiOiBcInNmYlwiLFxuICAgIFwic2duLUJFLU5MXCI6IFwidmd0XCIsXG4gICAgXCJzZ24tQlJcIjogXCJienNcIixcbiAgICBcInNnbi1DSC1ERVwiOiBcInNnZ1wiLFxuICAgIFwic2duLUNPXCI6IFwiY3NuXCIsXG4gICAgXCJzZ24tREVcIjogXCJnc2dcIixcbiAgICBcInNnbi1ES1wiOiBcImRzbFwiLFxuICAgIFwic2duLUVTXCI6IFwic3NwXCIsXG4gICAgXCJzZ24tRlJcIjogXCJmc2xcIixcbiAgICBcInNnbi1HQlwiOiBcImJmaVwiLFxuICAgIFwic2duLUdSXCI6IFwiZ3NzXCIsXG4gICAgXCJzZ24tSUVcIjogXCJpc2dcIixcbiAgICBcInNnbi1JVFwiOiBcImlzZVwiLFxuICAgIFwic2duLUpQXCI6IFwianNsXCIsXG4gICAgXCJzZ24tTVhcIjogXCJtZnNcIixcbiAgICBcInNnbi1OSVwiOiBcIm5jc1wiLFxuICAgIFwic2duLU5MXCI6IFwiZHNlXCIsXG4gICAgXCJzZ24tTk9cIjogXCJuc2lcIixcbiAgICBcInNnbi1QVFwiOiBcInBzclwiLFxuICAgIFwic2duLVNFXCI6IFwic3dsXCIsXG4gICAgXCJzZ24tVVNcIjogXCJhc2VcIixcbiAgICBcInNnbi1aQVwiOiBcInNmc1wiLFxuICAgIFwic2hcIjogXCJzci1MYXRuXCIsXG4gICAgXCJzaW5cIjogXCJzaVwiLFxuICAgIFwic2trXCI6IFwib3liXCIsXG4gICAgXCJzbGtcIjogXCJza1wiLFxuICAgIFwic2xvXCI6IFwic2tcIixcbiAgICBcInNsdlwiOiBcInNsXCIsXG4gICAgXCJzbWVcIjogXCJzZVwiLFxuICAgIFwic21vXCI6IFwic21cIixcbiAgICBcInNuYVwiOiBcInNuXCIsXG4gICAgXCJzbmRcIjogXCJzZFwiLFxuICAgIFwic29tXCI6IFwic29cIixcbiAgICBcInNvdFwiOiBcInN0XCIsXG4gICAgXCJzcGFcIjogXCJlc1wiLFxuICAgIFwic3B5XCI6IFwia2xuXCIsXG4gICAgXCJzcWlcIjogXCJzcVwiLFxuICAgIFwic3JjXCI6IFwic2NcIixcbiAgICBcInNyZFwiOiBcInNjXCIsXG4gICAgXCJzcnBcIjogXCJzclwiLFxuICAgIFwic3N3XCI6IFwic3NcIixcbiAgICBcInN1bFwiOiBcInNnZFwiLFxuICAgIFwic3VtXCI6IFwidWx3XCIsXG4gICAgXCJzdW5cIjogXCJzdVwiLFxuICAgIFwic3dhXCI6IFwic3dcIixcbiAgICBcInN3Y1wiOiBcInN3LUNEXCIsXG4gICAgXCJzd2VcIjogXCJzdlwiLFxuICAgIFwic3doXCI6IFwic3dcIixcbiAgICBcInRhaFwiOiBcInR5XCIsXG4gICAgXCJ0YW1cIjogXCJ0YVwiLFxuICAgIFwidGF0XCI6IFwidHRcIixcbiAgICBcInRkdVwiOiBcImR0cFwiLFxuICAgIFwidGVsXCI6IFwidGVcIixcbiAgICBcInRnZ1wiOiBcImJqcFwiLFxuICAgIFwidGdrXCI6IFwidGdcIixcbiAgICBcInRnbFwiOiBcImZpbFwiLFxuICAgIFwidGhhXCI6IFwidGhcIixcbiAgICBcInRoY1wiOiBcInRwb1wiLFxuICAgIFwidGh3XCI6IFwib2xhXCIsXG4gICAgXCJ0aHhcIjogXCJveWJcIixcbiAgICBcInRpYlwiOiBcImJvXCIsXG4gICAgXCJ0aWRcIjogXCJpdGRcIixcbiAgICBcInRpZVwiOiBcInJhc1wiLFxuICAgIFwidGlyXCI6IFwidGlcIixcbiAgICBcInRra1wiOiBcInR3bVwiLFxuICAgIFwidGxcIjogXCJmaWxcIixcbiAgICBcInRsd1wiOiBcIndlb1wiLFxuICAgIFwidG1wXCI6IFwidHlqXCIsXG4gICAgXCJ0bmVcIjogXCJrYWtcIixcbiAgICBcInRuZlwiOiBcImZhLUFGXCIsXG4gICAgXCJ0b25cIjogXCJ0b1wiLFxuICAgIFwidHNmXCI6IFwidGFqXCIsXG4gICAgXCJ0c25cIjogXCJ0blwiLFxuICAgIFwidHNvXCI6IFwidHNcIixcbiAgICBcInR0cVwiOiBcInRtaFwiLFxuICAgIFwidHVrXCI6IFwidGtcIixcbiAgICBcInR1clwiOiBcInRyXCIsXG4gICAgXCJ0d1wiOiBcImFrXCIsXG4gICAgXCJ0d2lcIjogXCJha1wiLFxuICAgIFwidWlnXCI6IFwidWdcIixcbiAgICBcInVrclwiOiBcInVrXCIsXG4gICAgXCJ1bXVcIjogXCJkZWxcIixcbiAgICBcInVuZC1hYWxhbmRcIjogXCJ1bmQtQVhcIixcbiAgICBcInVuZC1hcmV2ZWxhXCI6IFwidW5kXCIsXG4gICAgXCJ1bmQtYXJldm1kYVwiOiBcInVuZFwiLFxuICAgIFwidW5kLWJva21hbFwiOiBcInVuZFwiLFxuICAgIFwidW5kLWhha2thXCI6IFwidW5kXCIsXG4gICAgXCJ1bmQtaGVwYnVybi1oZXBsb2NcIjogXCJ1bmQtYWxhbGM5N1wiLFxuICAgIFwidW5kLWxvamJhblwiOiBcInVuZFwiLFxuICAgIFwidW5kLW55bm9yc2tcIjogXCJ1bmRcIixcbiAgICBcInVuZC1zYWFob1wiOiBcInVuZFwiLFxuICAgIFwidW5kLXhpYW5nXCI6IFwidW5kXCIsXG4gICAgXCJ1bnBcIjogXCJ3cm9cIixcbiAgICBcInVva1wiOiBcImVtYVwiLFxuICAgIFwidXJkXCI6IFwidXJcIixcbiAgICBcInV6YlwiOiBcInV6XCIsXG4gICAgXCJ1em5cIjogXCJ1elwiLFxuICAgIFwidmVuXCI6IFwidmVcIixcbiAgICBcInZpZVwiOiBcInZpXCIsXG4gICAgXCJ2b2xcIjogXCJ2b1wiLFxuICAgIFwid2VsXCI6IFwiY3lcIixcbiAgICBcIndnd1wiOiBcIndnYlwiLFxuICAgIFwid2l0XCI6IFwibm9sXCIsXG4gICAgXCJ3aXdcIjogXCJud29cIixcbiAgICBcIndsblwiOiBcIndhXCIsXG4gICAgXCJ3b2xcIjogXCJ3b1wiLFxuICAgIFwieGJhXCI6IFwiY2F4XCIsXG4gICAgXCJ4aG9cIjogXCJ4aFwiLFxuICAgIFwieGlhXCI6IFwiYWNuXCIsXG4gICAgXCJ4a2hcIjogXCJ3YXdcIixcbiAgICBcInhwZVwiOiBcImtwZVwiLFxuICAgIFwieHJxXCI6IFwiZG13XCIsXG4gICAgXCJ4c2pcIjogXCJzdWpcIixcbiAgICBcInhzbFwiOiBcImRlblwiLFxuICAgIFwieWJkXCI6IFwicmtpXCIsXG4gICAgXCJ5ZGRcIjogXCJ5aVwiLFxuICAgIFwieWVuXCI6IFwieW5xXCIsXG4gICAgXCJ5aWRcIjogXCJ5aVwiLFxuICAgIFwieWl5XCI6IFwieXJtXCIsXG4gICAgXCJ5bWFcIjogXCJscnJcIixcbiAgICBcInltdFwiOiBcIm10bVwiLFxuICAgIFwieW9yXCI6IFwieW9cIixcbiAgICBcInlvc1wiOiBcInpvbVwiLFxuICAgIFwieXV1XCI6IFwieXVnXCIsXG4gICAgXCJ6YWlcIjogXCJ6YXBcIixcbiAgICBcInpoLWNtblwiOiBcInpoXCIsXG4gICAgXCJ6aC1jbW4tSGFuc1wiOiBcInpoLUhhbnNcIixcbiAgICBcInpoLWNtbi1IYW50XCI6IFwiemgtSGFudFwiLFxuICAgIFwiemgtZ2FuXCI6IFwiZ2FuXCIsXG4gICAgXCJ6aC1ndW95dVwiOiBcInpoXCIsXG4gICAgXCJ6aC1oYWtrYVwiOiBcImhha1wiLFxuICAgIFwiemgtbWluXCI6IFwibmFuLXgtemgtbWluXCIsXG4gICAgXCJ6aC1taW4tbmFuXCI6IFwibmFuXCIsXG4gICAgXCJ6aC13dXVcIjogXCJ3dXVcIixcbiAgICBcInpoLXhpYW5nXCI6IFwiaHNuXCIsXG4gICAgXCJ6aC15dWVcIjogXCJ5dWVcIixcbiAgICBcInpoYVwiOiBcInphXCIsXG4gICAgXCJ6aG9cIjogXCJ6aFwiLFxuICAgIFwiemlyXCI6IFwic2N2XCIsXG4gICAgXCJ6c21cIjogXCJtc1wiLFxuICAgIFwienVsXCI6IFwienVcIixcbiAgICBcInp5YlwiOiBcInphXCJcbn07XG5leHBvcnRzLnRlcnJpdG9yeUFsaWFzID0ge1xuICAgIFwiMTAwXCI6IFwiQkdcIixcbiAgICBcIjEwNFwiOiBcIk1NXCIsXG4gICAgXCIxMDhcIjogXCJCSVwiLFxuICAgIFwiMTEyXCI6IFwiQllcIixcbiAgICBcIjExNlwiOiBcIktIXCIsXG4gICAgXCIxMjBcIjogXCJDTVwiLFxuICAgIFwiMTI0XCI6IFwiQ0FcIixcbiAgICBcIjEzMlwiOiBcIkNWXCIsXG4gICAgXCIxMzZcIjogXCJLWVwiLFxuICAgIFwiMTQwXCI6IFwiQ0ZcIixcbiAgICBcIjE0NFwiOiBcIkxLXCIsXG4gICAgXCIxNDhcIjogXCJURFwiLFxuICAgIFwiMTUyXCI6IFwiQ0xcIixcbiAgICBcIjE1NlwiOiBcIkNOXCIsXG4gICAgXCIxNThcIjogXCJUV1wiLFxuICAgIFwiMTYyXCI6IFwiQ1hcIixcbiAgICBcIjE2NlwiOiBcIkNDXCIsXG4gICAgXCIxNzBcIjogXCJDT1wiLFxuICAgIFwiMTcyXCI6IFwiUlUgQU0gQVogQlkgR0UgS0cgS1ogTUQgVEogVE0gVUEgVVpcIixcbiAgICBcIjE3NFwiOiBcIktNXCIsXG4gICAgXCIxNzVcIjogXCJZVFwiLFxuICAgIFwiMTc4XCI6IFwiQ0dcIixcbiAgICBcIjE4MFwiOiBcIkNEXCIsXG4gICAgXCIxODRcIjogXCJDS1wiLFxuICAgIFwiMTg4XCI6IFwiQ1JcIixcbiAgICBcIjE5MVwiOiBcIkhSXCIsXG4gICAgXCIxOTJcIjogXCJDVVwiLFxuICAgIFwiMTk2XCI6IFwiQ1lcIixcbiAgICBcIjIwMFwiOiBcIkNaIFNLXCIsXG4gICAgXCIyMDNcIjogXCJDWlwiLFxuICAgIFwiMjA0XCI6IFwiQkpcIixcbiAgICBcIjIwOFwiOiBcIkRLXCIsXG4gICAgXCIyMTJcIjogXCJETVwiLFxuICAgIFwiMjE0XCI6IFwiRE9cIixcbiAgICBcIjIxOFwiOiBcIkVDXCIsXG4gICAgXCIyMjJcIjogXCJTVlwiLFxuICAgIFwiMjI2XCI6IFwiR1FcIixcbiAgICBcIjIzMFwiOiBcIkVUXCIsXG4gICAgXCIyMzFcIjogXCJFVFwiLFxuICAgIFwiMjMyXCI6IFwiRVJcIixcbiAgICBcIjIzM1wiOiBcIkVFXCIsXG4gICAgXCIyMzRcIjogXCJGT1wiLFxuICAgIFwiMjM4XCI6IFwiRktcIixcbiAgICBcIjIzOVwiOiBcIkdTXCIsXG4gICAgXCIyNDJcIjogXCJGSlwiLFxuICAgIFwiMjQ2XCI6IFwiRklcIixcbiAgICBcIjI0OFwiOiBcIkFYXCIsXG4gICAgXCIyNDlcIjogXCJGUlwiLFxuICAgIFwiMjUwXCI6IFwiRlJcIixcbiAgICBcIjI1NFwiOiBcIkdGXCIsXG4gICAgXCIyNThcIjogXCJQRlwiLFxuICAgIFwiMjYwXCI6IFwiVEZcIixcbiAgICBcIjI2MlwiOiBcIkRKXCIsXG4gICAgXCIyNjZcIjogXCJHQVwiLFxuICAgIFwiMjY4XCI6IFwiR0VcIixcbiAgICBcIjI3MFwiOiBcIkdNXCIsXG4gICAgXCIyNzVcIjogXCJQU1wiLFxuICAgIFwiMjc2XCI6IFwiREVcIixcbiAgICBcIjI3OFwiOiBcIkRFXCIsXG4gICAgXCIyODBcIjogXCJERVwiLFxuICAgIFwiMjg4XCI6IFwiR0hcIixcbiAgICBcIjI5MlwiOiBcIkdJXCIsXG4gICAgXCIyOTZcIjogXCJLSVwiLFxuICAgIFwiMzAwXCI6IFwiR1JcIixcbiAgICBcIjMwNFwiOiBcIkdMXCIsXG4gICAgXCIzMDhcIjogXCJHRFwiLFxuICAgIFwiMzEyXCI6IFwiR1BcIixcbiAgICBcIjMxNlwiOiBcIkdVXCIsXG4gICAgXCIzMjBcIjogXCJHVFwiLFxuICAgIFwiMzI0XCI6IFwiR05cIixcbiAgICBcIjMyOFwiOiBcIkdZXCIsXG4gICAgXCIzMzJcIjogXCJIVFwiLFxuICAgIFwiMzM0XCI6IFwiSE1cIixcbiAgICBcIjMzNlwiOiBcIlZBXCIsXG4gICAgXCIzNDBcIjogXCJITlwiLFxuICAgIFwiMzQ0XCI6IFwiSEtcIixcbiAgICBcIjM0OFwiOiBcIkhVXCIsXG4gICAgXCIzNTJcIjogXCJJU1wiLFxuICAgIFwiMzU2XCI6IFwiSU5cIixcbiAgICBcIjM2MFwiOiBcIklEXCIsXG4gICAgXCIzNjRcIjogXCJJUlwiLFxuICAgIFwiMzY4XCI6IFwiSVFcIixcbiAgICBcIjM3MlwiOiBcIklFXCIsXG4gICAgXCIzNzZcIjogXCJJTFwiLFxuICAgIFwiMzgwXCI6IFwiSVRcIixcbiAgICBcIjM4NFwiOiBcIkNJXCIsXG4gICAgXCIzODhcIjogXCJKTVwiLFxuICAgIFwiMzkyXCI6IFwiSlBcIixcbiAgICBcIjM5OFwiOiBcIktaXCIsXG4gICAgXCI0MDBcIjogXCJKT1wiLFxuICAgIFwiNDA0XCI6IFwiS0VcIixcbiAgICBcIjQwOFwiOiBcIktQXCIsXG4gICAgXCI0MTBcIjogXCJLUlwiLFxuICAgIFwiNDE0XCI6IFwiS1dcIixcbiAgICBcIjQxN1wiOiBcIktHXCIsXG4gICAgXCI0MThcIjogXCJMQVwiLFxuICAgIFwiNDIyXCI6IFwiTEJcIixcbiAgICBcIjQyNlwiOiBcIkxTXCIsXG4gICAgXCI0MjhcIjogXCJMVlwiLFxuICAgIFwiNDMwXCI6IFwiTFJcIixcbiAgICBcIjQzNFwiOiBcIkxZXCIsXG4gICAgXCI0MzhcIjogXCJMSVwiLFxuICAgIFwiNDQwXCI6IFwiTFRcIixcbiAgICBcIjQ0MlwiOiBcIkxVXCIsXG4gICAgXCI0NDZcIjogXCJNT1wiLFxuICAgIFwiNDUwXCI6IFwiTUdcIixcbiAgICBcIjQ1NFwiOiBcIk1XXCIsXG4gICAgXCI0NThcIjogXCJNWVwiLFxuICAgIFwiNDYyXCI6IFwiTVZcIixcbiAgICBcIjQ2NlwiOiBcIk1MXCIsXG4gICAgXCI0NzBcIjogXCJNVFwiLFxuICAgIFwiNDc0XCI6IFwiTVFcIixcbiAgICBcIjQ3OFwiOiBcIk1SXCIsXG4gICAgXCI0ODBcIjogXCJNVVwiLFxuICAgIFwiNDg0XCI6IFwiTVhcIixcbiAgICBcIjQ5MlwiOiBcIk1DXCIsXG4gICAgXCI0OTZcIjogXCJNTlwiLFxuICAgIFwiNDk4XCI6IFwiTURcIixcbiAgICBcIjQ5OVwiOiBcIk1FXCIsXG4gICAgXCI1MDBcIjogXCJNU1wiLFxuICAgIFwiNTA0XCI6IFwiTUFcIixcbiAgICBcIjUwOFwiOiBcIk1aXCIsXG4gICAgXCI1MTJcIjogXCJPTVwiLFxuICAgIFwiNTE2XCI6IFwiTkFcIixcbiAgICBcIjUyMFwiOiBcIk5SXCIsXG4gICAgXCI1MjRcIjogXCJOUFwiLFxuICAgIFwiNTI4XCI6IFwiTkxcIixcbiAgICBcIjUzMFwiOiBcIkNXIFNYIEJRXCIsXG4gICAgXCI1MzFcIjogXCJDV1wiLFxuICAgIFwiNTMyXCI6IFwiQ1cgU1ggQlFcIixcbiAgICBcIjUzM1wiOiBcIkFXXCIsXG4gICAgXCI1MzRcIjogXCJTWFwiLFxuICAgIFwiNTM1XCI6IFwiQlFcIixcbiAgICBcIjUzNlwiOiBcIlNBIElRXCIsXG4gICAgXCI1NDBcIjogXCJOQ1wiLFxuICAgIFwiNTQ4XCI6IFwiVlVcIixcbiAgICBcIjU1NFwiOiBcIk5aXCIsXG4gICAgXCI1NThcIjogXCJOSVwiLFxuICAgIFwiNTYyXCI6IFwiTkVcIixcbiAgICBcIjU2NlwiOiBcIk5HXCIsXG4gICAgXCI1NzBcIjogXCJOVVwiLFxuICAgIFwiNTc0XCI6IFwiTkZcIixcbiAgICBcIjU3OFwiOiBcIk5PXCIsXG4gICAgXCI1ODBcIjogXCJNUFwiLFxuICAgIFwiNTgxXCI6IFwiVU1cIixcbiAgICBcIjU4MlwiOiBcIkZNIE1IIE1QIFBXXCIsXG4gICAgXCI1ODNcIjogXCJGTVwiLFxuICAgIFwiNTg0XCI6IFwiTUhcIixcbiAgICBcIjU4NVwiOiBcIlBXXCIsXG4gICAgXCI1ODZcIjogXCJQS1wiLFxuICAgIFwiNTkxXCI6IFwiUEFcIixcbiAgICBcIjU5OFwiOiBcIlBHXCIsXG4gICAgXCI2MDBcIjogXCJQWVwiLFxuICAgIFwiNjA0XCI6IFwiUEVcIixcbiAgICBcIjYwOFwiOiBcIlBIXCIsXG4gICAgXCI2MTJcIjogXCJQTlwiLFxuICAgIFwiNjE2XCI6IFwiUExcIixcbiAgICBcIjYyMFwiOiBcIlBUXCIsXG4gICAgXCI2MjRcIjogXCJHV1wiLFxuICAgIFwiNjI2XCI6IFwiVExcIixcbiAgICBcIjYzMFwiOiBcIlBSXCIsXG4gICAgXCI2MzRcIjogXCJRQVwiLFxuICAgIFwiNjM4XCI6IFwiUkVcIixcbiAgICBcIjY0MlwiOiBcIlJPXCIsXG4gICAgXCI2NDNcIjogXCJSVVwiLFxuICAgIFwiNjQ2XCI6IFwiUldcIixcbiAgICBcIjY1MlwiOiBcIkJMXCIsXG4gICAgXCI2NTRcIjogXCJTSFwiLFxuICAgIFwiNjU5XCI6IFwiS05cIixcbiAgICBcIjY2MFwiOiBcIkFJXCIsXG4gICAgXCI2NjJcIjogXCJMQ1wiLFxuICAgIFwiNjYzXCI6IFwiTUZcIixcbiAgICBcIjY2NlwiOiBcIlBNXCIsXG4gICAgXCI2NzBcIjogXCJWQ1wiLFxuICAgIFwiNjc0XCI6IFwiU01cIixcbiAgICBcIjY3OFwiOiBcIlNUXCIsXG4gICAgXCI2ODJcIjogXCJTQVwiLFxuICAgIFwiNjg2XCI6IFwiU05cIixcbiAgICBcIjY4OFwiOiBcIlJTXCIsXG4gICAgXCI2OTBcIjogXCJTQ1wiLFxuICAgIFwiNjk0XCI6IFwiU0xcIixcbiAgICBcIjcwMlwiOiBcIlNHXCIsXG4gICAgXCI3MDNcIjogXCJTS1wiLFxuICAgIFwiNzA0XCI6IFwiVk5cIixcbiAgICBcIjcwNVwiOiBcIlNJXCIsXG4gICAgXCI3MDZcIjogXCJTT1wiLFxuICAgIFwiNzEwXCI6IFwiWkFcIixcbiAgICBcIjcxNlwiOiBcIlpXXCIsXG4gICAgXCI3MjBcIjogXCJZRVwiLFxuICAgIFwiNzI0XCI6IFwiRVNcIixcbiAgICBcIjcyOFwiOiBcIlNTXCIsXG4gICAgXCI3MjlcIjogXCJTRFwiLFxuICAgIFwiNzMyXCI6IFwiRUhcIixcbiAgICBcIjczNlwiOiBcIlNEXCIsXG4gICAgXCI3NDBcIjogXCJTUlwiLFxuICAgIFwiNzQ0XCI6IFwiU0pcIixcbiAgICBcIjc0OFwiOiBcIlNaXCIsXG4gICAgXCI3NTJcIjogXCJTRVwiLFxuICAgIFwiNzU2XCI6IFwiQ0hcIixcbiAgICBcIjc2MFwiOiBcIlNZXCIsXG4gICAgXCI3NjJcIjogXCJUSlwiLFxuICAgIFwiNzY0XCI6IFwiVEhcIixcbiAgICBcIjc2OFwiOiBcIlRHXCIsXG4gICAgXCI3NzJcIjogXCJUS1wiLFxuICAgIFwiNzc2XCI6IFwiVE9cIixcbiAgICBcIjc4MFwiOiBcIlRUXCIsXG4gICAgXCI3ODRcIjogXCJBRVwiLFxuICAgIFwiNzg4XCI6IFwiVE5cIixcbiAgICBcIjc5MlwiOiBcIlRSXCIsXG4gICAgXCI3OTVcIjogXCJUTVwiLFxuICAgIFwiNzk2XCI6IFwiVENcIixcbiAgICBcIjc5OFwiOiBcIlRWXCIsXG4gICAgXCI4MDBcIjogXCJVR1wiLFxuICAgIFwiODA0XCI6IFwiVUFcIixcbiAgICBcIjgwN1wiOiBcIk1LXCIsXG4gICAgXCI4MTBcIjogXCJSVSBBTSBBWiBCWSBFRSBHRSBLWiBLRyBMViBMVCBNRCBUSiBUTSBVQSBVWlwiLFxuICAgIFwiODE4XCI6IFwiRUdcIixcbiAgICBcIjgyNlwiOiBcIkdCXCIsXG4gICAgXCI4MzBcIjogXCJKRSBHR1wiLFxuICAgIFwiODMxXCI6IFwiR0dcIixcbiAgICBcIjgzMlwiOiBcIkpFXCIsXG4gICAgXCI4MzNcIjogXCJJTVwiLFxuICAgIFwiODM0XCI6IFwiVFpcIixcbiAgICBcIjg0MFwiOiBcIlVTXCIsXG4gICAgXCI4NTBcIjogXCJWSVwiLFxuICAgIFwiODU0XCI6IFwiQkZcIixcbiAgICBcIjg1OFwiOiBcIlVZXCIsXG4gICAgXCI4NjBcIjogXCJVWlwiLFxuICAgIFwiODYyXCI6IFwiVkVcIixcbiAgICBcIjg3NlwiOiBcIldGXCIsXG4gICAgXCI4ODJcIjogXCJXU1wiLFxuICAgIFwiODg2XCI6IFwiWUVcIixcbiAgICBcIjg4N1wiOiBcIllFXCIsXG4gICAgXCI4OTBcIjogXCJSUyBNRSBTSSBIUiBNSyBCQVwiLFxuICAgIFwiODkxXCI6IFwiUlMgTUVcIixcbiAgICBcIjg5NFwiOiBcIlpNXCIsXG4gICAgXCI5NThcIjogXCJBQVwiLFxuICAgIFwiOTU5XCI6IFwiUU1cIixcbiAgICBcIjk2MFwiOiBcIlFOXCIsXG4gICAgXCI5NjJcIjogXCJRUFwiLFxuICAgIFwiOTYzXCI6IFwiUVFcIixcbiAgICBcIjk2NFwiOiBcIlFSXCIsXG4gICAgXCI5NjVcIjogXCJRU1wiLFxuICAgIFwiOTY2XCI6IFwiUVRcIixcbiAgICBcIjk2N1wiOiBcIkVVXCIsXG4gICAgXCI5NjhcIjogXCJRVlwiLFxuICAgIFwiOTY5XCI6IFwiUVdcIixcbiAgICBcIjk3MFwiOiBcIlFYXCIsXG4gICAgXCI5NzFcIjogXCJRWVwiLFxuICAgIFwiOTcyXCI6IFwiUVpcIixcbiAgICBcIjk3M1wiOiBcIlhBXCIsXG4gICAgXCI5NzRcIjogXCJYQlwiLFxuICAgIFwiOTc1XCI6IFwiWENcIixcbiAgICBcIjk3NlwiOiBcIlhEXCIsXG4gICAgXCI5NzdcIjogXCJYRVwiLFxuICAgIFwiOTc4XCI6IFwiWEZcIixcbiAgICBcIjk3OVwiOiBcIlhHXCIsXG4gICAgXCI5ODBcIjogXCJYSFwiLFxuICAgIFwiOTgxXCI6IFwiWElcIixcbiAgICBcIjk4MlwiOiBcIlhKXCIsXG4gICAgXCI5ODNcIjogXCJYS1wiLFxuICAgIFwiOTg0XCI6IFwiWExcIixcbiAgICBcIjk4NVwiOiBcIlhNXCIsXG4gICAgXCI5ODZcIjogXCJYTlwiLFxuICAgIFwiOTg3XCI6IFwiWE9cIixcbiAgICBcIjk4OFwiOiBcIlhQXCIsXG4gICAgXCI5ODlcIjogXCJYUVwiLFxuICAgIFwiOTkwXCI6IFwiWFJcIixcbiAgICBcIjk5MVwiOiBcIlhTXCIsXG4gICAgXCI5OTJcIjogXCJYVFwiLFxuICAgIFwiOTkzXCI6IFwiWFVcIixcbiAgICBcIjk5NFwiOiBcIlhWXCIsXG4gICAgXCI5OTVcIjogXCJYV1wiLFxuICAgIFwiOTk2XCI6IFwiWFhcIixcbiAgICBcIjk5N1wiOiBcIlhZXCIsXG4gICAgXCI5OThcIjogXCJYWlwiLFxuICAgIFwiOTk5XCI6IFwiWlpcIixcbiAgICBcIjAwNFwiOiBcIkFGXCIsXG4gICAgXCIwMDhcIjogXCJBTFwiLFxuICAgIFwiMDEwXCI6IFwiQVFcIixcbiAgICBcIjAxMlwiOiBcIkRaXCIsXG4gICAgXCIwMTZcIjogXCJBU1wiLFxuICAgIFwiMDIwXCI6IFwiQURcIixcbiAgICBcIjAyNFwiOiBcIkFPXCIsXG4gICAgXCIwMjhcIjogXCJBR1wiLFxuICAgIFwiMDMxXCI6IFwiQVpcIixcbiAgICBcIjAzMlwiOiBcIkFSXCIsXG4gICAgXCIwMzZcIjogXCJBVVwiLFxuICAgIFwiMDQwXCI6IFwiQVRcIixcbiAgICBcIjA0NFwiOiBcIkJTXCIsXG4gICAgXCIwNDhcIjogXCJCSFwiLFxuICAgIFwiMDUwXCI6IFwiQkRcIixcbiAgICBcIjA1MVwiOiBcIkFNXCIsXG4gICAgXCIwNTJcIjogXCJCQlwiLFxuICAgIFwiMDU2XCI6IFwiQkVcIixcbiAgICBcIjA2MFwiOiBcIkJNXCIsXG4gICAgXCIwNjJcIjogXCIwMzQgMTQzXCIsXG4gICAgXCIwNjRcIjogXCJCVFwiLFxuICAgIFwiMDY4XCI6IFwiQk9cIixcbiAgICBcIjA3MFwiOiBcIkJBXCIsXG4gICAgXCIwNzJcIjogXCJCV1wiLFxuICAgIFwiMDc0XCI6IFwiQlZcIixcbiAgICBcIjA3NlwiOiBcIkJSXCIsXG4gICAgXCIwODRcIjogXCJCWlwiLFxuICAgIFwiMDg2XCI6IFwiSU9cIixcbiAgICBcIjA5MFwiOiBcIlNCXCIsXG4gICAgXCIwOTJcIjogXCJWR1wiLFxuICAgIFwiMDk2XCI6IFwiQk5cIixcbiAgICBcIkFBQVwiOiBcIkFBXCIsXG4gICAgXCJBQldcIjogXCJBV1wiLFxuICAgIFwiQUZHXCI6IFwiQUZcIixcbiAgICBcIkFHT1wiOiBcIkFPXCIsXG4gICAgXCJBSUFcIjogXCJBSVwiLFxuICAgIFwiQUxBXCI6IFwiQVhcIixcbiAgICBcIkFMQlwiOiBcIkFMXCIsXG4gICAgXCJBTlwiOiBcIkNXIFNYIEJRXCIsXG4gICAgXCJBTkRcIjogXCJBRFwiLFxuICAgIFwiQU5UXCI6IFwiQ1cgU1ggQlFcIixcbiAgICBcIkFSRVwiOiBcIkFFXCIsXG4gICAgXCJBUkdcIjogXCJBUlwiLFxuICAgIFwiQVJNXCI6IFwiQU1cIixcbiAgICBcIkFTQ1wiOiBcIkFDXCIsXG4gICAgXCJBU01cIjogXCJBU1wiLFxuICAgIFwiQVRBXCI6IFwiQVFcIixcbiAgICBcIkFURlwiOiBcIlRGXCIsXG4gICAgXCJBVEdcIjogXCJBR1wiLFxuICAgIFwiQVVTXCI6IFwiQVVcIixcbiAgICBcIkFVVFwiOiBcIkFUXCIsXG4gICAgXCJBWkVcIjogXCJBWlwiLFxuICAgIFwiQkRJXCI6IFwiQklcIixcbiAgICBcIkJFTFwiOiBcIkJFXCIsXG4gICAgXCJCRU5cIjogXCJCSlwiLFxuICAgIFwiQkVTXCI6IFwiQlFcIixcbiAgICBcIkJGQVwiOiBcIkJGXCIsXG4gICAgXCJCR0RcIjogXCJCRFwiLFxuICAgIFwiQkdSXCI6IFwiQkdcIixcbiAgICBcIkJIUlwiOiBcIkJIXCIsXG4gICAgXCJCSFNcIjogXCJCU1wiLFxuICAgIFwiQklIXCI6IFwiQkFcIixcbiAgICBcIkJMTVwiOiBcIkJMXCIsXG4gICAgXCJCTFJcIjogXCJCWVwiLFxuICAgIFwiQkxaXCI6IFwiQlpcIixcbiAgICBcIkJNVVwiOiBcIkJNXCIsXG4gICAgXCJCT0xcIjogXCJCT1wiLFxuICAgIFwiQlJBXCI6IFwiQlJcIixcbiAgICBcIkJSQlwiOiBcIkJCXCIsXG4gICAgXCJCUk5cIjogXCJCTlwiLFxuICAgIFwiQlROXCI6IFwiQlRcIixcbiAgICBcIkJVXCI6IFwiTU1cIixcbiAgICBcIkJVUlwiOiBcIk1NXCIsXG4gICAgXCJCVlRcIjogXCJCVlwiLFxuICAgIFwiQldBXCI6IFwiQldcIixcbiAgICBcIkNBRlwiOiBcIkNGXCIsXG4gICAgXCJDQU5cIjogXCJDQVwiLFxuICAgIFwiQ0NLXCI6IFwiQ0NcIixcbiAgICBcIkNIRVwiOiBcIkNIXCIsXG4gICAgXCJDSExcIjogXCJDTFwiLFxuICAgIFwiQ0hOXCI6IFwiQ05cIixcbiAgICBcIkNJVlwiOiBcIkNJXCIsXG4gICAgXCJDTVJcIjogXCJDTVwiLFxuICAgIFwiQ09EXCI6IFwiQ0RcIixcbiAgICBcIkNPR1wiOiBcIkNHXCIsXG4gICAgXCJDT0tcIjogXCJDS1wiLFxuICAgIFwiQ09MXCI6IFwiQ09cIixcbiAgICBcIkNPTVwiOiBcIktNXCIsXG4gICAgXCJDUFRcIjogXCJDUFwiLFxuICAgIFwiQ1BWXCI6IFwiQ1ZcIixcbiAgICBcIkNSSVwiOiBcIkNSXCIsXG4gICAgXCJDU1wiOiBcIlJTIE1FXCIsXG4gICAgXCJDVFwiOiBcIktJXCIsXG4gICAgXCJDVUJcIjogXCJDVVwiLFxuICAgIFwiQ1VXXCI6IFwiQ1dcIixcbiAgICBcIkNYUlwiOiBcIkNYXCIsXG4gICAgXCJDWU1cIjogXCJLWVwiLFxuICAgIFwiQ1lQXCI6IFwiQ1lcIixcbiAgICBcIkNaRVwiOiBcIkNaXCIsXG4gICAgXCJERFwiOiBcIkRFXCIsXG4gICAgXCJERFJcIjogXCJERVwiLFxuICAgIFwiREVVXCI6IFwiREVcIixcbiAgICBcIkRHQVwiOiBcIkRHXCIsXG4gICAgXCJESklcIjogXCJESlwiLFxuICAgIFwiRE1BXCI6IFwiRE1cIixcbiAgICBcIkROS1wiOiBcIkRLXCIsXG4gICAgXCJET01cIjogXCJET1wiLFxuICAgIFwiRFlcIjogXCJCSlwiLFxuICAgIFwiRFpBXCI6IFwiRFpcIixcbiAgICBcIkVDVVwiOiBcIkVDXCIsXG4gICAgXCJFR1lcIjogXCJFR1wiLFxuICAgIFwiRVJJXCI6IFwiRVJcIixcbiAgICBcIkVTSFwiOiBcIkVIXCIsXG4gICAgXCJFU1BcIjogXCJFU1wiLFxuICAgIFwiRVNUXCI6IFwiRUVcIixcbiAgICBcIkVUSFwiOiBcIkVUXCIsXG4gICAgXCJGSU5cIjogXCJGSVwiLFxuICAgIFwiRkpJXCI6IFwiRkpcIixcbiAgICBcIkZMS1wiOiBcIkZLXCIsXG4gICAgXCJGUVwiOiBcIkFRIFRGXCIsXG4gICAgXCJGUkFcIjogXCJGUlwiLFxuICAgIFwiRlJPXCI6IFwiRk9cIixcbiAgICBcIkZTTVwiOiBcIkZNXCIsXG4gICAgXCJGWFwiOiBcIkZSXCIsXG4gICAgXCJGWFhcIjogXCJGUlwiLFxuICAgIFwiR0FCXCI6IFwiR0FcIixcbiAgICBcIkdCUlwiOiBcIkdCXCIsXG4gICAgXCJHRU9cIjogXCJHRVwiLFxuICAgIFwiR0dZXCI6IFwiR0dcIixcbiAgICBcIkdIQVwiOiBcIkdIXCIsXG4gICAgXCJHSUJcIjogXCJHSVwiLFxuICAgIFwiR0lOXCI6IFwiR05cIixcbiAgICBcIkdMUFwiOiBcIkdQXCIsXG4gICAgXCJHTUJcIjogXCJHTVwiLFxuICAgIFwiR05CXCI6IFwiR1dcIixcbiAgICBcIkdOUVwiOiBcIkdRXCIsXG4gICAgXCJHUkNcIjogXCJHUlwiLFxuICAgIFwiR1JEXCI6IFwiR0RcIixcbiAgICBcIkdSTFwiOiBcIkdMXCIsXG4gICAgXCJHVE1cIjogXCJHVFwiLFxuICAgIFwiR1VGXCI6IFwiR0ZcIixcbiAgICBcIkdVTVwiOiBcIkdVXCIsXG4gICAgXCJHVVlcIjogXCJHWVwiLFxuICAgIFwiSEtHXCI6IFwiSEtcIixcbiAgICBcIkhNRFwiOiBcIkhNXCIsXG4gICAgXCJITkRcIjogXCJITlwiLFxuICAgIFwiSFJWXCI6IFwiSFJcIixcbiAgICBcIkhUSVwiOiBcIkhUXCIsXG4gICAgXCJIVU5cIjogXCJIVVwiLFxuICAgIFwiSFZcIjogXCJCRlwiLFxuICAgIFwiSUROXCI6IFwiSURcIixcbiAgICBcIklNTlwiOiBcIklNXCIsXG4gICAgXCJJTkRcIjogXCJJTlwiLFxuICAgIFwiSU9UXCI6IFwiSU9cIixcbiAgICBcIklSTFwiOiBcIklFXCIsXG4gICAgXCJJUk5cIjogXCJJUlwiLFxuICAgIFwiSVJRXCI6IFwiSVFcIixcbiAgICBcIklTTFwiOiBcIklTXCIsXG4gICAgXCJJU1JcIjogXCJJTFwiLFxuICAgIFwiSVRBXCI6IFwiSVRcIixcbiAgICBcIkpBTVwiOiBcIkpNXCIsXG4gICAgXCJKRVlcIjogXCJKRVwiLFxuICAgIFwiSk9SXCI6IFwiSk9cIixcbiAgICBcIkpQTlwiOiBcIkpQXCIsXG4gICAgXCJKVFwiOiBcIlVNXCIsXG4gICAgXCJLQVpcIjogXCJLWlwiLFxuICAgIFwiS0VOXCI6IFwiS0VcIixcbiAgICBcIktHWlwiOiBcIktHXCIsXG4gICAgXCJLSE1cIjogXCJLSFwiLFxuICAgIFwiS0lSXCI6IFwiS0lcIixcbiAgICBcIktOQVwiOiBcIktOXCIsXG4gICAgXCJLT1JcIjogXCJLUlwiLFxuICAgIFwiS1dUXCI6IFwiS1dcIixcbiAgICBcIkxBT1wiOiBcIkxBXCIsXG4gICAgXCJMQk5cIjogXCJMQlwiLFxuICAgIFwiTEJSXCI6IFwiTFJcIixcbiAgICBcIkxCWVwiOiBcIkxZXCIsXG4gICAgXCJMQ0FcIjogXCJMQ1wiLFxuICAgIFwiTElFXCI6IFwiTElcIixcbiAgICBcIkxLQVwiOiBcIkxLXCIsXG4gICAgXCJMU09cIjogXCJMU1wiLFxuICAgIFwiTFRVXCI6IFwiTFRcIixcbiAgICBcIkxVWFwiOiBcIkxVXCIsXG4gICAgXCJMVkFcIjogXCJMVlwiLFxuICAgIFwiTUFDXCI6IFwiTU9cIixcbiAgICBcIk1BRlwiOiBcIk1GXCIsXG4gICAgXCJNQVJcIjogXCJNQVwiLFxuICAgIFwiTUNPXCI6IFwiTUNcIixcbiAgICBcIk1EQVwiOiBcIk1EXCIsXG4gICAgXCJNREdcIjogXCJNR1wiLFxuICAgIFwiTURWXCI6IFwiTVZcIixcbiAgICBcIk1FWFwiOiBcIk1YXCIsXG4gICAgXCJNSExcIjogXCJNSFwiLFxuICAgIFwiTUlcIjogXCJVTVwiLFxuICAgIFwiTUtEXCI6IFwiTUtcIixcbiAgICBcIk1MSVwiOiBcIk1MXCIsXG4gICAgXCJNTFRcIjogXCJNVFwiLFxuICAgIFwiTU1SXCI6IFwiTU1cIixcbiAgICBcIk1ORVwiOiBcIk1FXCIsXG4gICAgXCJNTkdcIjogXCJNTlwiLFxuICAgIFwiTU5QXCI6IFwiTVBcIixcbiAgICBcIk1PWlwiOiBcIk1aXCIsXG4gICAgXCJNUlRcIjogXCJNUlwiLFxuICAgIFwiTVNSXCI6IFwiTVNcIixcbiAgICBcIk1UUVwiOiBcIk1RXCIsXG4gICAgXCJNVVNcIjogXCJNVVwiLFxuICAgIFwiTVdJXCI6IFwiTVdcIixcbiAgICBcIk1ZU1wiOiBcIk1ZXCIsXG4gICAgXCJNWVRcIjogXCJZVFwiLFxuICAgIFwiTkFNXCI6IFwiTkFcIixcbiAgICBcIk5DTFwiOiBcIk5DXCIsXG4gICAgXCJORVJcIjogXCJORVwiLFxuICAgIFwiTkZLXCI6IFwiTkZcIixcbiAgICBcIk5HQVwiOiBcIk5HXCIsXG4gICAgXCJOSFwiOiBcIlZVXCIsXG4gICAgXCJOSUNcIjogXCJOSVwiLFxuICAgIFwiTklVXCI6IFwiTlVcIixcbiAgICBcIk5MRFwiOiBcIk5MXCIsXG4gICAgXCJOT1JcIjogXCJOT1wiLFxuICAgIFwiTlBMXCI6IFwiTlBcIixcbiAgICBcIk5RXCI6IFwiQVFcIixcbiAgICBcIk5SVVwiOiBcIk5SXCIsXG4gICAgXCJOVFwiOiBcIlNBIElRXCIsXG4gICAgXCJOVFpcIjogXCJTQSBJUVwiLFxuICAgIFwiTlpMXCI6IFwiTlpcIixcbiAgICBcIk9NTlwiOiBcIk9NXCIsXG4gICAgXCJQQUtcIjogXCJQS1wiLFxuICAgIFwiUEFOXCI6IFwiUEFcIixcbiAgICBcIlBDXCI6IFwiRk0gTUggTVAgUFdcIixcbiAgICBcIlBDTlwiOiBcIlBOXCIsXG4gICAgXCJQRVJcIjogXCJQRVwiLFxuICAgIFwiUEhMXCI6IFwiUEhcIixcbiAgICBcIlBMV1wiOiBcIlBXXCIsXG4gICAgXCJQTkdcIjogXCJQR1wiLFxuICAgIFwiUE9MXCI6IFwiUExcIixcbiAgICBcIlBSSVwiOiBcIlBSXCIsXG4gICAgXCJQUktcIjogXCJLUFwiLFxuICAgIFwiUFJUXCI6IFwiUFRcIixcbiAgICBcIlBSWVwiOiBcIlBZXCIsXG4gICAgXCJQU0VcIjogXCJQU1wiLFxuICAgIFwiUFVcIjogXCJVTVwiLFxuICAgIFwiUFlGXCI6IFwiUEZcIixcbiAgICBcIlBaXCI6IFwiUEFcIixcbiAgICBcIlFBVFwiOiBcIlFBXCIsXG4gICAgXCJRTU1cIjogXCJRTVwiLFxuICAgIFwiUU5OXCI6IFwiUU5cIixcbiAgICBcIlFQUFwiOiBcIlFQXCIsXG4gICAgXCJRUVFcIjogXCJRUVwiLFxuICAgIFwiUVJSXCI6IFwiUVJcIixcbiAgICBcIlFTU1wiOiBcIlFTXCIsXG4gICAgXCJRVFRcIjogXCJRVFwiLFxuICAgIFwiUVVcIjogXCJFVVwiLFxuICAgIFwiUVVVXCI6IFwiRVVcIixcbiAgICBcIlFWVlwiOiBcIlFWXCIsXG4gICAgXCJRV1dcIjogXCJRV1wiLFxuICAgIFwiUVhYXCI6IFwiUVhcIixcbiAgICBcIlFZWVwiOiBcIlFZXCIsXG4gICAgXCJRWlpcIjogXCJRWlwiLFxuICAgIFwiUkVVXCI6IFwiUkVcIixcbiAgICBcIlJIXCI6IFwiWldcIixcbiAgICBcIlJPVVwiOiBcIlJPXCIsXG4gICAgXCJSVVNcIjogXCJSVVwiLFxuICAgIFwiUldBXCI6IFwiUldcIixcbiAgICBcIlNBVVwiOiBcIlNBXCIsXG4gICAgXCJTQ0dcIjogXCJSUyBNRVwiLFxuICAgIFwiU0ROXCI6IFwiU0RcIixcbiAgICBcIlNFTlwiOiBcIlNOXCIsXG4gICAgXCJTR1BcIjogXCJTR1wiLFxuICAgIFwiU0dTXCI6IFwiR1NcIixcbiAgICBcIlNITlwiOiBcIlNIXCIsXG4gICAgXCJTSk1cIjogXCJTSlwiLFxuICAgIFwiU0xCXCI6IFwiU0JcIixcbiAgICBcIlNMRVwiOiBcIlNMXCIsXG4gICAgXCJTTFZcIjogXCJTVlwiLFxuICAgIFwiU01SXCI6IFwiU01cIixcbiAgICBcIlNPTVwiOiBcIlNPXCIsXG4gICAgXCJTUE1cIjogXCJQTVwiLFxuICAgIFwiU1JCXCI6IFwiUlNcIixcbiAgICBcIlNTRFwiOiBcIlNTXCIsXG4gICAgXCJTVFBcIjogXCJTVFwiLFxuICAgIFwiU1VcIjogXCJSVSBBTSBBWiBCWSBFRSBHRSBLWiBLRyBMViBMVCBNRCBUSiBUTSBVQSBVWlwiLFxuICAgIFwiU1VOXCI6IFwiUlUgQU0gQVogQlkgRUUgR0UgS1ogS0cgTFYgTFQgTUQgVEogVE0gVUEgVVpcIixcbiAgICBcIlNVUlwiOiBcIlNSXCIsXG4gICAgXCJTVktcIjogXCJTS1wiLFxuICAgIFwiU1ZOXCI6IFwiU0lcIixcbiAgICBcIlNXRVwiOiBcIlNFXCIsXG4gICAgXCJTV1pcIjogXCJTWlwiLFxuICAgIFwiU1hNXCI6IFwiU1hcIixcbiAgICBcIlNZQ1wiOiBcIlNDXCIsXG4gICAgXCJTWVJcIjogXCJTWVwiLFxuICAgIFwiVEFBXCI6IFwiVEFcIixcbiAgICBcIlRDQVwiOiBcIlRDXCIsXG4gICAgXCJUQ0RcIjogXCJURFwiLFxuICAgIFwiVEdPXCI6IFwiVEdcIixcbiAgICBcIlRIQVwiOiBcIlRIXCIsXG4gICAgXCJUSktcIjogXCJUSlwiLFxuICAgIFwiVEtMXCI6IFwiVEtcIixcbiAgICBcIlRLTVwiOiBcIlRNXCIsXG4gICAgXCJUTFNcIjogXCJUTFwiLFxuICAgIFwiVE1QXCI6IFwiVExcIixcbiAgICBcIlRPTlwiOiBcIlRPXCIsXG4gICAgXCJUUFwiOiBcIlRMXCIsXG4gICAgXCJUVE9cIjogXCJUVFwiLFxuICAgIFwiVFVOXCI6IFwiVE5cIixcbiAgICBcIlRVUlwiOiBcIlRSXCIsXG4gICAgXCJUVVZcIjogXCJUVlwiLFxuICAgIFwiVFdOXCI6IFwiVFdcIixcbiAgICBcIlRaQVwiOiBcIlRaXCIsXG4gICAgXCJVR0FcIjogXCJVR1wiLFxuICAgIFwiVUtcIjogXCJHQlwiLFxuICAgIFwiVUtSXCI6IFwiVUFcIixcbiAgICBcIlVNSVwiOiBcIlVNXCIsXG4gICAgXCJVUllcIjogXCJVWVwiLFxuICAgIFwiVVNBXCI6IFwiVVNcIixcbiAgICBcIlVaQlwiOiBcIlVaXCIsXG4gICAgXCJWQVRcIjogXCJWQVwiLFxuICAgIFwiVkNUXCI6IFwiVkNcIixcbiAgICBcIlZEXCI6IFwiVk5cIixcbiAgICBcIlZFTlwiOiBcIlZFXCIsXG4gICAgXCJWR0JcIjogXCJWR1wiLFxuICAgIFwiVklSXCI6IFwiVklcIixcbiAgICBcIlZOTVwiOiBcIlZOXCIsXG4gICAgXCJWVVRcIjogXCJWVVwiLFxuICAgIFwiV0tcIjogXCJVTVwiLFxuICAgIFwiV0xGXCI6IFwiV0ZcIixcbiAgICBcIldTTVwiOiBcIldTXCIsXG4gICAgXCJYQUFcIjogXCJYQVwiLFxuICAgIFwiWEJCXCI6IFwiWEJcIixcbiAgICBcIlhDQ1wiOiBcIlhDXCIsXG4gICAgXCJYRERcIjogXCJYRFwiLFxuICAgIFwiWEVFXCI6IFwiWEVcIixcbiAgICBcIlhGRlwiOiBcIlhGXCIsXG4gICAgXCJYR0dcIjogXCJYR1wiLFxuICAgIFwiWEhIXCI6IFwiWEhcIixcbiAgICBcIlhJSVwiOiBcIlhJXCIsXG4gICAgXCJYSkpcIjogXCJYSlwiLFxuICAgIFwiWEtLXCI6IFwiWEtcIixcbiAgICBcIlhMTFwiOiBcIlhMXCIsXG4gICAgXCJYTU1cIjogXCJYTVwiLFxuICAgIFwiWE5OXCI6IFwiWE5cIixcbiAgICBcIlhPT1wiOiBcIlhPXCIsXG4gICAgXCJYUFBcIjogXCJYUFwiLFxuICAgIFwiWFFRXCI6IFwiWFFcIixcbiAgICBcIlhSUlwiOiBcIlhSXCIsXG4gICAgXCJYU1NcIjogXCJYU1wiLFxuICAgIFwiWFRUXCI6IFwiWFRcIixcbiAgICBcIlhVVVwiOiBcIlhVXCIsXG4gICAgXCJYVlZcIjogXCJYVlwiLFxuICAgIFwiWFdXXCI6IFwiWFdcIixcbiAgICBcIlhYWFwiOiBcIlhYXCIsXG4gICAgXCJYWVlcIjogXCJYWVwiLFxuICAgIFwiWFpaXCI6IFwiWFpcIixcbiAgICBcIllEXCI6IFwiWUVcIixcbiAgICBcIllFTVwiOiBcIllFXCIsXG4gICAgXCJZTURcIjogXCJZRVwiLFxuICAgIFwiWVVcIjogXCJSUyBNRVwiLFxuICAgIFwiWVVHXCI6IFwiUlMgTUVcIixcbiAgICBcIlpBRlwiOiBcIlpBXCIsXG4gICAgXCJaQVJcIjogXCJDRFwiLFxuICAgIFwiWk1CXCI6IFwiWk1cIixcbiAgICBcIlpSXCI6IFwiQ0RcIixcbiAgICBcIlpXRVwiOiBcIlpXXCIsXG4gICAgXCJaWlpcIjogXCJaWlwiXG59O1xuZXhwb3J0cy5zY3JpcHRBbGlhcyA9IHtcbiAgICBcIlFhYWlcIjogXCJaaW5oXCJcbn07XG5leHBvcnRzLnZhcmlhbnRBbGlhcyA9IHtcbiAgICBcImhlcGxvY1wiOiBcImFsYWxjOTdcIixcbiAgICBcInBvbHl0b25pXCI6IFwicG9seXRvblwiXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVtaXRVbmljb2RlTG9jYWxlSWQgPSBleHBvcnRzLmVtaXRVbmljb2RlTGFuZ3VhZ2VJZCA9IHZvaWQgMDtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuZnVuY3Rpb24gZW1pdFVuaWNvZGVMYW5ndWFnZUlkKGxhbmcpIHtcbiAgICBpZiAoIWxhbmcpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gdHNsaWJfMS5fX3NwcmVhZEFycmF5cyhbbGFuZy5sYW5nLCBsYW5nLnNjcmlwdCwgbGFuZy5yZWdpb25dLCAobGFuZy52YXJpYW50cyB8fCBbXSkpLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAuam9pbignLScpO1xufVxuZXhwb3J0cy5lbWl0VW5pY29kZUxhbmd1YWdlSWQgPSBlbWl0VW5pY29kZUxhbmd1YWdlSWQ7XG5mdW5jdGlvbiBlbWl0VW5pY29kZUxvY2FsZUlkKF9hKSB7XG4gICAgdmFyIGxhbmcgPSBfYS5sYW5nLCBleHRlbnNpb25zID0gX2EuZXh0ZW5zaW9ucztcbiAgICB2YXIgY2h1bmtzID0gW2VtaXRVbmljb2RlTGFuZ3VhZ2VJZChsYW5nKV07XG4gICAgZm9yICh2YXIgX2kgPSAwLCBleHRlbnNpb25zXzEgPSBleHRlbnNpb25zOyBfaSA8IGV4dGVuc2lvbnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGV4dCA9IGV4dGVuc2lvbnNfMVtfaV07XG4gICAgICAgIGNodW5rcy5wdXNoKGV4dC50eXBlKTtcbiAgICAgICAgc3dpdGNoIChleHQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICAgICAgY2h1bmtzLnB1c2guYXBwbHkoY2h1bmtzLCB0c2xpYl8xLl9fc3ByZWFkQXJyYXlzKGV4dC5hdHRyaWJ1dGVzLCBleHQua2V5d29yZHMucmVkdWNlKGZ1bmN0aW9uIChhbGwsIGt2KSB7IHJldHVybiBhbGwuY29uY2F0KGt2KTsgfSwgW10pKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaC5hcHBseShjaHVua3MsIHRzbGliXzEuX19zcHJlYWRBcnJheXMoW2VtaXRVbmljb2RlTGFuZ3VhZ2VJZChleHQubGFuZyldLCBleHQuZmllbGRzLnJlZHVjZShmdW5jdGlvbiAoYWxsLCBrdikgeyByZXR1cm4gYWxsLmNvbmNhdChrdik7IH0sIFtdKSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaChleHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaHVua3MuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJy0nKTtcbn1cbmV4cG9ydHMuZW1pdFVuaWNvZGVMb2NhbGVJZCA9IGVtaXRVbmljb2RlTG9jYWxlSWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VVbmljb2RlTG9jYWxlSWQgPSBleHBvcnRzLnBhcnNlVW5pY29kZUxhbmd1YWdlSWQgPSBleHBvcnRzLmlzVW5pY29kZVZhcmlhbnRTdWJ0YWcgPSBleHBvcnRzLmlzVW5pY29kZVNjcmlwdFN1YnRhZyA9IGV4cG9ydHMuaXNVbmljb2RlUmVnaW9uU3VidGFnID0gZXhwb3J0cy5pc1N0cnVjdHVyYWxseVZhbGlkTGFuZ3VhZ2VUYWcgPSBleHBvcnRzLmlzVW5pY29kZUxhbmd1YWdlU3VidGFnID0gZXhwb3J0cy5TRVBBUkFUT1IgPSB2b2lkIDA7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBBTFBIQU5VTV8xXzggPSAvXlthLXowLTldezEsOH0kL2k7XG52YXIgQUxQSEFOVU1fMl84ID0gL15bYS16MC05XXsyLDh9JC9pO1xudmFyIEFMUEhBTlVNXzNfOCA9IC9eW2EtejAtOV17Myw4fSQvaTtcbnZhciBLRVlfUkVHRVggPSAvXlthLXowLTldW2Etel0kL2k7XG52YXIgVFlQRV9SRUdFWCA9IC9eW2EtejAtOV17Myw4fSQvaTtcbnZhciBBTFBIQV80ID0gL15bYS16XXs0fSQvaTtcbi8vIGFscGhhbnVtLVt0VHVVeFhdXG52YXIgT1RIRVJfRVhURU5TSU9OX1RZUEUgPSAvXlswLTlhLXN2d3l6XSQvaTtcbnZhciBVTklDT0RFX1JFR0lPTl9TVUJUQUdfUkVHRVggPSAvXihbYS16XXsyfXxbMC05XXszfSkkL2k7XG52YXIgVU5JQ09ERV9WQVJJQU5UX1NVQlRBR19SRUdFWCA9IC9eKFthLXowLTldezUsOH18WzAtOV1bYS16MC05XXszfSkkL2k7XG52YXIgVU5JQ09ERV9MQU5HVUFHRV9TVUJUQUdfUkVHRVggPSAvXihbYS16XXsyLDN9fFthLXpdezUsOH0pJC9pO1xudmFyIFRLRVlfUkVHRVggPSAvXlthLXpdWzAtOV0kL2k7XG5leHBvcnRzLlNFUEFSQVRPUiA9ICctJztcbmZ1bmN0aW9uIGlzVW5pY29kZUxhbmd1YWdlU3VidGFnKGxhbmcpIHtcbiAgICByZXR1cm4gVU5JQ09ERV9MQU5HVUFHRV9TVUJUQUdfUkVHRVgudGVzdChsYW5nKTtcbn1cbmV4cG9ydHMuaXNVbmljb2RlTGFuZ3VhZ2VTdWJ0YWcgPSBpc1VuaWNvZGVMYW5ndWFnZVN1YnRhZztcbmZ1bmN0aW9uIGlzU3RydWN0dXJhbGx5VmFsaWRMYW5ndWFnZVRhZyh0YWcpIHtcbiAgICB0cnkge1xuICAgICAgICBwYXJzZVVuaWNvZGVMYW5ndWFnZUlkKHRhZy5zcGxpdChleHBvcnRzLlNFUEFSQVRPUikpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5pc1N0cnVjdHVyYWxseVZhbGlkTGFuZ3VhZ2VUYWcgPSBpc1N0cnVjdHVyYWxseVZhbGlkTGFuZ3VhZ2VUYWc7XG5mdW5jdGlvbiBpc1VuaWNvZGVSZWdpb25TdWJ0YWcocmVnaW9uKSB7XG4gICAgcmV0dXJuIFVOSUNPREVfUkVHSU9OX1NVQlRBR19SRUdFWC50ZXN0KHJlZ2lvbik7XG59XG5leHBvcnRzLmlzVW5pY29kZVJlZ2lvblN1YnRhZyA9IGlzVW5pY29kZVJlZ2lvblN1YnRhZztcbmZ1bmN0aW9uIGlzVW5pY29kZVNjcmlwdFN1YnRhZyhzY3JpcHQpIHtcbiAgICByZXR1cm4gQUxQSEFfNC50ZXN0KHNjcmlwdCk7XG59XG5leHBvcnRzLmlzVW5pY29kZVNjcmlwdFN1YnRhZyA9IGlzVW5pY29kZVNjcmlwdFN1YnRhZztcbmZ1bmN0aW9uIGlzVW5pY29kZVZhcmlhbnRTdWJ0YWcodmFyaWFudCkge1xuICAgIHJldHVybiBVTklDT0RFX1ZBUklBTlRfU1VCVEFHX1JFR0VYLnRlc3QodmFyaWFudCk7XG59XG5leHBvcnRzLmlzVW5pY29kZVZhcmlhbnRTdWJ0YWcgPSBpc1VuaWNvZGVWYXJpYW50U3VidGFnO1xuZnVuY3Rpb24gcGFyc2VVbmljb2RlTGFuZ3VhZ2VJZChjaHVua3MpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY2h1bmtzID0gY2h1bmtzLnNwbGl0KGV4cG9ydHMuU0VQQVJBVE9SKTtcbiAgICB9XG4gICAgdmFyIGxhbmcgPSBjaHVua3Muc2hpZnQoKTtcbiAgICBpZiAoIWxhbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01pc3NpbmcgdW5pY29kZV9sYW5ndWFnZV9zdWJ0YWcnKTtcbiAgICB9XG4gICAgaWYgKGxhbmcgPT09ICdyb290Jykge1xuICAgICAgICByZXR1cm4geyBsYW5nOiAncm9vdCcsIHZhcmlhbnRzOiBbXSB9O1xuICAgIH1cbiAgICAvLyB1bmljb2RlX2xhbmd1YWdlX3N1YnRhZ1xuICAgIGlmICghaXNVbmljb2RlTGFuZ3VhZ2VTdWJ0YWcobGFuZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hbGZvcm1lZCB1bmljb2RlX2xhbmd1YWdlX3N1YnRhZycpO1xuICAgIH1cbiAgICB2YXIgc2NyaXB0O1xuICAgIC8vIHVuaWNvZGVfc2NyaXB0X3N1YnRhZ1xuICAgIGlmIChpc1VuaWNvZGVTY3JpcHRTdWJ0YWcoY2h1bmtzWzBdKSkge1xuICAgICAgICBzY3JpcHQgPSBjaHVua3Muc2hpZnQoKTtcbiAgICB9XG4gICAgdmFyIHJlZ2lvbjtcbiAgICAvLyB1bmljb2RlX3JlZ2lvbl9zdWJ0YWdcbiAgICBpZiAoaXNVbmljb2RlUmVnaW9uU3VidGFnKGNodW5rc1swXSkpIHtcbiAgICAgICAgcmVnaW9uID0gY2h1bmtzLnNoaWZ0KCk7XG4gICAgfVxuICAgIHZhciB2YXJpYW50cyA9IHt9O1xuICAgIHdoaWxlIChjaHVua3MubGVuZ3RoICYmIGlzVW5pY29kZVZhcmlhbnRTdWJ0YWcoY2h1bmtzWzBdKSkge1xuICAgICAgICB2YXIgdmFyaWFudCA9IGNodW5rcy5zaGlmdCgpO1xuICAgICAgICBpZiAodmFyaWFudCBpbiB2YXJpYW50cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEdXBsaWNhdGUgdmFyaWFudCBcXFwiXCIgKyB2YXJpYW50ICsgXCJcXFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhcmlhbnRzW3ZhcmlhbnRdID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGFuZzogbGFuZyxcbiAgICAgICAgc2NyaXB0OiBzY3JpcHQsXG4gICAgICAgIHJlZ2lvbjogcmVnaW9uLFxuICAgICAgICB2YXJpYW50czogT2JqZWN0LmtleXModmFyaWFudHMpLFxuICAgIH07XG59XG5leHBvcnRzLnBhcnNlVW5pY29kZUxhbmd1YWdlSWQgPSBwYXJzZVVuaWNvZGVMYW5ndWFnZUlkO1xuZnVuY3Rpb24gcGFyc2VVbmljb2RlRXh0ZW5zaW9uKGNodW5rcykge1xuICAgIHZhciBrZXl3b3JkcyA9IFtdO1xuICAgIHZhciBrZXl3b3JkO1xuICAgIHdoaWxlIChjaHVua3MubGVuZ3RoICYmIChrZXl3b3JkID0gcGFyc2VLZXl3b3JkKGNodW5rcykpKSB7XG4gICAgICAgIGtleXdvcmRzLnB1c2goa2V5d29yZCk7XG4gICAgfVxuICAgIGlmIChrZXl3b3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICd1JyxcbiAgICAgICAgICAgIGtleXdvcmRzOiBrZXl3b3JkcyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFtdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBNaXggb2YgYXR0cmlidXRlcyAmIGtleXdvcmRzXG4gICAgLy8gQ2hlY2sgZm9yIGF0dHJpYnV0ZXMgZmlyc3RcbiAgICB2YXIgYXR0cmlidXRlcyA9IFtdO1xuICAgIHdoaWxlIChjaHVua3MubGVuZ3RoICYmIEFMUEhBTlVNXzNfOC50ZXN0KGNodW5rc1swXSkpIHtcbiAgICAgICAgYXR0cmlidXRlcy5wdXNoKGNodW5rcy5zaGlmdCgpKTtcbiAgICB9XG4gICAgd2hpbGUgKGNodW5rcy5sZW5ndGggJiYgKGtleXdvcmQgPSBwYXJzZUtleXdvcmQoY2h1bmtzKSkpIHtcbiAgICAgICAga2V5d29yZHMucHVzaChrZXl3b3JkKTtcbiAgICB9XG4gICAgaWYgKGtleXdvcmRzLmxlbmd0aCB8fCBhdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ3UnLFxuICAgICAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICAgICAgICAgIGtleXdvcmRzOiBrZXl3b3JkcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hbGZvcm1lZCB1bmljb2RlX2V4dGVuc2lvbicpO1xufVxuZnVuY3Rpb24gcGFyc2VLZXl3b3JkKGNodW5rcykge1xuICAgIHZhciBrZXk7XG4gICAgaWYgKCFLRVlfUkVHRVgudGVzdChjaHVua3NbMF0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAga2V5ID0gY2h1bmtzLnNoaWZ0KCk7XG4gICAgdmFyIHR5cGUgPSBbXTtcbiAgICB3aGlsZSAoY2h1bmtzLmxlbmd0aCAmJiBUWVBFX1JFR0VYLnRlc3QoY2h1bmtzWzBdKSkge1xuICAgICAgICB0eXBlLnB1c2goY2h1bmtzLnNoaWZ0KCkpO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSAnJztcbiAgICBpZiAodHlwZS5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSB0eXBlLmpvaW4oZXhwb3J0cy5TRVBBUkFUT1IpO1xuICAgIH1cbiAgICByZXR1cm4gW2tleSwgdmFsdWVdO1xufVxuZnVuY3Rpb24gcGFyc2VUcmFuc2Zvcm1lZEV4dGVuc2lvbihjaHVua3MpIHtcbiAgICB2YXIgbGFuZztcbiAgICB0cnkge1xuICAgICAgICBsYW5nID0gcGFyc2VVbmljb2RlTGFuZ3VhZ2VJZChjaHVua3MpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBUcnkganVzdCBwYXJzaW5nIHRmaWVsZFxuICAgIH1cbiAgICB2YXIgZmllbGRzID0gW107XG4gICAgd2hpbGUgKGNodW5rcy5sZW5ndGggJiYgVEtFWV9SRUdFWC50ZXN0KGNodW5rc1swXSkpIHtcbiAgICAgICAgdmFyIGtleSA9IGNodW5rcy5zaGlmdCgpO1xuICAgICAgICB2YXIgdmFsdWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKGNodW5rcy5sZW5ndGggJiYgQUxQSEFOVU1fM184LnRlc3QoY2h1bmtzWzBdKSkge1xuICAgICAgICAgICAgdmFsdWUucHVzaChjaHVua3Muc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTWlzc2luZyB0dmFsdWUgZm9yIHRrZXkgXFxcIlwiICsga2V5ICsgXCJcXFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkcy5wdXNoKFtrZXksIHZhbHVlLmpvaW4oZXhwb3J0cy5TRVBBUkFUT1IpXSk7XG4gICAgfVxuICAgIGlmIChmaWVsZHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAndCcsXG4gICAgICAgICAgICBmaWVsZHM6IGZpZWxkcyxcbiAgICAgICAgICAgIGxhbmc6IGxhbmcsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYWxmb3JtZWQgdHJhbnNmb3JtZWRfZXh0ZW5zaW9uJyk7XG59XG5mdW5jdGlvbiBwYXJzZVB1RXh0ZW5zaW9uKGNodW5rcykge1xuICAgIHZhciBleHRzID0gW107XG4gICAgd2hpbGUgKGNodW5rcy5sZW5ndGggJiYgQUxQSEFOVU1fMV84LnRlc3QoY2h1bmtzWzBdKSkge1xuICAgICAgICBleHRzLnB1c2goY2h1bmtzLnNoaWZ0KCkpO1xuICAgIH1cbiAgICBpZiAoZXh0cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICd4JyxcbiAgICAgICAgICAgIHZhbHVlOiBleHRzLmpvaW4oZXhwb3J0cy5TRVBBUkFUT1IpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTWFsZm9ybWVkIHByaXZhdGVfdXNlX2V4dGVuc2lvbicpO1xufVxuZnVuY3Rpb24gcGFyc2VPdGhlckV4dGVuc2lvblZhbHVlKGNodW5rcykge1xuICAgIHZhciBleHRzID0gW107XG4gICAgd2hpbGUgKGNodW5rcy5sZW5ndGggJiYgQUxQSEFOVU1fMl84LnRlc3QoY2h1bmtzWzBdKSkge1xuICAgICAgICBleHRzLnB1c2goY2h1bmtzLnNoaWZ0KCkpO1xuICAgIH1cbiAgICBpZiAoZXh0cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGV4dHMuam9pbihleHBvcnRzLlNFUEFSQVRPUik7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cbmZ1bmN0aW9uIHBhcnNlRXh0ZW5zaW9ucyhjaHVua3MpIHtcbiAgICBpZiAoIWNodW5rcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHsgZXh0ZW5zaW9uczogW10gfTtcbiAgICB9XG4gICAgdmFyIGV4dGVuc2lvbnMgPSBbXTtcbiAgICB2YXIgdW5pY29kZUV4dGVuc2lvbjtcbiAgICB2YXIgdHJhbnNmb3JtZWRFeHRlbnNpb247XG4gICAgdmFyIHB1RXh0ZW5zaW9uO1xuICAgIHZhciBvdGhlckV4dGVuc2lvbk1hcCA9IHt9O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIHR5cGUgPSBjaHVua3Muc2hpZnQoKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgIGNhc2UgJ1UnOlxuICAgICAgICAgICAgICAgIGlmICh1bmljb2RlRXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGVyZSBjYW4gb25seSBiZSAxIC11LSBleHRlbnNpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdW5pY29kZUV4dGVuc2lvbiA9IHBhcnNlVW5pY29kZUV4dGVuc2lvbihjaHVua3MpO1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaCh1bmljb2RlRXh0ZW5zaW9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybWVkRXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGVyZSBjYW4gb25seSBiZSAxIC10LSBleHRlbnNpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRFeHRlbnNpb24gPSBwYXJzZVRyYW5zZm9ybWVkRXh0ZW5zaW9uKGNodW5rcyk7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKHRyYW5zZm9ybWVkRXh0ZW5zaW9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgY2FzZSAnWCc6XG4gICAgICAgICAgICAgICAgaWYgKHB1RXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGVyZSBjYW4gb25seSBiZSAxIC14LSBleHRlbnNpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHVFeHRlbnNpb24gPSBwYXJzZVB1RXh0ZW5zaW9uKGNodW5rcyk7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKHB1RXh0ZW5zaW9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKCFPVEhFUl9FWFRFTlNJT05fVFlQRS50ZXN0KHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYWxmb3JtZWQgZXh0ZW5zaW9uIHR5cGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgaW4gb3RoZXJFeHRlbnNpb25NYXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGVyZSBjYW4gb25seSBiZSAxIC1cIiArIHR5cGUgKyBcIi0gZXh0ZW5zaW9uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZXh0ZW5zaW9uID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGFyc2VPdGhlckV4dGVuc2lvblZhbHVlKGNodW5rcyksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBvdGhlckV4dGVuc2lvbk1hcFtleHRlbnNpb24udHlwZV0gPSBleHRlbnNpb247XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKGV4dGVuc2lvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChjaHVua3MubGVuZ3RoKTtcbiAgICByZXR1cm4geyBleHRlbnNpb25zOiBleHRlbnNpb25zIH07XG59XG5mdW5jdGlvbiBwYXJzZVVuaWNvZGVMb2NhbGVJZChsb2NhbGUpIHtcbiAgICB2YXIgY2h1bmtzID0gbG9jYWxlLnNwbGl0KGV4cG9ydHMuU0VQQVJBVE9SKTtcbiAgICB2YXIgbGFuZyA9IHBhcnNlVW5pY29kZUxhbmd1YWdlSWQoY2h1bmtzKTtcbiAgICByZXR1cm4gdHNsaWJfMS5fX2Fzc2lnbih7IGxhbmc6IGxhbmcgfSwgcGFyc2VFeHRlbnNpb25zKGNodW5rcykpO1xufVxuZXhwb3J0cy5wYXJzZVVuaWNvZGVMb2NhbGVJZCA9IHBhcnNlVW5pY29kZUxvY2FsZUlkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBUeXBlLW9ubHkgY2lyY3VsYXIgaW1wb3J0XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWN5Y2xlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaW50ZXJuYWxTbG90TWFwID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGdldEludGVybmFsU2xvdHMoeCkge1xuICAgIHZhciBpbnRlcm5hbFNsb3RzID0gaW50ZXJuYWxTbG90TWFwLmdldCh4KTtcbiAgICBpZiAoIWludGVybmFsU2xvdHMpIHtcbiAgICAgICAgaW50ZXJuYWxTbG90cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGludGVybmFsU2xvdE1hcC5zZXQoeCwgaW50ZXJuYWxTbG90cyk7XG4gICAgfVxuICAgIHJldHVybiBpbnRlcm5hbFNsb3RzO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0SW50ZXJuYWxTbG90cztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Mb2NhbGUgPSB2b2lkIDA7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBlY21hNDAyX2Fic3RyYWN0XzEgPSByZXF1aXJlKFwiQGZvcm1hdGpzL2VjbWE0MDItYWJzdHJhY3RcIik7XG52YXIgaW50bF9nZXRjYW5vbmljYWxsb2NhbGVzXzEgPSByZXF1aXJlKFwiQGZvcm1hdGpzL2ludGwtZ2V0Y2Fub25pY2FsbG9jYWxlc1wiKTtcbnZhciBsaWtlbHlTdWJ0YWdzRGF0YSA9IHRzbGliXzEuX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJjbGRyLWNvcmUvc3VwcGxlbWVudGFsL2xpa2VseVN1YnRhZ3MuanNvblwiKSk7XG52YXIgZ2V0X2ludGVybmFsX3Nsb3RzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9nZXRfaW50ZXJuYWxfc2xvdHNcIikpO1xudmFyIGxpa2VseVN1YnRhZ3MgPSBsaWtlbHlTdWJ0YWdzRGF0YS5zdXBwbGVtZW50YWwubGlrZWx5U3VidGFncztcbnZhciBSRUxFVkFOVF9FWFRFTlNJT05fS0VZUyA9IFsnY2EnLCAnY28nLCAnaGMnLCAna2YnLCAna24nLCAnbnUnXTtcbnZhciBVTklDT0RFX1RZUEVfUkVHRVggPSAvXlthLXowLTldezMsOH0oLVthLXowLTldezMsOH0pKiQvaTtcbmZ1bmN0aW9uIGFwcGx5T3B0aW9uc1RvVGFnKHRhZywgb3B0aW9ucykge1xuICAgIGVjbWE0MDJfYWJzdHJhY3RfMS5pbnZhcmlhbnQodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycsICdsYW5ndWFnZSB0YWcgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIGVjbWE0MDJfYWJzdHJhY3RfMS5pbnZhcmlhbnQoaW50bF9nZXRjYW5vbmljYWxsb2NhbGVzXzEuaXNTdHJ1Y3R1cmFsbHlWYWxpZExhbmd1YWdlVGFnKHRhZyksICdtYWxmb3JtZWQgbGFuZ3VhZ2UgdGFnJywgUmFuZ2VFcnJvcik7XG4gICAgdmFyIGxhbmd1YWdlID0gZWNtYTQwMl9hYnN0cmFjdF8xLkdldE9wdGlvbihvcHRpb25zLCAnbGFuZ3VhZ2UnLCAnc3RyaW5nJywgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgIGlmIChsYW5ndWFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVjbWE0MDJfYWJzdHJhY3RfMS5pbnZhcmlhbnQoaW50bF9nZXRjYW5vbmljYWxsb2NhbGVzXzEuaXNVbmljb2RlTGFuZ3VhZ2VTdWJ0YWcobGFuZ3VhZ2UpLCAnTWFsZm9ybWVkIHVuaWNvZGVfbGFuZ3VhZ2Vfc3VidGFnJywgUmFuZ2VFcnJvcik7XG4gICAgfVxuICAgIHZhciBzY3JpcHQgPSBlY21hNDAyX2Fic3RyYWN0XzEuR2V0T3B0aW9uKG9wdGlvbnMsICdzY3JpcHQnLCAnc3RyaW5nJywgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgIGlmIChzY3JpcHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlY21hNDAyX2Fic3RyYWN0XzEuaW52YXJpYW50KGludGxfZ2V0Y2Fub25pY2FsbG9jYWxlc18xLmlzVW5pY29kZVNjcmlwdFN1YnRhZyhzY3JpcHQpLCAnTWFsZm9ybWVkIHVuaWNvZGVfc2NyaXB0X3N1YnRhZycsIFJhbmdlRXJyb3IpO1xuICAgIH1cbiAgICB2YXIgcmVnaW9uID0gZWNtYTQwMl9hYnN0cmFjdF8xLkdldE9wdGlvbihvcHRpb25zLCAncmVnaW9uJywgJ3N0cmluZycsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICBpZiAocmVnaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWNtYTQwMl9hYnN0cmFjdF8xLmludmFyaWFudChpbnRsX2dldGNhbm9uaWNhbGxvY2FsZXNfMS5pc1VuaWNvZGVSZWdpb25TdWJ0YWcocmVnaW9uKSwgJ01hbGZvcm1lZCB1bmljb2RlX3JlZ2lvbl9zdWJ0YWcnLCBSYW5nZUVycm9yKTtcbiAgICB9XG4gICAgdmFyIGxhbmd1YWdlSWQgPSBpbnRsX2dldGNhbm9uaWNhbGxvY2FsZXNfMS5wYXJzZVVuaWNvZGVMYW5ndWFnZUlkKHRhZyk7XG4gICAgaWYgKGxhbmd1YWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGFuZ3VhZ2VJZC5sYW5nID0gbGFuZ3VhZ2U7XG4gICAgfVxuICAgIGlmIChzY3JpcHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsYW5ndWFnZUlkLnNjcmlwdCA9IHNjcmlwdDtcbiAgICB9XG4gICAgaWYgKHJlZ2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxhbmd1YWdlSWQucmVnaW9uID0gcmVnaW9uO1xuICAgIH1cbiAgICByZXR1cm4gSW50bC5nZXRDYW5vbmljYWxMb2NhbGVzKGludGxfZ2V0Y2Fub25pY2FsbG9jYWxlc18xLmVtaXRVbmljb2RlTG9jYWxlSWQodHNsaWJfMS5fX2Fzc2lnbih0c2xpYl8xLl9fYXNzaWduKHt9LCBpbnRsX2dldGNhbm9uaWNhbGxvY2FsZXNfMS5wYXJzZVVuaWNvZGVMb2NhbGVJZCh0YWcpKSwgeyBsYW5nOiBsYW5ndWFnZUlkIH0pKSlbMF07XG59XG5mdW5jdGlvbiBhcHBseVVuaWNvZGVFeHRlbnNpb25Ub1RhZyh0YWcsIG9wdGlvbnMsIHJlbGV2YW50RXh0ZW5zaW9uS2V5cykge1xuICAgIHZhciB1bmljb2RlRXh0ZW5zaW9uO1xuICAgIHZhciBrZXl3b3JkcyA9IFtdO1xuICAgIHZhciBhc3QgPSBpbnRsX2dldGNhbm9uaWNhbGxvY2FsZXNfMS5wYXJzZVVuaWNvZGVMb2NhbGVJZCh0YWcpO1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBhc3QuZXh0ZW5zaW9uczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGV4dCA9IF9hW19pXTtcbiAgICAgICAgaWYgKGV4dC50eXBlID09PSAndScpIHtcbiAgICAgICAgICAgIHVuaWNvZGVFeHRlbnNpb24gPSBleHQ7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShleHQua2V5d29yZHMpKVxuICAgICAgICAgICAgICAgIGtleXdvcmRzID0gZXh0LmtleXdvcmRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAodmFyIF9iID0gMCwgcmVsZXZhbnRFeHRlbnNpb25LZXlzXzEgPSByZWxldmFudEV4dGVuc2lvbktleXM7IF9iIDwgcmVsZXZhbnRFeHRlbnNpb25LZXlzXzEubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgIHZhciBrZXkgPSByZWxldmFudEV4dGVuc2lvbktleXNfMVtfYl07XG4gICAgICAgIHZhciB2YWx1ZSA9IHZvaWQgMCwgZW50cnkgPSB2b2lkIDA7XG4gICAgICAgIGZvciAodmFyIF9jID0gMCwga2V5d29yZHNfMSA9IGtleXdvcmRzOyBfYyA8IGtleXdvcmRzXzEubGVuZ3RoOyBfYysrKSB7XG4gICAgICAgICAgICB2YXIga2V5d29yZCA9IGtleXdvcmRzXzFbX2NdO1xuICAgICAgICAgICAgaWYgKGtleXdvcmRbMF0gPT09IGtleSkge1xuICAgICAgICAgICAgICAgIGVudHJ5ID0ga2V5d29yZDtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGVudHJ5WzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVjbWE0MDJfYWJzdHJhY3RfMS5pbnZhcmlhbnQoa2V5IGluIG9wdGlvbnMsIGtleSArIFwiIG11c3QgYmUgaW4gb3B0aW9uc1wiKTtcbiAgICAgICAgdmFyIG9wdGlvbnNWYWx1ZSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgaWYgKG9wdGlvbnNWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlY21hNDAyX2Fic3RyYWN0XzEuaW52YXJpYW50KHR5cGVvZiBvcHRpb25zVmFsdWUgPT09ICdzdHJpbmcnLCBcIlZhbHVlIGZvciBcIiArIGtleSArIFwiIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgICAgICB2YWx1ZSA9IG9wdGlvbnNWYWx1ZTtcbiAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGVudHJ5WzFdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXl3b3Jkcy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKCF1bmljb2RlRXh0ZW5zaW9uKSB7XG4gICAgICAgIGlmIChrZXl3b3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFzdC5leHRlbnNpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICd1JyxcbiAgICAgICAgICAgICAgICBrZXl3b3Jkczoga2V5d29yZHMsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogW10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdW5pY29kZUV4dGVuc2lvbi5rZXl3b3JkcyA9IGtleXdvcmRzO1xuICAgIH1cbiAgICByZXN1bHQubG9jYWxlID0gSW50bFxuICAgICAgICAuZ2V0Q2Fub25pY2FsTG9jYWxlcyhpbnRsX2dldGNhbm9uaWNhbGxvY2FsZXNfMS5lbWl0VW5pY29kZUxvY2FsZUlkKGFzdCkpWzBdO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtZXJnZVVuaWNvZGVMYW5ndWFnZUlkKGxhbmcsIHNjcmlwdCwgcmVnaW9uLCB2YXJpYW50cywgcmVwbGFjZW1lbnQpIHtcbiAgICBpZiAodmFyaWFudHMgPT09IHZvaWQgMCkgeyB2YXJpYW50cyA9IFtdOyB9XG4gICAgaWYgKCFyZXBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFuZzogbGFuZyB8fCAndW5kJyxcbiAgICAgICAgICAgIHNjcmlwdDogc2NyaXB0LFxuICAgICAgICAgICAgcmVnaW9uOiByZWdpb24sXG4gICAgICAgICAgICB2YXJpYW50czogdmFyaWFudHMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGxhbmc6ICFsYW5nIHx8IGxhbmcgPT09ICd1bmQnID8gcmVwbGFjZW1lbnQubGFuZyA6IGxhbmcsXG4gICAgICAgIHNjcmlwdDogc2NyaXB0IHx8IHJlcGxhY2VtZW50LnNjcmlwdCxcbiAgICAgICAgcmVnaW9uOiByZWdpb24gfHwgcmVwbGFjZW1lbnQucmVnaW9uLFxuICAgICAgICB2YXJpYW50czogdHNsaWJfMS5fX3NwcmVhZEFycmF5cyh2YXJpYW50cywgcmVwbGFjZW1lbnQudmFyaWFudHMpLFxuICAgIH07XG59XG5mdW5jdGlvbiBhZGRMaWtlbHlTdWJ0YWdzKHRhZykge1xuICAgIHZhciBhc3QgPSBpbnRsX2dldGNhbm9uaWNhbGxvY2FsZXNfMS5wYXJzZVVuaWNvZGVMb2NhbGVJZCh0YWcpO1xuICAgIHZhciB1bmljb2RlTGFuZ0lkID0gYXN0Lmxhbmc7XG4gICAgdmFyIGxhbmcgPSB1bmljb2RlTGFuZ0lkLmxhbmcsIHNjcmlwdCA9IHVuaWNvZGVMYW5nSWQuc2NyaXB0LCByZWdpb24gPSB1bmljb2RlTGFuZ0lkLnJlZ2lvbiwgdmFyaWFudHMgPSB1bmljb2RlTGFuZ0lkLnZhcmlhbnRzO1xuICAgIGlmIChzY3JpcHQgJiYgcmVnaW9uKSB7XG4gICAgICAgIHZhciBtYXRjaF8xID0gbGlrZWx5U3VidGFnc1tpbnRsX2dldGNhbm9uaWNhbGxvY2FsZXNfMS5lbWl0VW5pY29kZUxhbmd1YWdlSWQoeyBsYW5nOiBsYW5nLCBzY3JpcHQ6IHNjcmlwdCwgcmVnaW9uOiByZWdpb24sIHZhcmlhbnRzOiBbXSB9KV07XG4gICAgICAgIGlmIChtYXRjaF8xKSB7XG4gICAgICAgICAgICB2YXIgcGFydHNfMSA9IGludGxfZ2V0Y2Fub25pY2FsbG9jYWxlc18xLnBhcnNlVW5pY29kZUxhbmd1YWdlSWQobWF0Y2hfMSk7XG4gICAgICAgICAgICBhc3QubGFuZyA9IG1lcmdlVW5pY29kZUxhbmd1YWdlSWQodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdmFyaWFudHMsIHBhcnRzXzEpO1xuICAgICAgICAgICAgcmV0dXJuIGludGxfZ2V0Y2Fub25pY2FsbG9jYWxlc18xLmVtaXRVbmljb2RlTG9jYWxlSWQoYXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2NyaXB0KSB7XG4gICAgICAgIHZhciBtYXRjaF8yID0gbGlrZWx5U3VidGFnc1tpbnRsX2dldGNhbm9uaWNhbGxvY2FsZXNfMS5lbWl0VW5pY29kZUxhbmd1YWdlSWQoeyBsYW5nOiBsYW5nLCBzY3JpcHQ6IHNjcmlwdCwgdmFyaWFudHM6IFtdIH0pXTtcbiAgICAgICAgaWYgKG1hdGNoXzIpIHtcbiAgICAgICAgICAgIHZhciBwYXJ0c18yID0gaW50bF9nZXRjYW5vbmljYWxsb2NhbGVzXzEucGFyc2VVbmljb2RlTGFuZ3VhZ2VJZChtYXRjaF8yKTtcbiAgICAgICAgICAgIGFzdC5sYW5nID0gbWVyZ2VVbmljb2RlTGFuZ3VhZ2VJZCh1bmRlZmluZWQsIHVuZGVmaW5lZCwgcmVnaW9uLCB2YXJpYW50cywgcGFydHNfMik7XG4gICAgICAgICAgICByZXR1cm4gaW50bF9nZXRjYW5vbmljYWxsb2NhbGVzXzEuZW1pdFVuaWNvZGVMb2NhbGVJZChhc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyZWdpb24pIHtcbiAgICAgICAgdmFyIG1hdGNoXzMgPSBsaWtlbHlTdWJ0YWdzW2ludGxfZ2V0Y2Fub25pY2FsbG9jYWxlc18xLmVtaXRVbmljb2RlTGFuZ3VhZ2VJZCh7IGxhbmc6IGxhbmcsIHJlZ2lvbjogcmVnaW9uLCB2YXJpYW50czogW10gfSldO1xuICAgICAgICBpZiAobWF0Y2hfMykge1xuICAgICAgICAgICAgdmFyIHBhcnRzXzMgPSBpbnRsX2dldGNhbm9uaWNhbGxvY2FsZXNfMS5wYXJzZVVuaWNvZGVMYW5ndWFnZUlkKG1hdGNoXzMpO1xuICAgICAgICAgICAgYXN0LmxhbmcgPSBtZXJnZVVuaWNvZGVMYW5ndWFnZUlkKHVuZGVmaW5lZCwgc2NyaXB0LCB1bmRlZmluZWQsIHZhcmlhbnRzLCBwYXJ0c18zKTtcbiAgICAgICAgICAgIHJldHVybiBpbnRsX2dldGNhbm9uaWNhbGxvY2FsZXNfMS5lbWl0VW5pY29kZUxvY2FsZUlkKGFzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIG1hdGNoID0gbGlrZWx5U3VidGFnc1tsYW5nXSB8fFxuICAgICAgICBsaWtlbHlTdWJ0YWdzW2ludGxfZ2V0Y2Fub25pY2FsbG9jYWxlc18xLmVtaXRVbmljb2RlTGFuZ3VhZ2VJZCh7IGxhbmc6ICd1bmQnLCBzY3JpcHQ6IHNjcmlwdCwgdmFyaWFudHM6IFtdIH0pXTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG1hdGNoIGZvciBhZGRMaWtlbHlTdWJ0YWdzXCIpO1xuICAgIH1cbiAgICB2YXIgcGFydHMgPSBpbnRsX2dldGNhbm9uaWNhbGxvY2FsZXNfMS5wYXJzZVVuaWNvZGVMYW5ndWFnZUlkKG1hdGNoKTtcbiAgICBhc3QubGFuZyA9IG1lcmdlVW5pY29kZUxhbmd1YWdlSWQodW5kZWZpbmVkLCBzY3JpcHQsIHJlZ2lvbiwgdmFyaWFudHMsIHBhcnRzKTtcbiAgICByZXR1cm4gaW50bF9nZXRjYW5vbmljYWxsb2NhbGVzXzEuZW1pdFVuaWNvZGVMb2NhbGVJZChhc3QpO1xufVxuLyoqXG4gKiBGcm9tOiBodHRwczovL2dpdGh1Yi5jb20vdW5pY29kZS1vcmcvaWN1L2Jsb2IvNDIzMWNhNWJlMDUzYTIyYTFiZTI0ZWI4OTE4MTc0NThjOTdkYjcwOS9pY3U0ai9tYWluL2NsYXNzZXMvY29yZS9zcmMvY29tL2libS9pY3UvdXRpbC9VTG9jYWxlLmphdmEjTDIzOTVcbiAqIEBwYXJhbSB0YWdcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlTGlrZWx5U3VidGFncyh0YWcpIHtcbiAgICB2YXIgbWF4TG9jYWxlID0gYWRkTGlrZWx5U3VidGFncyh0YWcpO1xuICAgIGlmICghbWF4TG9jYWxlKSB7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIG1heExvY2FsZSA9IGludGxfZ2V0Y2Fub25pY2FsbG9jYWxlc18xLmVtaXRVbmljb2RlTGFuZ3VhZ2VJZCh0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24oe30sIGludGxfZ2V0Y2Fub25pY2FsbG9jYWxlc18xLnBhcnNlVW5pY29kZUxhbmd1YWdlSWQobWF4TG9jYWxlKSksIHsgdmFyaWFudHM6IFtdIH0pKTtcbiAgICB2YXIgYXN0ID0gaW50bF9nZXRjYW5vbmljYWxsb2NhbGVzXzEucGFyc2VVbmljb2RlTG9jYWxlSWQodGFnKTtcbiAgICB2YXIgX2EgPSBhc3QubGFuZywgbGFuZyA9IF9hLmxhbmcsIHNjcmlwdCA9IF9hLnNjcmlwdCwgcmVnaW9uID0gX2EucmVnaW9uLCB2YXJpYW50cyA9IF9hLnZhcmlhbnRzO1xuICAgIHZhciB0cmlhbCA9IGFkZExpa2VseVN1YnRhZ3MoaW50bF9nZXRjYW5vbmljYWxsb2NhbGVzXzEuZW1pdFVuaWNvZGVMYW5ndWFnZUlkKHsgbGFuZzogbGFuZywgdmFyaWFudHM6IFtdIH0pKTtcbiAgICBpZiAodHJpYWwgPT09IG1heExvY2FsZSkge1xuICAgICAgICByZXR1cm4gaW50bF9nZXRjYW5vbmljYWxsb2NhbGVzXzEuZW1pdFVuaWNvZGVMb2NhbGVJZCh0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24oe30sIGFzdCksIHsgbGFuZzogbWVyZ2VVbmljb2RlTGFuZ3VhZ2VJZChsYW5nLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdmFyaWFudHMpIH0pKTtcbiAgICB9XG4gICAgaWYgKHJlZ2lvbikge1xuICAgICAgICB2YXIgdHJpYWxfMSA9IGFkZExpa2VseVN1YnRhZ3MoaW50bF9nZXRjYW5vbmljYWxsb2NhbGVzXzEuZW1pdFVuaWNvZGVMYW5ndWFnZUlkKHsgbGFuZzogbGFuZywgcmVnaW9uOiByZWdpb24sIHZhcmlhbnRzOiBbXSB9KSk7XG4gICAgICAgIGlmICh0cmlhbF8xID09PSBtYXhMb2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRsX2dldGNhbm9uaWNhbGxvY2FsZXNfMS5lbWl0VW5pY29kZUxvY2FsZUlkKHRzbGliXzEuX19hc3NpZ24odHNsaWJfMS5fX2Fzc2lnbih7fSwgYXN0KSwgeyBsYW5nOiBtZXJnZVVuaWNvZGVMYW5ndWFnZUlkKGxhbmcsIHVuZGVmaW5lZCwgcmVnaW9uLCB2YXJpYW50cykgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzY3JpcHQpIHtcbiAgICAgICAgdmFyIHRyaWFsXzIgPSBhZGRMaWtlbHlTdWJ0YWdzKGludGxfZ2V0Y2Fub25pY2FsbG9jYWxlc18xLmVtaXRVbmljb2RlTGFuZ3VhZ2VJZCh7IGxhbmc6IGxhbmcsIHNjcmlwdDogc2NyaXB0LCB2YXJpYW50czogW10gfSkpO1xuICAgICAgICBpZiAodHJpYWxfMiA9PT0gbWF4TG9jYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50bF9nZXRjYW5vbmljYWxsb2NhbGVzXzEuZW1pdFVuaWNvZGVMb2NhbGVJZCh0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24oe30sIGFzdCksIHsgbGFuZzogbWVyZ2VVbmljb2RlTGFuZ3VhZ2VJZChsYW5nLCBzY3JpcHQsIHVuZGVmaW5lZCwgdmFyaWFudHMpIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFnO1xufVxudmFyIExvY2FsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb2NhbGUodGFnLCBvcHRzKSB7XG4gICAgICAgIC8vIHRlc3QyNjIvdGVzdC9pbnRsNDAyL1JlbGF0aXZlVGltZUZvcm1hdC9jb25zdHJ1Y3Rvci9jb25zdHJ1Y3Rvci9uZXd0YXJnZXQtdW5kZWZpbmVkLmpzXG4gICAgICAgIC8vIENhbm5vdCB1c2UgYG5ldy50YXJnZXRgIGJjIG9mIElFMTEgJiBUUyB0cmFuc3BpbGVzIGl0IHRvIHNvbWV0aGluZyBlbHNlXG4gICAgICAgIHZhciBuZXdUYXJnZXQgPSB0aGlzICYmIHRoaXMgaW5zdGFuY2VvZiBMb2NhbGUgPyB0aGlzLmNvbnN0cnVjdG9yIDogdm9pZCAwO1xuICAgICAgICBpZiAoIW5ld1RhcmdldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludGwuTG9jYWxlIG11c3QgYmUgY2FsbGVkIHdpdGggJ25ldydcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbGV2YW50RXh0ZW5zaW9uS2V5cyA9IExvY2FsZS5yZWxldmFudEV4dGVuc2lvbktleXM7XG4gICAgICAgIHZhciBpbnRlcm5hbFNsb3RzTGlzdCA9IFtcbiAgICAgICAgICAgICdpbml0aWFsaXplZExvY2FsZScsXG4gICAgICAgICAgICAnbG9jYWxlJyxcbiAgICAgICAgICAgICdjYWxlbmRhcicsXG4gICAgICAgICAgICAnY29sbGF0aW9uJyxcbiAgICAgICAgICAgICdob3VyQ3ljbGUnLFxuICAgICAgICAgICAgJ251bWJlcmluZ1N5c3RlbScsXG4gICAgICAgIF07XG4gICAgICAgIGlmIChyZWxldmFudEV4dGVuc2lvbktleXMuaW5kZXhPZigna2YnKSA+IC0xKSB7XG4gICAgICAgICAgICBpbnRlcm5hbFNsb3RzTGlzdC5wdXNoKCdjYXNlRmlyc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVsZXZhbnRFeHRlbnNpb25LZXlzLmluZGV4T2YoJ2tuJykgPiAtMSkge1xuICAgICAgICAgICAgaW50ZXJuYWxTbG90c0xpc3QucHVzaCgnbnVtZXJpYycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpcnN0IGFyZ3VtZW50IHRvIEludGwuTG9jYWxlIGNvbnN0cnVjdG9yIGNhbid0IGJlIGVtcHR5IG9yIG1pc3NpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0YWcgIT09ICdzdHJpbmcnICYmIHR5cGVvZiB0YWcgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0YWcgbXVzdCBiZSBhIHN0cmluZyBvciBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW50ZXJuYWxTbG90cztcbiAgICAgICAgaWYgKHR5cGVvZiB0YWcgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAoaW50ZXJuYWxTbG90cyA9IGdldF9pbnRlcm5hbF9zbG90c18xLmRlZmF1bHQodGFnKSkgJiZcbiAgICAgICAgICAgIGludGVybmFsU2xvdHMuaW5pdGlhbGl6ZWRMb2NhbGUpIHtcbiAgICAgICAgICAgIHRhZyA9IGludGVybmFsU2xvdHMubG9jYWxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFnID0gdGFnLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaW50ZXJuYWxTbG90cyA9IGdldF9pbnRlcm5hbF9zbG90c18xLmRlZmF1bHQodGhpcyk7XG4gICAgICAgIHZhciBvcHRpb25zO1xuICAgICAgICBpZiAob3B0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBlY21hNDAyX2Fic3RyYWN0XzEuVG9PYmplY3Qob3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGFnID0gYXBwbHlPcHRpb25zVG9UYWcodGFnLCBvcHRpb25zKTtcbiAgICAgICAgdmFyIG9wdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHZhciBjYWxlbmRhciA9IGVjbWE0MDJfYWJzdHJhY3RfMS5HZXRPcHRpb24ob3B0aW9ucywgJ2NhbGVuZGFyJywgJ3N0cmluZycsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKGNhbGVuZGFyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghVU5JQ09ERV9UWVBFX1JFR0VYLnRlc3QoY2FsZW5kYXIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2ludmFsaWQgY2FsZW5kYXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvcHQuY2EgPSBjYWxlbmRhcjtcbiAgICAgICAgdmFyIGNvbGxhdGlvbiA9IGVjbWE0MDJfYWJzdHJhY3RfMS5HZXRPcHRpb24ob3B0aW9ucywgJ2NvbGxhdGlvbicsICdzdHJpbmcnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChjb2xsYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFVTklDT0RFX1RZUEVfUkVHRVgudGVzdChjb2xsYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2ludmFsaWQgY29sbGF0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3B0LmNvID0gY29sbGF0aW9uO1xuICAgICAgICB2YXIgaGMgPSBlY21hNDAyX2Fic3RyYWN0XzEuR2V0T3B0aW9uKG9wdGlvbnMsICdob3VyQ3ljbGUnLCAnc3RyaW5nJywgWydoMTEnLCAnaDEyJywgJ2gyMycsICdoMjQnXSwgdW5kZWZpbmVkKTtcbiAgICAgICAgb3B0LmhjID0gaGM7XG4gICAgICAgIHZhciBrZiA9IGVjbWE0MDJfYWJzdHJhY3RfMS5HZXRPcHRpb24ob3B0aW9ucywgJ2Nhc2VGaXJzdCcsICdzdHJpbmcnLCBbJ3VwcGVyJywgJ2xvd2VyJywgJ2ZhbHNlJ10sIHVuZGVmaW5lZCk7XG4gICAgICAgIG9wdC5rZiA9IGtmO1xuICAgICAgICB2YXIgX2tuID0gZWNtYTQwMl9hYnN0cmFjdF8xLkdldE9wdGlvbihvcHRpb25zLCAnbnVtZXJpYycsICdib29sZWFuJywgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgICAgICB2YXIga247XG4gICAgICAgIGlmIChfa24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAga24gPSBTdHJpbmcoX2tuKTtcbiAgICAgICAgfVxuICAgICAgICBvcHQua24gPSBrbjtcbiAgICAgICAgdmFyIG51bWJlcmluZ1N5c3RlbSA9IGVjbWE0MDJfYWJzdHJhY3RfMS5HZXRPcHRpb24ob3B0aW9ucywgJ251bWJlcmluZ1N5c3RlbScsICdzdHJpbmcnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChudW1iZXJpbmdTeXN0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFVTklDT0RFX1RZUEVfUkVHRVgudGVzdChudW1iZXJpbmdTeXN0ZW0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgbnVtYmVyaW5nU3lzdGVtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3B0Lm51ID0gbnVtYmVyaW5nU3lzdGVtO1xuICAgICAgICB2YXIgciA9IGFwcGx5VW5pY29kZUV4dGVuc2lvblRvVGFnKHRhZywgb3B0LCByZWxldmFudEV4dGVuc2lvbktleXMpO1xuICAgICAgICBpbnRlcm5hbFNsb3RzLmxvY2FsZSA9IHIubG9jYWxlO1xuICAgICAgICBpbnRlcm5hbFNsb3RzLmNhbGVuZGFyID0gci5jYTtcbiAgICAgICAgaW50ZXJuYWxTbG90cy5jb2xsYXRpb24gPSByLmNvO1xuICAgICAgICBpbnRlcm5hbFNsb3RzLmhvdXJDeWNsZSA9IHIuaGM7XG4gICAgICAgIGlmIChyZWxldmFudEV4dGVuc2lvbktleXMuaW5kZXhPZigna2YnKSA+IC0xKSB7XG4gICAgICAgICAgICBpbnRlcm5hbFNsb3RzLmNhc2VGaXJzdCA9IHIua2Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbGV2YW50RXh0ZW5zaW9uS2V5cy5pbmRleE9mKCdrbicpID4gLTEpIHtcbiAgICAgICAgICAgIGludGVybmFsU2xvdHMubnVtZXJpYyA9IGVjbWE0MDJfYWJzdHJhY3RfMS5TYW1lVmFsdWUoci5rbiwgJ3RydWUnKTtcbiAgICAgICAgfVxuICAgICAgICBpbnRlcm5hbFNsb3RzLm51bWJlcmluZ1N5c3RlbSA9IHIubnU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS8jTGlrZWx5X1N1YnRhZ3NcbiAgICAgKi9cbiAgICBMb2NhbGUucHJvdG90eXBlLm1heGltaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0X2ludGVybmFsX3Nsb3RzXzEuZGVmYXVsdCh0aGlzKS5sb2NhbGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgbWF4aW1pemVkTG9jYWxlID0gYWRkTGlrZWx5U3VidGFncyhsb2NhbGUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2NhbGUobWF4aW1pemVkTG9jYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2NhbGUobG9jYWxlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1LyNMaWtlbHlfU3VidGFnc1xuICAgICAqL1xuICAgIExvY2FsZS5wcm90b3R5cGUubWluaW1pemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRfaW50ZXJuYWxfc2xvdHNfMS5kZWZhdWx0KHRoaXMpLmxvY2FsZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBtaW5pbWl6ZWRMb2NhbGUgPSByZW1vdmVMaWtlbHlTdWJ0YWdzKGxvY2FsZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExvY2FsZShtaW5pbWl6ZWRMb2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExvY2FsZShsb2NhbGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMb2NhbGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZ2V0X2ludGVybmFsX3Nsb3RzXzEuZGVmYXVsdCh0aGlzKS5sb2NhbGU7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9jYWxlLnByb3RvdHlwZSwgXCJiYXNlTmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxvY2FsZSA9IGdldF9pbnRlcm5hbF9zbG90c18xLmRlZmF1bHQodGhpcykubG9jYWxlO1xuICAgICAgICAgICAgcmV0dXJuIGludGxfZ2V0Y2Fub25pY2FsbG9jYWxlc18xLmVtaXRVbmljb2RlTGFuZ3VhZ2VJZChpbnRsX2dldGNhbm9uaWNhbGxvY2FsZXNfMS5wYXJzZVVuaWNvZGVMYW5ndWFnZUlkKGxvY2FsZSkpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvY2FsZS5wcm90b3R5cGUsIFwiY2FsZW5kYXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRfaW50ZXJuYWxfc2xvdHNfMS5kZWZhdWx0KHRoaXMpLmNhbGVuZGFyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvY2FsZS5wcm90b3R5cGUsIFwiY29sbGF0aW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0X2ludGVybmFsX3Nsb3RzXzEuZGVmYXVsdCh0aGlzKS5jb2xsYXRpb247XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9jYWxlLnByb3RvdHlwZSwgXCJob3VyQ3ljbGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRfaW50ZXJuYWxfc2xvdHNfMS5kZWZhdWx0KHRoaXMpLmhvdXJDeWNsZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2NhbGUucHJvdG90eXBlLCBcImNhc2VGaXJzdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldF9pbnRlcm5hbF9zbG90c18xLmRlZmF1bHQodGhpcykuY2FzZUZpcnN0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvY2FsZS5wcm90b3R5cGUsIFwibnVtZXJpY1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldF9pbnRlcm5hbF9zbG90c18xLmRlZmF1bHQodGhpcykubnVtZXJpYztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2NhbGUucHJvdG90eXBlLCBcIm51bWJlcmluZ1N5c3RlbVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldF9pbnRlcm5hbF9zbG90c18xLmRlZmF1bHQodGhpcykubnVtYmVyaW5nU3lzdGVtO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvY2FsZS5wcm90b3R5cGUsIFwibGFuZ3VhZ2VcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogaHR0cHM6Ly90YzM5LmVzL3Byb3Bvc2FsLWludGwtbG9jYWxlLyNzZWMtSW50bC5Mb2NhbGUucHJvdG90eXBlLmxhbmd1YWdlXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUgPSBnZXRfaW50ZXJuYWxfc2xvdHNfMS5kZWZhdWx0KHRoaXMpLmxvY2FsZTtcbiAgICAgICAgICAgIHJldHVybiBpbnRsX2dldGNhbm9uaWNhbGxvY2FsZXNfMS5wYXJzZVVuaWNvZGVMYW5ndWFnZUlkKGxvY2FsZSkubGFuZztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2NhbGUucHJvdG90eXBlLCBcInNjcmlwdFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBodHRwczovL3RjMzkuZXMvcHJvcG9zYWwtaW50bC1sb2NhbGUvI3NlYy1JbnRsLkxvY2FsZS5wcm90b3R5cGUuc2NyaXB0XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUgPSBnZXRfaW50ZXJuYWxfc2xvdHNfMS5kZWZhdWx0KHRoaXMpLmxvY2FsZTtcbiAgICAgICAgICAgIHJldHVybiBpbnRsX2dldGNhbm9uaWNhbGxvY2FsZXNfMS5wYXJzZVVuaWNvZGVMYW5ndWFnZUlkKGxvY2FsZSkuc2NyaXB0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvY2FsZS5wcm90b3R5cGUsIFwicmVnaW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGh0dHBzOi8vdGMzOS5lcy9wcm9wb3NhbC1pbnRsLWxvY2FsZS8jc2VjLUludGwuTG9jYWxlLnByb3RvdHlwZS5yZWdpb25cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxvY2FsZSA9IGdldF9pbnRlcm5hbF9zbG90c18xLmRlZmF1bHQodGhpcykubG9jYWxlO1xuICAgICAgICAgICAgcmV0dXJuIGludGxfZ2V0Y2Fub25pY2FsbG9jYWxlc18xLnBhcnNlVW5pY29kZUxhbmd1YWdlSWQobG9jYWxlKS5yZWdpb247XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBMb2NhbGUucmVsZXZhbnRFeHRlbnNpb25LZXlzID0gUkVMRVZBTlRfRVhURU5TSU9OX0tFWVM7XG4gICAgcmV0dXJuIExvY2FsZTtcbn0oKSk7XG5leHBvcnRzLkxvY2FsZSA9IExvY2FsZTtcbnRyeSB7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2NhbGUucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgICAgIHZhbHVlOiAnSW50bC5Mb2NhbGUnLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9jYWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciwgJ2xlbmd0aCcsIHtcbiAgICAgICAgdmFsdWU6IDEsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB9KTtcbn1cbmNhdGNoIChlKSB7XG4gICAgLy8gTWV0YSBmaXggc28gd2UncmUgdGVzdDI2Mi1jb21wbGlhbnQsIG5vdCBpbXBvcnRhbnRcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IExvY2FsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF8xID0gcmVxdWlyZShcIi4vXCIpO1xudmFyIHNob3VsZF9wb2x5ZmlsbF8xID0gcmVxdWlyZShcIi4vc2hvdWxkLXBvbHlmaWxsXCIpO1xuaWYgKHNob3VsZF9wb2x5ZmlsbF8xLnNob3VsZFBvbHlmaWxsKCkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW50bCwgJ0xvY2FsZScsIHtcbiAgICAgICAgdmFsdWU6IF8xLkxvY2FsZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgfSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hvdWxkUG9seWZpbGwgPSB2b2lkIDA7XG4vKipcbiAqIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTEwNjgyXG4gKi9cbmZ1bmN0aW9uIGhhc0ludGxHZXRDYW5vbmljYWxMb2NhbGVzQnVnKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50bC5Mb2NhbGUoJ3VuZC14LXByaXZhdGUnKS50b1N0cmluZygpID09PSAneC1wcml2YXRlJztcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gc2hvdWxkUG9seWZpbGwoKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgSW50bCA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgISgnTG9jYWxlJyBpbiBJbnRsKSB8fFxuICAgICAgICBoYXNJbnRsR2V0Q2Fub25pY2FsTG9jYWxlc0J1ZygpKTtcbn1cbmV4cG9ydHMuc2hvdWxkUG9seWZpbGwgPSBzaG91bGRQb2x5ZmlsbDtcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJzdXBwbGVtZW50YWxcIjoge1xuICAgIFwidmVyc2lvblwiOiB7XG4gICAgICBcIl91bmljb2RlVmVyc2lvblwiOiBcIjEzLjAuMFwiLFxuICAgICAgXCJfY2xkclZlcnNpb25cIjogXCIzOFwiXG4gICAgfSxcbiAgICBcImxpa2VseVN1YnRhZ3NcIjoge1xuICAgICAgXCJhYVwiOiBcImFhLUxhdG4tRVRcIixcbiAgICAgIFwiYWFpXCI6IFwiYWFpLUxhdG4tWlpcIixcbiAgICAgIFwiYWFrXCI6IFwiYWFrLUxhdG4tWlpcIixcbiAgICAgIFwiYWF1XCI6IFwiYWF1LUxhdG4tWlpcIixcbiAgICAgIFwiYWJcIjogXCJhYi1DeXJsLUdFXCIsXG4gICAgICBcImFiaVwiOiBcImFiaS1MYXRuLVpaXCIsXG4gICAgICBcImFicVwiOiBcImFicS1DeXJsLVpaXCIsXG4gICAgICBcImFiclwiOiBcImFici1MYXRuLUdIXCIsXG4gICAgICBcImFidFwiOiBcImFidC1MYXRuLVpaXCIsXG4gICAgICBcImFieVwiOiBcImFieS1MYXRuLVpaXCIsXG4gICAgICBcImFjZFwiOiBcImFjZC1MYXRuLVpaXCIsXG4gICAgICBcImFjZVwiOiBcImFjZS1MYXRuLUlEXCIsXG4gICAgICBcImFjaFwiOiBcImFjaC1MYXRuLVVHXCIsXG4gICAgICBcImFkYVwiOiBcImFkYS1MYXRuLUdIXCIsXG4gICAgICBcImFkZVwiOiBcImFkZS1MYXRuLVpaXCIsXG4gICAgICBcImFkalwiOiBcImFkai1MYXRuLVpaXCIsXG4gICAgICBcImFkcFwiOiBcImFkcC1UaWJ0LUJUXCIsXG4gICAgICBcImFkeVwiOiBcImFkeS1DeXJsLVJVXCIsXG4gICAgICBcImFkelwiOiBcImFkei1MYXRuLVpaXCIsXG4gICAgICBcImFlXCI6IFwiYWUtQXZzdC1JUlwiLFxuICAgICAgXCJhZWJcIjogXCJhZWItQXJhYi1UTlwiLFxuICAgICAgXCJhZXlcIjogXCJhZXktTGF0bi1aWlwiLFxuICAgICAgXCJhZlwiOiBcImFmLUxhdG4tWkFcIixcbiAgICAgIFwiYWdjXCI6IFwiYWdjLUxhdG4tWlpcIixcbiAgICAgIFwiYWdkXCI6IFwiYWdkLUxhdG4tWlpcIixcbiAgICAgIFwiYWdnXCI6IFwiYWdnLUxhdG4tWlpcIixcbiAgICAgIFwiYWdtXCI6IFwiYWdtLUxhdG4tWlpcIixcbiAgICAgIFwiYWdvXCI6IFwiYWdvLUxhdG4tWlpcIixcbiAgICAgIFwiYWdxXCI6IFwiYWdxLUxhdG4tQ01cIixcbiAgICAgIFwiYWhhXCI6IFwiYWhhLUxhdG4tWlpcIixcbiAgICAgIFwiYWhsXCI6IFwiYWhsLUxhdG4tWlpcIixcbiAgICAgIFwiYWhvXCI6IFwiYWhvLUFob20tSU5cIixcbiAgICAgIFwiYWpnXCI6IFwiYWpnLUxhdG4tWlpcIixcbiAgICAgIFwiYWtcIjogXCJhay1MYXRuLUdIXCIsXG4gICAgICBcImFra1wiOiBcImFray1Yc3V4LUlRXCIsXG4gICAgICBcImFsYVwiOiBcImFsYS1MYXRuLVpaXCIsXG4gICAgICBcImFsaVwiOiBcImFsaS1MYXRuLVpaXCIsXG4gICAgICBcImFsblwiOiBcImFsbi1MYXRuLVhLXCIsXG4gICAgICBcImFsdFwiOiBcImFsdC1DeXJsLVJVXCIsXG4gICAgICBcImFtXCI6IFwiYW0tRXRoaS1FVFwiLFxuICAgICAgXCJhbW1cIjogXCJhbW0tTGF0bi1aWlwiLFxuICAgICAgXCJhbW5cIjogXCJhbW4tTGF0bi1aWlwiLFxuICAgICAgXCJhbW9cIjogXCJhbW8tTGF0bi1OR1wiLFxuICAgICAgXCJhbXBcIjogXCJhbXAtTGF0bi1aWlwiLFxuICAgICAgXCJhblwiOiBcImFuLUxhdG4tRVNcIixcbiAgICAgIFwiYW5jXCI6IFwiYW5jLUxhdG4tWlpcIixcbiAgICAgIFwiYW5rXCI6IFwiYW5rLUxhdG4tWlpcIixcbiAgICAgIFwiYW5uXCI6IFwiYW5uLUxhdG4tWlpcIixcbiAgICAgIFwiYW55XCI6IFwiYW55LUxhdG4tWlpcIixcbiAgICAgIFwiYW9qXCI6IFwiYW9qLUxhdG4tWlpcIixcbiAgICAgIFwiYW9tXCI6IFwiYW9tLUxhdG4tWlpcIixcbiAgICAgIFwiYW96XCI6IFwiYW96LUxhdG4tSURcIixcbiAgICAgIFwiYXBjXCI6IFwiYXBjLUFyYWItWlpcIixcbiAgICAgIFwiYXBkXCI6IFwiYXBkLUFyYWItVEdcIixcbiAgICAgIFwiYXBlXCI6IFwiYXBlLUxhdG4tWlpcIixcbiAgICAgIFwiYXByXCI6IFwiYXByLUxhdG4tWlpcIixcbiAgICAgIFwiYXBzXCI6IFwiYXBzLUxhdG4tWlpcIixcbiAgICAgIFwiYXB6XCI6IFwiYXB6LUxhdG4tWlpcIixcbiAgICAgIFwiYXJcIjogXCJhci1BcmFiLUVHXCIsXG4gICAgICBcImFyY1wiOiBcImFyYy1Bcm1pLUlSXCIsXG4gICAgICBcImFyYy1OYmF0XCI6IFwiYXJjLU5iYXQtSk9cIixcbiAgICAgIFwiYXJjLVBhbG1cIjogXCJhcmMtUGFsbS1TWVwiLFxuICAgICAgXCJhcmhcIjogXCJhcmgtTGF0bi1aWlwiLFxuICAgICAgXCJhcm5cIjogXCJhcm4tTGF0bi1DTFwiLFxuICAgICAgXCJhcm9cIjogXCJhcm8tTGF0bi1CT1wiLFxuICAgICAgXCJhcnFcIjogXCJhcnEtQXJhYi1EWlwiLFxuICAgICAgXCJhcnNcIjogXCJhcnMtQXJhYi1TQVwiLFxuICAgICAgXCJhcnlcIjogXCJhcnktQXJhYi1NQVwiLFxuICAgICAgXCJhcnpcIjogXCJhcnotQXJhYi1FR1wiLFxuICAgICAgXCJhc1wiOiBcImFzLUJlbmctSU5cIixcbiAgICAgIFwiYXNhXCI6IFwiYXNhLUxhdG4tVFpcIixcbiAgICAgIFwiYXNlXCI6IFwiYXNlLVNnbnctVVNcIixcbiAgICAgIFwiYXNnXCI6IFwiYXNnLUxhdG4tWlpcIixcbiAgICAgIFwiYXNvXCI6IFwiYXNvLUxhdG4tWlpcIixcbiAgICAgIFwiYXN0XCI6IFwiYXN0LUxhdG4tRVNcIixcbiAgICAgIFwiYXRhXCI6IFwiYXRhLUxhdG4tWlpcIixcbiAgICAgIFwiYXRnXCI6IFwiYXRnLUxhdG4tWlpcIixcbiAgICAgIFwiYXRqXCI6IFwiYXRqLUxhdG4tQ0FcIixcbiAgICAgIFwiYXV5XCI6IFwiYXV5LUxhdG4tWlpcIixcbiAgICAgIFwiYXZcIjogXCJhdi1DeXJsLVJVXCIsXG4gICAgICBcImF2bFwiOiBcImF2bC1BcmFiLVpaXCIsXG4gICAgICBcImF2blwiOiBcImF2bi1MYXRuLVpaXCIsXG4gICAgICBcImF2dFwiOiBcImF2dC1MYXRuLVpaXCIsXG4gICAgICBcImF2dVwiOiBcImF2dS1MYXRuLVpaXCIsXG4gICAgICBcImF3YVwiOiBcImF3YS1EZXZhLUlOXCIsXG4gICAgICBcImF3YlwiOiBcImF3Yi1MYXRuLVpaXCIsXG4gICAgICBcImF3b1wiOiBcImF3by1MYXRuLVpaXCIsXG4gICAgICBcImF3eFwiOiBcImF3eC1MYXRuLVpaXCIsXG4gICAgICBcImF5XCI6IFwiYXktTGF0bi1CT1wiLFxuICAgICAgXCJheWJcIjogXCJheWItTGF0bi1aWlwiLFxuICAgICAgXCJhelwiOiBcImF6LUxhdG4tQVpcIixcbiAgICAgIFwiYXotQXJhYlwiOiBcImF6LUFyYWItSVJcIixcbiAgICAgIFwiYXotSVFcIjogXCJhei1BcmFiLUlRXCIsXG4gICAgICBcImF6LUlSXCI6IFwiYXotQXJhYi1JUlwiLFxuICAgICAgXCJhei1SVVwiOiBcImF6LUN5cmwtUlVcIixcbiAgICAgIFwiYmFcIjogXCJiYS1DeXJsLVJVXCIsXG4gICAgICBcImJhbFwiOiBcImJhbC1BcmFiLVBLXCIsXG4gICAgICBcImJhblwiOiBcImJhbi1MYXRuLUlEXCIsXG4gICAgICBcImJhcFwiOiBcImJhcC1EZXZhLU5QXCIsXG4gICAgICBcImJhclwiOiBcImJhci1MYXRuLUFUXCIsXG4gICAgICBcImJhc1wiOiBcImJhcy1MYXRuLUNNXCIsXG4gICAgICBcImJhdlwiOiBcImJhdi1MYXRuLVpaXCIsXG4gICAgICBcImJheFwiOiBcImJheC1CYW11LUNNXCIsXG4gICAgICBcImJiYVwiOiBcImJiYS1MYXRuLVpaXCIsXG4gICAgICBcImJiYlwiOiBcImJiYi1MYXRuLVpaXCIsXG4gICAgICBcImJiY1wiOiBcImJiYy1MYXRuLUlEXCIsXG4gICAgICBcImJiZFwiOiBcImJiZC1MYXRuLVpaXCIsXG4gICAgICBcImJialwiOiBcImJiai1MYXRuLUNNXCIsXG4gICAgICBcImJicFwiOiBcImJicC1MYXRuLVpaXCIsXG4gICAgICBcImJiclwiOiBcImJici1MYXRuLVpaXCIsXG4gICAgICBcImJjZlwiOiBcImJjZi1MYXRuLVpaXCIsXG4gICAgICBcImJjaFwiOiBcImJjaC1MYXRuLVpaXCIsXG4gICAgICBcImJjaVwiOiBcImJjaS1MYXRuLUNJXCIsXG4gICAgICBcImJjbVwiOiBcImJjbS1MYXRuLVpaXCIsXG4gICAgICBcImJjblwiOiBcImJjbi1MYXRuLVpaXCIsXG4gICAgICBcImJjb1wiOiBcImJjby1MYXRuLVpaXCIsXG4gICAgICBcImJjcVwiOiBcImJjcS1FdGhpLVpaXCIsXG4gICAgICBcImJjdVwiOiBcImJjdS1MYXRuLVpaXCIsXG4gICAgICBcImJkZFwiOiBcImJkZC1MYXRuLVpaXCIsXG4gICAgICBcImJlXCI6IFwiYmUtQ3lybC1CWVwiLFxuICAgICAgXCJiZWZcIjogXCJiZWYtTGF0bi1aWlwiLFxuICAgICAgXCJiZWhcIjogXCJiZWgtTGF0bi1aWlwiLFxuICAgICAgXCJiZWpcIjogXCJiZWotQXJhYi1TRFwiLFxuICAgICAgXCJiZW1cIjogXCJiZW0tTGF0bi1aTVwiLFxuICAgICAgXCJiZXRcIjogXCJiZXQtTGF0bi1aWlwiLFxuICAgICAgXCJiZXdcIjogXCJiZXctTGF0bi1JRFwiLFxuICAgICAgXCJiZXhcIjogXCJiZXgtTGF0bi1aWlwiLFxuICAgICAgXCJiZXpcIjogXCJiZXotTGF0bi1UWlwiLFxuICAgICAgXCJiZmRcIjogXCJiZmQtTGF0bi1DTVwiLFxuICAgICAgXCJiZnFcIjogXCJiZnEtVGFtbC1JTlwiLFxuICAgICAgXCJiZnRcIjogXCJiZnQtQXJhYi1QS1wiLFxuICAgICAgXCJiZnlcIjogXCJiZnktRGV2YS1JTlwiLFxuICAgICAgXCJiZ1wiOiBcImJnLUN5cmwtQkdcIixcbiAgICAgIFwiYmdjXCI6IFwiYmdjLURldmEtSU5cIixcbiAgICAgIFwiYmduXCI6IFwiYmduLUFyYWItUEtcIixcbiAgICAgIFwiYmd4XCI6IFwiYmd4LUdyZWstVFJcIixcbiAgICAgIFwiYmhiXCI6IFwiYmhiLURldmEtSU5cIixcbiAgICAgIFwiYmhnXCI6IFwiYmhnLUxhdG4tWlpcIixcbiAgICAgIFwiYmhpXCI6IFwiYmhpLURldmEtSU5cIixcbiAgICAgIFwiYmhsXCI6IFwiYmhsLUxhdG4tWlpcIixcbiAgICAgIFwiYmhvXCI6IFwiYmhvLURldmEtSU5cIixcbiAgICAgIFwiYmh5XCI6IFwiYmh5LUxhdG4tWlpcIixcbiAgICAgIFwiYmlcIjogXCJiaS1MYXRuLVZVXCIsXG4gICAgICBcImJpYlwiOiBcImJpYi1MYXRuLVpaXCIsXG4gICAgICBcImJpZ1wiOiBcImJpZy1MYXRuLVpaXCIsXG4gICAgICBcImJpa1wiOiBcImJpay1MYXRuLVBIXCIsXG4gICAgICBcImJpbVwiOiBcImJpbS1MYXRuLVpaXCIsXG4gICAgICBcImJpblwiOiBcImJpbi1MYXRuLU5HXCIsXG4gICAgICBcImJpb1wiOiBcImJpby1MYXRuLVpaXCIsXG4gICAgICBcImJpcVwiOiBcImJpcS1MYXRuLVpaXCIsXG4gICAgICBcImJqaFwiOiBcImJqaC1MYXRuLVpaXCIsXG4gICAgICBcImJqaVwiOiBcImJqaS1FdGhpLVpaXCIsXG4gICAgICBcImJqalwiOiBcImJqai1EZXZhLUlOXCIsXG4gICAgICBcImJqblwiOiBcImJqbi1MYXRuLUlEXCIsXG4gICAgICBcImJqb1wiOiBcImJqby1MYXRuLVpaXCIsXG4gICAgICBcImJqclwiOiBcImJqci1MYXRuLVpaXCIsXG4gICAgICBcImJqdFwiOiBcImJqdC1MYXRuLVNOXCIsXG4gICAgICBcImJqelwiOiBcImJqei1MYXRuLVpaXCIsXG4gICAgICBcImJrY1wiOiBcImJrYy1MYXRuLVpaXCIsXG4gICAgICBcImJrbVwiOiBcImJrbS1MYXRuLUNNXCIsXG4gICAgICBcImJrcVwiOiBcImJrcS1MYXRuLVpaXCIsXG4gICAgICBcImJrdVwiOiBcImJrdS1MYXRuLVBIXCIsXG4gICAgICBcImJrdlwiOiBcImJrdi1MYXRuLVpaXCIsXG4gICAgICBcImJsdFwiOiBcImJsdC1UYXZ0LVZOXCIsXG4gICAgICBcImJtXCI6IFwiYm0tTGF0bi1NTFwiLFxuICAgICAgXCJibWhcIjogXCJibWgtTGF0bi1aWlwiLFxuICAgICAgXCJibWtcIjogXCJibWstTGF0bi1aWlwiLFxuICAgICAgXCJibXFcIjogXCJibXEtTGF0bi1NTFwiLFxuICAgICAgXCJibXVcIjogXCJibXUtTGF0bi1aWlwiLFxuICAgICAgXCJiblwiOiBcImJuLUJlbmctQkRcIixcbiAgICAgIFwiYm5nXCI6IFwiYm5nLUxhdG4tWlpcIixcbiAgICAgIFwiYm5tXCI6IFwiYm5tLUxhdG4tWlpcIixcbiAgICAgIFwiYm5wXCI6IFwiYm5wLUxhdG4tWlpcIixcbiAgICAgIFwiYm9cIjogXCJiby1UaWJ0LUNOXCIsXG4gICAgICBcImJvalwiOiBcImJvai1MYXRuLVpaXCIsXG4gICAgICBcImJvbVwiOiBcImJvbS1MYXRuLVpaXCIsXG4gICAgICBcImJvblwiOiBcImJvbi1MYXRuLVpaXCIsXG4gICAgICBcImJweVwiOiBcImJweS1CZW5nLUlOXCIsXG4gICAgICBcImJxY1wiOiBcImJxYy1MYXRuLVpaXCIsXG4gICAgICBcImJxaVwiOiBcImJxaS1BcmFiLUlSXCIsXG4gICAgICBcImJxcFwiOiBcImJxcC1MYXRuLVpaXCIsXG4gICAgICBcImJxdlwiOiBcImJxdi1MYXRuLUNJXCIsXG4gICAgICBcImJyXCI6IFwiYnItTGF0bi1GUlwiLFxuICAgICAgXCJicmFcIjogXCJicmEtRGV2YS1JTlwiLFxuICAgICAgXCJicmhcIjogXCJicmgtQXJhYi1QS1wiLFxuICAgICAgXCJicnhcIjogXCJicngtRGV2YS1JTlwiLFxuICAgICAgXCJicnpcIjogXCJicnotTGF0bi1aWlwiLFxuICAgICAgXCJic1wiOiBcImJzLUxhdG4tQkFcIixcbiAgICAgIFwiYnNqXCI6IFwiYnNqLUxhdG4tWlpcIixcbiAgICAgIFwiYnNxXCI6IFwiYnNxLUJhc3MtTFJcIixcbiAgICAgIFwiYnNzXCI6IFwiYnNzLUxhdG4tQ01cIixcbiAgICAgIFwiYnN0XCI6IFwiYnN0LUV0aGktWlpcIixcbiAgICAgIFwiYnRvXCI6IFwiYnRvLUxhdG4tUEhcIixcbiAgICAgIFwiYnR0XCI6IFwiYnR0LUxhdG4tWlpcIixcbiAgICAgIFwiYnR2XCI6IFwiYnR2LURldmEtUEtcIixcbiAgICAgIFwiYnVhXCI6IFwiYnVhLUN5cmwtUlVcIixcbiAgICAgIFwiYnVjXCI6IFwiYnVjLUxhdG4tWVRcIixcbiAgICAgIFwiYnVkXCI6IFwiYnVkLUxhdG4tWlpcIixcbiAgICAgIFwiYnVnXCI6IFwiYnVnLUxhdG4tSURcIixcbiAgICAgIFwiYnVrXCI6IFwiYnVrLUxhdG4tWlpcIixcbiAgICAgIFwiYnVtXCI6IFwiYnVtLUxhdG4tQ01cIixcbiAgICAgIFwiYnVvXCI6IFwiYnVvLUxhdG4tWlpcIixcbiAgICAgIFwiYnVzXCI6IFwiYnVzLUxhdG4tWlpcIixcbiAgICAgIFwiYnV1XCI6IFwiYnV1LUxhdG4tWlpcIixcbiAgICAgIFwiYnZiXCI6IFwiYnZiLUxhdG4tR1FcIixcbiAgICAgIFwiYndkXCI6IFwiYndkLUxhdG4tWlpcIixcbiAgICAgIFwiYndyXCI6IFwiYndyLUxhdG4tWlpcIixcbiAgICAgIFwiYnhoXCI6IFwiYnhoLUxhdG4tWlpcIixcbiAgICAgIFwiYnllXCI6IFwiYnllLUxhdG4tWlpcIixcbiAgICAgIFwiYnluXCI6IFwiYnluLUV0aGktRVJcIixcbiAgICAgIFwiYnlyXCI6IFwiYnlyLUxhdG4tWlpcIixcbiAgICAgIFwiYnlzXCI6IFwiYnlzLUxhdG4tWlpcIixcbiAgICAgIFwiYnl2XCI6IFwiYnl2LUxhdG4tQ01cIixcbiAgICAgIFwiYnl4XCI6IFwiYnl4LUxhdG4tWlpcIixcbiAgICAgIFwiYnphXCI6IFwiYnphLUxhdG4tWlpcIixcbiAgICAgIFwiYnplXCI6IFwiYnplLUxhdG4tTUxcIixcbiAgICAgIFwiYnpmXCI6IFwiYnpmLUxhdG4tWlpcIixcbiAgICAgIFwiYnpoXCI6IFwiYnpoLUxhdG4tWlpcIixcbiAgICAgIFwiYnp3XCI6IFwiYnp3LUxhdG4tWlpcIixcbiAgICAgIFwiY2FcIjogXCJjYS1MYXRuLUVTXCIsXG4gICAgICBcImNhZFwiOiBcImNhZC1MYXRuLVVTXCIsXG4gICAgICBcImNhblwiOiBcImNhbi1MYXRuLVpaXCIsXG4gICAgICBcImNialwiOiBcImNiai1MYXRuLVpaXCIsXG4gICAgICBcImNjaFwiOiBcImNjaC1MYXRuLU5HXCIsXG4gICAgICBcImNjcFwiOiBcImNjcC1DYWttLUJEXCIsXG4gICAgICBcImNlXCI6IFwiY2UtQ3lybC1SVVwiLFxuICAgICAgXCJjZWJcIjogXCJjZWItTGF0bi1QSFwiLFxuICAgICAgXCJjZmFcIjogXCJjZmEtTGF0bi1aWlwiLFxuICAgICAgXCJjZ2dcIjogXCJjZ2ctTGF0bi1VR1wiLFxuICAgICAgXCJjaFwiOiBcImNoLUxhdG4tR1VcIixcbiAgICAgIFwiY2hrXCI6IFwiY2hrLUxhdG4tRk1cIixcbiAgICAgIFwiY2htXCI6IFwiY2htLUN5cmwtUlVcIixcbiAgICAgIFwiY2hvXCI6IFwiY2hvLUxhdG4tVVNcIixcbiAgICAgIFwiY2hwXCI6IFwiY2hwLUxhdG4tQ0FcIixcbiAgICAgIFwiY2hyXCI6IFwiY2hyLUNoZXItVVNcIixcbiAgICAgIFwiY2ljXCI6IFwiY2ljLUxhdG4tVVNcIixcbiAgICAgIFwiY2phXCI6IFwiY2phLUFyYWItS0hcIixcbiAgICAgIFwiY2ptXCI6IFwiY2ptLUNoYW0tVk5cIixcbiAgICAgIFwiY2p2XCI6IFwiY2p2LUxhdG4tWlpcIixcbiAgICAgIFwiY2tiXCI6IFwiY2tiLUFyYWItSVFcIixcbiAgICAgIFwiY2tsXCI6IFwiY2tsLUxhdG4tWlpcIixcbiAgICAgIFwiY2tvXCI6IFwiY2tvLUxhdG4tWlpcIixcbiAgICAgIFwiY2t5XCI6IFwiY2t5LUxhdG4tWlpcIixcbiAgICAgIFwiY2xhXCI6IFwiY2xhLUxhdG4tWlpcIixcbiAgICAgIFwiY21lXCI6IFwiY21lLUxhdG4tWlpcIixcbiAgICAgIFwiY21nXCI6IFwiY21nLVNveW8tTU5cIixcbiAgICAgIFwiY29cIjogXCJjby1MYXRuLUZSXCIsXG4gICAgICBcImNvcFwiOiBcImNvcC1Db3B0LUVHXCIsXG4gICAgICBcImNwc1wiOiBcImNwcy1MYXRuLVBIXCIsXG4gICAgICBcImNyXCI6IFwiY3ItQ2Fucy1DQVwiLFxuICAgICAgXCJjcmhcIjogXCJjcmgtQ3lybC1VQVwiLFxuICAgICAgXCJjcmpcIjogXCJjcmotQ2Fucy1DQVwiLFxuICAgICAgXCJjcmtcIjogXCJjcmstQ2Fucy1DQVwiLFxuICAgICAgXCJjcmxcIjogXCJjcmwtQ2Fucy1DQVwiLFxuICAgICAgXCJjcm1cIjogXCJjcm0tQ2Fucy1DQVwiLFxuICAgICAgXCJjcnNcIjogXCJjcnMtTGF0bi1TQ1wiLFxuICAgICAgXCJjc1wiOiBcImNzLUxhdG4tQ1pcIixcbiAgICAgIFwiY3NiXCI6IFwiY3NiLUxhdG4tUExcIixcbiAgICAgIFwiY3N3XCI6IFwiY3N3LUNhbnMtQ0FcIixcbiAgICAgIFwiY3RkXCI6IFwiY3RkLVBhdWMtTU1cIixcbiAgICAgIFwiY3VcIjogXCJjdS1DeXJsLVJVXCIsXG4gICAgICBcImN1LUdsYWdcIjogXCJjdS1HbGFnLUJHXCIsXG4gICAgICBcImN2XCI6IFwiY3YtQ3lybC1SVVwiLFxuICAgICAgXCJjeVwiOiBcImN5LUxhdG4tR0JcIixcbiAgICAgIFwiZGFcIjogXCJkYS1MYXRuLURLXCIsXG4gICAgICBcImRhZFwiOiBcImRhZC1MYXRuLVpaXCIsXG4gICAgICBcImRhZlwiOiBcImRhZi1MYXRuLUNJXCIsXG4gICAgICBcImRhZ1wiOiBcImRhZy1MYXRuLVpaXCIsXG4gICAgICBcImRhaFwiOiBcImRhaC1MYXRuLVpaXCIsXG4gICAgICBcImRha1wiOiBcImRhay1MYXRuLVVTXCIsXG4gICAgICBcImRhclwiOiBcImRhci1DeXJsLVJVXCIsXG4gICAgICBcImRhdlwiOiBcImRhdi1MYXRuLUtFXCIsXG4gICAgICBcImRiZFwiOiBcImRiZC1MYXRuLVpaXCIsXG4gICAgICBcImRicVwiOiBcImRicS1MYXRuLVpaXCIsXG4gICAgICBcImRjY1wiOiBcImRjYy1BcmFiLUlOXCIsXG4gICAgICBcImRkblwiOiBcImRkbi1MYXRuLVpaXCIsXG4gICAgICBcImRlXCI6IFwiZGUtTGF0bi1ERVwiLFxuICAgICAgXCJkZWRcIjogXCJkZWQtTGF0bi1aWlwiLFxuICAgICAgXCJkZW5cIjogXCJkZW4tTGF0bi1DQVwiLFxuICAgICAgXCJkZ2FcIjogXCJkZ2EtTGF0bi1aWlwiLFxuICAgICAgXCJkZ2hcIjogXCJkZ2gtTGF0bi1aWlwiLFxuICAgICAgXCJkZ2lcIjogXCJkZ2ktTGF0bi1aWlwiLFxuICAgICAgXCJkZ2xcIjogXCJkZ2wtQXJhYi1aWlwiLFxuICAgICAgXCJkZ3JcIjogXCJkZ3ItTGF0bi1DQVwiLFxuICAgICAgXCJkZ3pcIjogXCJkZ3otTGF0bi1aWlwiLFxuICAgICAgXCJkaWFcIjogXCJkaWEtTGF0bi1aWlwiLFxuICAgICAgXCJkamVcIjogXCJkamUtTGF0bi1ORVwiLFxuICAgICAgXCJkbmpcIjogXCJkbmotTGF0bi1DSVwiLFxuICAgICAgXCJkb2JcIjogXCJkb2ItTGF0bi1aWlwiLFxuICAgICAgXCJkb2lcIjogXCJkb2ktRGV2YS1JTlwiLFxuICAgICAgXCJkb3BcIjogXCJkb3AtTGF0bi1aWlwiLFxuICAgICAgXCJkb3dcIjogXCJkb3ctTGF0bi1aWlwiLFxuICAgICAgXCJkcmhcIjogXCJkcmgtTW9uZy1DTlwiLFxuICAgICAgXCJkcmlcIjogXCJkcmktTGF0bi1aWlwiLFxuICAgICAgXCJkcnNcIjogXCJkcnMtRXRoaS1aWlwiLFxuICAgICAgXCJkc2JcIjogXCJkc2ItTGF0bi1ERVwiLFxuICAgICAgXCJkdG1cIjogXCJkdG0tTGF0bi1NTFwiLFxuICAgICAgXCJkdHBcIjogXCJkdHAtTGF0bi1NWVwiLFxuICAgICAgXCJkdHNcIjogXCJkdHMtTGF0bi1aWlwiLFxuICAgICAgXCJkdHlcIjogXCJkdHktRGV2YS1OUFwiLFxuICAgICAgXCJkdWFcIjogXCJkdWEtTGF0bi1DTVwiLFxuICAgICAgXCJkdWNcIjogXCJkdWMtTGF0bi1aWlwiLFxuICAgICAgXCJkdWRcIjogXCJkdWQtTGF0bi1aWlwiLFxuICAgICAgXCJkdWdcIjogXCJkdWctTGF0bi1aWlwiLFxuICAgICAgXCJkdlwiOiBcImR2LVRoYWEtTVZcIixcbiAgICAgIFwiZHZhXCI6IFwiZHZhLUxhdG4tWlpcIixcbiAgICAgIFwiZHd3XCI6IFwiZHd3LUxhdG4tWlpcIixcbiAgICAgIFwiZHlvXCI6IFwiZHlvLUxhdG4tU05cIixcbiAgICAgIFwiZHl1XCI6IFwiZHl1LUxhdG4tQkZcIixcbiAgICAgIFwiZHpcIjogXCJkei1UaWJ0LUJUXCIsXG4gICAgICBcImR6Z1wiOiBcImR6Zy1MYXRuLVpaXCIsXG4gICAgICBcImVidVwiOiBcImVidS1MYXRuLUtFXCIsXG4gICAgICBcImVlXCI6IFwiZWUtTGF0bi1HSFwiLFxuICAgICAgXCJlZmlcIjogXCJlZmktTGF0bi1OR1wiLFxuICAgICAgXCJlZ2xcIjogXCJlZ2wtTGF0bi1JVFwiLFxuICAgICAgXCJlZ3lcIjogXCJlZ3ktRWd5cC1FR1wiLFxuICAgICAgXCJla2FcIjogXCJla2EtTGF0bi1aWlwiLFxuICAgICAgXCJla3lcIjogXCJla3ktS2FsaS1NTVwiLFxuICAgICAgXCJlbFwiOiBcImVsLUdyZWstR1JcIixcbiAgICAgIFwiZW1hXCI6IFwiZW1hLUxhdG4tWlpcIixcbiAgICAgIFwiZW1pXCI6IFwiZW1pLUxhdG4tWlpcIixcbiAgICAgIFwiZW5cIjogXCJlbi1MYXRuLVVTXCIsXG4gICAgICBcImVuLVNoYXdcIjogXCJlbi1TaGF3LUdCXCIsXG4gICAgICBcImVublwiOiBcImVubi1MYXRuLVpaXCIsXG4gICAgICBcImVucVwiOiBcImVucS1MYXRuLVpaXCIsXG4gICAgICBcImVvXCI6IFwiZW8tTGF0bi0wMDFcIixcbiAgICAgIFwiZXJpXCI6IFwiZXJpLUxhdG4tWlpcIixcbiAgICAgIFwiZXNcIjogXCJlcy1MYXRuLUVTXCIsXG4gICAgICBcImVzZ1wiOiBcImVzZy1Hb25tLUlOXCIsXG4gICAgICBcImVzdVwiOiBcImVzdS1MYXRuLVVTXCIsXG4gICAgICBcImV0XCI6IFwiZXQtTGF0bi1FRVwiLFxuICAgICAgXCJldHJcIjogXCJldHItTGF0bi1aWlwiLFxuICAgICAgXCJldHRcIjogXCJldHQtSXRhbC1JVFwiLFxuICAgICAgXCJldHVcIjogXCJldHUtTGF0bi1aWlwiLFxuICAgICAgXCJldHhcIjogXCJldHgtTGF0bi1aWlwiLFxuICAgICAgXCJldVwiOiBcImV1LUxhdG4tRVNcIixcbiAgICAgIFwiZXdvXCI6IFwiZXdvLUxhdG4tQ01cIixcbiAgICAgIFwiZXh0XCI6IFwiZXh0LUxhdG4tRVNcIixcbiAgICAgIFwiZXphXCI6IFwiZXphLUxhdG4tWlpcIixcbiAgICAgIFwiZmFcIjogXCJmYS1BcmFiLUlSXCIsXG4gICAgICBcImZhYVwiOiBcImZhYS1MYXRuLVpaXCIsXG4gICAgICBcImZhYlwiOiBcImZhYi1MYXRuLVpaXCIsXG4gICAgICBcImZhZ1wiOiBcImZhZy1MYXRuLVpaXCIsXG4gICAgICBcImZhaVwiOiBcImZhaS1MYXRuLVpaXCIsXG4gICAgICBcImZhblwiOiBcImZhbi1MYXRuLUdRXCIsXG4gICAgICBcImZmXCI6IFwiZmYtTGF0bi1TTlwiLFxuICAgICAgXCJmZi1BZGxtXCI6IFwiZmYtQWRsbS1HTlwiLFxuICAgICAgXCJmZmlcIjogXCJmZmktTGF0bi1aWlwiLFxuICAgICAgXCJmZm1cIjogXCJmZm0tTGF0bi1NTFwiLFxuICAgICAgXCJmaVwiOiBcImZpLUxhdG4tRklcIixcbiAgICAgIFwiZmlhXCI6IFwiZmlhLUFyYWItU0RcIixcbiAgICAgIFwiZmlsXCI6IFwiZmlsLUxhdG4tUEhcIixcbiAgICAgIFwiZml0XCI6IFwiZml0LUxhdG4tU0VcIixcbiAgICAgIFwiZmpcIjogXCJmai1MYXRuLUZKXCIsXG4gICAgICBcImZsclwiOiBcImZsci1MYXRuLVpaXCIsXG4gICAgICBcImZtcFwiOiBcImZtcC1MYXRuLVpaXCIsXG4gICAgICBcImZvXCI6IFwiZm8tTGF0bi1GT1wiLFxuICAgICAgXCJmb2RcIjogXCJmb2QtTGF0bi1aWlwiLFxuICAgICAgXCJmb25cIjogXCJmb24tTGF0bi1CSlwiLFxuICAgICAgXCJmb3JcIjogXCJmb3ItTGF0bi1aWlwiLFxuICAgICAgXCJmcGVcIjogXCJmcGUtTGF0bi1aWlwiLFxuICAgICAgXCJmcXNcIjogXCJmcXMtTGF0bi1aWlwiLFxuICAgICAgXCJmclwiOiBcImZyLUxhdG4tRlJcIixcbiAgICAgIFwiZnJjXCI6IFwiZnJjLUxhdG4tVVNcIixcbiAgICAgIFwiZnJwXCI6IFwiZnJwLUxhdG4tRlJcIixcbiAgICAgIFwiZnJyXCI6IFwiZnJyLUxhdG4tREVcIixcbiAgICAgIFwiZnJzXCI6IFwiZnJzLUxhdG4tREVcIixcbiAgICAgIFwiZnViXCI6IFwiZnViLUFyYWItQ01cIixcbiAgICAgIFwiZnVkXCI6IFwiZnVkLUxhdG4tV0ZcIixcbiAgICAgIFwiZnVlXCI6IFwiZnVlLUxhdG4tWlpcIixcbiAgICAgIFwiZnVmXCI6IFwiZnVmLUxhdG4tR05cIixcbiAgICAgIFwiZnVoXCI6IFwiZnVoLUxhdG4tWlpcIixcbiAgICAgIFwiZnVxXCI6IFwiZnVxLUxhdG4tTkVcIixcbiAgICAgIFwiZnVyXCI6IFwiZnVyLUxhdG4tSVRcIixcbiAgICAgIFwiZnV2XCI6IFwiZnV2LUxhdG4tTkdcIixcbiAgICAgIFwiZnV5XCI6IFwiZnV5LUxhdG4tWlpcIixcbiAgICAgIFwiZnZyXCI6IFwiZnZyLUxhdG4tU0RcIixcbiAgICAgIFwiZnlcIjogXCJmeS1MYXRuLU5MXCIsXG4gICAgICBcImdhXCI6IFwiZ2EtTGF0bi1JRVwiLFxuICAgICAgXCJnYWFcIjogXCJnYWEtTGF0bi1HSFwiLFxuICAgICAgXCJnYWZcIjogXCJnYWYtTGF0bi1aWlwiLFxuICAgICAgXCJnYWdcIjogXCJnYWctTGF0bi1NRFwiLFxuICAgICAgXCJnYWhcIjogXCJnYWgtTGF0bi1aWlwiLFxuICAgICAgXCJnYWpcIjogXCJnYWotTGF0bi1aWlwiLFxuICAgICAgXCJnYW1cIjogXCJnYW0tTGF0bi1aWlwiLFxuICAgICAgXCJnYW5cIjogXCJnYW4tSGFucy1DTlwiLFxuICAgICAgXCJnYXdcIjogXCJnYXctTGF0bi1aWlwiLFxuICAgICAgXCJnYXlcIjogXCJnYXktTGF0bi1JRFwiLFxuICAgICAgXCJnYmFcIjogXCJnYmEtTGF0bi1aWlwiLFxuICAgICAgXCJnYmZcIjogXCJnYmYtTGF0bi1aWlwiLFxuICAgICAgXCJnYm1cIjogXCJnYm0tRGV2YS1JTlwiLFxuICAgICAgXCJnYnlcIjogXCJnYnktTGF0bi1aWlwiLFxuICAgICAgXCJnYnpcIjogXCJnYnotQXJhYi1JUlwiLFxuICAgICAgXCJnY3JcIjogXCJnY3ItTGF0bi1HRlwiLFxuICAgICAgXCJnZFwiOiBcImdkLUxhdG4tR0JcIixcbiAgICAgIFwiZ2RlXCI6IFwiZ2RlLUxhdG4tWlpcIixcbiAgICAgIFwiZ2RuXCI6IFwiZ2RuLUxhdG4tWlpcIixcbiAgICAgIFwiZ2RyXCI6IFwiZ2RyLUxhdG4tWlpcIixcbiAgICAgIFwiZ2ViXCI6IFwiZ2ViLUxhdG4tWlpcIixcbiAgICAgIFwiZ2VqXCI6IFwiZ2VqLUxhdG4tWlpcIixcbiAgICAgIFwiZ2VsXCI6IFwiZ2VsLUxhdG4tWlpcIixcbiAgICAgIFwiZ2V6XCI6IFwiZ2V6LUV0aGktRVRcIixcbiAgICAgIFwiZ2ZrXCI6IFwiZ2ZrLUxhdG4tWlpcIixcbiAgICAgIFwiZ2duXCI6IFwiZ2duLURldmEtTlBcIixcbiAgICAgIFwiZ2hzXCI6IFwiZ2hzLUxhdG4tWlpcIixcbiAgICAgIFwiZ2lsXCI6IFwiZ2lsLUxhdG4tS0lcIixcbiAgICAgIFwiZ2ltXCI6IFwiZ2ltLUxhdG4tWlpcIixcbiAgICAgIFwiZ2prXCI6IFwiZ2prLUFyYWItUEtcIixcbiAgICAgIFwiZ2puXCI6IFwiZ2puLUxhdG4tWlpcIixcbiAgICAgIFwiZ2p1XCI6IFwiZ2p1LUFyYWItUEtcIixcbiAgICAgIFwiZ2tuXCI6IFwiZ2tuLUxhdG4tWlpcIixcbiAgICAgIFwiZ2twXCI6IFwiZ2twLUxhdG4tWlpcIixcbiAgICAgIFwiZ2xcIjogXCJnbC1MYXRuLUVTXCIsXG4gICAgICBcImdsa1wiOiBcImdsay1BcmFiLUlSXCIsXG4gICAgICBcImdtbVwiOiBcImdtbS1MYXRuLVpaXCIsXG4gICAgICBcImdtdlwiOiBcImdtdi1FdGhpLVpaXCIsXG4gICAgICBcImduXCI6IFwiZ24tTGF0bi1QWVwiLFxuICAgICAgXCJnbmRcIjogXCJnbmQtTGF0bi1aWlwiLFxuICAgICAgXCJnbmdcIjogXCJnbmctTGF0bi1aWlwiLFxuICAgICAgXCJnb2RcIjogXCJnb2QtTGF0bi1aWlwiLFxuICAgICAgXCJnb2ZcIjogXCJnb2YtRXRoaS1aWlwiLFxuICAgICAgXCJnb2lcIjogXCJnb2ktTGF0bi1aWlwiLFxuICAgICAgXCJnb21cIjogXCJnb20tRGV2YS1JTlwiLFxuICAgICAgXCJnb25cIjogXCJnb24tVGVsdS1JTlwiLFxuICAgICAgXCJnb3JcIjogXCJnb3ItTGF0bi1JRFwiLFxuICAgICAgXCJnb3NcIjogXCJnb3MtTGF0bi1OTFwiLFxuICAgICAgXCJnb3RcIjogXCJnb3QtR290aC1VQVwiLFxuICAgICAgXCJncmJcIjogXCJncmItTGF0bi1aWlwiLFxuICAgICAgXCJncmNcIjogXCJncmMtQ3BydC1DWVwiLFxuICAgICAgXCJncmMtTGluYlwiOiBcImdyYy1MaW5iLUdSXCIsXG4gICAgICBcImdydFwiOiBcImdydC1CZW5nLUlOXCIsXG4gICAgICBcImdyd1wiOiBcImdydy1MYXRuLVpaXCIsXG4gICAgICBcImdzd1wiOiBcImdzdy1MYXRuLUNIXCIsXG4gICAgICBcImd1XCI6IFwiZ3UtR3Vqci1JTlwiLFxuICAgICAgXCJndWJcIjogXCJndWItTGF0bi1CUlwiLFxuICAgICAgXCJndWNcIjogXCJndWMtTGF0bi1DT1wiLFxuICAgICAgXCJndWRcIjogXCJndWQtTGF0bi1aWlwiLFxuICAgICAgXCJndXJcIjogXCJndXItTGF0bi1HSFwiLFxuICAgICAgXCJndXdcIjogXCJndXctTGF0bi1aWlwiLFxuICAgICAgXCJndXhcIjogXCJndXgtTGF0bi1aWlwiLFxuICAgICAgXCJndXpcIjogXCJndXotTGF0bi1LRVwiLFxuICAgICAgXCJndlwiOiBcImd2LUxhdG4tSU1cIixcbiAgICAgIFwiZ3ZmXCI6IFwiZ3ZmLUxhdG4tWlpcIixcbiAgICAgIFwiZ3ZyXCI6IFwiZ3ZyLURldmEtTlBcIixcbiAgICAgIFwiZ3ZzXCI6IFwiZ3ZzLUxhdG4tWlpcIixcbiAgICAgIFwiZ3djXCI6IFwiZ3djLUFyYWItWlpcIixcbiAgICAgIFwiZ3dpXCI6IFwiZ3dpLUxhdG4tQ0FcIixcbiAgICAgIFwiZ3d0XCI6IFwiZ3d0LUFyYWItWlpcIixcbiAgICAgIFwiZ3lpXCI6IFwiZ3lpLUxhdG4tWlpcIixcbiAgICAgIFwiaGFcIjogXCJoYS1MYXRuLU5HXCIsXG4gICAgICBcImhhLUNNXCI6IFwiaGEtQXJhYi1DTVwiLFxuICAgICAgXCJoYS1TRFwiOiBcImhhLUFyYWItU0RcIixcbiAgICAgIFwiaGFnXCI6IFwiaGFnLUxhdG4tWlpcIixcbiAgICAgIFwiaGFrXCI6IFwiaGFrLUhhbnMtQ05cIixcbiAgICAgIFwiaGFtXCI6IFwiaGFtLUxhdG4tWlpcIixcbiAgICAgIFwiaGF3XCI6IFwiaGF3LUxhdG4tVVNcIixcbiAgICAgIFwiaGF6XCI6IFwiaGF6LUFyYWItQUZcIixcbiAgICAgIFwiaGJiXCI6IFwiaGJiLUxhdG4tWlpcIixcbiAgICAgIFwiaGR5XCI6IFwiaGR5LUV0aGktWlpcIixcbiAgICAgIFwiaGVcIjogXCJoZS1IZWJyLUlMXCIsXG4gICAgICBcImhoeVwiOiBcImhoeS1MYXRuLVpaXCIsXG4gICAgICBcImhpXCI6IFwiaGktRGV2YS1JTlwiLFxuICAgICAgXCJoaWFcIjogXCJoaWEtTGF0bi1aWlwiLFxuICAgICAgXCJoaWZcIjogXCJoaWYtTGF0bi1GSlwiLFxuICAgICAgXCJoaWdcIjogXCJoaWctTGF0bi1aWlwiLFxuICAgICAgXCJoaWhcIjogXCJoaWgtTGF0bi1aWlwiLFxuICAgICAgXCJoaWxcIjogXCJoaWwtTGF0bi1QSFwiLFxuICAgICAgXCJobGFcIjogXCJobGEtTGF0bi1aWlwiLFxuICAgICAgXCJobHVcIjogXCJobHUtSGx1dy1UUlwiLFxuICAgICAgXCJobWRcIjogXCJobWQtUGxyZC1DTlwiLFxuICAgICAgXCJobXRcIjogXCJobXQtTGF0bi1aWlwiLFxuICAgICAgXCJobmRcIjogXCJobmQtQXJhYi1QS1wiLFxuICAgICAgXCJobmVcIjogXCJobmUtRGV2YS1JTlwiLFxuICAgICAgXCJobmpcIjogXCJobmotSG1uZy1MQVwiLFxuICAgICAgXCJobm5cIjogXCJobm4tTGF0bi1QSFwiLFxuICAgICAgXCJobm9cIjogXCJobm8tQXJhYi1QS1wiLFxuICAgICAgXCJob1wiOiBcImhvLUxhdG4tUEdcIixcbiAgICAgIFwiaG9jXCI6IFwiaG9jLURldmEtSU5cIixcbiAgICAgIFwiaG9qXCI6IFwiaG9qLURldmEtSU5cIixcbiAgICAgIFwiaG90XCI6IFwiaG90LUxhdG4tWlpcIixcbiAgICAgIFwiaHJcIjogXCJoci1MYXRuLUhSXCIsXG4gICAgICBcImhzYlwiOiBcImhzYi1MYXRuLURFXCIsXG4gICAgICBcImhzblwiOiBcImhzbi1IYW5zLUNOXCIsXG4gICAgICBcImh0XCI6IFwiaHQtTGF0bi1IVFwiLFxuICAgICAgXCJodVwiOiBcImh1LUxhdG4tSFVcIixcbiAgICAgIFwiaHVpXCI6IFwiaHVpLUxhdG4tWlpcIixcbiAgICAgIFwiaHlcIjogXCJoeS1Bcm1uLUFNXCIsXG4gICAgICBcImh6XCI6IFwiaHotTGF0bi1OQVwiLFxuICAgICAgXCJpYVwiOiBcImlhLUxhdG4tMDAxXCIsXG4gICAgICBcImlhblwiOiBcImlhbi1MYXRuLVpaXCIsXG4gICAgICBcImlhclwiOiBcImlhci1MYXRuLVpaXCIsXG4gICAgICBcImliYVwiOiBcImliYS1MYXRuLU1ZXCIsXG4gICAgICBcImliYlwiOiBcImliYi1MYXRuLU5HXCIsXG4gICAgICBcImlieVwiOiBcImlieS1MYXRuLVpaXCIsXG4gICAgICBcImljYVwiOiBcImljYS1MYXRuLVpaXCIsXG4gICAgICBcImljaFwiOiBcImljaC1MYXRuLVpaXCIsXG4gICAgICBcImlkXCI6IFwiaWQtTGF0bi1JRFwiLFxuICAgICAgXCJpZGRcIjogXCJpZGQtTGF0bi1aWlwiLFxuICAgICAgXCJpZGlcIjogXCJpZGktTGF0bi1aWlwiLFxuICAgICAgXCJpZHVcIjogXCJpZHUtTGF0bi1aWlwiLFxuICAgICAgXCJpZmVcIjogXCJpZmUtTGF0bi1UR1wiLFxuICAgICAgXCJpZ1wiOiBcImlnLUxhdG4tTkdcIixcbiAgICAgIFwiaWdiXCI6IFwiaWdiLUxhdG4tWlpcIixcbiAgICAgIFwiaWdlXCI6IFwiaWdlLUxhdG4tWlpcIixcbiAgICAgIFwiaWlcIjogXCJpaS1ZaWlpLUNOXCIsXG4gICAgICBcImlqalwiOiBcImlqai1MYXRuLVpaXCIsXG4gICAgICBcImlrXCI6IFwiaWstTGF0bi1VU1wiLFxuICAgICAgXCJpa2tcIjogXCJpa2stTGF0bi1aWlwiLFxuICAgICAgXCJpa3RcIjogXCJpa3QtTGF0bi1DQVwiLFxuICAgICAgXCJpa3dcIjogXCJpa3ctTGF0bi1aWlwiLFxuICAgICAgXCJpa3hcIjogXCJpa3gtTGF0bi1aWlwiLFxuICAgICAgXCJpbG9cIjogXCJpbG8tTGF0bi1QSFwiLFxuICAgICAgXCJpbW9cIjogXCJpbW8tTGF0bi1aWlwiLFxuICAgICAgXCJpblwiOiBcImluLUxhdG4tSURcIixcbiAgICAgIFwiaW5oXCI6IFwiaW5oLUN5cmwtUlVcIixcbiAgICAgIFwiaW9cIjogXCJpby1MYXRuLTAwMVwiLFxuICAgICAgXCJpb3VcIjogXCJpb3UtTGF0bi1aWlwiLFxuICAgICAgXCJpcmlcIjogXCJpcmktTGF0bi1aWlwiLFxuICAgICAgXCJpc1wiOiBcImlzLUxhdG4tSVNcIixcbiAgICAgIFwiaXRcIjogXCJpdC1MYXRuLUlUXCIsXG4gICAgICBcIml1XCI6IFwiaXUtQ2Fucy1DQVwiLFxuICAgICAgXCJpd1wiOiBcIml3LUhlYnItSUxcIixcbiAgICAgIFwiaXdtXCI6IFwiaXdtLUxhdG4tWlpcIixcbiAgICAgIFwiaXdzXCI6IFwiaXdzLUxhdG4tWlpcIixcbiAgICAgIFwiaXpoXCI6IFwiaXpoLUxhdG4tUlVcIixcbiAgICAgIFwiaXppXCI6IFwiaXppLUxhdG4tWlpcIixcbiAgICAgIFwiamFcIjogXCJqYS1KcGFuLUpQXCIsXG4gICAgICBcImphYlwiOiBcImphYi1MYXRuLVpaXCIsXG4gICAgICBcImphbVwiOiBcImphbS1MYXRuLUpNXCIsXG4gICAgICBcImphclwiOiBcImphci1MYXRuLVpaXCIsXG4gICAgICBcImpib1wiOiBcImpiby1MYXRuLTAwMVwiLFxuICAgICAgXCJqYnVcIjogXCJqYnUtTGF0bi1aWlwiLFxuICAgICAgXCJqZW5cIjogXCJqZW4tTGF0bi1aWlwiLFxuICAgICAgXCJqZ2tcIjogXCJqZ2stTGF0bi1aWlwiLFxuICAgICAgXCJqZ29cIjogXCJqZ28tTGF0bi1DTVwiLFxuICAgICAgXCJqaVwiOiBcImppLUhlYnItVUFcIixcbiAgICAgIFwiamliXCI6IFwiamliLUxhdG4tWlpcIixcbiAgICAgIFwiam1jXCI6IFwiam1jLUxhdG4tVFpcIixcbiAgICAgIFwiam1sXCI6IFwiam1sLURldmEtTlBcIixcbiAgICAgIFwianJhXCI6IFwianJhLUxhdG4tWlpcIixcbiAgICAgIFwianV0XCI6IFwianV0LUxhdG4tREtcIixcbiAgICAgIFwianZcIjogXCJqdi1MYXRuLUlEXCIsXG4gICAgICBcImp3XCI6IFwianctTGF0bi1JRFwiLFxuICAgICAgXCJrYVwiOiBcImthLUdlb3ItR0VcIixcbiAgICAgIFwia2FhXCI6IFwia2FhLUN5cmwtVVpcIixcbiAgICAgIFwia2FiXCI6IFwia2FiLUxhdG4tRFpcIixcbiAgICAgIFwia2FjXCI6IFwia2FjLUxhdG4tTU1cIixcbiAgICAgIFwia2FkXCI6IFwia2FkLUxhdG4tWlpcIixcbiAgICAgIFwia2FpXCI6IFwia2FpLUxhdG4tWlpcIixcbiAgICAgIFwia2FqXCI6IFwia2FqLUxhdG4tTkdcIixcbiAgICAgIFwia2FtXCI6IFwia2FtLUxhdG4tS0VcIixcbiAgICAgIFwia2FvXCI6IFwia2FvLUxhdG4tTUxcIixcbiAgICAgIFwia2JkXCI6IFwia2JkLUN5cmwtUlVcIixcbiAgICAgIFwia2JtXCI6IFwia2JtLUxhdG4tWlpcIixcbiAgICAgIFwia2JwXCI6IFwia2JwLUxhdG4tWlpcIixcbiAgICAgIFwia2JxXCI6IFwia2JxLUxhdG4tWlpcIixcbiAgICAgIFwia2J4XCI6IFwia2J4LUxhdG4tWlpcIixcbiAgICAgIFwia2J5XCI6IFwia2J5LUFyYWItTkVcIixcbiAgICAgIFwia2NnXCI6IFwia2NnLUxhdG4tTkdcIixcbiAgICAgIFwia2NrXCI6IFwia2NrLUxhdG4tWldcIixcbiAgICAgIFwia2NsXCI6IFwia2NsLUxhdG4tWlpcIixcbiAgICAgIFwia2N0XCI6IFwia2N0LUxhdG4tWlpcIixcbiAgICAgIFwia2RlXCI6IFwia2RlLUxhdG4tVFpcIixcbiAgICAgIFwia2RoXCI6IFwia2RoLUFyYWItVEdcIixcbiAgICAgIFwia2RsXCI6IFwia2RsLUxhdG4tWlpcIixcbiAgICAgIFwia2R0XCI6IFwia2R0LVRoYWktVEhcIixcbiAgICAgIFwia2VhXCI6IFwia2VhLUxhdG4tQ1ZcIixcbiAgICAgIFwia2VuXCI6IFwia2VuLUxhdG4tQ01cIixcbiAgICAgIFwia2V6XCI6IFwia2V6LUxhdG4tWlpcIixcbiAgICAgIFwia2ZvXCI6IFwia2ZvLUxhdG4tQ0lcIixcbiAgICAgIFwia2ZyXCI6IFwia2ZyLURldmEtSU5cIixcbiAgICAgIFwia2Z5XCI6IFwia2Z5LURldmEtSU5cIixcbiAgICAgIFwia2dcIjogXCJrZy1MYXRuLUNEXCIsXG4gICAgICBcImtnZVwiOiBcImtnZS1MYXRuLUlEXCIsXG4gICAgICBcImtnZlwiOiBcImtnZi1MYXRuLVpaXCIsXG4gICAgICBcImtncFwiOiBcImtncC1MYXRuLUJSXCIsXG4gICAgICBcImtoYVwiOiBcImtoYS1MYXRuLUlOXCIsXG4gICAgICBcImtoYlwiOiBcImtoYi1UYWx1LUNOXCIsXG4gICAgICBcImtoblwiOiBcImtobi1EZXZhLUlOXCIsXG4gICAgICBcImtocVwiOiBcImtocS1MYXRuLU1MXCIsXG4gICAgICBcImtoc1wiOiBcImtocy1MYXRuLVpaXCIsXG4gICAgICBcImtodFwiOiBcImtodC1NeW1yLUlOXCIsXG4gICAgICBcImtod1wiOiBcImtody1BcmFiLVBLXCIsXG4gICAgICBcImtoelwiOiBcImtoei1MYXRuLVpaXCIsXG4gICAgICBcImtpXCI6IFwia2ktTGF0bi1LRVwiLFxuICAgICAgXCJraWpcIjogXCJraWotTGF0bi1aWlwiLFxuICAgICAgXCJraXVcIjogXCJraXUtTGF0bi1UUlwiLFxuICAgICAgXCJraXdcIjogXCJraXctTGF0bi1aWlwiLFxuICAgICAgXCJralwiOiBcImtqLUxhdG4tTkFcIixcbiAgICAgIFwia2pkXCI6IFwia2pkLUxhdG4tWlpcIixcbiAgICAgIFwia2pnXCI6IFwia2pnLUxhb28tTEFcIixcbiAgICAgIFwia2pzXCI6IFwia2pzLUxhdG4tWlpcIixcbiAgICAgIFwia2p5XCI6IFwia2p5LUxhdG4tWlpcIixcbiAgICAgIFwia2tcIjogXCJray1DeXJsLUtaXCIsXG4gICAgICBcImtrLUFGXCI6IFwia2stQXJhYi1BRlwiLFxuICAgICAgXCJray1BcmFiXCI6IFwia2stQXJhYi1DTlwiLFxuICAgICAgXCJray1DTlwiOiBcImtrLUFyYWItQ05cIixcbiAgICAgIFwia2stSVJcIjogXCJray1BcmFiLUlSXCIsXG4gICAgICBcImtrLU1OXCI6IFwia2stQXJhYi1NTlwiLFxuICAgICAgXCJra2NcIjogXCJra2MtTGF0bi1aWlwiLFxuICAgICAgXCJra2pcIjogXCJra2otTGF0bi1DTVwiLFxuICAgICAgXCJrbFwiOiBcImtsLUxhdG4tR0xcIixcbiAgICAgIFwia2xuXCI6IFwia2xuLUxhdG4tS0VcIixcbiAgICAgIFwia2xxXCI6IFwia2xxLUxhdG4tWlpcIixcbiAgICAgIFwia2x0XCI6IFwia2x0LUxhdG4tWlpcIixcbiAgICAgIFwia2x4XCI6IFwia2x4LUxhdG4tWlpcIixcbiAgICAgIFwia21cIjogXCJrbS1LaG1yLUtIXCIsXG4gICAgICBcImttYlwiOiBcImttYi1MYXRuLUFPXCIsXG4gICAgICBcImttaFwiOiBcImttaC1MYXRuLVpaXCIsXG4gICAgICBcImttb1wiOiBcImttby1MYXRuLVpaXCIsXG4gICAgICBcImttc1wiOiBcImttcy1MYXRuLVpaXCIsXG4gICAgICBcImttdVwiOiBcImttdS1MYXRuLVpaXCIsXG4gICAgICBcImttd1wiOiBcImttdy1MYXRuLVpaXCIsXG4gICAgICBcImtuXCI6IFwia24tS25kYS1JTlwiLFxuICAgICAgXCJrbmZcIjogXCJrbmYtTGF0bi1HV1wiLFxuICAgICAgXCJrbnBcIjogXCJrbnAtTGF0bi1aWlwiLFxuICAgICAgXCJrb1wiOiBcImtvLUtvcmUtS1JcIixcbiAgICAgIFwia29pXCI6IFwia29pLUN5cmwtUlVcIixcbiAgICAgIFwia29rXCI6IFwia29rLURldmEtSU5cIixcbiAgICAgIFwia29sXCI6IFwia29sLUxhdG4tWlpcIixcbiAgICAgIFwia29zXCI6IFwia29zLUxhdG4tRk1cIixcbiAgICAgIFwia296XCI6IFwia296LUxhdG4tWlpcIixcbiAgICAgIFwia3BlXCI6IFwia3BlLUxhdG4tTFJcIixcbiAgICAgIFwia3BmXCI6IFwia3BmLUxhdG4tWlpcIixcbiAgICAgIFwia3BvXCI6IFwia3BvLUxhdG4tWlpcIixcbiAgICAgIFwia3ByXCI6IFwia3ByLUxhdG4tWlpcIixcbiAgICAgIFwia3B4XCI6IFwia3B4LUxhdG4tWlpcIixcbiAgICAgIFwia3FiXCI6IFwia3FiLUxhdG4tWlpcIixcbiAgICAgIFwia3FmXCI6IFwia3FmLUxhdG4tWlpcIixcbiAgICAgIFwia3FzXCI6IFwia3FzLUxhdG4tWlpcIixcbiAgICAgIFwia3F5XCI6IFwia3F5LUV0aGktWlpcIixcbiAgICAgIFwia3JcIjogXCJrci1MYXRuLVpaXCIsXG4gICAgICBcImtyY1wiOiBcImtyYy1DeXJsLVJVXCIsXG4gICAgICBcImtyaVwiOiBcImtyaS1MYXRuLVNMXCIsXG4gICAgICBcImtyalwiOiBcImtyai1MYXRuLVBIXCIsXG4gICAgICBcImtybFwiOiBcImtybC1MYXRuLVJVXCIsXG4gICAgICBcImtyc1wiOiBcImtycy1MYXRuLVpaXCIsXG4gICAgICBcImtydVwiOiBcImtydS1EZXZhLUlOXCIsXG4gICAgICBcImtzXCI6IFwia3MtQXJhYi1JTlwiLFxuICAgICAgXCJrc2JcIjogXCJrc2ItTGF0bi1UWlwiLFxuICAgICAgXCJrc2RcIjogXCJrc2QtTGF0bi1aWlwiLFxuICAgICAgXCJrc2ZcIjogXCJrc2YtTGF0bi1DTVwiLFxuICAgICAgXCJrc2hcIjogXCJrc2gtTGF0bi1ERVwiLFxuICAgICAgXCJrc2pcIjogXCJrc2otTGF0bi1aWlwiLFxuICAgICAgXCJrc3JcIjogXCJrc3ItTGF0bi1aWlwiLFxuICAgICAgXCJrdGJcIjogXCJrdGItRXRoaS1aWlwiLFxuICAgICAgXCJrdG1cIjogXCJrdG0tTGF0bi1aWlwiLFxuICAgICAgXCJrdG9cIjogXCJrdG8tTGF0bi1aWlwiLFxuICAgICAgXCJrdHJcIjogXCJrdHItTGF0bi1NWVwiLFxuICAgICAgXCJrdVwiOiBcImt1LUxhdG4tVFJcIixcbiAgICAgIFwia3UtQXJhYlwiOiBcImt1LUFyYWItSVFcIixcbiAgICAgIFwia3UtTEJcIjogXCJrdS1BcmFiLUxCXCIsXG4gICAgICBcImt1LVllemlcIjogXCJrdS1ZZXppLUdFXCIsXG4gICAgICBcImt1YlwiOiBcImt1Yi1MYXRuLVpaXCIsXG4gICAgICBcImt1ZFwiOiBcImt1ZC1MYXRuLVpaXCIsXG4gICAgICBcImt1ZVwiOiBcImt1ZS1MYXRuLVpaXCIsXG4gICAgICBcImt1alwiOiBcImt1ai1MYXRuLVpaXCIsXG4gICAgICBcImt1bVwiOiBcImt1bS1DeXJsLVJVXCIsXG4gICAgICBcImt1blwiOiBcImt1bi1MYXRuLVpaXCIsXG4gICAgICBcImt1cFwiOiBcImt1cC1MYXRuLVpaXCIsXG4gICAgICBcImt1c1wiOiBcImt1cy1MYXRuLVpaXCIsXG4gICAgICBcImt2XCI6IFwia3YtQ3lybC1SVVwiLFxuICAgICAgXCJrdmdcIjogXCJrdmctTGF0bi1aWlwiLFxuICAgICAgXCJrdnJcIjogXCJrdnItTGF0bi1JRFwiLFxuICAgICAgXCJrdnhcIjogXCJrdngtQXJhYi1QS1wiLFxuICAgICAgXCJrd1wiOiBcImt3LUxhdG4tR0JcIixcbiAgICAgIFwia3dqXCI6IFwia3dqLUxhdG4tWlpcIixcbiAgICAgIFwia3dvXCI6IFwia3dvLUxhdG4tWlpcIixcbiAgICAgIFwia3dxXCI6IFwia3dxLUxhdG4tWlpcIixcbiAgICAgIFwia3hhXCI6IFwia3hhLUxhdG4tWlpcIixcbiAgICAgIFwia3hjXCI6IFwia3hjLUV0aGktWlpcIixcbiAgICAgIFwia3hlXCI6IFwia3hlLUxhdG4tWlpcIixcbiAgICAgIFwia3hsXCI6IFwia3hsLURldmEtSU5cIixcbiAgICAgIFwia3htXCI6IFwia3htLVRoYWktVEhcIixcbiAgICAgIFwia3hwXCI6IFwia3hwLUFyYWItUEtcIixcbiAgICAgIFwia3h3XCI6IFwia3h3LUxhdG4tWlpcIixcbiAgICAgIFwia3h6XCI6IFwia3h6LUxhdG4tWlpcIixcbiAgICAgIFwia3lcIjogXCJreS1DeXJsLUtHXCIsXG4gICAgICBcImt5LUFyYWJcIjogXCJreS1BcmFiLUNOXCIsXG4gICAgICBcImt5LUNOXCI6IFwia3ktQXJhYi1DTlwiLFxuICAgICAgXCJreS1MYXRuXCI6IFwia3ktTGF0bi1UUlwiLFxuICAgICAgXCJreS1UUlwiOiBcImt5LUxhdG4tVFJcIixcbiAgICAgIFwia3llXCI6IFwia3llLUxhdG4tWlpcIixcbiAgICAgIFwia3l4XCI6IFwia3l4LUxhdG4tWlpcIixcbiAgICAgIFwia3poXCI6IFwia3poLUFyYWItWlpcIixcbiAgICAgIFwia3pqXCI6IFwia3pqLUxhdG4tTVlcIixcbiAgICAgIFwia3pyXCI6IFwia3pyLUxhdG4tWlpcIixcbiAgICAgIFwia3p0XCI6IFwia3p0LUxhdG4tTVlcIixcbiAgICAgIFwibGFcIjogXCJsYS1MYXRuLVZBXCIsXG4gICAgICBcImxhYlwiOiBcImxhYi1MaW5hLUdSXCIsXG4gICAgICBcImxhZFwiOiBcImxhZC1IZWJyLUlMXCIsXG4gICAgICBcImxhZ1wiOiBcImxhZy1MYXRuLVRaXCIsXG4gICAgICBcImxhaFwiOiBcImxhaC1BcmFiLVBLXCIsXG4gICAgICBcImxhalwiOiBcImxhai1MYXRuLVVHXCIsXG4gICAgICBcImxhc1wiOiBcImxhcy1MYXRuLVpaXCIsXG4gICAgICBcImxiXCI6IFwibGItTGF0bi1MVVwiLFxuICAgICAgXCJsYmVcIjogXCJsYmUtQ3lybC1SVVwiLFxuICAgICAgXCJsYnVcIjogXCJsYnUtTGF0bi1aWlwiLFxuICAgICAgXCJsYndcIjogXCJsYnctTGF0bi1JRFwiLFxuICAgICAgXCJsY21cIjogXCJsY20tTGF0bi1aWlwiLFxuICAgICAgXCJsY3BcIjogXCJsY3AtVGhhaS1DTlwiLFxuICAgICAgXCJsZGJcIjogXCJsZGItTGF0bi1aWlwiLFxuICAgICAgXCJsZWRcIjogXCJsZWQtTGF0bi1aWlwiLFxuICAgICAgXCJsZWVcIjogXCJsZWUtTGF0bi1aWlwiLFxuICAgICAgXCJsZW1cIjogXCJsZW0tTGF0bi1aWlwiLFxuICAgICAgXCJsZXBcIjogXCJsZXAtTGVwYy1JTlwiLFxuICAgICAgXCJsZXFcIjogXCJsZXEtTGF0bi1aWlwiLFxuICAgICAgXCJsZXVcIjogXCJsZXUtTGF0bi1aWlwiLFxuICAgICAgXCJsZXpcIjogXCJsZXotQ3lybC1SVVwiLFxuICAgICAgXCJsZ1wiOiBcImxnLUxhdG4tVUdcIixcbiAgICAgIFwibGdnXCI6IFwibGdnLUxhdG4tWlpcIixcbiAgICAgIFwibGlcIjogXCJsaS1MYXRuLU5MXCIsXG4gICAgICBcImxpYVwiOiBcImxpYS1MYXRuLVpaXCIsXG4gICAgICBcImxpZFwiOiBcImxpZC1MYXRuLVpaXCIsXG4gICAgICBcImxpZlwiOiBcImxpZi1EZXZhLU5QXCIsXG4gICAgICBcImxpZi1MaW1iXCI6IFwibGlmLUxpbWItSU5cIixcbiAgICAgIFwibGlnXCI6IFwibGlnLUxhdG4tWlpcIixcbiAgICAgIFwibGloXCI6IFwibGloLUxhdG4tWlpcIixcbiAgICAgIFwibGlqXCI6IFwibGlqLUxhdG4tSVRcIixcbiAgICAgIFwibGlzXCI6IFwibGlzLUxpc3UtQ05cIixcbiAgICAgIFwibGpwXCI6IFwibGpwLUxhdG4tSURcIixcbiAgICAgIFwibGtpXCI6IFwibGtpLUFyYWItSVJcIixcbiAgICAgIFwibGt0XCI6IFwibGt0LUxhdG4tVVNcIixcbiAgICAgIFwibGxlXCI6IFwibGxlLUxhdG4tWlpcIixcbiAgICAgIFwibGxuXCI6IFwibGxuLUxhdG4tWlpcIixcbiAgICAgIFwibG1uXCI6IFwibG1uLVRlbHUtSU5cIixcbiAgICAgIFwibG1vXCI6IFwibG1vLUxhdG4tSVRcIixcbiAgICAgIFwibG1wXCI6IFwibG1wLUxhdG4tWlpcIixcbiAgICAgIFwibG5cIjogXCJsbi1MYXRuLUNEXCIsXG4gICAgICBcImxuc1wiOiBcImxucy1MYXRuLVpaXCIsXG4gICAgICBcImxudVwiOiBcImxudS1MYXRuLVpaXCIsXG4gICAgICBcImxvXCI6IFwibG8tTGFvby1MQVwiLFxuICAgICAgXCJsb2pcIjogXCJsb2otTGF0bi1aWlwiLFxuICAgICAgXCJsb2tcIjogXCJsb2stTGF0bi1aWlwiLFxuICAgICAgXCJsb2xcIjogXCJsb2wtTGF0bi1DRFwiLFxuICAgICAgXCJsb3JcIjogXCJsb3ItTGF0bi1aWlwiLFxuICAgICAgXCJsb3NcIjogXCJsb3MtTGF0bi1aWlwiLFxuICAgICAgXCJsb3pcIjogXCJsb3otTGF0bi1aTVwiLFxuICAgICAgXCJscmNcIjogXCJscmMtQXJhYi1JUlwiLFxuICAgICAgXCJsdFwiOiBcImx0LUxhdG4tTFRcIixcbiAgICAgIFwibHRnXCI6IFwibHRnLUxhdG4tTFZcIixcbiAgICAgIFwibHVcIjogXCJsdS1MYXRuLUNEXCIsXG4gICAgICBcImx1YVwiOiBcImx1YS1MYXRuLUNEXCIsXG4gICAgICBcImx1b1wiOiBcImx1by1MYXRuLUtFXCIsXG4gICAgICBcImx1eVwiOiBcImx1eS1MYXRuLUtFXCIsXG4gICAgICBcImx1elwiOiBcImx1ei1BcmFiLUlSXCIsXG4gICAgICBcImx2XCI6IFwibHYtTGF0bi1MVlwiLFxuICAgICAgXCJsd2xcIjogXCJsd2wtVGhhaS1USFwiLFxuICAgICAgXCJsemhcIjogXCJsemgtSGFucy1DTlwiLFxuICAgICAgXCJsenpcIjogXCJsenotTGF0bi1UUlwiLFxuICAgICAgXCJtYWRcIjogXCJtYWQtTGF0bi1JRFwiLFxuICAgICAgXCJtYWZcIjogXCJtYWYtTGF0bi1DTVwiLFxuICAgICAgXCJtYWdcIjogXCJtYWctRGV2YS1JTlwiLFxuICAgICAgXCJtYWlcIjogXCJtYWktRGV2YS1JTlwiLFxuICAgICAgXCJtYWtcIjogXCJtYWstTGF0bi1JRFwiLFxuICAgICAgXCJtYW5cIjogXCJtYW4tTGF0bi1HTVwiLFxuICAgICAgXCJtYW4tR05cIjogXCJtYW4tTmtvby1HTlwiLFxuICAgICAgXCJtYW4tTmtvb1wiOiBcIm1hbi1Oa29vLUdOXCIsXG4gICAgICBcIm1hc1wiOiBcIm1hcy1MYXRuLUtFXCIsXG4gICAgICBcIm1hd1wiOiBcIm1hdy1MYXRuLVpaXCIsXG4gICAgICBcIm1helwiOiBcIm1hei1MYXRuLU1YXCIsXG4gICAgICBcIm1iaFwiOiBcIm1iaC1MYXRuLVpaXCIsXG4gICAgICBcIm1ib1wiOiBcIm1iby1MYXRuLVpaXCIsXG4gICAgICBcIm1icVwiOiBcIm1icS1MYXRuLVpaXCIsXG4gICAgICBcIm1idVwiOiBcIm1idS1MYXRuLVpaXCIsXG4gICAgICBcIm1id1wiOiBcIm1idy1MYXRuLVpaXCIsXG4gICAgICBcIm1jaVwiOiBcIm1jaS1MYXRuLVpaXCIsXG4gICAgICBcIm1jcFwiOiBcIm1jcC1MYXRuLVpaXCIsXG4gICAgICBcIm1jcVwiOiBcIm1jcS1MYXRuLVpaXCIsXG4gICAgICBcIm1jclwiOiBcIm1jci1MYXRuLVpaXCIsXG4gICAgICBcIm1jdVwiOiBcIm1jdS1MYXRuLVpaXCIsXG4gICAgICBcIm1kYVwiOiBcIm1kYS1MYXRuLVpaXCIsXG4gICAgICBcIm1kZVwiOiBcIm1kZS1BcmFiLVpaXCIsXG4gICAgICBcIm1kZlwiOiBcIm1kZi1DeXJsLVJVXCIsXG4gICAgICBcIm1kaFwiOiBcIm1kaC1MYXRuLVBIXCIsXG4gICAgICBcIm1kalwiOiBcIm1kai1MYXRuLVpaXCIsXG4gICAgICBcIm1kclwiOiBcIm1kci1MYXRuLUlEXCIsXG4gICAgICBcIm1keFwiOiBcIm1keC1FdGhpLVpaXCIsXG4gICAgICBcIm1lZFwiOiBcIm1lZC1MYXRuLVpaXCIsXG4gICAgICBcIm1lZVwiOiBcIm1lZS1MYXRuLVpaXCIsXG4gICAgICBcIm1la1wiOiBcIm1lay1MYXRuLVpaXCIsXG4gICAgICBcIm1lblwiOiBcIm1lbi1MYXRuLVNMXCIsXG4gICAgICBcIm1lclwiOiBcIm1lci1MYXRuLUtFXCIsXG4gICAgICBcIm1ldFwiOiBcIm1ldC1MYXRuLVpaXCIsXG4gICAgICBcIm1ldVwiOiBcIm1ldS1MYXRuLVpaXCIsXG4gICAgICBcIm1mYVwiOiBcIm1mYS1BcmFiLVRIXCIsXG4gICAgICBcIm1mZVwiOiBcIm1mZS1MYXRuLU1VXCIsXG4gICAgICBcIm1mblwiOiBcIm1mbi1MYXRuLVpaXCIsXG4gICAgICBcIm1mb1wiOiBcIm1mby1MYXRuLVpaXCIsXG4gICAgICBcIm1mcVwiOiBcIm1mcS1MYXRuLVpaXCIsXG4gICAgICBcIm1nXCI6IFwibWctTGF0bi1NR1wiLFxuICAgICAgXCJtZ2hcIjogXCJtZ2gtTGF0bi1NWlwiLFxuICAgICAgXCJtZ2xcIjogXCJtZ2wtTGF0bi1aWlwiLFxuICAgICAgXCJtZ29cIjogXCJtZ28tTGF0bi1DTVwiLFxuICAgICAgXCJtZ3BcIjogXCJtZ3AtRGV2YS1OUFwiLFxuICAgICAgXCJtZ3lcIjogXCJtZ3ktTGF0bi1UWlwiLFxuICAgICAgXCJtaFwiOiBcIm1oLUxhdG4tTUhcIixcbiAgICAgIFwibWhpXCI6IFwibWhpLUxhdG4tWlpcIixcbiAgICAgIFwibWhsXCI6IFwibWhsLUxhdG4tWlpcIixcbiAgICAgIFwibWlcIjogXCJtaS1MYXRuLU5aXCIsXG4gICAgICBcIm1pZlwiOiBcIm1pZi1MYXRuLVpaXCIsXG4gICAgICBcIm1pblwiOiBcIm1pbi1MYXRuLUlEXCIsXG4gICAgICBcIm1pc1wiOiBcIm1pcy1IYXRyLUlRXCIsXG4gICAgICBcIm1pcy1NZWRmXCI6IFwibWlzLU1lZGYtTkdcIixcbiAgICAgIFwibWl3XCI6IFwibWl3LUxhdG4tWlpcIixcbiAgICAgIFwibWtcIjogXCJtay1DeXJsLU1LXCIsXG4gICAgICBcIm1raVwiOiBcIm1raS1BcmFiLVpaXCIsXG4gICAgICBcIm1rbFwiOiBcIm1rbC1MYXRuLVpaXCIsXG4gICAgICBcIm1rcFwiOiBcIm1rcC1MYXRuLVpaXCIsXG4gICAgICBcIm1rd1wiOiBcIm1rdy1MYXRuLVpaXCIsXG4gICAgICBcIm1sXCI6IFwibWwtTWx5bS1JTlwiLFxuICAgICAgXCJtbGVcIjogXCJtbGUtTGF0bi1aWlwiLFxuICAgICAgXCJtbHBcIjogXCJtbHAtTGF0bi1aWlwiLFxuICAgICAgXCJtbHNcIjogXCJtbHMtTGF0bi1TRFwiLFxuICAgICAgXCJtbW9cIjogXCJtbW8tTGF0bi1aWlwiLFxuICAgICAgXCJtbXVcIjogXCJtbXUtTGF0bi1aWlwiLFxuICAgICAgXCJtbXhcIjogXCJtbXgtTGF0bi1aWlwiLFxuICAgICAgXCJtblwiOiBcIm1uLUN5cmwtTU5cIixcbiAgICAgIFwibW4tQ05cIjogXCJtbi1Nb25nLUNOXCIsXG4gICAgICBcIm1uLU1vbmdcIjogXCJtbi1Nb25nLUNOXCIsXG4gICAgICBcIm1uYVwiOiBcIm1uYS1MYXRuLVpaXCIsXG4gICAgICBcIm1uZlwiOiBcIm1uZi1MYXRuLVpaXCIsXG4gICAgICBcIm1uaVwiOiBcIm1uaS1CZW5nLUlOXCIsXG4gICAgICBcIm1ud1wiOiBcIm1udy1NeW1yLU1NXCIsXG4gICAgICBcIm1vXCI6IFwibW8tTGF0bi1ST1wiLFxuICAgICAgXCJtb2FcIjogXCJtb2EtTGF0bi1aWlwiLFxuICAgICAgXCJtb2VcIjogXCJtb2UtTGF0bi1DQVwiLFxuICAgICAgXCJtb2hcIjogXCJtb2gtTGF0bi1DQVwiLFxuICAgICAgXCJtb3NcIjogXCJtb3MtTGF0bi1CRlwiLFxuICAgICAgXCJtb3hcIjogXCJtb3gtTGF0bi1aWlwiLFxuICAgICAgXCJtcHBcIjogXCJtcHAtTGF0bi1aWlwiLFxuICAgICAgXCJtcHNcIjogXCJtcHMtTGF0bi1aWlwiLFxuICAgICAgXCJtcHRcIjogXCJtcHQtTGF0bi1aWlwiLFxuICAgICAgXCJtcHhcIjogXCJtcHgtTGF0bi1aWlwiLFxuICAgICAgXCJtcWxcIjogXCJtcWwtTGF0bi1aWlwiLFxuICAgICAgXCJtclwiOiBcIm1yLURldmEtSU5cIixcbiAgICAgIFwibXJkXCI6IFwibXJkLURldmEtTlBcIixcbiAgICAgIFwibXJqXCI6IFwibXJqLUN5cmwtUlVcIixcbiAgICAgIFwibXJvXCI6IFwibXJvLU1yb28tQkRcIixcbiAgICAgIFwibXNcIjogXCJtcy1MYXRuLU1ZXCIsXG4gICAgICBcIm1zLUNDXCI6IFwibXMtQXJhYi1DQ1wiLFxuICAgICAgXCJtdFwiOiBcIm10LUxhdG4tTVRcIixcbiAgICAgIFwibXRjXCI6IFwibXRjLUxhdG4tWlpcIixcbiAgICAgIFwibXRmXCI6IFwibXRmLUxhdG4tWlpcIixcbiAgICAgIFwibXRpXCI6IFwibXRpLUxhdG4tWlpcIixcbiAgICAgIFwibXRyXCI6IFwibXRyLURldmEtSU5cIixcbiAgICAgIFwibXVhXCI6IFwibXVhLUxhdG4tQ01cIixcbiAgICAgIFwibXVyXCI6IFwibXVyLUxhdG4tWlpcIixcbiAgICAgIFwibXVzXCI6IFwibXVzLUxhdG4tVVNcIixcbiAgICAgIFwibXZhXCI6IFwibXZhLUxhdG4tWlpcIixcbiAgICAgIFwibXZuXCI6IFwibXZuLUxhdG4tWlpcIixcbiAgICAgIFwibXZ5XCI6IFwibXZ5LUFyYWItUEtcIixcbiAgICAgIFwibXdrXCI6IFwibXdrLUxhdG4tTUxcIixcbiAgICAgIFwibXdyXCI6IFwibXdyLURldmEtSU5cIixcbiAgICAgIFwibXd2XCI6IFwibXd2LUxhdG4tSURcIixcbiAgICAgIFwibXd3XCI6IFwibXd3LUhtbnAtVVNcIixcbiAgICAgIFwibXhjXCI6IFwibXhjLUxhdG4tWldcIixcbiAgICAgIFwibXhtXCI6IFwibXhtLUxhdG4tWlpcIixcbiAgICAgIFwibXlcIjogXCJteS1NeW1yLU1NXCIsXG4gICAgICBcIm15a1wiOiBcIm15ay1MYXRuLVpaXCIsXG4gICAgICBcIm15bVwiOiBcIm15bS1FdGhpLVpaXCIsXG4gICAgICBcIm15dlwiOiBcIm15di1DeXJsLVJVXCIsXG4gICAgICBcIm15d1wiOiBcIm15dy1MYXRuLVpaXCIsXG4gICAgICBcIm15eFwiOiBcIm15eC1MYXRuLVVHXCIsXG4gICAgICBcIm15elwiOiBcIm15ei1NYW5kLUlSXCIsXG4gICAgICBcIm16a1wiOiBcIm16ay1MYXRuLVpaXCIsXG4gICAgICBcIm16bVwiOiBcIm16bS1MYXRuLVpaXCIsXG4gICAgICBcIm16blwiOiBcIm16bi1BcmFiLUlSXCIsXG4gICAgICBcIm16cFwiOiBcIm16cC1MYXRuLVpaXCIsXG4gICAgICBcIm16d1wiOiBcIm16dy1MYXRuLVpaXCIsXG4gICAgICBcIm16elwiOiBcIm16ei1MYXRuLVpaXCIsXG4gICAgICBcIm5hXCI6IFwibmEtTGF0bi1OUlwiLFxuICAgICAgXCJuYWNcIjogXCJuYWMtTGF0bi1aWlwiLFxuICAgICAgXCJuYWZcIjogXCJuYWYtTGF0bi1aWlwiLFxuICAgICAgXCJuYWtcIjogXCJuYWstTGF0bi1aWlwiLFxuICAgICAgXCJuYW5cIjogXCJuYW4tSGFucy1DTlwiLFxuICAgICAgXCJuYXBcIjogXCJuYXAtTGF0bi1JVFwiLFxuICAgICAgXCJuYXFcIjogXCJuYXEtTGF0bi1OQVwiLFxuICAgICAgXCJuYXNcIjogXCJuYXMtTGF0bi1aWlwiLFxuICAgICAgXCJuYlwiOiBcIm5iLUxhdG4tTk9cIixcbiAgICAgIFwibmNhXCI6IFwibmNhLUxhdG4tWlpcIixcbiAgICAgIFwibmNlXCI6IFwibmNlLUxhdG4tWlpcIixcbiAgICAgIFwibmNmXCI6IFwibmNmLUxhdG4tWlpcIixcbiAgICAgIFwibmNoXCI6IFwibmNoLUxhdG4tTVhcIixcbiAgICAgIFwibmNvXCI6IFwibmNvLUxhdG4tWlpcIixcbiAgICAgIFwibmN1XCI6IFwibmN1LUxhdG4tWlpcIixcbiAgICAgIFwibmRcIjogXCJuZC1MYXRuLVpXXCIsXG4gICAgICBcIm5kY1wiOiBcIm5kYy1MYXRuLU1aXCIsXG4gICAgICBcIm5kc1wiOiBcIm5kcy1MYXRuLURFXCIsXG4gICAgICBcIm5lXCI6IFwibmUtRGV2YS1OUFwiLFxuICAgICAgXCJuZWJcIjogXCJuZWItTGF0bi1aWlwiLFxuICAgICAgXCJuZXdcIjogXCJuZXctRGV2YS1OUFwiLFxuICAgICAgXCJuZXhcIjogXCJuZXgtTGF0bi1aWlwiLFxuICAgICAgXCJuZnJcIjogXCJuZnItTGF0bi1aWlwiLFxuICAgICAgXCJuZ1wiOiBcIm5nLUxhdG4tTkFcIixcbiAgICAgIFwibmdhXCI6IFwibmdhLUxhdG4tWlpcIixcbiAgICAgIFwibmdiXCI6IFwibmdiLUxhdG4tWlpcIixcbiAgICAgIFwibmdsXCI6IFwibmdsLUxhdG4tTVpcIixcbiAgICAgIFwibmhiXCI6IFwibmhiLUxhdG4tWlpcIixcbiAgICAgIFwibmhlXCI6IFwibmhlLUxhdG4tTVhcIixcbiAgICAgIFwibmh3XCI6IFwibmh3LUxhdG4tTVhcIixcbiAgICAgIFwibmlmXCI6IFwibmlmLUxhdG4tWlpcIixcbiAgICAgIFwibmlpXCI6IFwibmlpLUxhdG4tWlpcIixcbiAgICAgIFwibmlqXCI6IFwibmlqLUxhdG4tSURcIixcbiAgICAgIFwibmluXCI6IFwibmluLUxhdG4tWlpcIixcbiAgICAgIFwibml1XCI6IFwibml1LUxhdG4tTlVcIixcbiAgICAgIFwibml5XCI6IFwibml5LUxhdG4tWlpcIixcbiAgICAgIFwibml6XCI6IFwibml6LUxhdG4tWlpcIixcbiAgICAgIFwibmpvXCI6IFwibmpvLUxhdG4tSU5cIixcbiAgICAgIFwibmtnXCI6IFwibmtnLUxhdG4tWlpcIixcbiAgICAgIFwibmtvXCI6IFwibmtvLUxhdG4tWlpcIixcbiAgICAgIFwibmxcIjogXCJubC1MYXRuLU5MXCIsXG4gICAgICBcIm5tZ1wiOiBcIm5tZy1MYXRuLUNNXCIsXG4gICAgICBcIm5telwiOiBcIm5tei1MYXRuLVpaXCIsXG4gICAgICBcIm5uXCI6IFwibm4tTGF0bi1OT1wiLFxuICAgICAgXCJubmZcIjogXCJubmYtTGF0bi1aWlwiLFxuICAgICAgXCJubmhcIjogXCJubmgtTGF0bi1DTVwiLFxuICAgICAgXCJubmtcIjogXCJubmstTGF0bi1aWlwiLFxuICAgICAgXCJubm1cIjogXCJubm0tTGF0bi1aWlwiLFxuICAgICAgXCJubnBcIjogXCJubnAtV2Noby1JTlwiLFxuICAgICAgXCJub1wiOiBcIm5vLUxhdG4tTk9cIixcbiAgICAgIFwibm9kXCI6IFwibm9kLUxhbmEtVEhcIixcbiAgICAgIFwibm9lXCI6IFwibm9lLURldmEtSU5cIixcbiAgICAgIFwibm9uXCI6IFwibm9uLVJ1bnItU0VcIixcbiAgICAgIFwibm9wXCI6IFwibm9wLUxhdG4tWlpcIixcbiAgICAgIFwibm91XCI6IFwibm91LUxhdG4tWlpcIixcbiAgICAgIFwibnFvXCI6IFwibnFvLU5rb28tR05cIixcbiAgICAgIFwibnJcIjogXCJuci1MYXRuLVpBXCIsXG4gICAgICBcIm5yYlwiOiBcIm5yYi1MYXRuLVpaXCIsXG4gICAgICBcIm5za1wiOiBcIm5zay1DYW5zLUNBXCIsXG4gICAgICBcIm5zblwiOiBcIm5zbi1MYXRuLVpaXCIsXG4gICAgICBcIm5zb1wiOiBcIm5zby1MYXRuLVpBXCIsXG4gICAgICBcIm5zc1wiOiBcIm5zcy1MYXRuLVpaXCIsXG4gICAgICBcIm50bVwiOiBcIm50bS1MYXRuLVpaXCIsXG4gICAgICBcIm50clwiOiBcIm50ci1MYXRuLVpaXCIsXG4gICAgICBcIm51aVwiOiBcIm51aS1MYXRuLVpaXCIsXG4gICAgICBcIm51cFwiOiBcIm51cC1MYXRuLVpaXCIsXG4gICAgICBcIm51c1wiOiBcIm51cy1MYXRuLVNTXCIsXG4gICAgICBcIm51dlwiOiBcIm51di1MYXRuLVpaXCIsXG4gICAgICBcIm51eFwiOiBcIm51eC1MYXRuLVpaXCIsXG4gICAgICBcIm52XCI6IFwibnYtTGF0bi1VU1wiLFxuICAgICAgXCJud2JcIjogXCJud2ItTGF0bi1aWlwiLFxuICAgICAgXCJueHFcIjogXCJueHEtTGF0bi1DTlwiLFxuICAgICAgXCJueHJcIjogXCJueHItTGF0bi1aWlwiLFxuICAgICAgXCJueVwiOiBcIm55LUxhdG4tTVdcIixcbiAgICAgIFwibnltXCI6IFwibnltLUxhdG4tVFpcIixcbiAgICAgIFwibnluXCI6IFwibnluLUxhdG4tVUdcIixcbiAgICAgIFwibnppXCI6IFwibnppLUxhdG4tR0hcIixcbiAgICAgIFwib2NcIjogXCJvYy1MYXRuLUZSXCIsXG4gICAgICBcIm9nY1wiOiBcIm9nYy1MYXRuLVpaXCIsXG4gICAgICBcIm9rclwiOiBcIm9rci1MYXRuLVpaXCIsXG4gICAgICBcIm9rdlwiOiBcIm9rdi1MYXRuLVpaXCIsXG4gICAgICBcIm9tXCI6IFwib20tTGF0bi1FVFwiLFxuICAgICAgXCJvbmdcIjogXCJvbmctTGF0bi1aWlwiLFxuICAgICAgXCJvbm5cIjogXCJvbm4tTGF0bi1aWlwiLFxuICAgICAgXCJvbnNcIjogXCJvbnMtTGF0bi1aWlwiLFxuICAgICAgXCJvcG1cIjogXCJvcG0tTGF0bi1aWlwiLFxuICAgICAgXCJvclwiOiBcIm9yLU9yeWEtSU5cIixcbiAgICAgIFwib3JvXCI6IFwib3JvLUxhdG4tWlpcIixcbiAgICAgIFwib3J1XCI6IFwib3J1LUFyYWItWlpcIixcbiAgICAgIFwib3NcIjogXCJvcy1DeXJsLUdFXCIsXG4gICAgICBcIm9zYVwiOiBcIm9zYS1Pc2dlLVVTXCIsXG4gICAgICBcIm90YVwiOiBcIm90YS1BcmFiLVpaXCIsXG4gICAgICBcIm90a1wiOiBcIm90ay1PcmtoLU1OXCIsXG4gICAgICBcIm96bVwiOiBcIm96bS1MYXRuLVpaXCIsXG4gICAgICBcInBhXCI6IFwicGEtR3VydS1JTlwiLFxuICAgICAgXCJwYS1BcmFiXCI6IFwicGEtQXJhYi1QS1wiLFxuICAgICAgXCJwYS1QS1wiOiBcInBhLUFyYWItUEtcIixcbiAgICAgIFwicGFnXCI6IFwicGFnLUxhdG4tUEhcIixcbiAgICAgIFwicGFsXCI6IFwicGFsLVBobGktSVJcIixcbiAgICAgIFwicGFsLVBobHBcIjogXCJwYWwtUGhscC1DTlwiLFxuICAgICAgXCJwYW1cIjogXCJwYW0tTGF0bi1QSFwiLFxuICAgICAgXCJwYXBcIjogXCJwYXAtTGF0bi1BV1wiLFxuICAgICAgXCJwYXVcIjogXCJwYXUtTGF0bi1QV1wiLFxuICAgICAgXCJwYmlcIjogXCJwYmktTGF0bi1aWlwiLFxuICAgICAgXCJwY2RcIjogXCJwY2QtTGF0bi1GUlwiLFxuICAgICAgXCJwY21cIjogXCJwY20tTGF0bi1OR1wiLFxuICAgICAgXCJwZGNcIjogXCJwZGMtTGF0bi1VU1wiLFxuICAgICAgXCJwZHRcIjogXCJwZHQtTGF0bi1DQVwiLFxuICAgICAgXCJwZWRcIjogXCJwZWQtTGF0bi1aWlwiLFxuICAgICAgXCJwZW9cIjogXCJwZW8tWHBlby1JUlwiLFxuICAgICAgXCJwZXhcIjogXCJwZXgtTGF0bi1aWlwiLFxuICAgICAgXCJwZmxcIjogXCJwZmwtTGF0bi1ERVwiLFxuICAgICAgXCJwaGxcIjogXCJwaGwtQXJhYi1aWlwiLFxuICAgICAgXCJwaG5cIjogXCJwaG4tUGhueC1MQlwiLFxuICAgICAgXCJwaWxcIjogXCJwaWwtTGF0bi1aWlwiLFxuICAgICAgXCJwaXBcIjogXCJwaXAtTGF0bi1aWlwiLFxuICAgICAgXCJwa2FcIjogXCJwa2EtQnJhaC1JTlwiLFxuICAgICAgXCJwa29cIjogXCJwa28tTGF0bi1LRVwiLFxuICAgICAgXCJwbFwiOiBcInBsLUxhdG4tUExcIixcbiAgICAgIFwicGxhXCI6IFwicGxhLUxhdG4tWlpcIixcbiAgICAgIFwicG1zXCI6IFwicG1zLUxhdG4tSVRcIixcbiAgICAgIFwicG5nXCI6IFwicG5nLUxhdG4tWlpcIixcbiAgICAgIFwicG5uXCI6IFwicG5uLUxhdG4tWlpcIixcbiAgICAgIFwicG50XCI6IFwicG50LUdyZWstR1JcIixcbiAgICAgIFwicG9uXCI6IFwicG9uLUxhdG4tRk1cIixcbiAgICAgIFwicHBhXCI6IFwicHBhLURldmEtSU5cIixcbiAgICAgIFwicHBvXCI6IFwicHBvLUxhdG4tWlpcIixcbiAgICAgIFwicHJhXCI6IFwicHJhLUtoYXItUEtcIixcbiAgICAgIFwicHJkXCI6IFwicHJkLUFyYWItSVJcIixcbiAgICAgIFwicHJnXCI6IFwicHJnLUxhdG4tMDAxXCIsXG4gICAgICBcInBzXCI6IFwicHMtQXJhYi1BRlwiLFxuICAgICAgXCJwc3NcIjogXCJwc3MtTGF0bi1aWlwiLFxuICAgICAgXCJwdFwiOiBcInB0LUxhdG4tQlJcIixcbiAgICAgIFwicHRwXCI6IFwicHRwLUxhdG4tWlpcIixcbiAgICAgIFwicHV1XCI6IFwicHV1LUxhdG4tR0FcIixcbiAgICAgIFwicHdhXCI6IFwicHdhLUxhdG4tWlpcIixcbiAgICAgIFwicXVcIjogXCJxdS1MYXRuLVBFXCIsXG4gICAgICBcInF1Y1wiOiBcInF1Yy1MYXRuLUdUXCIsXG4gICAgICBcInF1Z1wiOiBcInF1Zy1MYXRuLUVDXCIsXG4gICAgICBcInJhaVwiOiBcInJhaS1MYXRuLVpaXCIsXG4gICAgICBcInJhalwiOiBcInJhai1EZXZhLUlOXCIsXG4gICAgICBcInJhb1wiOiBcInJhby1MYXRuLVpaXCIsXG4gICAgICBcInJjZlwiOiBcInJjZi1MYXRuLVJFXCIsXG4gICAgICBcInJlalwiOiBcInJlai1MYXRuLUlEXCIsXG4gICAgICBcInJlbFwiOiBcInJlbC1MYXRuLVpaXCIsXG4gICAgICBcInJlc1wiOiBcInJlcy1MYXRuLVpaXCIsXG4gICAgICBcInJnblwiOiBcInJnbi1MYXRuLUlUXCIsXG4gICAgICBcInJoZ1wiOiBcInJoZy1BcmFiLU1NXCIsXG4gICAgICBcInJpYVwiOiBcInJpYS1MYXRuLUlOXCIsXG4gICAgICBcInJpZlwiOiBcInJpZi1UZm5nLU1BXCIsXG4gICAgICBcInJpZi1OTFwiOiBcInJpZi1MYXRuLU5MXCIsXG4gICAgICBcInJqc1wiOiBcInJqcy1EZXZhLU5QXCIsXG4gICAgICBcInJrdFwiOiBcInJrdC1CZW5nLUJEXCIsXG4gICAgICBcInJtXCI6IFwicm0tTGF0bi1DSFwiLFxuICAgICAgXCJybWZcIjogXCJybWYtTGF0bi1GSVwiLFxuICAgICAgXCJybW9cIjogXCJybW8tTGF0bi1DSFwiLFxuICAgICAgXCJybXRcIjogXCJybXQtQXJhYi1JUlwiLFxuICAgICAgXCJybXVcIjogXCJybXUtTGF0bi1TRVwiLFxuICAgICAgXCJyblwiOiBcInJuLUxhdG4tQklcIixcbiAgICAgIFwicm5hXCI6IFwicm5hLUxhdG4tWlpcIixcbiAgICAgIFwicm5nXCI6IFwicm5nLUxhdG4tTVpcIixcbiAgICAgIFwicm9cIjogXCJyby1MYXRuLVJPXCIsXG4gICAgICBcInJvYlwiOiBcInJvYi1MYXRuLUlEXCIsXG4gICAgICBcInJvZlwiOiBcInJvZi1MYXRuLVRaXCIsXG4gICAgICBcInJvb1wiOiBcInJvby1MYXRuLVpaXCIsXG4gICAgICBcInJyb1wiOiBcInJyby1MYXRuLVpaXCIsXG4gICAgICBcInJ0bVwiOiBcInJ0bS1MYXRuLUZKXCIsXG4gICAgICBcInJ1XCI6IFwicnUtQ3lybC1SVVwiLFxuICAgICAgXCJydWVcIjogXCJydWUtQ3lybC1VQVwiLFxuICAgICAgXCJydWdcIjogXCJydWctTGF0bi1TQlwiLFxuICAgICAgXCJyd1wiOiBcInJ3LUxhdG4tUldcIixcbiAgICAgIFwicndrXCI6IFwicndrLUxhdG4tVFpcIixcbiAgICAgIFwicndvXCI6IFwicndvLUxhdG4tWlpcIixcbiAgICAgIFwicnl1XCI6IFwicnl1LUthbmEtSlBcIixcbiAgICAgIFwic2FcIjogXCJzYS1EZXZhLUlOXCIsXG4gICAgICBcInNhZlwiOiBcInNhZi1MYXRuLUdIXCIsXG4gICAgICBcInNhaFwiOiBcInNhaC1DeXJsLVJVXCIsXG4gICAgICBcInNhcVwiOiBcInNhcS1MYXRuLUtFXCIsXG4gICAgICBcInNhc1wiOiBcInNhcy1MYXRuLUlEXCIsXG4gICAgICBcInNhdFwiOiBcInNhdC1PbGNrLUlOXCIsXG4gICAgICBcInNhdlwiOiBcInNhdi1MYXRuLVNOXCIsXG4gICAgICBcInNhelwiOiBcInNhei1TYXVyLUlOXCIsXG4gICAgICBcInNiYVwiOiBcInNiYS1MYXRuLVpaXCIsXG4gICAgICBcInNiZVwiOiBcInNiZS1MYXRuLVpaXCIsXG4gICAgICBcInNicFwiOiBcInNicC1MYXRuLVRaXCIsXG4gICAgICBcInNjXCI6IFwic2MtTGF0bi1JVFwiLFxuICAgICAgXCJzY2tcIjogXCJzY2stRGV2YS1JTlwiLFxuICAgICAgXCJzY2xcIjogXCJzY2wtQXJhYi1aWlwiLFxuICAgICAgXCJzY25cIjogXCJzY24tTGF0bi1JVFwiLFxuICAgICAgXCJzY29cIjogXCJzY28tTGF0bi1HQlwiLFxuICAgICAgXCJzY3NcIjogXCJzY3MtTGF0bi1DQVwiLFxuICAgICAgXCJzZFwiOiBcInNkLUFyYWItUEtcIixcbiAgICAgIFwic2QtRGV2YVwiOiBcInNkLURldmEtSU5cIixcbiAgICAgIFwic2QtS2hvalwiOiBcInNkLUtob2otSU5cIixcbiAgICAgIFwic2QtU2luZFwiOiBcInNkLVNpbmQtSU5cIixcbiAgICAgIFwic2RjXCI6IFwic2RjLUxhdG4tSVRcIixcbiAgICAgIFwic2RoXCI6IFwic2RoLUFyYWItSVJcIixcbiAgICAgIFwic2VcIjogXCJzZS1MYXRuLU5PXCIsXG4gICAgICBcInNlZlwiOiBcInNlZi1MYXRuLUNJXCIsXG4gICAgICBcInNlaFwiOiBcInNlaC1MYXRuLU1aXCIsXG4gICAgICBcInNlaVwiOiBcInNlaS1MYXRuLU1YXCIsXG4gICAgICBcInNlc1wiOiBcInNlcy1MYXRuLU1MXCIsXG4gICAgICBcInNnXCI6IFwic2ctTGF0bi1DRlwiLFxuICAgICAgXCJzZ2FcIjogXCJzZ2EtT2dhbS1JRVwiLFxuICAgICAgXCJzZ3NcIjogXCJzZ3MtTGF0bi1MVFwiLFxuICAgICAgXCJzZ3dcIjogXCJzZ3ctRXRoaS1aWlwiLFxuICAgICAgXCJzZ3pcIjogXCJzZ3otTGF0bi1aWlwiLFxuICAgICAgXCJzaGlcIjogXCJzaGktVGZuZy1NQVwiLFxuICAgICAgXCJzaGtcIjogXCJzaGstTGF0bi1aWlwiLFxuICAgICAgXCJzaG5cIjogXCJzaG4tTXltci1NTVwiLFxuICAgICAgXCJzaHVcIjogXCJzaHUtQXJhYi1aWlwiLFxuICAgICAgXCJzaVwiOiBcInNpLVNpbmgtTEtcIixcbiAgICAgIFwic2lkXCI6IFwic2lkLUxhdG4tRVRcIixcbiAgICAgIFwic2lnXCI6IFwic2lnLUxhdG4tWlpcIixcbiAgICAgIFwic2lsXCI6IFwic2lsLUxhdG4tWlpcIixcbiAgICAgIFwic2ltXCI6IFwic2ltLUxhdG4tWlpcIixcbiAgICAgIFwic2pyXCI6IFwic2pyLUxhdG4tWlpcIixcbiAgICAgIFwic2tcIjogXCJzay1MYXRuLVNLXCIsXG4gICAgICBcInNrY1wiOiBcInNrYy1MYXRuLVpaXCIsXG4gICAgICBcInNrclwiOiBcInNrci1BcmFiLVBLXCIsXG4gICAgICBcInNrc1wiOiBcInNrcy1MYXRuLVpaXCIsXG4gICAgICBcInNsXCI6IFwic2wtTGF0bi1TSVwiLFxuICAgICAgXCJzbGRcIjogXCJzbGQtTGF0bi1aWlwiLFxuICAgICAgXCJzbGlcIjogXCJzbGktTGF0bi1QTFwiLFxuICAgICAgXCJzbGxcIjogXCJzbGwtTGF0bi1aWlwiLFxuICAgICAgXCJzbHlcIjogXCJzbHktTGF0bi1JRFwiLFxuICAgICAgXCJzbVwiOiBcInNtLUxhdG4tV1NcIixcbiAgICAgIFwic21hXCI6IFwic21hLUxhdG4tU0VcIixcbiAgICAgIFwic21qXCI6IFwic21qLUxhdG4tU0VcIixcbiAgICAgIFwic21uXCI6IFwic21uLUxhdG4tRklcIixcbiAgICAgIFwic21wXCI6IFwic21wLVNhbXItSUxcIixcbiAgICAgIFwic21xXCI6IFwic21xLUxhdG4tWlpcIixcbiAgICAgIFwic21zXCI6IFwic21zLUxhdG4tRklcIixcbiAgICAgIFwic25cIjogXCJzbi1MYXRuLVpXXCIsXG4gICAgICBcInNuY1wiOiBcInNuYy1MYXRuLVpaXCIsXG4gICAgICBcInNua1wiOiBcInNuay1MYXRuLU1MXCIsXG4gICAgICBcInNucFwiOiBcInNucC1MYXRuLVpaXCIsXG4gICAgICBcInNueFwiOiBcInNueC1MYXRuLVpaXCIsXG4gICAgICBcInNueVwiOiBcInNueS1MYXRuLVpaXCIsXG4gICAgICBcInNvXCI6IFwic28tTGF0bi1TT1wiLFxuICAgICAgXCJzb2dcIjogXCJzb2ctU29nZC1VWlwiLFxuICAgICAgXCJzb2tcIjogXCJzb2stTGF0bi1aWlwiLFxuICAgICAgXCJzb3FcIjogXCJzb3EtTGF0bi1aWlwiLFxuICAgICAgXCJzb3VcIjogXCJzb3UtVGhhaS1USFwiLFxuICAgICAgXCJzb3lcIjogXCJzb3ktTGF0bi1aWlwiLFxuICAgICAgXCJzcGRcIjogXCJzcGQtTGF0bi1aWlwiLFxuICAgICAgXCJzcGxcIjogXCJzcGwtTGF0bi1aWlwiLFxuICAgICAgXCJzcHNcIjogXCJzcHMtTGF0bi1aWlwiLFxuICAgICAgXCJzcVwiOiBcInNxLUxhdG4tQUxcIixcbiAgICAgIFwic3JcIjogXCJzci1DeXJsLVJTXCIsXG4gICAgICBcInNyLU1FXCI6IFwic3ItTGF0bi1NRVwiLFxuICAgICAgXCJzci1ST1wiOiBcInNyLUxhdG4tUk9cIixcbiAgICAgIFwic3ItUlVcIjogXCJzci1MYXRuLVJVXCIsXG4gICAgICBcInNyLVRSXCI6IFwic3ItTGF0bi1UUlwiLFxuICAgICAgXCJzcmJcIjogXCJzcmItU29yYS1JTlwiLFxuICAgICAgXCJzcm5cIjogXCJzcm4tTGF0bi1TUlwiLFxuICAgICAgXCJzcnJcIjogXCJzcnItTGF0bi1TTlwiLFxuICAgICAgXCJzcnhcIjogXCJzcngtRGV2YS1JTlwiLFxuICAgICAgXCJzc1wiOiBcInNzLUxhdG4tWkFcIixcbiAgICAgIFwic3NkXCI6IFwic3NkLUxhdG4tWlpcIixcbiAgICAgIFwic3NnXCI6IFwic3NnLUxhdG4tWlpcIixcbiAgICAgIFwic3N5XCI6IFwic3N5LUxhdG4tRVJcIixcbiAgICAgIFwic3RcIjogXCJzdC1MYXRuLVpBXCIsXG4gICAgICBcInN0a1wiOiBcInN0ay1MYXRuLVpaXCIsXG4gICAgICBcInN0cVwiOiBcInN0cS1MYXRuLURFXCIsXG4gICAgICBcInN1XCI6IFwic3UtTGF0bi1JRFwiLFxuICAgICAgXCJzdWFcIjogXCJzdWEtTGF0bi1aWlwiLFxuICAgICAgXCJzdWVcIjogXCJzdWUtTGF0bi1aWlwiLFxuICAgICAgXCJzdWtcIjogXCJzdWstTGF0bi1UWlwiLFxuICAgICAgXCJzdXJcIjogXCJzdXItTGF0bi1aWlwiLFxuICAgICAgXCJzdXNcIjogXCJzdXMtTGF0bi1HTlwiLFxuICAgICAgXCJzdlwiOiBcInN2LUxhdG4tU0VcIixcbiAgICAgIFwic3dcIjogXCJzdy1MYXRuLVRaXCIsXG4gICAgICBcInN3YlwiOiBcInN3Yi1BcmFiLVlUXCIsXG4gICAgICBcInN3Y1wiOiBcInN3Yy1MYXRuLUNEXCIsXG4gICAgICBcInN3Z1wiOiBcInN3Zy1MYXRuLURFXCIsXG4gICAgICBcInN3cFwiOiBcInN3cC1MYXRuLVpaXCIsXG4gICAgICBcInN3dlwiOiBcInN3di1EZXZhLUlOXCIsXG4gICAgICBcInN4blwiOiBcInN4bi1MYXRuLUlEXCIsXG4gICAgICBcInN4d1wiOiBcInN4dy1MYXRuLVpaXCIsXG4gICAgICBcInN5bFwiOiBcInN5bC1CZW5nLUJEXCIsXG4gICAgICBcInN5clwiOiBcInN5ci1TeXJjLUlRXCIsXG4gICAgICBcInN6bFwiOiBcInN6bC1MYXRuLVBMXCIsXG4gICAgICBcInRhXCI6IFwidGEtVGFtbC1JTlwiLFxuICAgICAgXCJ0YWpcIjogXCJ0YWotRGV2YS1OUFwiLFxuICAgICAgXCJ0YWxcIjogXCJ0YWwtTGF0bi1aWlwiLFxuICAgICAgXCJ0YW5cIjogXCJ0YW4tTGF0bi1aWlwiLFxuICAgICAgXCJ0YXFcIjogXCJ0YXEtTGF0bi1aWlwiLFxuICAgICAgXCJ0YmNcIjogXCJ0YmMtTGF0bi1aWlwiLFxuICAgICAgXCJ0YmRcIjogXCJ0YmQtTGF0bi1aWlwiLFxuICAgICAgXCJ0YmZcIjogXCJ0YmYtTGF0bi1aWlwiLFxuICAgICAgXCJ0YmdcIjogXCJ0YmctTGF0bi1aWlwiLFxuICAgICAgXCJ0Ym9cIjogXCJ0Ym8tTGF0bi1aWlwiLFxuICAgICAgXCJ0YndcIjogXCJ0YnctTGF0bi1QSFwiLFxuICAgICAgXCJ0YnpcIjogXCJ0YnotTGF0bi1aWlwiLFxuICAgICAgXCJ0Y2lcIjogXCJ0Y2ktTGF0bi1aWlwiLFxuICAgICAgXCJ0Y3lcIjogXCJ0Y3ktS25kYS1JTlwiLFxuICAgICAgXCJ0ZGRcIjogXCJ0ZGQtVGFsZS1DTlwiLFxuICAgICAgXCJ0ZGdcIjogXCJ0ZGctRGV2YS1OUFwiLFxuICAgICAgXCJ0ZGhcIjogXCJ0ZGgtRGV2YS1OUFwiLFxuICAgICAgXCJ0ZHVcIjogXCJ0ZHUtTGF0bi1NWVwiLFxuICAgICAgXCJ0ZVwiOiBcInRlLVRlbHUtSU5cIixcbiAgICAgIFwidGVkXCI6IFwidGVkLUxhdG4tWlpcIixcbiAgICAgIFwidGVtXCI6IFwidGVtLUxhdG4tU0xcIixcbiAgICAgIFwidGVvXCI6IFwidGVvLUxhdG4tVUdcIixcbiAgICAgIFwidGV0XCI6IFwidGV0LUxhdG4tVExcIixcbiAgICAgIFwidGZpXCI6IFwidGZpLUxhdG4tWlpcIixcbiAgICAgIFwidGdcIjogXCJ0Zy1DeXJsLVRKXCIsXG4gICAgICBcInRnLUFyYWJcIjogXCJ0Zy1BcmFiLVBLXCIsXG4gICAgICBcInRnLVBLXCI6IFwidGctQXJhYi1QS1wiLFxuICAgICAgXCJ0Z2NcIjogXCJ0Z2MtTGF0bi1aWlwiLFxuICAgICAgXCJ0Z29cIjogXCJ0Z28tTGF0bi1aWlwiLFxuICAgICAgXCJ0Z3VcIjogXCJ0Z3UtTGF0bi1aWlwiLFxuICAgICAgXCJ0aFwiOiBcInRoLVRoYWktVEhcIixcbiAgICAgIFwidGhsXCI6IFwidGhsLURldmEtTlBcIixcbiAgICAgIFwidGhxXCI6IFwidGhxLURldmEtTlBcIixcbiAgICAgIFwidGhyXCI6IFwidGhyLURldmEtTlBcIixcbiAgICAgIFwidGlcIjogXCJ0aS1FdGhpLUVUXCIsXG4gICAgICBcInRpZlwiOiBcInRpZi1MYXRuLVpaXCIsXG4gICAgICBcInRpZ1wiOiBcInRpZy1FdGhpLUVSXCIsXG4gICAgICBcInRpa1wiOiBcInRpay1MYXRuLVpaXCIsXG4gICAgICBcInRpbVwiOiBcInRpbS1MYXRuLVpaXCIsXG4gICAgICBcInRpb1wiOiBcInRpby1MYXRuLVpaXCIsXG4gICAgICBcInRpdlwiOiBcInRpdi1MYXRuLU5HXCIsXG4gICAgICBcInRrXCI6IFwidGstTGF0bi1UTVwiLFxuICAgICAgXCJ0a2xcIjogXCJ0a2wtTGF0bi1US1wiLFxuICAgICAgXCJ0a3JcIjogXCJ0a3ItTGF0bi1BWlwiLFxuICAgICAgXCJ0a3RcIjogXCJ0a3QtRGV2YS1OUFwiLFxuICAgICAgXCJ0bFwiOiBcInRsLUxhdG4tUEhcIixcbiAgICAgIFwidGxmXCI6IFwidGxmLUxhdG4tWlpcIixcbiAgICAgIFwidGx4XCI6IFwidGx4LUxhdG4tWlpcIixcbiAgICAgIFwidGx5XCI6IFwidGx5LUxhdG4tQVpcIixcbiAgICAgIFwidG1oXCI6IFwidG1oLUxhdG4tTkVcIixcbiAgICAgIFwidG15XCI6IFwidG15LUxhdG4tWlpcIixcbiAgICAgIFwidG5cIjogXCJ0bi1MYXRuLVpBXCIsXG4gICAgICBcInRuaFwiOiBcInRuaC1MYXRuLVpaXCIsXG4gICAgICBcInRvXCI6IFwidG8tTGF0bi1UT1wiLFxuICAgICAgXCJ0b2ZcIjogXCJ0b2YtTGF0bi1aWlwiLFxuICAgICAgXCJ0b2dcIjogXCJ0b2ctTGF0bi1NV1wiLFxuICAgICAgXCJ0b3FcIjogXCJ0b3EtTGF0bi1aWlwiLFxuICAgICAgXCJ0cGlcIjogXCJ0cGktTGF0bi1QR1wiLFxuICAgICAgXCJ0cG1cIjogXCJ0cG0tTGF0bi1aWlwiLFxuICAgICAgXCJ0cHpcIjogXCJ0cHotTGF0bi1aWlwiLFxuICAgICAgXCJ0cW9cIjogXCJ0cW8tTGF0bi1aWlwiLFxuICAgICAgXCJ0clwiOiBcInRyLUxhdG4tVFJcIixcbiAgICAgIFwidHJ1XCI6IFwidHJ1LUxhdG4tVFJcIixcbiAgICAgIFwidHJ2XCI6IFwidHJ2LUxhdG4tVFdcIixcbiAgICAgIFwidHJ3XCI6IFwidHJ3LUFyYWItUEtcIixcbiAgICAgIFwidHNcIjogXCJ0cy1MYXRuLVpBXCIsXG4gICAgICBcInRzZFwiOiBcInRzZC1HcmVrLUdSXCIsXG4gICAgICBcInRzZlwiOiBcInRzZi1EZXZhLU5QXCIsXG4gICAgICBcInRzZ1wiOiBcInRzZy1MYXRuLVBIXCIsXG4gICAgICBcInRzalwiOiBcInRzai1UaWJ0LUJUXCIsXG4gICAgICBcInRzd1wiOiBcInRzdy1MYXRuLVpaXCIsXG4gICAgICBcInR0XCI6IFwidHQtQ3lybC1SVVwiLFxuICAgICAgXCJ0dGRcIjogXCJ0dGQtTGF0bi1aWlwiLFxuICAgICAgXCJ0dGVcIjogXCJ0dGUtTGF0bi1aWlwiLFxuICAgICAgXCJ0dGpcIjogXCJ0dGotTGF0bi1VR1wiLFxuICAgICAgXCJ0dHJcIjogXCJ0dHItTGF0bi1aWlwiLFxuICAgICAgXCJ0dHNcIjogXCJ0dHMtVGhhaS1USFwiLFxuICAgICAgXCJ0dHRcIjogXCJ0dHQtTGF0bi1BWlwiLFxuICAgICAgXCJ0dWhcIjogXCJ0dWgtTGF0bi1aWlwiLFxuICAgICAgXCJ0dWxcIjogXCJ0dWwtTGF0bi1aWlwiLFxuICAgICAgXCJ0dW1cIjogXCJ0dW0tTGF0bi1NV1wiLFxuICAgICAgXCJ0dXFcIjogXCJ0dXEtTGF0bi1aWlwiLFxuICAgICAgXCJ0dmRcIjogXCJ0dmQtTGF0bi1aWlwiLFxuICAgICAgXCJ0dmxcIjogXCJ0dmwtTGF0bi1UVlwiLFxuICAgICAgXCJ0dnVcIjogXCJ0dnUtTGF0bi1aWlwiLFxuICAgICAgXCJ0d2hcIjogXCJ0d2gtTGF0bi1aWlwiLFxuICAgICAgXCJ0d3FcIjogXCJ0d3EtTGF0bi1ORVwiLFxuICAgICAgXCJ0eGdcIjogXCJ0eGctVGFuZy1DTlwiLFxuICAgICAgXCJ0eVwiOiBcInR5LUxhdG4tUEZcIixcbiAgICAgIFwidHlhXCI6IFwidHlhLUxhdG4tWlpcIixcbiAgICAgIFwidHl2XCI6IFwidHl2LUN5cmwtUlVcIixcbiAgICAgIFwidHptXCI6IFwidHptLUxhdG4tTUFcIixcbiAgICAgIFwidWJ1XCI6IFwidWJ1LUxhdG4tWlpcIixcbiAgICAgIFwidWRtXCI6IFwidWRtLUN5cmwtUlVcIixcbiAgICAgIFwidWdcIjogXCJ1Zy1BcmFiLUNOXCIsXG4gICAgICBcInVnLUN5cmxcIjogXCJ1Zy1DeXJsLUtaXCIsXG4gICAgICBcInVnLUtaXCI6IFwidWctQ3lybC1LWlwiLFxuICAgICAgXCJ1Zy1NTlwiOiBcInVnLUN5cmwtTU5cIixcbiAgICAgIFwidWdhXCI6IFwidWdhLVVnYXItU1lcIixcbiAgICAgIFwidWtcIjogXCJ1ay1DeXJsLVVBXCIsXG4gICAgICBcInVsaVwiOiBcInVsaS1MYXRuLUZNXCIsXG4gICAgICBcInVtYlwiOiBcInVtYi1MYXRuLUFPXCIsXG4gICAgICBcInVuZFwiOiBcImVuLUxhdG4tVVNcIixcbiAgICAgIFwidW5kLTAwMlwiOiBcImVuLUxhdG4tTkdcIixcbiAgICAgIFwidW5kLTAwM1wiOiBcImVuLUxhdG4tVVNcIixcbiAgICAgIFwidW5kLTAwNVwiOiBcInB0LUxhdG4tQlJcIixcbiAgICAgIFwidW5kLTAwOVwiOiBcImVuLUxhdG4tQVVcIixcbiAgICAgIFwidW5kLTAxMVwiOiBcImVuLUxhdG4tTkdcIixcbiAgICAgIFwidW5kLTAxM1wiOiBcImVzLUxhdG4tTVhcIixcbiAgICAgIFwidW5kLTAxNFwiOiBcInN3LUxhdG4tVFpcIixcbiAgICAgIFwidW5kLTAxNVwiOiBcImFyLUFyYWItRUdcIixcbiAgICAgIFwidW5kLTAxN1wiOiBcInN3LUxhdG4tQ0RcIixcbiAgICAgIFwidW5kLTAxOFwiOiBcImVuLUxhdG4tWkFcIixcbiAgICAgIFwidW5kLTAxOVwiOiBcImVuLUxhdG4tVVNcIixcbiAgICAgIFwidW5kLTAyMVwiOiBcImVuLUxhdG4tVVNcIixcbiAgICAgIFwidW5kLTAyOVwiOiBcImVzLUxhdG4tQ1VcIixcbiAgICAgIFwidW5kLTAzMFwiOiBcInpoLUhhbnMtQ05cIixcbiAgICAgIFwidW5kLTAzNFwiOiBcImhpLURldmEtSU5cIixcbiAgICAgIFwidW5kLTAzNVwiOiBcImlkLUxhdG4tSURcIixcbiAgICAgIFwidW5kLTAzOVwiOiBcIml0LUxhdG4tSVRcIixcbiAgICAgIFwidW5kLTA1M1wiOiBcImVuLUxhdG4tQVVcIixcbiAgICAgIFwidW5kLTA1NFwiOiBcImVuLUxhdG4tUEdcIixcbiAgICAgIFwidW5kLTA1N1wiOiBcImVuLUxhdG4tR1VcIixcbiAgICAgIFwidW5kLTA2MVwiOiBcInNtLUxhdG4tV1NcIixcbiAgICAgIFwidW5kLTE0MlwiOiBcInpoLUhhbnMtQ05cIixcbiAgICAgIFwidW5kLTE0M1wiOiBcInV6LUxhdG4tVVpcIixcbiAgICAgIFwidW5kLTE0NVwiOiBcImFyLUFyYWItU0FcIixcbiAgICAgIFwidW5kLTE1MFwiOiBcInJ1LUN5cmwtUlVcIixcbiAgICAgIFwidW5kLTE1MVwiOiBcInJ1LUN5cmwtUlVcIixcbiAgICAgIFwidW5kLTE1NFwiOiBcImVuLUxhdG4tR0JcIixcbiAgICAgIFwidW5kLTE1NVwiOiBcImRlLUxhdG4tREVcIixcbiAgICAgIFwidW5kLTIwMlwiOiBcImVuLUxhdG4tTkdcIixcbiAgICAgIFwidW5kLTQxOVwiOiBcImVzLUxhdG4tNDE5XCIsXG4gICAgICBcInVuZC1BRFwiOiBcImNhLUxhdG4tQURcIixcbiAgICAgIFwidW5kLUFkbG1cIjogXCJmZi1BZGxtLUdOXCIsXG4gICAgICBcInVuZC1BRVwiOiBcImFyLUFyYWItQUVcIixcbiAgICAgIFwidW5kLUFGXCI6IFwiZmEtQXJhYi1BRlwiLFxuICAgICAgXCJ1bmQtQWdoYlwiOiBcImxlei1BZ2hiLVJVXCIsXG4gICAgICBcInVuZC1BaG9tXCI6IFwiYWhvLUFob20tSU5cIixcbiAgICAgIFwidW5kLUFMXCI6IFwic3EtTGF0bi1BTFwiLFxuICAgICAgXCJ1bmQtQU1cIjogXCJoeS1Bcm1uLUFNXCIsXG4gICAgICBcInVuZC1BT1wiOiBcInB0LUxhdG4tQU9cIixcbiAgICAgIFwidW5kLUFRXCI6IFwidW5kLUxhdG4tQVFcIixcbiAgICAgIFwidW5kLUFSXCI6IFwiZXMtTGF0bi1BUlwiLFxuICAgICAgXCJ1bmQtQXJhYlwiOiBcImFyLUFyYWItRUdcIixcbiAgICAgIFwidW5kLUFyYWItQ0NcIjogXCJtcy1BcmFiLUNDXCIsXG4gICAgICBcInVuZC1BcmFiLUNOXCI6IFwidWctQXJhYi1DTlwiLFxuICAgICAgXCJ1bmQtQXJhYi1HQlwiOiBcImtzLUFyYWItR0JcIixcbiAgICAgIFwidW5kLUFyYWItSURcIjogXCJtcy1BcmFiLUlEXCIsXG4gICAgICBcInVuZC1BcmFiLUlOXCI6IFwidXItQXJhYi1JTlwiLFxuICAgICAgXCJ1bmQtQXJhYi1LSFwiOiBcImNqYS1BcmFiLUtIXCIsXG4gICAgICBcInVuZC1BcmFiLU1NXCI6IFwicmhnLUFyYWItTU1cIixcbiAgICAgIFwidW5kLUFyYWItTU5cIjogXCJray1BcmFiLU1OXCIsXG4gICAgICBcInVuZC1BcmFiLU1VXCI6IFwidXItQXJhYi1NVVwiLFxuICAgICAgXCJ1bmQtQXJhYi1OR1wiOiBcImhhLUFyYWItTkdcIixcbiAgICAgIFwidW5kLUFyYWItUEtcIjogXCJ1ci1BcmFiLVBLXCIsXG4gICAgICBcInVuZC1BcmFiLVRHXCI6IFwiYXBkLUFyYWItVEdcIixcbiAgICAgIFwidW5kLUFyYWItVEhcIjogXCJtZmEtQXJhYi1USFwiLFxuICAgICAgXCJ1bmQtQXJhYi1USlwiOiBcImZhLUFyYWItVEpcIixcbiAgICAgIFwidW5kLUFyYWItVFJcIjogXCJhei1BcmFiLVRSXCIsXG4gICAgICBcInVuZC1BcmFiLVlUXCI6IFwic3diLUFyYWItWVRcIixcbiAgICAgIFwidW5kLUFybWlcIjogXCJhcmMtQXJtaS1JUlwiLFxuICAgICAgXCJ1bmQtQXJtblwiOiBcImh5LUFybW4tQU1cIixcbiAgICAgIFwidW5kLUFTXCI6IFwic20tTGF0bi1BU1wiLFxuICAgICAgXCJ1bmQtQVRcIjogXCJkZS1MYXRuLUFUXCIsXG4gICAgICBcInVuZC1BdnN0XCI6IFwiYWUtQXZzdC1JUlwiLFxuICAgICAgXCJ1bmQtQVdcIjogXCJubC1MYXRuLUFXXCIsXG4gICAgICBcInVuZC1BWFwiOiBcInN2LUxhdG4tQVhcIixcbiAgICAgIFwidW5kLUFaXCI6IFwiYXotTGF0bi1BWlwiLFxuICAgICAgXCJ1bmQtQkFcIjogXCJicy1MYXRuLUJBXCIsXG4gICAgICBcInVuZC1CYWxpXCI6IFwiYmFuLUJhbGktSURcIixcbiAgICAgIFwidW5kLUJhbXVcIjogXCJiYXgtQmFtdS1DTVwiLFxuICAgICAgXCJ1bmQtQmFzc1wiOiBcImJzcS1CYXNzLUxSXCIsXG4gICAgICBcInVuZC1CYXRrXCI6IFwiYmJjLUJhdGstSURcIixcbiAgICAgIFwidW5kLUJEXCI6IFwiYm4tQmVuZy1CRFwiLFxuICAgICAgXCJ1bmQtQkVcIjogXCJubC1MYXRuLUJFXCIsXG4gICAgICBcInVuZC1CZW5nXCI6IFwiYm4tQmVuZy1CRFwiLFxuICAgICAgXCJ1bmQtQkZcIjogXCJmci1MYXRuLUJGXCIsXG4gICAgICBcInVuZC1CR1wiOiBcImJnLUN5cmwtQkdcIixcbiAgICAgIFwidW5kLUJIXCI6IFwiYXItQXJhYi1CSFwiLFxuICAgICAgXCJ1bmQtQmhrc1wiOiBcInNhLUJoa3MtSU5cIixcbiAgICAgIFwidW5kLUJJXCI6IFwicm4tTGF0bi1CSVwiLFxuICAgICAgXCJ1bmQtQkpcIjogXCJmci1MYXRuLUJKXCIsXG4gICAgICBcInVuZC1CTFwiOiBcImZyLUxhdG4tQkxcIixcbiAgICAgIFwidW5kLUJOXCI6IFwibXMtTGF0bi1CTlwiLFxuICAgICAgXCJ1bmQtQk9cIjogXCJlcy1MYXRuLUJPXCIsXG4gICAgICBcInVuZC1Cb3BvXCI6IFwiemgtQm9wby1UV1wiLFxuICAgICAgXCJ1bmQtQlFcIjogXCJwYXAtTGF0bi1CUVwiLFxuICAgICAgXCJ1bmQtQlJcIjogXCJwdC1MYXRuLUJSXCIsXG4gICAgICBcInVuZC1CcmFoXCI6IFwicGthLUJyYWgtSU5cIixcbiAgICAgIFwidW5kLUJyYWlcIjogXCJmci1CcmFpLUZSXCIsXG4gICAgICBcInVuZC1CVFwiOiBcImR6LVRpYnQtQlRcIixcbiAgICAgIFwidW5kLUJ1Z2lcIjogXCJidWctQnVnaS1JRFwiLFxuICAgICAgXCJ1bmQtQnVoZFwiOiBcImJrdS1CdWhkLVBIXCIsXG4gICAgICBcInVuZC1CVlwiOiBcInVuZC1MYXRuLUJWXCIsXG4gICAgICBcInVuZC1CWVwiOiBcImJlLUN5cmwtQllcIixcbiAgICAgIFwidW5kLUNha21cIjogXCJjY3AtQ2FrbS1CRFwiLFxuICAgICAgXCJ1bmQtQ2Fuc1wiOiBcImNyLUNhbnMtQ0FcIixcbiAgICAgIFwidW5kLUNhcmlcIjogXCJ4Y3ItQ2FyaS1UUlwiLFxuICAgICAgXCJ1bmQtQ0RcIjogXCJzdy1MYXRuLUNEXCIsXG4gICAgICBcInVuZC1DRlwiOiBcImZyLUxhdG4tQ0ZcIixcbiAgICAgIFwidW5kLUNHXCI6IFwiZnItTGF0bi1DR1wiLFxuICAgICAgXCJ1bmQtQ0hcIjogXCJkZS1MYXRuLUNIXCIsXG4gICAgICBcInVuZC1DaGFtXCI6IFwiY2ptLUNoYW0tVk5cIixcbiAgICAgIFwidW5kLUNoZXJcIjogXCJjaHItQ2hlci1VU1wiLFxuICAgICAgXCJ1bmQtQ2hyc1wiOiBcInhjby1DaHJzLVVaXCIsXG4gICAgICBcInVuZC1DSVwiOiBcImZyLUxhdG4tQ0lcIixcbiAgICAgIFwidW5kLUNMXCI6IFwiZXMtTGF0bi1DTFwiLFxuICAgICAgXCJ1bmQtQ01cIjogXCJmci1MYXRuLUNNXCIsXG4gICAgICBcInVuZC1DTlwiOiBcInpoLUhhbnMtQ05cIixcbiAgICAgIFwidW5kLUNPXCI6IFwiZXMtTGF0bi1DT1wiLFxuICAgICAgXCJ1bmQtQ29wdFwiOiBcImNvcC1Db3B0LUVHXCIsXG4gICAgICBcInVuZC1DUFwiOiBcInVuZC1MYXRuLUNQXCIsXG4gICAgICBcInVuZC1DcHJ0XCI6IFwiZ3JjLUNwcnQtQ1lcIixcbiAgICAgIFwidW5kLUNSXCI6IFwiZXMtTGF0bi1DUlwiLFxuICAgICAgXCJ1bmQtQ1VcIjogXCJlcy1MYXRuLUNVXCIsXG4gICAgICBcInVuZC1DVlwiOiBcInB0LUxhdG4tQ1ZcIixcbiAgICAgIFwidW5kLUNXXCI6IFwicGFwLUxhdG4tQ1dcIixcbiAgICAgIFwidW5kLUNZXCI6IFwiZWwtR3Jlay1DWVwiLFxuICAgICAgXCJ1bmQtQ3lybFwiOiBcInJ1LUN5cmwtUlVcIixcbiAgICAgIFwidW5kLUN5cmwtQUxcIjogXCJtay1DeXJsLUFMXCIsXG4gICAgICBcInVuZC1DeXJsLUJBXCI6IFwic3ItQ3lybC1CQVwiLFxuICAgICAgXCJ1bmQtQ3lybC1HRVwiOiBcIm9zLUN5cmwtR0VcIixcbiAgICAgIFwidW5kLUN5cmwtR1JcIjogXCJtay1DeXJsLUdSXCIsXG4gICAgICBcInVuZC1DeXJsLU1EXCI6IFwidWstQ3lybC1NRFwiLFxuICAgICAgXCJ1bmQtQ3lybC1ST1wiOiBcImJnLUN5cmwtUk9cIixcbiAgICAgIFwidW5kLUN5cmwtU0tcIjogXCJ1ay1DeXJsLVNLXCIsXG4gICAgICBcInVuZC1DeXJsLVRSXCI6IFwia2JkLUN5cmwtVFJcIixcbiAgICAgIFwidW5kLUN5cmwtWEtcIjogXCJzci1DeXJsLVhLXCIsXG4gICAgICBcInVuZC1DWlwiOiBcImNzLUxhdG4tQ1pcIixcbiAgICAgIFwidW5kLURFXCI6IFwiZGUtTGF0bi1ERVwiLFxuICAgICAgXCJ1bmQtRGV2YVwiOiBcImhpLURldmEtSU5cIixcbiAgICAgIFwidW5kLURldmEtQlRcIjogXCJuZS1EZXZhLUJUXCIsXG4gICAgICBcInVuZC1EZXZhLUZKXCI6IFwiaGlmLURldmEtRkpcIixcbiAgICAgIFwidW5kLURldmEtTVVcIjogXCJiaG8tRGV2YS1NVVwiLFxuICAgICAgXCJ1bmQtRGV2YS1QS1wiOiBcImJ0di1EZXZhLVBLXCIsXG4gICAgICBcInVuZC1EaWFrXCI6IFwiZHYtRGlhay1NVlwiLFxuICAgICAgXCJ1bmQtREpcIjogXCJhYS1MYXRuLURKXCIsXG4gICAgICBcInVuZC1ES1wiOiBcImRhLUxhdG4tREtcIixcbiAgICAgIFwidW5kLURPXCI6IFwiZXMtTGF0bi1ET1wiLFxuICAgICAgXCJ1bmQtRG9nclwiOiBcImRvaS1Eb2dyLUlOXCIsXG4gICAgICBcInVuZC1EdXBsXCI6IFwiZnItRHVwbC1GUlwiLFxuICAgICAgXCJ1bmQtRFpcIjogXCJhci1BcmFiLURaXCIsXG4gICAgICBcInVuZC1FQVwiOiBcImVzLUxhdG4tRUFcIixcbiAgICAgIFwidW5kLUVDXCI6IFwiZXMtTGF0bi1FQ1wiLFxuICAgICAgXCJ1bmQtRUVcIjogXCJldC1MYXRuLUVFXCIsXG4gICAgICBcInVuZC1FR1wiOiBcImFyLUFyYWItRUdcIixcbiAgICAgIFwidW5kLUVneXBcIjogXCJlZ3ktRWd5cC1FR1wiLFxuICAgICAgXCJ1bmQtRUhcIjogXCJhci1BcmFiLUVIXCIsXG4gICAgICBcInVuZC1FbGJhXCI6IFwic3EtRWxiYS1BTFwiLFxuICAgICAgXCJ1bmQtRWx5bVwiOiBcImFyYy1FbHltLUlSXCIsXG4gICAgICBcInVuZC1FUlwiOiBcInRpLUV0aGktRVJcIixcbiAgICAgIFwidW5kLUVTXCI6IFwiZXMtTGF0bi1FU1wiLFxuICAgICAgXCJ1bmQtRVRcIjogXCJhbS1FdGhpLUVUXCIsXG4gICAgICBcInVuZC1FdGhpXCI6IFwiYW0tRXRoaS1FVFwiLFxuICAgICAgXCJ1bmQtRVVcIjogXCJlbi1MYXRuLUlFXCIsXG4gICAgICBcInVuZC1FWlwiOiBcImRlLUxhdG4tRVpcIixcbiAgICAgIFwidW5kLUZJXCI6IFwiZmktTGF0bi1GSVwiLFxuICAgICAgXCJ1bmQtRk9cIjogXCJmby1MYXRuLUZPXCIsXG4gICAgICBcInVuZC1GUlwiOiBcImZyLUxhdG4tRlJcIixcbiAgICAgIFwidW5kLUdBXCI6IFwiZnItTGF0bi1HQVwiLFxuICAgICAgXCJ1bmQtR0VcIjogXCJrYS1HZW9yLUdFXCIsXG4gICAgICBcInVuZC1HZW9yXCI6IFwia2EtR2Vvci1HRVwiLFxuICAgICAgXCJ1bmQtR0ZcIjogXCJmci1MYXRuLUdGXCIsXG4gICAgICBcInVuZC1HSFwiOiBcImFrLUxhdG4tR0hcIixcbiAgICAgIFwidW5kLUdMXCI6IFwia2wtTGF0bi1HTFwiLFxuICAgICAgXCJ1bmQtR2xhZ1wiOiBcImN1LUdsYWctQkdcIixcbiAgICAgIFwidW5kLUdOXCI6IFwiZnItTGF0bi1HTlwiLFxuICAgICAgXCJ1bmQtR29uZ1wiOiBcIndzZy1Hb25nLUlOXCIsXG4gICAgICBcInVuZC1Hb25tXCI6IFwiZXNnLUdvbm0tSU5cIixcbiAgICAgIFwidW5kLUdvdGhcIjogXCJnb3QtR290aC1VQVwiLFxuICAgICAgXCJ1bmQtR1BcIjogXCJmci1MYXRuLUdQXCIsXG4gICAgICBcInVuZC1HUVwiOiBcImVzLUxhdG4tR1FcIixcbiAgICAgIFwidW5kLUdSXCI6IFwiZWwtR3Jlay1HUlwiLFxuICAgICAgXCJ1bmQtR3JhblwiOiBcInNhLUdyYW4tSU5cIixcbiAgICAgIFwidW5kLUdyZWtcIjogXCJlbC1HcmVrLUdSXCIsXG4gICAgICBcInVuZC1HcmVrLVRSXCI6IFwiYmd4LUdyZWstVFJcIixcbiAgICAgIFwidW5kLUdTXCI6IFwidW5kLUxhdG4tR1NcIixcbiAgICAgIFwidW5kLUdUXCI6IFwiZXMtTGF0bi1HVFwiLFxuICAgICAgXCJ1bmQtR3VqclwiOiBcImd1LUd1anItSU5cIixcbiAgICAgIFwidW5kLUd1cnVcIjogXCJwYS1HdXJ1LUlOXCIsXG4gICAgICBcInVuZC1HV1wiOiBcInB0LUxhdG4tR1dcIixcbiAgICAgIFwidW5kLUhhbmJcIjogXCJ6aC1IYW5iLVRXXCIsXG4gICAgICBcInVuZC1IYW5nXCI6IFwia28tSGFuZy1LUlwiLFxuICAgICAgXCJ1bmQtSGFuaVwiOiBcInpoLUhhbmktQ05cIixcbiAgICAgIFwidW5kLUhhbm9cIjogXCJobm4tSGFuby1QSFwiLFxuICAgICAgXCJ1bmQtSGFuc1wiOiBcInpoLUhhbnMtQ05cIixcbiAgICAgIFwidW5kLUhhbnRcIjogXCJ6aC1IYW50LVRXXCIsXG4gICAgICBcInVuZC1IYXRyXCI6IFwibWlzLUhhdHItSVFcIixcbiAgICAgIFwidW5kLUhlYnJcIjogXCJoZS1IZWJyLUlMXCIsXG4gICAgICBcInVuZC1IZWJyLUNBXCI6IFwieWktSGVici1DQVwiLFxuICAgICAgXCJ1bmQtSGVici1HQlwiOiBcInlpLUhlYnItR0JcIixcbiAgICAgIFwidW5kLUhlYnItU0VcIjogXCJ5aS1IZWJyLVNFXCIsXG4gICAgICBcInVuZC1IZWJyLVVBXCI6IFwieWktSGVici1VQVwiLFxuICAgICAgXCJ1bmQtSGVici1VU1wiOiBcInlpLUhlYnItVVNcIixcbiAgICAgIFwidW5kLUhpcmFcIjogXCJqYS1IaXJhLUpQXCIsXG4gICAgICBcInVuZC1IS1wiOiBcInpoLUhhbnQtSEtcIixcbiAgICAgIFwidW5kLUhsdXdcIjogXCJobHUtSGx1dy1UUlwiLFxuICAgICAgXCJ1bmQtSE1cIjogXCJ1bmQtTGF0bi1ITVwiLFxuICAgICAgXCJ1bmQtSG1uZ1wiOiBcImhuai1IbW5nLUxBXCIsXG4gICAgICBcInVuZC1IbW5wXCI6IFwibXd3LUhtbnAtVVNcIixcbiAgICAgIFwidW5kLUhOXCI6IFwiZXMtTGF0bi1ITlwiLFxuICAgICAgXCJ1bmQtSFJcIjogXCJoci1MYXRuLUhSXCIsXG4gICAgICBcInVuZC1IVFwiOiBcImh0LUxhdG4tSFRcIixcbiAgICAgIFwidW5kLUhVXCI6IFwiaHUtTGF0bi1IVVwiLFxuICAgICAgXCJ1bmQtSHVuZ1wiOiBcImh1LUh1bmctSFVcIixcbiAgICAgIFwidW5kLUlDXCI6IFwiZXMtTGF0bi1JQ1wiLFxuICAgICAgXCJ1bmQtSURcIjogXCJpZC1MYXRuLUlEXCIsXG4gICAgICBcInVuZC1JTFwiOiBcImhlLUhlYnItSUxcIixcbiAgICAgIFwidW5kLUlOXCI6IFwiaGktRGV2YS1JTlwiLFxuICAgICAgXCJ1bmQtSVFcIjogXCJhci1BcmFiLUlRXCIsXG4gICAgICBcInVuZC1JUlwiOiBcImZhLUFyYWItSVJcIixcbiAgICAgIFwidW5kLUlTXCI6IFwiaXMtTGF0bi1JU1wiLFxuICAgICAgXCJ1bmQtSVRcIjogXCJpdC1MYXRuLUlUXCIsXG4gICAgICBcInVuZC1JdGFsXCI6IFwiZXR0LUl0YWwtSVRcIixcbiAgICAgIFwidW5kLUphbW9cIjogXCJrby1KYW1vLUtSXCIsXG4gICAgICBcInVuZC1KYXZhXCI6IFwianYtSmF2YS1JRFwiLFxuICAgICAgXCJ1bmQtSk9cIjogXCJhci1BcmFiLUpPXCIsXG4gICAgICBcInVuZC1KUFwiOiBcImphLUpwYW4tSlBcIixcbiAgICAgIFwidW5kLUpwYW5cIjogXCJqYS1KcGFuLUpQXCIsXG4gICAgICBcInVuZC1LYWxpXCI6IFwiZWt5LUthbGktTU1cIixcbiAgICAgIFwidW5kLUthbmFcIjogXCJqYS1LYW5hLUpQXCIsXG4gICAgICBcInVuZC1LRVwiOiBcInN3LUxhdG4tS0VcIixcbiAgICAgIFwidW5kLUtHXCI6IFwia3ktQ3lybC1LR1wiLFxuICAgICAgXCJ1bmQtS0hcIjogXCJrbS1LaG1yLUtIXCIsXG4gICAgICBcInVuZC1LaGFyXCI6IFwicHJhLUtoYXItUEtcIixcbiAgICAgIFwidW5kLUtobXJcIjogXCJrbS1LaG1yLUtIXCIsXG4gICAgICBcInVuZC1LaG9qXCI6IFwic2QtS2hvai1JTlwiLFxuICAgICAgXCJ1bmQtS2l0c1wiOiBcInprdC1LaXRzLUNOXCIsXG4gICAgICBcInVuZC1LTVwiOiBcImFyLUFyYWItS01cIixcbiAgICAgIFwidW5kLUtuZGFcIjogXCJrbi1LbmRhLUlOXCIsXG4gICAgICBcInVuZC1Lb3JlXCI6IFwia28tS29yZS1LUlwiLFxuICAgICAgXCJ1bmQtS1BcIjogXCJrby1Lb3JlLUtQXCIsXG4gICAgICBcInVuZC1LUlwiOiBcImtvLUtvcmUtS1JcIixcbiAgICAgIFwidW5kLUt0aGlcIjogXCJiaG8tS3RoaS1JTlwiLFxuICAgICAgXCJ1bmQtS1dcIjogXCJhci1BcmFiLUtXXCIsXG4gICAgICBcInVuZC1LWlwiOiBcInJ1LUN5cmwtS1pcIixcbiAgICAgIFwidW5kLUxBXCI6IFwibG8tTGFvby1MQVwiLFxuICAgICAgXCJ1bmQtTGFuYVwiOiBcIm5vZC1MYW5hLVRIXCIsXG4gICAgICBcInVuZC1MYW9vXCI6IFwibG8tTGFvby1MQVwiLFxuICAgICAgXCJ1bmQtTGF0bi1BRlwiOiBcInRrLUxhdG4tQUZcIixcbiAgICAgIFwidW5kLUxhdG4tQU1cIjogXCJrdS1MYXRuLUFNXCIsXG4gICAgICBcInVuZC1MYXRuLUNOXCI6IFwiemEtTGF0bi1DTlwiLFxuICAgICAgXCJ1bmQtTGF0bi1DWVwiOiBcInRyLUxhdG4tQ1lcIixcbiAgICAgIFwidW5kLUxhdG4tRFpcIjogXCJmci1MYXRuLURaXCIsXG4gICAgICBcInVuZC1MYXRuLUVUXCI6IFwiZW4tTGF0bi1FVFwiLFxuICAgICAgXCJ1bmQtTGF0bi1HRVwiOiBcImt1LUxhdG4tR0VcIixcbiAgICAgIFwidW5kLUxhdG4tSVJcIjogXCJ0ay1MYXRuLUlSXCIsXG4gICAgICBcInVuZC1MYXRuLUtNXCI6IFwiZnItTGF0bi1LTVwiLFxuICAgICAgXCJ1bmQtTGF0bi1NQVwiOiBcImZyLUxhdG4tTUFcIixcbiAgICAgIFwidW5kLUxhdG4tTUtcIjogXCJzcS1MYXRuLU1LXCIsXG4gICAgICBcInVuZC1MYXRuLU1NXCI6IFwia2FjLUxhdG4tTU1cIixcbiAgICAgIFwidW5kLUxhdG4tTU9cIjogXCJwdC1MYXRuLU1PXCIsXG4gICAgICBcInVuZC1MYXRuLU1SXCI6IFwiZnItTGF0bi1NUlwiLFxuICAgICAgXCJ1bmQtTGF0bi1SVVwiOiBcImtybC1MYXRuLVJVXCIsXG4gICAgICBcInVuZC1MYXRuLVNZXCI6IFwiZnItTGF0bi1TWVwiLFxuICAgICAgXCJ1bmQtTGF0bi1UTlwiOiBcImZyLUxhdG4tVE5cIixcbiAgICAgIFwidW5kLUxhdG4tVFdcIjogXCJ0cnYtTGF0bi1UV1wiLFxuICAgICAgXCJ1bmQtTGF0bi1VQVwiOiBcInBsLUxhdG4tVUFcIixcbiAgICAgIFwidW5kLUxCXCI6IFwiYXItQXJhYi1MQlwiLFxuICAgICAgXCJ1bmQtTGVwY1wiOiBcImxlcC1MZXBjLUlOXCIsXG4gICAgICBcInVuZC1MSVwiOiBcImRlLUxhdG4tTElcIixcbiAgICAgIFwidW5kLUxpbWJcIjogXCJsaWYtTGltYi1JTlwiLFxuICAgICAgXCJ1bmQtTGluYVwiOiBcImxhYi1MaW5hLUdSXCIsXG4gICAgICBcInVuZC1MaW5iXCI6IFwiZ3JjLUxpbmItR1JcIixcbiAgICAgIFwidW5kLUxpc3VcIjogXCJsaXMtTGlzdS1DTlwiLFxuICAgICAgXCJ1bmQtTEtcIjogXCJzaS1TaW5oLUxLXCIsXG4gICAgICBcInVuZC1MU1wiOiBcInN0LUxhdG4tTFNcIixcbiAgICAgIFwidW5kLUxUXCI6IFwibHQtTGF0bi1MVFwiLFxuICAgICAgXCJ1bmQtTFVcIjogXCJmci1MYXRuLUxVXCIsXG4gICAgICBcInVuZC1MVlwiOiBcImx2LUxhdG4tTFZcIixcbiAgICAgIFwidW5kLUxZXCI6IFwiYXItQXJhYi1MWVwiLFxuICAgICAgXCJ1bmQtTHljaVwiOiBcInhsYy1MeWNpLVRSXCIsXG4gICAgICBcInVuZC1MeWRpXCI6IFwieGxkLUx5ZGktVFJcIixcbiAgICAgIFwidW5kLU1BXCI6IFwiYXItQXJhYi1NQVwiLFxuICAgICAgXCJ1bmQtTWFoalwiOiBcImhpLU1haGotSU5cIixcbiAgICAgIFwidW5kLU1ha2FcIjogXCJtYWstTWFrYS1JRFwiLFxuICAgICAgXCJ1bmQtTWFuZFwiOiBcIm15ei1NYW5kLUlSXCIsXG4gICAgICBcInVuZC1NYW5pXCI6IFwieG1uLU1hbmktQ05cIixcbiAgICAgIFwidW5kLU1hcmNcIjogXCJiby1NYXJjLUNOXCIsXG4gICAgICBcInVuZC1NQ1wiOiBcImZyLUxhdG4tTUNcIixcbiAgICAgIFwidW5kLU1EXCI6IFwicm8tTGF0bi1NRFwiLFxuICAgICAgXCJ1bmQtTUVcIjogXCJzci1MYXRuLU1FXCIsXG4gICAgICBcInVuZC1NZWRmXCI6IFwibWlzLU1lZGYtTkdcIixcbiAgICAgIFwidW5kLU1lbmRcIjogXCJtZW4tTWVuZC1TTFwiLFxuICAgICAgXCJ1bmQtTWVyY1wiOiBcInhtci1NZXJjLVNEXCIsXG4gICAgICBcInVuZC1NZXJvXCI6IFwieG1yLU1lcm8tU0RcIixcbiAgICAgIFwidW5kLU1GXCI6IFwiZnItTGF0bi1NRlwiLFxuICAgICAgXCJ1bmQtTUdcIjogXCJtZy1MYXRuLU1HXCIsXG4gICAgICBcInVuZC1NS1wiOiBcIm1rLUN5cmwtTUtcIixcbiAgICAgIFwidW5kLU1MXCI6IFwiYm0tTGF0bi1NTFwiLFxuICAgICAgXCJ1bmQtTWx5bVwiOiBcIm1sLU1seW0tSU5cIixcbiAgICAgIFwidW5kLU1NXCI6IFwibXktTXltci1NTVwiLFxuICAgICAgXCJ1bmQtTU5cIjogXCJtbi1DeXJsLU1OXCIsXG4gICAgICBcInVuZC1NT1wiOiBcInpoLUhhbnQtTU9cIixcbiAgICAgIFwidW5kLU1vZGlcIjogXCJtci1Nb2RpLUlOXCIsXG4gICAgICBcInVuZC1Nb25nXCI6IFwibW4tTW9uZy1DTlwiLFxuICAgICAgXCJ1bmQtTVFcIjogXCJmci1MYXRuLU1RXCIsXG4gICAgICBcInVuZC1NUlwiOiBcImFyLUFyYWItTVJcIixcbiAgICAgIFwidW5kLU1yb29cIjogXCJtcm8tTXJvby1CRFwiLFxuICAgICAgXCJ1bmQtTVRcIjogXCJtdC1MYXRuLU1UXCIsXG4gICAgICBcInVuZC1NdGVpXCI6IFwibW5pLU10ZWktSU5cIixcbiAgICAgIFwidW5kLU1VXCI6IFwibWZlLUxhdG4tTVVcIixcbiAgICAgIFwidW5kLU11bHRcIjogXCJza3ItTXVsdC1QS1wiLFxuICAgICAgXCJ1bmQtTVZcIjogXCJkdi1UaGFhLU1WXCIsXG4gICAgICBcInVuZC1NWFwiOiBcImVzLUxhdG4tTVhcIixcbiAgICAgIFwidW5kLU1ZXCI6IFwibXMtTGF0bi1NWVwiLFxuICAgICAgXCJ1bmQtTXltclwiOiBcIm15LU15bXItTU1cIixcbiAgICAgIFwidW5kLU15bXItSU5cIjogXCJraHQtTXltci1JTlwiLFxuICAgICAgXCJ1bmQtTXltci1USFwiOiBcIm1udy1NeW1yLVRIXCIsXG4gICAgICBcInVuZC1NWlwiOiBcInB0LUxhdG4tTVpcIixcbiAgICAgIFwidW5kLU5BXCI6IFwiYWYtTGF0bi1OQVwiLFxuICAgICAgXCJ1bmQtTmFuZFwiOiBcInNhLU5hbmQtSU5cIixcbiAgICAgIFwidW5kLU5hcmJcIjogXCJ4bmEtTmFyYi1TQVwiLFxuICAgICAgXCJ1bmQtTmJhdFwiOiBcImFyYy1OYmF0LUpPXCIsXG4gICAgICBcInVuZC1OQ1wiOiBcImZyLUxhdG4tTkNcIixcbiAgICAgIFwidW5kLU5FXCI6IFwiaGEtTGF0bi1ORVwiLFxuICAgICAgXCJ1bmQtTmV3YVwiOiBcIm5ldy1OZXdhLU5QXCIsXG4gICAgICBcInVuZC1OSVwiOiBcImVzLUxhdG4tTklcIixcbiAgICAgIFwidW5kLU5rb29cIjogXCJtYW4tTmtvby1HTlwiLFxuICAgICAgXCJ1bmQtTkxcIjogXCJubC1MYXRuLU5MXCIsXG4gICAgICBcInVuZC1OT1wiOiBcIm5iLUxhdG4tTk9cIixcbiAgICAgIFwidW5kLU5QXCI6IFwibmUtRGV2YS1OUFwiLFxuICAgICAgXCJ1bmQtTnNodVwiOiBcInpoeC1Oc2h1LUNOXCIsXG4gICAgICBcInVuZC1PZ2FtXCI6IFwic2dhLU9nYW0tSUVcIixcbiAgICAgIFwidW5kLU9sY2tcIjogXCJzYXQtT2xjay1JTlwiLFxuICAgICAgXCJ1bmQtT01cIjogXCJhci1BcmFiLU9NXCIsXG4gICAgICBcInVuZC1PcmtoXCI6IFwib3RrLU9ya2gtTU5cIixcbiAgICAgIFwidW5kLU9yeWFcIjogXCJvci1PcnlhLUlOXCIsXG4gICAgICBcInVuZC1Pc2dlXCI6IFwib3NhLU9zZ2UtVVNcIixcbiAgICAgIFwidW5kLU9zbWFcIjogXCJzby1Pc21hLVNPXCIsXG4gICAgICBcInVuZC1QQVwiOiBcImVzLUxhdG4tUEFcIixcbiAgICAgIFwidW5kLVBhbG1cIjogXCJhcmMtUGFsbS1TWVwiLFxuICAgICAgXCJ1bmQtUGF1Y1wiOiBcImN0ZC1QYXVjLU1NXCIsXG4gICAgICBcInVuZC1QRVwiOiBcImVzLUxhdG4tUEVcIixcbiAgICAgIFwidW5kLVBlcm1cIjogXCJrdi1QZXJtLVJVXCIsXG4gICAgICBcInVuZC1QRlwiOiBcImZyLUxhdG4tUEZcIixcbiAgICAgIFwidW5kLVBHXCI6IFwidHBpLUxhdG4tUEdcIixcbiAgICAgIFwidW5kLVBIXCI6IFwiZmlsLUxhdG4tUEhcIixcbiAgICAgIFwidW5kLVBoYWdcIjogXCJsemgtUGhhZy1DTlwiLFxuICAgICAgXCJ1bmQtUGhsaVwiOiBcInBhbC1QaGxpLUlSXCIsXG4gICAgICBcInVuZC1QaGxwXCI6IFwicGFsLVBobHAtQ05cIixcbiAgICAgIFwidW5kLVBobnhcIjogXCJwaG4tUGhueC1MQlwiLFxuICAgICAgXCJ1bmQtUEtcIjogXCJ1ci1BcmFiLVBLXCIsXG4gICAgICBcInVuZC1QTFwiOiBcInBsLUxhdG4tUExcIixcbiAgICAgIFwidW5kLVBscmRcIjogXCJobWQtUGxyZC1DTlwiLFxuICAgICAgXCJ1bmQtUE1cIjogXCJmci1MYXRuLVBNXCIsXG4gICAgICBcInVuZC1QUlwiOiBcImVzLUxhdG4tUFJcIixcbiAgICAgIFwidW5kLVBydGlcIjogXCJ4cHItUHJ0aS1JUlwiLFxuICAgICAgXCJ1bmQtUFNcIjogXCJhci1BcmFiLVBTXCIsXG4gICAgICBcInVuZC1QVFwiOiBcInB0LUxhdG4tUFRcIixcbiAgICAgIFwidW5kLVBXXCI6IFwicGF1LUxhdG4tUFdcIixcbiAgICAgIFwidW5kLVBZXCI6IFwiZ24tTGF0bi1QWVwiLFxuICAgICAgXCJ1bmQtUUFcIjogXCJhci1BcmFiLVFBXCIsXG4gICAgICBcInVuZC1RT1wiOiBcImVuLUxhdG4tREdcIixcbiAgICAgIFwidW5kLVJFXCI6IFwiZnItTGF0bi1SRVwiLFxuICAgICAgXCJ1bmQtUmpuZ1wiOiBcInJlai1Sam5nLUlEXCIsXG4gICAgICBcInVuZC1ST1wiOiBcInJvLUxhdG4tUk9cIixcbiAgICAgIFwidW5kLVJvaGdcIjogXCJyaGctUm9oZy1NTVwiLFxuICAgICAgXCJ1bmQtUlNcIjogXCJzci1DeXJsLVJTXCIsXG4gICAgICBcInVuZC1SVVwiOiBcInJ1LUN5cmwtUlVcIixcbiAgICAgIFwidW5kLVJ1bnJcIjogXCJub24tUnVuci1TRVwiLFxuICAgICAgXCJ1bmQtUldcIjogXCJydy1MYXRuLVJXXCIsXG4gICAgICBcInVuZC1TQVwiOiBcImFyLUFyYWItU0FcIixcbiAgICAgIFwidW5kLVNhbXJcIjogXCJzbXAtU2Ftci1JTFwiLFxuICAgICAgXCJ1bmQtU2FyYlwiOiBcInhzYS1TYXJiLVlFXCIsXG4gICAgICBcInVuZC1TYXVyXCI6IFwic2F6LVNhdXItSU5cIixcbiAgICAgIFwidW5kLVNDXCI6IFwiZnItTGF0bi1TQ1wiLFxuICAgICAgXCJ1bmQtU0RcIjogXCJhci1BcmFiLVNEXCIsXG4gICAgICBcInVuZC1TRVwiOiBcInN2LUxhdG4tU0VcIixcbiAgICAgIFwidW5kLVNnbndcIjogXCJhc2UtU2dudy1VU1wiLFxuICAgICAgXCJ1bmQtU2hhd1wiOiBcImVuLVNoYXctR0JcIixcbiAgICAgIFwidW5kLVNocmRcIjogXCJzYS1TaHJkLUlOXCIsXG4gICAgICBcInVuZC1TSVwiOiBcInNsLUxhdG4tU0lcIixcbiAgICAgIFwidW5kLVNpZGRcIjogXCJzYS1TaWRkLUlOXCIsXG4gICAgICBcInVuZC1TaW5kXCI6IFwic2QtU2luZC1JTlwiLFxuICAgICAgXCJ1bmQtU2luaFwiOiBcInNpLVNpbmgtTEtcIixcbiAgICAgIFwidW5kLVNKXCI6IFwibmItTGF0bi1TSlwiLFxuICAgICAgXCJ1bmQtU0tcIjogXCJzay1MYXRuLVNLXCIsXG4gICAgICBcInVuZC1TTVwiOiBcIml0LUxhdG4tU01cIixcbiAgICAgIFwidW5kLVNOXCI6IFwiZnItTGF0bi1TTlwiLFxuICAgICAgXCJ1bmQtU09cIjogXCJzby1MYXRuLVNPXCIsXG4gICAgICBcInVuZC1Tb2dkXCI6IFwic29nLVNvZ2QtVVpcIixcbiAgICAgIFwidW5kLVNvZ29cIjogXCJzb2ctU29nby1VWlwiLFxuICAgICAgXCJ1bmQtU29yYVwiOiBcInNyYi1Tb3JhLUlOXCIsXG4gICAgICBcInVuZC1Tb3lvXCI6IFwiY21nLVNveW8tTU5cIixcbiAgICAgIFwidW5kLVNSXCI6IFwibmwtTGF0bi1TUlwiLFxuICAgICAgXCJ1bmQtU1RcIjogXCJwdC1MYXRuLVNUXCIsXG4gICAgICBcInVuZC1TdW5kXCI6IFwic3UtU3VuZC1JRFwiLFxuICAgICAgXCJ1bmQtU1ZcIjogXCJlcy1MYXRuLVNWXCIsXG4gICAgICBcInVuZC1TWVwiOiBcImFyLUFyYWItU1lcIixcbiAgICAgIFwidW5kLVN5bG9cIjogXCJzeWwtU3lsby1CRFwiLFxuICAgICAgXCJ1bmQtU3lyY1wiOiBcInN5ci1TeXJjLUlRXCIsXG4gICAgICBcInVuZC1UYWdiXCI6IFwidGJ3LVRhZ2ItUEhcIixcbiAgICAgIFwidW5kLVRha3JcIjogXCJkb2ktVGFrci1JTlwiLFxuICAgICAgXCJ1bmQtVGFsZVwiOiBcInRkZC1UYWxlLUNOXCIsXG4gICAgICBcInVuZC1UYWx1XCI6IFwia2hiLVRhbHUtQ05cIixcbiAgICAgIFwidW5kLVRhbWxcIjogXCJ0YS1UYW1sLUlOXCIsXG4gICAgICBcInVuZC1UYW5nXCI6IFwidHhnLVRhbmctQ05cIixcbiAgICAgIFwidW5kLVRhdnRcIjogXCJibHQtVGF2dC1WTlwiLFxuICAgICAgXCJ1bmQtVERcIjogXCJmci1MYXRuLVREXCIsXG4gICAgICBcInVuZC1UZWx1XCI6IFwidGUtVGVsdS1JTlwiLFxuICAgICAgXCJ1bmQtVEZcIjogXCJmci1MYXRuLVRGXCIsXG4gICAgICBcInVuZC1UZm5nXCI6IFwiemdoLVRmbmctTUFcIixcbiAgICAgIFwidW5kLVRHXCI6IFwiZnItTGF0bi1UR1wiLFxuICAgICAgXCJ1bmQtVGdsZ1wiOiBcImZpbC1UZ2xnLVBIXCIsXG4gICAgICBcInVuZC1USFwiOiBcInRoLVRoYWktVEhcIixcbiAgICAgIFwidW5kLVRoYWFcIjogXCJkdi1UaGFhLU1WXCIsXG4gICAgICBcInVuZC1UaGFpXCI6IFwidGgtVGhhaS1USFwiLFxuICAgICAgXCJ1bmQtVGhhaS1DTlwiOiBcImxjcC1UaGFpLUNOXCIsXG4gICAgICBcInVuZC1UaGFpLUtIXCI6IFwia2R0LVRoYWktS0hcIixcbiAgICAgIFwidW5kLVRoYWktTEFcIjogXCJrZHQtVGhhaS1MQVwiLFxuICAgICAgXCJ1bmQtVGlidFwiOiBcImJvLVRpYnQtQ05cIixcbiAgICAgIFwidW5kLVRpcmhcIjogXCJtYWktVGlyaC1JTlwiLFxuICAgICAgXCJ1bmQtVEpcIjogXCJ0Zy1DeXJsLVRKXCIsXG4gICAgICBcInVuZC1US1wiOiBcInRrbC1MYXRuLVRLXCIsXG4gICAgICBcInVuZC1UTFwiOiBcInB0LUxhdG4tVExcIixcbiAgICAgIFwidW5kLVRNXCI6IFwidGstTGF0bi1UTVwiLFxuICAgICAgXCJ1bmQtVE5cIjogXCJhci1BcmFiLVROXCIsXG4gICAgICBcInVuZC1UT1wiOiBcInRvLUxhdG4tVE9cIixcbiAgICAgIFwidW5kLVRSXCI6IFwidHItTGF0bi1UUlwiLFxuICAgICAgXCJ1bmQtVFZcIjogXCJ0dmwtTGF0bi1UVlwiLFxuICAgICAgXCJ1bmQtVFdcIjogXCJ6aC1IYW50LVRXXCIsXG4gICAgICBcInVuZC1UWlwiOiBcInN3LUxhdG4tVFpcIixcbiAgICAgIFwidW5kLVVBXCI6IFwidWstQ3lybC1VQVwiLFxuICAgICAgXCJ1bmQtVUdcIjogXCJzdy1MYXRuLVVHXCIsXG4gICAgICBcInVuZC1VZ2FyXCI6IFwidWdhLVVnYXItU1lcIixcbiAgICAgIFwidW5kLVVZXCI6IFwiZXMtTGF0bi1VWVwiLFxuICAgICAgXCJ1bmQtVVpcIjogXCJ1ei1MYXRuLVVaXCIsXG4gICAgICBcInVuZC1WQVwiOiBcIml0LUxhdG4tVkFcIixcbiAgICAgIFwidW5kLVZhaWlcIjogXCJ2YWktVmFpaS1MUlwiLFxuICAgICAgXCJ1bmQtVkVcIjogXCJlcy1MYXRuLVZFXCIsXG4gICAgICBcInVuZC1WTlwiOiBcInZpLUxhdG4tVk5cIixcbiAgICAgIFwidW5kLVZVXCI6IFwiYmktTGF0bi1WVVwiLFxuICAgICAgXCJ1bmQtV2FyYVwiOiBcImhvYy1XYXJhLUlOXCIsXG4gICAgICBcInVuZC1XY2hvXCI6IFwibm5wLVdjaG8tSU5cIixcbiAgICAgIFwidW5kLVdGXCI6IFwiZnItTGF0bi1XRlwiLFxuICAgICAgXCJ1bmQtV1NcIjogXCJzbS1MYXRuLVdTXCIsXG4gICAgICBcInVuZC1YS1wiOiBcInNxLUxhdG4tWEtcIixcbiAgICAgIFwidW5kLVhwZW9cIjogXCJwZW8tWHBlby1JUlwiLFxuICAgICAgXCJ1bmQtWHN1eFwiOiBcImFray1Yc3V4LUlRXCIsXG4gICAgICBcInVuZC1ZRVwiOiBcImFyLUFyYWItWUVcIixcbiAgICAgIFwidW5kLVllemlcIjogXCJrdS1ZZXppLUdFXCIsXG4gICAgICBcInVuZC1ZaWlpXCI6IFwiaWktWWlpaS1DTlwiLFxuICAgICAgXCJ1bmQtWVRcIjogXCJmci1MYXRuLVlUXCIsXG4gICAgICBcInVuZC1aYW5iXCI6IFwiY21nLVphbmItTU5cIixcbiAgICAgIFwidW5kLVpXXCI6IFwic24tTGF0bi1aV1wiLFxuICAgICAgXCJ1bnJcIjogXCJ1bnItQmVuZy1JTlwiLFxuICAgICAgXCJ1bnItRGV2YVwiOiBcInVuci1EZXZhLU5QXCIsXG4gICAgICBcInVuci1OUFwiOiBcInVuci1EZXZhLU5QXCIsXG4gICAgICBcInVueFwiOiBcInVueC1CZW5nLUlOXCIsXG4gICAgICBcInVva1wiOiBcInVvay1MYXRuLVpaXCIsXG4gICAgICBcInVyXCI6IFwidXItQXJhYi1QS1wiLFxuICAgICAgXCJ1cmlcIjogXCJ1cmktTGF0bi1aWlwiLFxuICAgICAgXCJ1cnRcIjogXCJ1cnQtTGF0bi1aWlwiLFxuICAgICAgXCJ1cndcIjogXCJ1cnctTGF0bi1aWlwiLFxuICAgICAgXCJ1c2FcIjogXCJ1c2EtTGF0bi1aWlwiLFxuICAgICAgXCJ1dGhcIjogXCJ1dGgtTGF0bi1aWlwiLFxuICAgICAgXCJ1dHJcIjogXCJ1dHItTGF0bi1aWlwiLFxuICAgICAgXCJ1dmhcIjogXCJ1dmgtTGF0bi1aWlwiLFxuICAgICAgXCJ1dmxcIjogXCJ1dmwtTGF0bi1aWlwiLFxuICAgICAgXCJ1elwiOiBcInV6LUxhdG4tVVpcIixcbiAgICAgIFwidXotQUZcIjogXCJ1ei1BcmFiLUFGXCIsXG4gICAgICBcInV6LUFyYWJcIjogXCJ1ei1BcmFiLUFGXCIsXG4gICAgICBcInV6LUNOXCI6IFwidXotQ3lybC1DTlwiLFxuICAgICAgXCJ2YWdcIjogXCJ2YWctTGF0bi1aWlwiLFxuICAgICAgXCJ2YWlcIjogXCJ2YWktVmFpaS1MUlwiLFxuICAgICAgXCJ2YW5cIjogXCJ2YW4tTGF0bi1aWlwiLFxuICAgICAgXCJ2ZVwiOiBcInZlLUxhdG4tWkFcIixcbiAgICAgIFwidmVjXCI6IFwidmVjLUxhdG4tSVRcIixcbiAgICAgIFwidmVwXCI6IFwidmVwLUxhdG4tUlVcIixcbiAgICAgIFwidmlcIjogXCJ2aS1MYXRuLVZOXCIsXG4gICAgICBcInZpY1wiOiBcInZpYy1MYXRuLVNYXCIsXG4gICAgICBcInZpdlwiOiBcInZpdi1MYXRuLVpaXCIsXG4gICAgICBcInZsc1wiOiBcInZscy1MYXRuLUJFXCIsXG4gICAgICBcInZtZlwiOiBcInZtZi1MYXRuLURFXCIsXG4gICAgICBcInZtd1wiOiBcInZtdy1MYXRuLU1aXCIsXG4gICAgICBcInZvXCI6IFwidm8tTGF0bi0wMDFcIixcbiAgICAgIFwidm90XCI6IFwidm90LUxhdG4tUlVcIixcbiAgICAgIFwidnJvXCI6IFwidnJvLUxhdG4tRUVcIixcbiAgICAgIFwidnVuXCI6IFwidnVuLUxhdG4tVFpcIixcbiAgICAgIFwidnV0XCI6IFwidnV0LUxhdG4tWlpcIixcbiAgICAgIFwid2FcIjogXCJ3YS1MYXRuLUJFXCIsXG4gICAgICBcIndhZVwiOiBcIndhZS1MYXRuLUNIXCIsXG4gICAgICBcIndhalwiOiBcIndhai1MYXRuLVpaXCIsXG4gICAgICBcIndhbFwiOiBcIndhbC1FdGhpLUVUXCIsXG4gICAgICBcIndhblwiOiBcIndhbi1MYXRuLVpaXCIsXG4gICAgICBcIndhclwiOiBcIndhci1MYXRuLVBIXCIsXG4gICAgICBcIndicFwiOiBcIndicC1MYXRuLUFVXCIsXG4gICAgICBcIndicVwiOiBcIndicS1UZWx1LUlOXCIsXG4gICAgICBcIndiclwiOiBcIndici1EZXZhLUlOXCIsXG4gICAgICBcIndjaVwiOiBcIndjaS1MYXRuLVpaXCIsXG4gICAgICBcIndlclwiOiBcIndlci1MYXRuLVpaXCIsXG4gICAgICBcIndnaVwiOiBcIndnaS1MYXRuLVpaXCIsXG4gICAgICBcIndoZ1wiOiBcIndoZy1MYXRuLVpaXCIsXG4gICAgICBcIndpYlwiOiBcIndpYi1MYXRuLVpaXCIsXG4gICAgICBcIndpdVwiOiBcIndpdS1MYXRuLVpaXCIsXG4gICAgICBcIndpdlwiOiBcIndpdi1MYXRuLVpaXCIsXG4gICAgICBcIndqYVwiOiBcIndqYS1MYXRuLVpaXCIsXG4gICAgICBcIndqaVwiOiBcIndqaS1MYXRuLVpaXCIsXG4gICAgICBcIndsc1wiOiBcIndscy1MYXRuLVdGXCIsXG4gICAgICBcIndtb1wiOiBcIndtby1MYXRuLVpaXCIsXG4gICAgICBcInduY1wiOiBcInduYy1MYXRuLVpaXCIsXG4gICAgICBcInduaVwiOiBcInduaS1BcmFiLUtNXCIsXG4gICAgICBcIndudVwiOiBcIndudS1MYXRuLVpaXCIsXG4gICAgICBcIndvXCI6IFwid28tTGF0bi1TTlwiLFxuICAgICAgXCJ3b2JcIjogXCJ3b2ItTGF0bi1aWlwiLFxuICAgICAgXCJ3b3NcIjogXCJ3b3MtTGF0bi1aWlwiLFxuICAgICAgXCJ3cnNcIjogXCJ3cnMtTGF0bi1aWlwiLFxuICAgICAgXCJ3c2dcIjogXCJ3c2ctR29uZy1JTlwiLFxuICAgICAgXCJ3c2tcIjogXCJ3c2stTGF0bi1aWlwiLFxuICAgICAgXCJ3dG1cIjogXCJ3dG0tRGV2YS1JTlwiLFxuICAgICAgXCJ3dXVcIjogXCJ3dXUtSGFucy1DTlwiLFxuICAgICAgXCJ3dXZcIjogXCJ3dXYtTGF0bi1aWlwiLFxuICAgICAgXCJ3d2FcIjogXCJ3d2EtTGF0bi1aWlwiLFxuICAgICAgXCJ4YXZcIjogXCJ4YXYtTGF0bi1CUlwiLFxuICAgICAgXCJ4YmlcIjogXCJ4YmktTGF0bi1aWlwiLFxuICAgICAgXCJ4Y29cIjogXCJ4Y28tQ2hycy1VWlwiLFxuICAgICAgXCJ4Y3JcIjogXCJ4Y3ItQ2FyaS1UUlwiLFxuICAgICAgXCJ4ZXNcIjogXCJ4ZXMtTGF0bi1aWlwiLFxuICAgICAgXCJ4aFwiOiBcInhoLUxhdG4tWkFcIixcbiAgICAgIFwieGxhXCI6IFwieGxhLUxhdG4tWlpcIixcbiAgICAgIFwieGxjXCI6IFwieGxjLUx5Y2ktVFJcIixcbiAgICAgIFwieGxkXCI6IFwieGxkLUx5ZGktVFJcIixcbiAgICAgIFwieG1mXCI6IFwieG1mLUdlb3ItR0VcIixcbiAgICAgIFwieG1uXCI6IFwieG1uLU1hbmktQ05cIixcbiAgICAgIFwieG1yXCI6IFwieG1yLU1lcmMtU0RcIixcbiAgICAgIFwieG5hXCI6IFwieG5hLU5hcmItU0FcIixcbiAgICAgIFwieG5yXCI6IFwieG5yLURldmEtSU5cIixcbiAgICAgIFwieG9nXCI6IFwieG9nLUxhdG4tVUdcIixcbiAgICAgIFwieG9uXCI6IFwieG9uLUxhdG4tWlpcIixcbiAgICAgIFwieHByXCI6IFwieHByLVBydGktSVJcIixcbiAgICAgIFwieHJiXCI6IFwieHJiLUxhdG4tWlpcIixcbiAgICAgIFwieHNhXCI6IFwieHNhLVNhcmItWUVcIixcbiAgICAgIFwieHNpXCI6IFwieHNpLUxhdG4tWlpcIixcbiAgICAgIFwieHNtXCI6IFwieHNtLUxhdG4tWlpcIixcbiAgICAgIFwieHNyXCI6IFwieHNyLURldmEtTlBcIixcbiAgICAgIFwieHdlXCI6IFwieHdlLUxhdG4tWlpcIixcbiAgICAgIFwieWFtXCI6IFwieWFtLUxhdG4tWlpcIixcbiAgICAgIFwieWFvXCI6IFwieWFvLUxhdG4tTVpcIixcbiAgICAgIFwieWFwXCI6IFwieWFwLUxhdG4tRk1cIixcbiAgICAgIFwieWFzXCI6IFwieWFzLUxhdG4tWlpcIixcbiAgICAgIFwieWF0XCI6IFwieWF0LUxhdG4tWlpcIixcbiAgICAgIFwieWF2XCI6IFwieWF2LUxhdG4tQ01cIixcbiAgICAgIFwieWF5XCI6IFwieWF5LUxhdG4tWlpcIixcbiAgICAgIFwieWF6XCI6IFwieWF6LUxhdG4tWlpcIixcbiAgICAgIFwieWJhXCI6IFwieWJhLUxhdG4tWlpcIixcbiAgICAgIFwieWJiXCI6IFwieWJiLUxhdG4tQ01cIixcbiAgICAgIFwieWJ5XCI6IFwieWJ5LUxhdG4tWlpcIixcbiAgICAgIFwieWVyXCI6IFwieWVyLUxhdG4tWlpcIixcbiAgICAgIFwieWdyXCI6IFwieWdyLUxhdG4tWlpcIixcbiAgICAgIFwieWd3XCI6IFwieWd3LUxhdG4tWlpcIixcbiAgICAgIFwieWlcIjogXCJ5aS1IZWJyLTAwMVwiLFxuICAgICAgXCJ5a29cIjogXCJ5a28tTGF0bi1aWlwiLFxuICAgICAgXCJ5bGVcIjogXCJ5bGUtTGF0bi1aWlwiLFxuICAgICAgXCJ5bGdcIjogXCJ5bGctTGF0bi1aWlwiLFxuICAgICAgXCJ5bGxcIjogXCJ5bGwtTGF0bi1aWlwiLFxuICAgICAgXCJ5bWxcIjogXCJ5bWwtTGF0bi1aWlwiLFxuICAgICAgXCJ5b1wiOiBcInlvLUxhdG4tTkdcIixcbiAgICAgIFwieW9uXCI6IFwieW9uLUxhdG4tWlpcIixcbiAgICAgIFwieXJiXCI6IFwieXJiLUxhdG4tWlpcIixcbiAgICAgIFwieXJlXCI6IFwieXJlLUxhdG4tWlpcIixcbiAgICAgIFwieXJsXCI6IFwieXJsLUxhdG4tQlJcIixcbiAgICAgIFwieXNzXCI6IFwieXNzLUxhdG4tWlpcIixcbiAgICAgIFwieXVhXCI6IFwieXVhLUxhdG4tTVhcIixcbiAgICAgIFwieXVlXCI6IFwieXVlLUhhbnQtSEtcIixcbiAgICAgIFwieXVlLUNOXCI6IFwieXVlLUhhbnMtQ05cIixcbiAgICAgIFwieXVlLUhhbnNcIjogXCJ5dWUtSGFucy1DTlwiLFxuICAgICAgXCJ5dWpcIjogXCJ5dWotTGF0bi1aWlwiLFxuICAgICAgXCJ5dXRcIjogXCJ5dXQtTGF0bi1aWlwiLFxuICAgICAgXCJ5dXdcIjogXCJ5dXctTGF0bi1aWlwiLFxuICAgICAgXCJ6YVwiOiBcInphLUxhdG4tQ05cIixcbiAgICAgIFwiemFnXCI6IFwiemFnLUxhdG4tU0RcIixcbiAgICAgIFwiemRqXCI6IFwiemRqLUFyYWItS01cIixcbiAgICAgIFwiemVhXCI6IFwiemVhLUxhdG4tTkxcIixcbiAgICAgIFwiemdoXCI6IFwiemdoLVRmbmctTUFcIixcbiAgICAgIFwiemhcIjogXCJ6aC1IYW5zLUNOXCIsXG4gICAgICBcInpoLUFVXCI6IFwiemgtSGFudC1BVVwiLFxuICAgICAgXCJ6aC1CTlwiOiBcInpoLUhhbnQtQk5cIixcbiAgICAgIFwiemgtQm9wb1wiOiBcInpoLUJvcG8tVFdcIixcbiAgICAgIFwiemgtR0JcIjogXCJ6aC1IYW50LUdCXCIsXG4gICAgICBcInpoLUdGXCI6IFwiemgtSGFudC1HRlwiLFxuICAgICAgXCJ6aC1IYW5iXCI6IFwiemgtSGFuYi1UV1wiLFxuICAgICAgXCJ6aC1IYW50XCI6IFwiemgtSGFudC1UV1wiLFxuICAgICAgXCJ6aC1IS1wiOiBcInpoLUhhbnQtSEtcIixcbiAgICAgIFwiemgtSURcIjogXCJ6aC1IYW50LUlEXCIsXG4gICAgICBcInpoLU1PXCI6IFwiemgtSGFudC1NT1wiLFxuICAgICAgXCJ6aC1QQVwiOiBcInpoLUhhbnQtUEFcIixcbiAgICAgIFwiemgtUEZcIjogXCJ6aC1IYW50LVBGXCIsXG4gICAgICBcInpoLVBIXCI6IFwiemgtSGFudC1QSFwiLFxuICAgICAgXCJ6aC1TUlwiOiBcInpoLUhhbnQtU1JcIixcbiAgICAgIFwiemgtVEhcIjogXCJ6aC1IYW50LVRIXCIsXG4gICAgICBcInpoLVRXXCI6IFwiemgtSGFudC1UV1wiLFxuICAgICAgXCJ6aC1VU1wiOiBcInpoLUhhbnQtVVNcIixcbiAgICAgIFwiemgtVk5cIjogXCJ6aC1IYW50LVZOXCIsXG4gICAgICBcInpoeFwiOiBcInpoeC1Oc2h1LUNOXCIsXG4gICAgICBcInppYVwiOiBcInppYS1MYXRuLVpaXCIsXG4gICAgICBcInprdFwiOiBcInprdC1LaXRzLUNOXCIsXG4gICAgICBcInpsbVwiOiBcInpsbS1MYXRuLVRHXCIsXG4gICAgICBcInptaVwiOiBcInptaS1MYXRuLU1ZXCIsXG4gICAgICBcInpuZVwiOiBcInpuZS1MYXRuLVpaXCIsXG4gICAgICBcInp1XCI6IFwienUtTGF0bi1aQVwiLFxuICAgICAgXCJ6emFcIjogXCJ6emEtTGF0bi1UUlwiXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICB9IGVsc2Uge1xuICAgIF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuXG4gIF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzcztcblxuICAgIGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTtcblxuICAgICAgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgIHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuXG4gICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7XG4gIH07XG5cbiAgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShuKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2Uobykge1xuICB2YXIgaSA9IDA7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAobyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkpIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICB9O1xuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICB9XG5cbiAgaSA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xuICByZXR1cm4gaS5uZXh0LmJpbmQoaSk7XG59XG5cbi8vIHRoZXNlIGFyZW4ndCByZWFsbHkgcHJpdmF0ZSwgYnV0IG5vciBhcmUgdGhleSByZWFsbHkgdXNlZnVsIHRvIGRvY3VtZW50XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xudmFyIEx1eG9uRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHNMb29zZShMdXhvbkVycm9yLCBfRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIEx1eG9uRXJyb3IoKSB7XG4gICAgcmV0dXJuIF9FcnJvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICByZXR1cm4gTHV4b25FcnJvcjtcbn0oIC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuXG52YXIgSW52YWxpZERhdGVUaW1lRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9MdXhvbkVycm9yKSB7XG4gIF9pbmhlcml0c0xvb3NlKEludmFsaWREYXRlVGltZUVycm9yLCBfTHV4b25FcnJvcik7XG5cbiAgZnVuY3Rpb24gSW52YWxpZERhdGVUaW1lRXJyb3IocmVhc29uKSB7XG4gICAgcmV0dXJuIF9MdXhvbkVycm9yLmNhbGwodGhpcywgXCJJbnZhbGlkIERhdGVUaW1lOiBcIiArIHJlYXNvbi50b01lc3NhZ2UoKSkgfHwgdGhpcztcbiAgfVxuXG4gIHJldHVybiBJbnZhbGlkRGF0ZVRpbWVFcnJvcjtcbn0oTHV4b25FcnJvcik7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIEludmFsaWRJbnRlcnZhbEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTHV4b25FcnJvcjIpIHtcbiAgX2luaGVyaXRzTG9vc2UoSW52YWxpZEludGVydmFsRXJyb3IsIF9MdXhvbkVycm9yMik7XG5cbiAgZnVuY3Rpb24gSW52YWxpZEludGVydmFsRXJyb3IocmVhc29uKSB7XG4gICAgcmV0dXJuIF9MdXhvbkVycm9yMi5jYWxsKHRoaXMsIFwiSW52YWxpZCBJbnRlcnZhbDogXCIgKyByZWFzb24udG9NZXNzYWdlKCkpIHx8IHRoaXM7XG4gIH1cblxuICByZXR1cm4gSW52YWxpZEludGVydmFsRXJyb3I7XG59KEx1eG9uRXJyb3IpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBJbnZhbGlkRHVyYXRpb25FcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0x1eG9uRXJyb3IzKSB7XG4gIF9pbmhlcml0c0xvb3NlKEludmFsaWREdXJhdGlvbkVycm9yLCBfTHV4b25FcnJvcjMpO1xuXG4gIGZ1bmN0aW9uIEludmFsaWREdXJhdGlvbkVycm9yKHJlYXNvbikge1xuICAgIHJldHVybiBfTHV4b25FcnJvcjMuY2FsbCh0aGlzLCBcIkludmFsaWQgRHVyYXRpb246IFwiICsgcmVhc29uLnRvTWVzc2FnZSgpKSB8fCB0aGlzO1xuICB9XG5cbiAgcmV0dXJuIEludmFsaWREdXJhdGlvbkVycm9yO1xufShMdXhvbkVycm9yKTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9MdXhvbkVycm9yNCkge1xuICBfaW5oZXJpdHNMb29zZShDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvciwgX0x1eG9uRXJyb3I0KTtcblxuICBmdW5jdGlvbiBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcigpIHtcbiAgICByZXR1cm4gX0x1eG9uRXJyb3I0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHJldHVybiBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcjtcbn0oTHV4b25FcnJvcik7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIEludmFsaWRVbml0RXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9MdXhvbkVycm9yNSkge1xuICBfaW5oZXJpdHNMb29zZShJbnZhbGlkVW5pdEVycm9yLCBfTHV4b25FcnJvcjUpO1xuXG4gIGZ1bmN0aW9uIEludmFsaWRVbml0RXJyb3IodW5pdCkge1xuICAgIHJldHVybiBfTHV4b25FcnJvcjUuY2FsbCh0aGlzLCBcIkludmFsaWQgdW5pdCBcIiArIHVuaXQpIHx8IHRoaXM7XG4gIH1cblxuICByZXR1cm4gSW52YWxpZFVuaXRFcnJvcjtcbn0oTHV4b25FcnJvcik7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIEludmFsaWRBcmd1bWVudEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTHV4b25FcnJvcjYpIHtcbiAgX2luaGVyaXRzTG9vc2UoSW52YWxpZEFyZ3VtZW50RXJyb3IsIF9MdXhvbkVycm9yNik7XG5cbiAgZnVuY3Rpb24gSW52YWxpZEFyZ3VtZW50RXJyb3IoKSB7XG4gICAgcmV0dXJuIF9MdXhvbkVycm9yNi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICByZXR1cm4gSW52YWxpZEFyZ3VtZW50RXJyb3I7XG59KEx1eG9uRXJyb3IpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBab25lSXNBYnN0cmFjdEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTHV4b25FcnJvcjcpIHtcbiAgX2luaGVyaXRzTG9vc2UoWm9uZUlzQWJzdHJhY3RFcnJvciwgX0x1eG9uRXJyb3I3KTtcblxuICBmdW5jdGlvbiBab25lSXNBYnN0cmFjdEVycm9yKCkge1xuICAgIHJldHVybiBfTHV4b25FcnJvcjcuY2FsbCh0aGlzLCBcIlpvbmUgaXMgYW4gYWJzdHJhY3QgY2xhc3NcIikgfHwgdGhpcztcbiAgfVxuXG4gIHJldHVybiBab25lSXNBYnN0cmFjdEVycm9yO1xufShMdXhvbkVycm9yKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgbiA9IFwibnVtZXJpY1wiLFxuICAgIHMgPSBcInNob3J0XCIsXG4gICAgbCA9IFwibG9uZ1wiO1xudmFyIERBVEVfU0hPUlQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBuLFxuICBkYXk6IG5cbn07XG52YXIgREFURV9NRUQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG5cbn07XG52YXIgREFURV9NRURfV0lUSF9XRUVLREFZID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBzXG59O1xudmFyIERBVEVfRlVMTCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogblxufTtcbnZhciBEQVRFX0hVR0UgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IGxcbn07XG52YXIgVElNRV9TSU1QTEUgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogblxufTtcbnZhciBUSU1FX1dJVEhfU0VDT05EUyA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG5cbn07XG52YXIgVElNRV9XSVRIX1NIT1JUX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIHRpbWVab25lTmFtZTogc1xufTtcbnZhciBUSU1FX1dJVEhfTE9OR19PRkZTRVQgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IGxcbn07XG52YXIgVElNRV8yNF9TSU1QTEUgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgaG91cjEyOiBmYWxzZVxufTtcbi8qKlxuICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfTsgZm9ybWF0IGxpa2UgJzA5OjMwOjIzJywgYWx3YXlzIDI0LWhvdXIuXG4gKi9cblxudmFyIFRJTUVfMjRfV0lUSF9TRUNPTkRTID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgaG91cjEyOiBmYWxzZVxufTtcbi8qKlxuICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfTsgZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEVEVCcsIGFsd2F5cyAyNC1ob3VyLlxuICovXG5cbnZhciBUSU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgaG91cjEyOiBmYWxzZSxcbiAgdGltZVpvbmVOYW1lOiBzXG59O1xuLyoqXG4gKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9OyBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgRWFzdGVybiBEYXlsaWdodCBUaW1lJywgYWx3YXlzIDI0LWhvdXIuXG4gKi9cblxudmFyIFRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIGhvdXIxMjogZmFsc2UsXG4gIHRpbWVab25lTmFtZTogbFxufTtcbi8qKlxuICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfTsgZm9ybWF0IGxpa2UgJzEwLzE0LzE5ODMsIDk6MzAgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAqL1xuXG52YXIgREFURVRJTUVfU0hPUlQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBuLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogblxufTtcbi8qKlxuICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfTsgZm9ybWF0IGxpa2UgJzEwLzE0LzE5ODMsIDk6MzA6MzMgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAqL1xuXG52YXIgREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbixcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogblxufTtcbnZhciBEQVRFVElNRV9NRUQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogblxufTtcbnZhciBEQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogblxufTtcbnZhciBEQVRFVElNRV9NRURfV0lUSF9XRUVLREFZID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBzLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG5cbn07XG52YXIgREFURVRJTUVfRlVMTCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICB0aW1lWm9uZU5hbWU6IHNcbn07XG52YXIgREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IHNcbn07XG52YXIgREFURVRJTUVfSFVHRSA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgd2Vla2RheTogbCxcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICB0aW1lWm9uZU5hbWU6IGxcbn07XG52YXIgREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IGwsXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IGxcbn07XG5cbi8qXG4gIFRoaXMgaXMganVzdCBhIGp1bmsgZHJhd2VyLCBjb250YWluaW5nIGFueXRoaW5nIHVzZWQgYWNyb3NzIG11bHRpcGxlIGNsYXNzZXMuXG4gIEJlY2F1c2UgTHV4b24gaXMgc21hbGwoaXNoKSwgdGhpcyBzaG91bGQgc3RheSBzbWFsbCBhbmQgd2Ugd29uJ3Qgd29ycnkgYWJvdXQgc3BsaXR0aW5nXG4gIGl0IHVwIGludG8sIHNheSwgcGFyc2luZ1V0aWwuanMgYW5kIGJhc2ljVXRpbC5qcyBhbmQgc28gb24uIEJ1dCB0aGV5IGFyZSBkaXZpZGVkIHVwIGJ5IGZlYXR1cmUgYXJlYS5cbiovXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbi8vIFRZUEVTXG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSBcInVuZGVmaW5lZFwiO1xufVxuZnVuY3Rpb24gaXNOdW1iZXIobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwibnVtYmVyXCI7XG59XG5mdW5jdGlvbiBpc0ludGVnZXIobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwibnVtYmVyXCIgJiYgbyAlIDEgPT09IDA7XG59XG5mdW5jdGlvbiBpc1N0cmluZyhvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzRGF0ZShvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBEYXRlXVwiO1xufSAvLyBDQVBBQklMSVRJRVNcblxuZnVuY3Rpb24gaGFzSW50bCgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdHlwZW9mIEludGwgIT09IFwidW5kZWZpbmVkXCIgJiYgSW50bC5EYXRlVGltZUZvcm1hdDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gaGFzRm9ybWF0VG9QYXJ0cygpIHtcbiAgcmV0dXJuICFpc1VuZGVmaW5lZChJbnRsLkRhdGVUaW1lRm9ybWF0LnByb3RvdHlwZS5mb3JtYXRUb1BhcnRzKTtcbn1cbmZ1bmN0aW9uIGhhc1JlbGF0aXZlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB0eXBlb2YgSW50bCAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhIUludGwuUmVsYXRpdmVUaW1lRm9ybWF0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59IC8vIE9CSkVDVFMgQU5EIEFSUkFZU1xuXG5mdW5jdGlvbiBtYXliZUFycmF5KHRoaW5nKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHRoaW5nKSA/IHRoaW5nIDogW3RoaW5nXTtcbn1cbmZ1bmN0aW9uIGJlc3RCeShhcnIsIGJ5LCBjb21wYXJlKSB7XG4gIGlmIChhcnIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBhcnIucmVkdWNlKGZ1bmN0aW9uIChiZXN0LCBuZXh0KSB7XG4gICAgdmFyIHBhaXIgPSBbYnkobmV4dCksIG5leHRdO1xuXG4gICAgaWYgKCFiZXN0KSB7XG4gICAgICByZXR1cm4gcGFpcjtcbiAgICB9IGVsc2UgaWYgKGNvbXBhcmUoYmVzdFswXSwgcGFpclswXSkgPT09IGJlc3RbMF0pIHtcbiAgICAgIHJldHVybiBiZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFpcjtcbiAgICB9XG4gIH0sIG51bGwpWzFdO1xufVxuZnVuY3Rpb24gcGljayhvYmosIGtleXMpIHtcbiAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChhLCBrKSB7XG4gICAgYVtrXSA9IG9ialtrXTtcbiAgICByZXR1cm4gYTtcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn0gLy8gTlVNQkVSUyBBTkQgU1RSSU5HU1xuXG5mdW5jdGlvbiBpbnRlZ2VyQmV0d2Vlbih0aGluZywgYm90dG9tLCB0b3ApIHtcbiAgcmV0dXJuIGlzSW50ZWdlcih0aGluZykgJiYgdGhpbmcgPj0gYm90dG9tICYmIHRoaW5nIDw9IHRvcDtcbn0gLy8geCAlIG4gYnV0IHRha2VzIHRoZSBzaWduIG9mIG4gaW5zdGVhZCBvZiB4XG5cbmZ1bmN0aW9uIGZsb29yTW9kKHgsIG4pIHtcbiAgcmV0dXJuIHggLSBuICogTWF0aC5mbG9vcih4IC8gbik7XG59XG5mdW5jdGlvbiBwYWRTdGFydChpbnB1dCwgbikge1xuICBpZiAobiA9PT0gdm9pZCAwKSB7XG4gICAgbiA9IDI7XG4gIH1cblxuICBpZiAoaW5wdXQudG9TdHJpbmcoKS5sZW5ndGggPCBuKSB7XG4gICAgcmV0dXJuIChcIjBcIi5yZXBlYXQobikgKyBpbnB1dCkuc2xpY2UoLW4pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpbnB1dC50b1N0cmluZygpO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZUludGVnZXIoc3RyaW5nKSB7XG4gIGlmIChpc1VuZGVmaW5lZChzdHJpbmcpIHx8IHN0cmluZyA9PT0gbnVsbCB8fCBzdHJpbmcgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJzZUludChzdHJpbmcsIDEwKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VNaWxsaXMoZnJhY3Rpb24pIHtcbiAgLy8gUmV0dXJuIHVuZGVmaW5lZCAoaW5zdGVhZCBvZiAwKSBpbiB0aGVzZSBjYXNlcywgd2hlcmUgZnJhY3Rpb24gaXMgbm90IHNldFxuICBpZiAoaXNVbmRlZmluZWQoZnJhY3Rpb24pIHx8IGZyYWN0aW9uID09PSBudWxsIHx8IGZyYWN0aW9uID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZiA9IHBhcnNlRmxvYXQoXCIwLlwiICsgZnJhY3Rpb24pICogMTAwMDtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihmKTtcbiAgfVxufVxuZnVuY3Rpb24gcm91bmRUbyhudW1iZXIsIGRpZ2l0cywgdG93YXJkWmVybykge1xuICBpZiAodG93YXJkWmVybyA9PT0gdm9pZCAwKSB7XG4gICAgdG93YXJkWmVybyA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGZhY3RvciA9IE1hdGgucG93KDEwLCBkaWdpdHMpLFxuICAgICAgcm91bmRlciA9IHRvd2FyZFplcm8gPyBNYXRoLnRydW5jIDogTWF0aC5yb3VuZDtcbiAgcmV0dXJuIHJvdW5kZXIobnVtYmVyICogZmFjdG9yKSAvIGZhY3Rvcjtcbn0gLy8gREFURSBCQVNJQ1NcblxuZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbn1cbmZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbn1cbmZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gIHZhciBtb2RNb250aCA9IGZsb29yTW9kKG1vbnRoIC0gMSwgMTIpICsgMSxcbiAgICAgIG1vZFllYXIgPSB5ZWFyICsgKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG5cbiAgaWYgKG1vZE1vbnRoID09PSAyKSB7XG4gICAgcmV0dXJuIGlzTGVhcFllYXIobW9kWWVhcikgPyAyOSA6IDI4O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbMzEsIG51bGwsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXVttb2RNb250aCAtIDFdO1xuICB9XG59IC8vIGNvdmVydCBhIGNhbGVuZGFyIG9iamVjdCB0byBhIGxvY2FsIHRpbWVzdGFtcCAoZXBvY2gsIGJ1dCB3aXRoIHRoZSBvZmZzZXQgYmFrZWQgaW4pXG5cbmZ1bmN0aW9uIG9ialRvTG9jYWxUUyhvYmopIHtcbiAgdmFyIGQgPSBEYXRlLlVUQyhvYmoueWVhciwgb2JqLm1vbnRoIC0gMSwgb2JqLmRheSwgb2JqLmhvdXIsIG9iai5taW51dGUsIG9iai5zZWNvbmQsIG9iai5taWxsaXNlY29uZCk7IC8vIGZvciBsZWdhY3kgcmVhc29ucywgeWVhcnMgYmV0d2VlbiAwIGFuZCA5OSBhcmUgaW50ZXJwcmV0ZWQgYXMgMTlYWDsgcmV2ZXJ0IHRoYXRcblxuICBpZiAob2JqLnllYXIgPCAxMDAgJiYgb2JqLnllYXIgPj0gMCkge1xuICAgIGQgPSBuZXcgRGF0ZShkKTtcbiAgICBkLnNldFVUQ0Z1bGxZZWFyKGQuZ2V0VVRDRnVsbFllYXIoKSAtIDE5MDApO1xuICB9XG5cbiAgcmV0dXJuICtkO1xufVxuZnVuY3Rpb24gd2Vla3NJbldlZWtZZWFyKHdlZWtZZWFyKSB7XG4gIHZhciBwMSA9ICh3ZWVrWWVhciArIE1hdGguZmxvb3Iod2Vla1llYXIgLyA0KSAtIE1hdGguZmxvb3Iod2Vla1llYXIgLyAxMDApICsgTWF0aC5mbG9vcih3ZWVrWWVhciAvIDQwMCkpICUgNyxcbiAgICAgIGxhc3QgPSB3ZWVrWWVhciAtIDEsXG4gICAgICBwMiA9IChsYXN0ICsgTWF0aC5mbG9vcihsYXN0IC8gNCkgLSBNYXRoLmZsb29yKGxhc3QgLyAxMDApICsgTWF0aC5mbG9vcihsYXN0IC8gNDAwKSkgJSA3O1xuICByZXR1cm4gcDEgPT09IDQgfHwgcDIgPT09IDMgPyA1MyA6IDUyO1xufVxuZnVuY3Rpb24gdW50cnVuY2F0ZVllYXIoeWVhcikge1xuICBpZiAoeWVhciA+IDk5KSB7XG4gICAgcmV0dXJuIHllYXI7XG4gIH0gZWxzZSByZXR1cm4geWVhciA+IDYwID8gMTkwMCArIHllYXIgOiAyMDAwICsgeWVhcjtcbn0gLy8gUEFSU0lOR1xuXG5mdW5jdGlvbiBwYXJzZVpvbmVJbmZvKHRzLCBvZmZzZXRGb3JtYXQsIGxvY2FsZSwgdGltZVpvbmUpIHtcbiAgaWYgKHRpbWVab25lID09PSB2b2lkIDApIHtcbiAgICB0aW1lWm9uZSA9IG51bGw7XG4gIH1cblxuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHRzKSxcbiAgICAgIGludGxPcHRzID0ge1xuICAgIGhvdXIxMjogZmFsc2UsXG4gICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgbW9udGg6IFwiMi1kaWdpdFwiLFxuICAgIGRheTogXCIyLWRpZ2l0XCIsXG4gICAgaG91cjogXCIyLWRpZ2l0XCIsXG4gICAgbWludXRlOiBcIjItZGlnaXRcIlxuICB9O1xuXG4gIGlmICh0aW1lWm9uZSkge1xuICAgIGludGxPcHRzLnRpbWVab25lID0gdGltZVpvbmU7XG4gIH1cblxuICB2YXIgbW9kaWZpZWQgPSBPYmplY3QuYXNzaWduKHtcbiAgICB0aW1lWm9uZU5hbWU6IG9mZnNldEZvcm1hdFxuICB9LCBpbnRsT3B0cyksXG4gICAgICBpbnRsID0gaGFzSW50bCgpO1xuXG4gIGlmIChpbnRsICYmIGhhc0Zvcm1hdFRvUGFydHMoKSkge1xuICAgIHZhciBwYXJzZWQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIG1vZGlmaWVkKS5mb3JtYXRUb1BhcnRzKGRhdGUpLmZpbmQoZnVuY3Rpb24gKG0pIHtcbiAgICAgIHJldHVybiBtLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0aW1lem9uZW5hbWVcIjtcbiAgICB9KTtcbiAgICByZXR1cm4gcGFyc2VkID8gcGFyc2VkLnZhbHVlIDogbnVsbDtcbiAgfSBlbHNlIGlmIChpbnRsKSB7XG4gICAgLy8gdGhpcyBwcm9iYWJseSBkb2Vzbid0IHdvcmsgZm9yIGFsbCBsb2NhbGVzXG4gICAgdmFyIHdpdGhvdXQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIGludGxPcHRzKS5mb3JtYXQoZGF0ZSksXG4gICAgICAgIGluY2x1ZGVkID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBtb2RpZmllZCkuZm9ybWF0KGRhdGUpLFxuICAgICAgICBkaWZmZWQgPSBpbmNsdWRlZC5zdWJzdHJpbmcod2l0aG91dC5sZW5ndGgpLFxuICAgICAgICB0cmltbWVkID0gZGlmZmVkLnJlcGxhY2UoL15bLCBcXHUyMDBlXSsvLCBcIlwiKTtcbiAgICByZXR1cm4gdHJpbW1lZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufSAvLyBzaWduZWRPZmZzZXQoJy01JywgJzMwJykgLT4gLTMzMFxuXG5mdW5jdGlvbiBzaWduZWRPZmZzZXQob2ZmSG91clN0ciwgb2ZmTWludXRlU3RyKSB7XG4gIHZhciBvZmZIb3VyID0gcGFyc2VJbnQob2ZmSG91clN0ciwgMTApOyAvLyBkb24ndCB8fCB0aGlzIGJlY2F1c2Ugd2Ugd2FudCB0byBwcmVzZXJ2ZSAtMFxuXG4gIGlmIChOdW1iZXIuaXNOYU4ob2ZmSG91cikpIHtcbiAgICBvZmZIb3VyID0gMDtcbiAgfVxuXG4gIHZhciBvZmZNaW4gPSBwYXJzZUludChvZmZNaW51dGVTdHIsIDEwKSB8fCAwLFxuICAgICAgb2ZmTWluU2lnbmVkID0gb2ZmSG91ciA8IDAgfHwgT2JqZWN0LmlzKG9mZkhvdXIsIC0wKSA/IC1vZmZNaW4gOiBvZmZNaW47XG4gIHJldHVybiBvZmZIb3VyICogNjAgKyBvZmZNaW5TaWduZWQ7XG59IC8vIENPRVJDSU9OXG5cbmZ1bmN0aW9uIGFzTnVtYmVyKHZhbHVlKSB7XG4gIHZhciBudW1lcmljVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIiB8fCB2YWx1ZSA9PT0gXCJcIiB8fCBOdW1iZXIuaXNOYU4obnVtZXJpY1ZhbHVlKSkgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiSW52YWxpZCB1bml0IHZhbHVlIFwiICsgdmFsdWUpO1xuICByZXR1cm4gbnVtZXJpY1ZhbHVlO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0KG9iaiwgbm9ybWFsaXplciwgbm9uVW5pdEtleXMpIHtcbiAgdmFyIG5vcm1hbGl6ZWQgPSB7fTtcblxuICBmb3IgKHZhciB1IGluIG9iaikge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eShvYmosIHUpKSB7XG4gICAgICBpZiAobm9uVW5pdEtleXMuaW5kZXhPZih1KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIHZhciB2ID0gb2JqW3VdO1xuICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgIG5vcm1hbGl6ZWRbbm9ybWFsaXplcih1KV0gPSBhc051bWJlcih2KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cbmZ1bmN0aW9uIGZvcm1hdE9mZnNldChvZmZzZXQsIGZvcm1hdCkge1xuICB2YXIgaG91cnMgPSBNYXRoLnRydW5jKE1hdGguYWJzKG9mZnNldCAvIDYwKSksXG4gICAgICBtaW51dGVzID0gTWF0aC50cnVuYyhNYXRoLmFicyhvZmZzZXQgJSA2MCkpLFxuICAgICAgc2lnbiA9IG9mZnNldCA+PSAwID8gXCIrXCIgOiBcIi1cIjtcblxuICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIFwiXCIgKyBzaWduICsgcGFkU3RhcnQoaG91cnMsIDIpICsgXCI6XCIgKyBwYWRTdGFydChtaW51dGVzLCAyKTtcblxuICAgIGNhc2UgXCJuYXJyb3dcIjpcbiAgICAgIHJldHVybiBcIlwiICsgc2lnbiArIGhvdXJzICsgKG1pbnV0ZXMgPiAwID8gXCI6XCIgKyBtaW51dGVzIDogXCJcIik7XG5cbiAgICBjYXNlIFwidGVjaGllXCI6XG4gICAgICByZXR1cm4gXCJcIiArIHNpZ24gKyBwYWRTdGFydChob3VycywgMikgKyBwYWRTdGFydChtaW51dGVzLCAyKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlZhbHVlIGZvcm1hdCBcIiArIGZvcm1hdCArIFwiIGlzIG91dCBvZiByYW5nZSBmb3IgcHJvcGVydHkgZm9ybWF0XCIpO1xuICB9XG59XG5mdW5jdGlvbiB0aW1lT2JqZWN0KG9iaikge1xuICByZXR1cm4gcGljayhvYmosIFtcImhvdXJcIiwgXCJtaW51dGVcIiwgXCJzZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiXSk7XG59XG52YXIgaWFuYVJlZ2V4ID0gL1tBLVphLXpfKy1dezEsMjU2fSg6P1xcL1tBLVphLXpfKy1dezEsMjU2fShcXC9bQS1aYS16XystXXsxLDI1Nn0pPyk/LztcblxuZnVuY3Rpb24gc3RyaW5naWZ5KG9iaikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBPYmplY3Qua2V5cyhvYmopLnNvcnQoKSk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuXG52YXIgbW9udGhzTG9uZyA9IFtcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdO1xudmFyIG1vbnRoc1Nob3J0ID0gW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdO1xudmFyIG1vbnRoc05hcnJvdyA9IFtcIkpcIiwgXCJGXCIsIFwiTVwiLCBcIkFcIiwgXCJNXCIsIFwiSlwiLCBcIkpcIiwgXCJBXCIsIFwiU1wiLCBcIk9cIiwgXCJOXCIsIFwiRFwiXTtcbmZ1bmN0aW9uIG1vbnRocyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gbW9udGhzTmFycm93O1xuXG4gICAgY2FzZSBcInNob3J0XCI6XG4gICAgICByZXR1cm4gbW9udGhzU2hvcnQ7XG5cbiAgICBjYXNlIFwibG9uZ1wiOlxuICAgICAgcmV0dXJuIG1vbnRoc0xvbmc7XG5cbiAgICBjYXNlIFwibnVtZXJpY1wiOlxuICAgICAgcmV0dXJuIFtcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIiwgXCI4XCIsIFwiOVwiLCBcIjEwXCIsIFwiMTFcIiwgXCIxMlwiXTtcblxuICAgIGNhc2UgXCIyLWRpZ2l0XCI6XG4gICAgICByZXR1cm4gW1wiMDFcIiwgXCIwMlwiLCBcIjAzXCIsIFwiMDRcIiwgXCIwNVwiLCBcIjA2XCIsIFwiMDdcIiwgXCIwOFwiLCBcIjA5XCIsIFwiMTBcIiwgXCIxMVwiLCBcIjEyXCJdO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG52YXIgd2Vla2RheXNMb25nID0gW1wiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIiwgXCJTdW5kYXlcIl07XG52YXIgd2Vla2RheXNTaG9ydCA9IFtcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiLCBcIlN1blwiXTtcbnZhciB3ZWVrZGF5c05hcnJvdyA9IFtcIk1cIiwgXCJUXCIsIFwiV1wiLCBcIlRcIiwgXCJGXCIsIFwiU1wiLCBcIlNcIl07XG5mdW5jdGlvbiB3ZWVrZGF5cyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gd2Vla2RheXNOYXJyb3c7XG5cbiAgICBjYXNlIFwic2hvcnRcIjpcbiAgICAgIHJldHVybiB3ZWVrZGF5c1Nob3J0O1xuXG4gICAgY2FzZSBcImxvbmdcIjpcbiAgICAgIHJldHVybiB3ZWVrZGF5c0xvbmc7XG5cbiAgICBjYXNlIFwibnVtZXJpY1wiOlxuICAgICAgcmV0dXJuIFtcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIl07XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbnZhciBtZXJpZGllbXMgPSBbXCJBTVwiLCBcIlBNXCJdO1xudmFyIGVyYXNMb25nID0gW1wiQmVmb3JlIENocmlzdFwiLCBcIkFubm8gRG9taW5pXCJdO1xudmFyIGVyYXNTaG9ydCA9IFtcIkJDXCIsIFwiQURcIl07XG52YXIgZXJhc05hcnJvdyA9IFtcIkJcIiwgXCJBXCJdO1xuZnVuY3Rpb24gZXJhcyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gZXJhc05hcnJvdztcblxuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIGVyYXNTaG9ydDtcblxuICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICByZXR1cm4gZXJhc0xvbmc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIG1lcmlkaWVtRm9yRGF0ZVRpbWUoZHQpIHtcbiAgcmV0dXJuIG1lcmlkaWVtc1tkdC5ob3VyIDwgMTIgPyAwIDogMV07XG59XG5mdW5jdGlvbiB3ZWVrZGF5Rm9yRGF0ZVRpbWUoZHQsIGxlbmd0aCkge1xuICByZXR1cm4gd2Vla2RheXMobGVuZ3RoKVtkdC53ZWVrZGF5IC0gMV07XG59XG5mdW5jdGlvbiBtb250aEZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIG1vbnRocyhsZW5ndGgpW2R0Lm1vbnRoIC0gMV07XG59XG5mdW5jdGlvbiBlcmFGb3JEYXRlVGltZShkdCwgbGVuZ3RoKSB7XG4gIHJldHVybiBlcmFzKGxlbmd0aClbZHQueWVhciA8IDAgPyAwIDogMV07XG59XG5mdW5jdGlvbiBmb3JtYXRSZWxhdGl2ZVRpbWUodW5pdCwgY291bnQsIG51bWVyaWMsIG5hcnJvdykge1xuICBpZiAobnVtZXJpYyA9PT0gdm9pZCAwKSB7XG4gICAgbnVtZXJpYyA9IFwiYWx3YXlzXCI7XG4gIH1cblxuICBpZiAobmFycm93ID09PSB2b2lkIDApIHtcbiAgICBuYXJyb3cgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciB1bml0cyA9IHtcbiAgICB5ZWFyczogW1wieWVhclwiLCBcInlyLlwiXSxcbiAgICBxdWFydGVyczogW1wicXVhcnRlclwiLCBcInF0ci5cIl0sXG4gICAgbW9udGhzOiBbXCJtb250aFwiLCBcIm1vLlwiXSxcbiAgICB3ZWVrczogW1wid2Vla1wiLCBcIndrLlwiXSxcbiAgICBkYXlzOiBbXCJkYXlcIiwgXCJkYXlcIiwgXCJkYXlzXCJdLFxuICAgIGhvdXJzOiBbXCJob3VyXCIsIFwiaHIuXCJdLFxuICAgIG1pbnV0ZXM6IFtcIm1pbnV0ZVwiLCBcIm1pbi5cIl0sXG4gICAgc2Vjb25kczogW1wic2Vjb25kXCIsIFwic2VjLlwiXVxuICB9O1xuICB2YXIgbGFzdGFibGUgPSBbXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCJdLmluZGV4T2YodW5pdCkgPT09IC0xO1xuXG4gIGlmIChudW1lcmljID09PSBcImF1dG9cIiAmJiBsYXN0YWJsZSkge1xuICAgIHZhciBpc0RheSA9IHVuaXQgPT09IFwiZGF5c1wiO1xuXG4gICAgc3dpdGNoIChjb3VudCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gaXNEYXkgPyBcInRvbW9ycm93XCIgOiBcIm5leHQgXCIgKyB1bml0c1t1bml0XVswXTtcblxuICAgICAgY2FzZSAtMTpcbiAgICAgICAgcmV0dXJuIGlzRGF5ID8gXCJ5ZXN0ZXJkYXlcIiA6IFwibGFzdCBcIiArIHVuaXRzW3VuaXRdWzBdO1xuXG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBpc0RheSA/IFwidG9kYXlcIiA6IFwidGhpcyBcIiArIHVuaXRzW3VuaXRdWzBdO1xuXG4gICAgfVxuICB9XG5cbiAgdmFyIGlzSW5QYXN0ID0gT2JqZWN0LmlzKGNvdW50LCAtMCkgfHwgY291bnQgPCAwLFxuICAgICAgZm10VmFsdWUgPSBNYXRoLmFicyhjb3VudCksXG4gICAgICBzaW5ndWxhciA9IGZtdFZhbHVlID09PSAxLFxuICAgICAgbGlsVW5pdHMgPSB1bml0c1t1bml0XSxcbiAgICAgIGZtdFVuaXQgPSBuYXJyb3cgPyBzaW5ndWxhciA/IGxpbFVuaXRzWzFdIDogbGlsVW5pdHNbMl0gfHwgbGlsVW5pdHNbMV0gOiBzaW5ndWxhciA/IHVuaXRzW3VuaXRdWzBdIDogdW5pdDtcbiAgcmV0dXJuIGlzSW5QYXN0ID8gZm10VmFsdWUgKyBcIiBcIiArIGZtdFVuaXQgKyBcIiBhZ29cIiA6IFwiaW4gXCIgKyBmbXRWYWx1ZSArIFwiIFwiICsgZm10VW5pdDtcbn1cbmZ1bmN0aW9uIGZvcm1hdFN0cmluZyhrbm93bkZvcm1hdCkge1xuICAvLyB0aGVzZSBhbGwgaGF2ZSB0aGUgb2Zmc2V0cyByZW1vdmVkIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gdGhlbVxuICAvLyB3aXRob3V0IGFsbCB0aGUgaW50bCBzdHVmZiB0aGlzIGlzIGJhY2tmaWxsaW5nXG4gIHZhciBmaWx0ZXJlZCA9IHBpY2soa25vd25Gb3JtYXQsIFtcIndlZWtkYXlcIiwgXCJlcmFcIiwgXCJ5ZWFyXCIsIFwibW9udGhcIiwgXCJkYXlcIiwgXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwidGltZVpvbmVOYW1lXCIsIFwiaG91cjEyXCJdKSxcbiAgICAgIGtleSA9IHN0cmluZ2lmeShmaWx0ZXJlZCksXG4gICAgICBkYXRlVGltZUh1Z2UgPSBcIkVFRUUsIExMTEwgZCwgeXl5eSwgaDptbSBhXCI7XG5cbiAgc3dpdGNoIChrZXkpIHtcbiAgICBjYXNlIHN0cmluZ2lmeShEQVRFX1NIT1JUKTpcbiAgICAgIHJldHVybiBcIk0vZC95eXl5XCI7XG5cbiAgICBjYXNlIHN0cmluZ2lmeShEQVRFX01FRCk6XG4gICAgICByZXR1cm4gXCJMTEwgZCwgeXl5eVwiO1xuXG4gICAgY2FzZSBzdHJpbmdpZnkoREFURV9NRURfV0lUSF9XRUVLREFZKTpcbiAgICAgIHJldHVybiBcIkVFRSwgTExMIGQsIHl5eXlcIjtcblxuICAgIGNhc2Ugc3RyaW5naWZ5KERBVEVfRlVMTCk6XG4gICAgICByZXR1cm4gXCJMTExMIGQsIHl5eXlcIjtcblxuICAgIGNhc2Ugc3RyaW5naWZ5KERBVEVfSFVHRSk6XG4gICAgICByZXR1cm4gXCJFRUVFLCBMTExMIGQsIHl5eXlcIjtcblxuICAgIGNhc2Ugc3RyaW5naWZ5KFRJTUVfU0lNUExFKTpcbiAgICAgIHJldHVybiBcImg6bW0gYVwiO1xuXG4gICAgY2FzZSBzdHJpbmdpZnkoVElNRV9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiaDptbTpzcyBhXCI7XG5cbiAgICBjYXNlIHN0cmluZ2lmeShUSU1FX1dJVEhfU0hPUlRfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcImg6bW0gYVwiO1xuXG4gICAgY2FzZSBzdHJpbmdpZnkoVElNRV9XSVRIX0xPTkdfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcImg6bW0gYVwiO1xuXG4gICAgY2FzZSBzdHJpbmdpZnkoVElNRV8yNF9TSU1QTEUpOlxuICAgICAgcmV0dXJuIFwiSEg6bW1cIjtcblxuICAgIGNhc2Ugc3RyaW5naWZ5KFRJTUVfMjRfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIkhIOm1tOnNzXCI7XG5cbiAgICBjYXNlIHN0cmluZ2lmeShUSU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcIkhIOm1tXCI7XG5cbiAgICBjYXNlIHN0cmluZ2lmeShUSU1FXzI0X1dJVEhfTE9OR19PRkZTRVQpOlxuICAgICAgcmV0dXJuIFwiSEg6bW1cIjtcblxuICAgIGNhc2Ugc3RyaW5naWZ5KERBVEVUSU1FX1NIT1JUKTpcbiAgICAgIHJldHVybiBcIk0vZC95eXl5LCBoOm1tIGFcIjtcblxuICAgIGNhc2Ugc3RyaW5naWZ5KERBVEVUSU1FX01FRCk6XG4gICAgICByZXR1cm4gXCJMTEwgZCwgeXl5eSwgaDptbSBhXCI7XG5cbiAgICBjYXNlIHN0cmluZ2lmeShEQVRFVElNRV9GVUxMKTpcbiAgICAgIHJldHVybiBcIkxMTEwgZCwgeXl5eSwgaDptbSBhXCI7XG5cbiAgICBjYXNlIHN0cmluZ2lmeShEQVRFVElNRV9IVUdFKTpcbiAgICAgIHJldHVybiBkYXRlVGltZUh1Z2U7XG5cbiAgICBjYXNlIHN0cmluZ2lmeShEQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiTS9kL3l5eXksIGg6bW06c3MgYVwiO1xuXG4gICAgY2FzZSBzdHJpbmdpZnkoREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJMTEwgZCwgeXl5eSwgaDptbTpzcyBhXCI7XG5cbiAgICBjYXNlIHN0cmluZ2lmeShEQVRFVElNRV9NRURfV0lUSF9XRUVLREFZKTpcbiAgICAgIHJldHVybiBcIkVFRSwgZCBMTEwgeXl5eSwgaDptbSBhXCI7XG5cbiAgICBjYXNlIHN0cmluZ2lmeShEQVRFVElNRV9GVUxMX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJMTExMIGQsIHl5eXksIGg6bW06c3MgYVwiO1xuXG4gICAgY2FzZSBzdHJpbmdpZnkoREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiRUVFRSwgTExMTCBkLCB5eXl5LCBoOm1tOnNzIGFcIjtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZGF0ZVRpbWVIdWdlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVRva2VucyhzcGxpdHMsIHRva2VuVG9TdHJpbmcpIHtcbiAgdmFyIHMgPSBcIlwiO1xuXG4gIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2Uoc3BsaXRzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICB2YXIgdG9rZW4gPSBfc3RlcC52YWx1ZTtcblxuICAgIGlmICh0b2tlbi5saXRlcmFsKSB7XG4gICAgICBzICs9IHRva2VuLnZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyArPSB0b2tlblRvU3RyaW5nKHRva2VuLnZhbCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHM7XG59XG5cbnZhciBfbWFjcm9Ub2tlblRvRm9ybWF0T3B0cyA9IHtcbiAgRDogREFURV9TSE9SVCxcbiAgREQ6IERBVEVfTUVELFxuICBEREQ6IERBVEVfRlVMTCxcbiAgRERERDogREFURV9IVUdFLFxuICB0OiBUSU1FX1NJTVBMRSxcbiAgdHQ6IFRJTUVfV0lUSF9TRUNPTkRTLFxuICB0dHQ6IFRJTUVfV0lUSF9TSE9SVF9PRkZTRVQsXG4gIHR0dHQ6IFRJTUVfV0lUSF9MT05HX09GRlNFVCxcbiAgVDogVElNRV8yNF9TSU1QTEUsXG4gIFRUOiBUSU1FXzI0X1dJVEhfU0VDT05EUyxcbiAgVFRUOiBUSU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VULFxuICBUVFRUOiBUSU1FXzI0X1dJVEhfTE9OR19PRkZTRVQsXG4gIGY6IERBVEVUSU1FX1NIT1JULFxuICBmZjogREFURVRJTUVfTUVELFxuICBmZmY6IERBVEVUSU1FX0ZVTEwsXG4gIGZmZmY6IERBVEVUSU1FX0hVR0UsXG4gIEY6IERBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUyxcbiAgRkY6IERBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMsXG4gIEZGRjogREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMsXG4gIEZGRkY6IERBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTXG59O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBGb3JtYXR0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBGb3JtYXR0ZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGxvY2FsZSwgb3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEZvcm1hdHRlcihsb2NhbGUsIG9wdHMpO1xuICB9O1xuXG4gIEZvcm1hdHRlci5wYXJzZUZvcm1hdCA9IGZ1bmN0aW9uIHBhcnNlRm9ybWF0KGZtdCkge1xuICAgIHZhciBjdXJyZW50ID0gbnVsbCxcbiAgICAgICAgY3VycmVudEZ1bGwgPSBcIlwiLFxuICAgICAgICBicmFja2V0ZWQgPSBmYWxzZTtcbiAgICB2YXIgc3BsaXRzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZtdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBmbXQuY2hhckF0KGkpO1xuXG4gICAgICBpZiAoYyA9PT0gXCInXCIpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRGdWxsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzcGxpdHMucHVzaCh7XG4gICAgICAgICAgICBsaXRlcmFsOiBicmFja2V0ZWQsXG4gICAgICAgICAgICB2YWw6IGN1cnJlbnRGdWxsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgICAgY3VycmVudEZ1bGwgPSBcIlwiO1xuICAgICAgICBicmFja2V0ZWQgPSAhYnJhY2tldGVkO1xuICAgICAgfSBlbHNlIGlmIChicmFja2V0ZWQpIHtcbiAgICAgICAgY3VycmVudEZ1bGwgKz0gYztcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gY3VycmVudCkge1xuICAgICAgICBjdXJyZW50RnVsbCArPSBjO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGN1cnJlbnRGdWxsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzcGxpdHMucHVzaCh7XG4gICAgICAgICAgICBsaXRlcmFsOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbDogY3VycmVudEZ1bGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRGdWxsID0gYztcbiAgICAgICAgY3VycmVudCA9IGM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRGdWxsLmxlbmd0aCA+IDApIHtcbiAgICAgIHNwbGl0cy5wdXNoKHtcbiAgICAgICAgbGl0ZXJhbDogYnJhY2tldGVkLFxuICAgICAgICB2YWw6IGN1cnJlbnRGdWxsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3BsaXRzO1xuICB9O1xuXG4gIEZvcm1hdHRlci5tYWNyb1Rva2VuVG9Gb3JtYXRPcHRzID0gZnVuY3Rpb24gbWFjcm9Ub2tlblRvRm9ybWF0T3B0cyh0b2tlbikge1xuICAgIHJldHVybiBfbWFjcm9Ub2tlblRvRm9ybWF0T3B0c1t0b2tlbl07XG4gIH07XG5cbiAgZnVuY3Rpb24gRm9ybWF0dGVyKGxvY2FsZSwgZm9ybWF0T3B0cykge1xuICAgIHRoaXMub3B0cyA9IGZvcm1hdE9wdHM7XG4gICAgdGhpcy5sb2MgPSBsb2NhbGU7XG4gICAgdGhpcy5zeXN0ZW1Mb2MgPSBudWxsO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEZvcm1hdHRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmZvcm1hdFdpdGhTeXN0ZW1EZWZhdWx0ID0gZnVuY3Rpb24gZm9ybWF0V2l0aFN5c3RlbURlZmF1bHQoZHQsIG9wdHMpIHtcbiAgICBpZiAodGhpcy5zeXN0ZW1Mb2MgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuc3lzdGVtTG9jID0gdGhpcy5sb2MucmVkZWZhdWx0VG9TeXN0ZW0oKTtcbiAgICB9XG5cbiAgICB2YXIgZGYgPSB0aGlzLnN5c3RlbUxvYy5kdEZvcm1hdHRlcihkdCwgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRzLCBvcHRzKSk7XG4gICAgcmV0dXJuIGRmLmZvcm1hdCgpO1xuICB9O1xuXG4gIF9wcm90by5mb3JtYXREYXRlVGltZSA9IGZ1bmN0aW9uIGZvcm1hdERhdGVUaW1lKGR0LCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBkZiA9IHRoaXMubG9jLmR0Rm9ybWF0dGVyKGR0LCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMsIG9wdHMpKTtcbiAgICByZXR1cm4gZGYuZm9ybWF0KCk7XG4gIH07XG5cbiAgX3Byb3RvLmZvcm1hdERhdGVUaW1lUGFydHMgPSBmdW5jdGlvbiBmb3JtYXREYXRlVGltZVBhcnRzKGR0LCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBkZiA9IHRoaXMubG9jLmR0Rm9ybWF0dGVyKGR0LCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMsIG9wdHMpKTtcbiAgICByZXR1cm4gZGYuZm9ybWF0VG9QYXJ0cygpO1xuICB9O1xuXG4gIF9wcm90by5yZXNvbHZlZE9wdGlvbnMgPSBmdW5jdGlvbiByZXNvbHZlZE9wdGlvbnMoZHQsIG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuXG4gICAgdmFyIGRmID0gdGhpcy5sb2MuZHRGb3JtYXR0ZXIoZHQsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0cywgb3B0cykpO1xuICAgIHJldHVybiBkZi5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgfTtcblxuICBfcHJvdG8ubnVtID0gZnVuY3Rpb24gbnVtKG4sIHApIHtcbiAgICBpZiAocCA9PT0gdm9pZCAwKSB7XG4gICAgICBwID0gMDtcbiAgICB9XG5cbiAgICAvLyB3ZSBnZXQgc29tZSBwZXJmIG91dCBvZiBkb2luZyB0aGlzIGhlcmUsIGFubm95aW5nbHlcbiAgICBpZiAodGhpcy5vcHRzLmZvcmNlU2ltcGxlKSB7XG4gICAgICByZXR1cm4gcGFkU3RhcnQobiwgcCk7XG4gICAgfVxuXG4gICAgdmFyIG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMpO1xuXG4gICAgaWYgKHAgPiAwKSB7XG4gICAgICBvcHRzLnBhZFRvID0gcDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5sb2MubnVtYmVyRm9ybWF0dGVyKG9wdHMpLmZvcm1hdChuKTtcbiAgfTtcblxuICBfcHJvdG8uZm9ybWF0RGF0ZVRpbWVGcm9tU3RyaW5nID0gZnVuY3Rpb24gZm9ybWF0RGF0ZVRpbWVGcm9tU3RyaW5nKGR0LCBmbXQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGtub3duRW5nbGlzaCA9IHRoaXMubG9jLmxpc3RpbmdNb2RlKCkgPT09IFwiZW5cIixcbiAgICAgICAgdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPSB0aGlzLmxvYy5vdXRwdXRDYWxlbmRhciAmJiB0aGlzLmxvYy5vdXRwdXRDYWxlbmRhciAhPT0gXCJncmVnb3J5XCIgJiYgaGFzRm9ybWF0VG9QYXJ0cygpLFxuICAgICAgICBzdHJpbmcgPSBmdW5jdGlvbiBzdHJpbmcob3B0cywgZXh0cmFjdCkge1xuICAgICAgcmV0dXJuIF90aGlzLmxvYy5leHRyYWN0KGR0LCBvcHRzLCBleHRyYWN0KTtcbiAgICB9LFxuICAgICAgICBmb3JtYXRPZmZzZXQgPSBmdW5jdGlvbiBmb3JtYXRPZmZzZXQob3B0cykge1xuICAgICAgaWYgKGR0LmlzT2Zmc2V0Rml4ZWQgJiYgZHQub2Zmc2V0ID09PSAwICYmIG9wdHMuYWxsb3daKSB7XG4gICAgICAgIHJldHVybiBcIlpcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGR0LmlzVmFsaWQgPyBkdC56b25lLmZvcm1hdE9mZnNldChkdC50cywgb3B0cy5mb3JtYXQpIDogXCJcIjtcbiAgICB9LFxuICAgICAgICBtZXJpZGllbSA9IGZ1bmN0aW9uIG1lcmlkaWVtKCkge1xuICAgICAgcmV0dXJuIGtub3duRW5nbGlzaCA/IG1lcmlkaWVtRm9yRGF0ZVRpbWUoZHQpIDogc3RyaW5nKHtcbiAgICAgICAgaG91cjogXCJudW1lcmljXCIsXG4gICAgICAgIGhvdXIxMjogdHJ1ZVxuICAgICAgfSwgXCJkYXlwZXJpb2RcIik7XG4gICAgfSxcbiAgICAgICAgbW9udGggPSBmdW5jdGlvbiBtb250aChsZW5ndGgsIHN0YW5kYWxvbmUpIHtcbiAgICAgIHJldHVybiBrbm93bkVuZ2xpc2ggPyBtb250aEZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIDogc3RyaW5nKHN0YW5kYWxvbmUgPyB7XG4gICAgICAgIG1vbnRoOiBsZW5ndGhcbiAgICAgIH0gOiB7XG4gICAgICAgIG1vbnRoOiBsZW5ndGgsXG4gICAgICAgIGRheTogXCJudW1lcmljXCJcbiAgICAgIH0sIFwibW9udGhcIik7XG4gICAgfSxcbiAgICAgICAgd2Vla2RheSA9IGZ1bmN0aW9uIHdlZWtkYXkobGVuZ3RoLCBzdGFuZGFsb25lKSB7XG4gICAgICByZXR1cm4ga25vd25FbmdsaXNoID8gd2Vla2RheUZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIDogc3RyaW5nKHN0YW5kYWxvbmUgPyB7XG4gICAgICAgIHdlZWtkYXk6IGxlbmd0aFxuICAgICAgfSA6IHtcbiAgICAgICAgd2Vla2RheTogbGVuZ3RoLFxuICAgICAgICBtb250aDogXCJsb25nXCIsXG4gICAgICAgIGRheTogXCJudW1lcmljXCJcbiAgICAgIH0sIFwid2Vla2RheVwiKTtcbiAgICB9LFxuICAgICAgICBtYXliZU1hY3JvID0gZnVuY3Rpb24gbWF5YmVNYWNybyh0b2tlbikge1xuICAgICAgdmFyIGZvcm1hdE9wdHMgPSBGb3JtYXR0ZXIubWFjcm9Ub2tlblRvRm9ybWF0T3B0cyh0b2tlbik7XG5cbiAgICAgIGlmIChmb3JtYXRPcHRzKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5mb3JtYXRXaXRoU3lzdGVtRGVmYXVsdChkdCwgZm9ybWF0T3B0cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgZXJhID0gZnVuY3Rpb24gZXJhKGxlbmd0aCkge1xuICAgICAgcmV0dXJuIGtub3duRW5nbGlzaCA/IGVyYUZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIDogc3RyaW5nKHtcbiAgICAgICAgZXJhOiBsZW5ndGhcbiAgICAgIH0sIFwiZXJhXCIpO1xuICAgIH0sXG4gICAgICAgIHRva2VuVG9TdHJpbmcgPSBmdW5jdGlvbiB0b2tlblRvU3RyaW5nKHRva2VuKSB7XG4gICAgICAvLyBXaGVyZSBwb3NzaWJsZTogaHR0cDovL2NsZHIudW5pY29kZS5vcmcvdHJhbnNsYXRpb24vZGF0ZS10aW1lI1RPQy1TdGFuZC1BbG9uZS12cy4tRm9ybWF0LVN0eWxlc1xuICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAvLyBtc1xuICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgIHJldHVybiBfdGhpcy5udW0oZHQubWlsbGlzZWNvbmQpO1xuXG4gICAgICAgIGNhc2UgXCJ1XCI6IC8vIGZhbGxzIHRocm91Z2hcblxuICAgICAgICBjYXNlIFwiU1NTXCI6XG4gICAgICAgICAgcmV0dXJuIF90aGlzLm51bShkdC5taWxsaXNlY29uZCwgMyk7XG4gICAgICAgIC8vIHNlY29uZHNcblxuICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgIHJldHVybiBfdGhpcy5udW0oZHQuc2Vjb25kKTtcblxuICAgICAgICBjYXNlIFwic3NcIjpcbiAgICAgICAgICByZXR1cm4gX3RoaXMubnVtKGR0LnNlY29uZCwgMik7XG4gICAgICAgIC8vIG1pbnV0ZXNcblxuICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgIHJldHVybiBfdGhpcy5udW0oZHQubWludXRlKTtcblxuICAgICAgICBjYXNlIFwibW1cIjpcbiAgICAgICAgICByZXR1cm4gX3RoaXMubnVtKGR0Lm1pbnV0ZSwgMik7XG4gICAgICAgIC8vIGhvdXJzXG5cbiAgICAgICAgY2FzZSBcImhcIjpcbiAgICAgICAgICByZXR1cm4gX3RoaXMubnVtKGR0LmhvdXIgJSAxMiA9PT0gMCA/IDEyIDogZHQuaG91ciAlIDEyKTtcblxuICAgICAgICBjYXNlIFwiaGhcIjpcbiAgICAgICAgICByZXR1cm4gX3RoaXMubnVtKGR0LmhvdXIgJSAxMiA9PT0gMCA/IDEyIDogZHQuaG91ciAlIDEyLCAyKTtcblxuICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgIHJldHVybiBfdGhpcy5udW0oZHQuaG91cik7XG5cbiAgICAgICAgY2FzZSBcIkhIXCI6XG4gICAgICAgICAgcmV0dXJuIF90aGlzLm51bShkdC5ob3VyLCAyKTtcbiAgICAgICAgLy8gb2Zmc2V0XG5cbiAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgICAvLyBsaWtlICs2XG4gICAgICAgICAgcmV0dXJuIGZvcm1hdE9mZnNldCh7XG4gICAgICAgICAgICBmb3JtYXQ6IFwibmFycm93XCIsXG4gICAgICAgICAgICBhbGxvd1o6IF90aGlzLm9wdHMuYWxsb3daXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgY2FzZSBcIlpaXCI6XG4gICAgICAgICAgLy8gbGlrZSArMDY6MDBcbiAgICAgICAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHtcbiAgICAgICAgICAgIGZvcm1hdDogXCJzaG9ydFwiLFxuICAgICAgICAgICAgYWxsb3daOiBfdGhpcy5vcHRzLmFsbG93WlxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNhc2UgXCJaWlpcIjpcbiAgICAgICAgICAvLyBsaWtlICswNjAwXG4gICAgICAgICAgcmV0dXJuIGZvcm1hdE9mZnNldCh7XG4gICAgICAgICAgICBmb3JtYXQ6IFwidGVjaGllXCIsXG4gICAgICAgICAgICBhbGxvd1o6IF90aGlzLm9wdHMuYWxsb3daXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgY2FzZSBcIlpaWlpcIjpcbiAgICAgICAgICAvLyBsaWtlIEVTVFxuICAgICAgICAgIHJldHVybiBkdC56b25lLm9mZnNldE5hbWUoZHQudHMsIHtcbiAgICAgICAgICAgIGZvcm1hdDogXCJzaG9ydFwiLFxuICAgICAgICAgICAgbG9jYWxlOiBfdGhpcy5sb2MubG9jYWxlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgY2FzZSBcIlpaWlpaXCI6XG4gICAgICAgICAgLy8gbGlrZSBFYXN0ZXJuIFN0YW5kYXJkIFRpbWVcbiAgICAgICAgICByZXR1cm4gZHQuem9uZS5vZmZzZXROYW1lKGR0LnRzLCB7XG4gICAgICAgICAgICBmb3JtYXQ6IFwibG9uZ1wiLFxuICAgICAgICAgICAgbG9jYWxlOiBfdGhpcy5sb2MubG9jYWxlXG4gICAgICAgICAgfSk7XG4gICAgICAgIC8vIHpvbmVcblxuICAgICAgICBjYXNlIFwielwiOlxuICAgICAgICAgIC8vIGxpa2UgQW1lcmljYS9OZXdfWW9ya1xuICAgICAgICAgIHJldHVybiBkdC56b25lTmFtZTtcbiAgICAgICAgLy8gbWVyaWRpZW1zXG5cbiAgICAgICAgY2FzZSBcImFcIjpcbiAgICAgICAgICByZXR1cm4gbWVyaWRpZW0oKTtcbiAgICAgICAgLy8gZGF0ZXNcblxuICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlciA/IHN0cmluZyh7XG4gICAgICAgICAgICBkYXk6IFwibnVtZXJpY1wiXG4gICAgICAgICAgfSwgXCJkYXlcIikgOiBfdGhpcy5udW0oZHQuZGF5KTtcblxuICAgICAgICBjYXNlIFwiZGRcIjpcbiAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPyBzdHJpbmcoe1xuICAgICAgICAgICAgZGF5OiBcIjItZGlnaXRcIlxuICAgICAgICAgIH0sIFwiZGF5XCIpIDogX3RoaXMubnVtKGR0LmRheSwgMik7XG4gICAgICAgIC8vIHdlZWtkYXlzIC0gc3RhbmRhbG9uZVxuXG4gICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgcmV0dXJuIF90aGlzLm51bShkdC53ZWVrZGF5KTtcblxuICAgICAgICBjYXNlIFwiY2NjXCI6XG4gICAgICAgICAgLy8gbGlrZSAnVHVlcydcbiAgICAgICAgICByZXR1cm4gd2Vla2RheShcInNob3J0XCIsIHRydWUpO1xuXG4gICAgICAgIGNhc2UgXCJjY2NjXCI6XG4gICAgICAgICAgLy8gbGlrZSAnVHVlc2RheSdcbiAgICAgICAgICByZXR1cm4gd2Vla2RheShcImxvbmdcIiwgdHJ1ZSk7XG5cbiAgICAgICAgY2FzZSBcImNjY2NjXCI6XG4gICAgICAgICAgLy8gbGlrZSAnVCdcbiAgICAgICAgICByZXR1cm4gd2Vla2RheShcIm5hcnJvd1wiLCB0cnVlKTtcbiAgICAgICAgLy8gd2Vla2RheXMgLSBmb3JtYXRcblxuICAgICAgICBjYXNlIFwiRVwiOlxuICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgIHJldHVybiBfdGhpcy5udW0oZHQud2Vla2RheSk7XG5cbiAgICAgICAgY2FzZSBcIkVFRVwiOlxuICAgICAgICAgIC8vIGxpa2UgJ1R1ZXMnXG4gICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJzaG9ydFwiLCBmYWxzZSk7XG5cbiAgICAgICAgY2FzZSBcIkVFRUVcIjpcbiAgICAgICAgICAvLyBsaWtlICdUdWVzZGF5J1xuICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibG9uZ1wiLCBmYWxzZSk7XG5cbiAgICAgICAgY2FzZSBcIkVFRUVFXCI6XG4gICAgICAgICAgLy8gbGlrZSAnVCdcbiAgICAgICAgICByZXR1cm4gd2Vla2RheShcIm5hcnJvd1wiLCBmYWxzZSk7XG4gICAgICAgIC8vIG1vbnRocyAtIHN0YW5kYWxvbmVcblxuICAgICAgICBjYXNlIFwiTFwiOlxuICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlciA/IHN0cmluZyh7XG4gICAgICAgICAgICBtb250aDogXCJudW1lcmljXCIsXG4gICAgICAgICAgICBkYXk6IFwibnVtZXJpY1wiXG4gICAgICAgICAgfSwgXCJtb250aFwiKSA6IF90aGlzLm51bShkdC5tb250aCk7XG5cbiAgICAgICAgY2FzZSBcIkxMXCI6XG4gICAgICAgICAgLy8gbGlrZSAwMSwgZG9lc24ndCBzZWVtIHRvIHdvcmtcbiAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPyBzdHJpbmcoe1xuICAgICAgICAgICAgbW9udGg6IFwiMi1kaWdpdFwiLFxuICAgICAgICAgICAgZGF5OiBcIm51bWVyaWNcIlxuICAgICAgICAgIH0sIFwibW9udGhcIikgOiBfdGhpcy5udW0oZHQubW9udGgsIDIpO1xuXG4gICAgICAgIGNhc2UgXCJMTExcIjpcbiAgICAgICAgICAvLyBsaWtlIEphblxuICAgICAgICAgIHJldHVybiBtb250aChcInNob3J0XCIsIHRydWUpO1xuXG4gICAgICAgIGNhc2UgXCJMTExMXCI6XG4gICAgICAgICAgLy8gbGlrZSBKYW51YXJ5XG4gICAgICAgICAgcmV0dXJuIG1vbnRoKFwibG9uZ1wiLCB0cnVlKTtcblxuICAgICAgICBjYXNlIFwiTExMTExcIjpcbiAgICAgICAgICAvLyBsaWtlIEpcbiAgICAgICAgICByZXR1cm4gbW9udGgoXCJuYXJyb3dcIiwgdHJ1ZSk7XG4gICAgICAgIC8vIG1vbnRocyAtIGZvcm1hdFxuXG4gICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyID8gc3RyaW5nKHtcbiAgICAgICAgICAgIG1vbnRoOiBcIm51bWVyaWNcIlxuICAgICAgICAgIH0sIFwibW9udGhcIikgOiBfdGhpcy5udW0oZHQubW9udGgpO1xuXG4gICAgICAgIGNhc2UgXCJNTVwiOlxuICAgICAgICAgIC8vIGxpa2UgMDFcbiAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPyBzdHJpbmcoe1xuICAgICAgICAgICAgbW9udGg6IFwiMi1kaWdpdFwiXG4gICAgICAgICAgfSwgXCJtb250aFwiKSA6IF90aGlzLm51bShkdC5tb250aCwgMik7XG5cbiAgICAgICAgY2FzZSBcIk1NTVwiOlxuICAgICAgICAgIC8vIGxpa2UgSmFuXG4gICAgICAgICAgcmV0dXJuIG1vbnRoKFwic2hvcnRcIiwgZmFsc2UpO1xuXG4gICAgICAgIGNhc2UgXCJNTU1NXCI6XG4gICAgICAgICAgLy8gbGlrZSBKYW51YXJ5XG4gICAgICAgICAgcmV0dXJuIG1vbnRoKFwibG9uZ1wiLCBmYWxzZSk7XG5cbiAgICAgICAgY2FzZSBcIk1NTU1NXCI6XG4gICAgICAgICAgLy8gbGlrZSBKXG4gICAgICAgICAgcmV0dXJuIG1vbnRoKFwibmFycm93XCIsIGZhbHNlKTtcbiAgICAgICAgLy8geWVhcnNcblxuICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgIC8vIGxpa2UgMjAxNFxuICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlciA/IHN0cmluZyh7XG4gICAgICAgICAgICB5ZWFyOiBcIm51bWVyaWNcIlxuICAgICAgICAgIH0sIFwieWVhclwiKSA6IF90aGlzLm51bShkdC55ZWFyKTtcblxuICAgICAgICBjYXNlIFwieXlcIjpcbiAgICAgICAgICAvLyBsaWtlIDE0XG4gICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyID8gc3RyaW5nKHtcbiAgICAgICAgICAgIHllYXI6IFwiMi1kaWdpdFwiXG4gICAgICAgICAgfSwgXCJ5ZWFyXCIpIDogX3RoaXMubnVtKGR0LnllYXIudG9TdHJpbmcoKS5zbGljZSgtMiksIDIpO1xuXG4gICAgICAgIGNhc2UgXCJ5eXl5XCI6XG4gICAgICAgICAgLy8gbGlrZSAwMDEyXG4gICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyID8gc3RyaW5nKHtcbiAgICAgICAgICAgIHllYXI6IFwibnVtZXJpY1wiXG4gICAgICAgICAgfSwgXCJ5ZWFyXCIpIDogX3RoaXMubnVtKGR0LnllYXIsIDQpO1xuXG4gICAgICAgIGNhc2UgXCJ5eXl5eXlcIjpcbiAgICAgICAgICAvLyBsaWtlIDAwMDAxMlxuICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlciA/IHN0cmluZyh7XG4gICAgICAgICAgICB5ZWFyOiBcIm51bWVyaWNcIlxuICAgICAgICAgIH0sIFwieWVhclwiKSA6IF90aGlzLm51bShkdC55ZWFyLCA2KTtcbiAgICAgICAgLy8gZXJhc1xuXG4gICAgICAgIGNhc2UgXCJHXCI6XG4gICAgICAgICAgLy8gbGlrZSBBRFxuICAgICAgICAgIHJldHVybiBlcmEoXCJzaG9ydFwiKTtcblxuICAgICAgICBjYXNlIFwiR0dcIjpcbiAgICAgICAgICAvLyBsaWtlIEFubm8gRG9taW5pXG4gICAgICAgICAgcmV0dXJuIGVyYShcImxvbmdcIik7XG5cbiAgICAgICAgY2FzZSBcIkdHR0dHXCI6XG4gICAgICAgICAgcmV0dXJuIGVyYShcIm5hcnJvd1wiKTtcblxuICAgICAgICBjYXNlIFwia2tcIjpcbiAgICAgICAgICByZXR1cm4gX3RoaXMubnVtKGR0LndlZWtZZWFyLnRvU3RyaW5nKCkuc2xpY2UoLTIpLCAyKTtcblxuICAgICAgICBjYXNlIFwia2tra1wiOlxuICAgICAgICAgIHJldHVybiBfdGhpcy5udW0oZHQud2Vla1llYXIsIDQpO1xuXG4gICAgICAgIGNhc2UgXCJXXCI6XG4gICAgICAgICAgcmV0dXJuIF90aGlzLm51bShkdC53ZWVrTnVtYmVyKTtcblxuICAgICAgICBjYXNlIFwiV1dcIjpcbiAgICAgICAgICByZXR1cm4gX3RoaXMubnVtKGR0LndlZWtOdW1iZXIsIDIpO1xuXG4gICAgICAgIGNhc2UgXCJvXCI6XG4gICAgICAgICAgcmV0dXJuIF90aGlzLm51bShkdC5vcmRpbmFsKTtcblxuICAgICAgICBjYXNlIFwib29vXCI6XG4gICAgICAgICAgcmV0dXJuIF90aGlzLm51bShkdC5vcmRpbmFsLCAzKTtcblxuICAgICAgICBjYXNlIFwicVwiOlxuICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgIHJldHVybiBfdGhpcy5udW0oZHQucXVhcnRlcik7XG5cbiAgICAgICAgY2FzZSBcInFxXCI6XG4gICAgICAgICAgLy8gbGlrZSAwMVxuICAgICAgICAgIHJldHVybiBfdGhpcy5udW0oZHQucXVhcnRlciwgMik7XG5cbiAgICAgICAgY2FzZSBcIlhcIjpcbiAgICAgICAgICByZXR1cm4gX3RoaXMubnVtKE1hdGguZmxvb3IoZHQudHMgLyAxMDAwKSk7XG5cbiAgICAgICAgY2FzZSBcInhcIjpcbiAgICAgICAgICByZXR1cm4gX3RoaXMubnVtKGR0LnRzKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBtYXliZU1hY3JvKHRva2VuKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHN0cmluZ2lmeVRva2VucyhGb3JtYXR0ZXIucGFyc2VGb3JtYXQoZm10KSwgdG9rZW5Ub1N0cmluZyk7XG4gIH07XG5cbiAgX3Byb3RvLmZvcm1hdER1cmF0aW9uRnJvbVN0cmluZyA9IGZ1bmN0aW9uIGZvcm1hdER1cmF0aW9uRnJvbVN0cmluZyhkdXIsIGZtdCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIHRva2VuVG9GaWVsZCA9IGZ1bmN0aW9uIHRva2VuVG9GaWVsZCh0b2tlbikge1xuICAgICAgc3dpdGNoICh0b2tlblswXSkge1xuICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgIHJldHVybiBcIm1pbGxpc2Vjb25kXCI7XG5cbiAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICByZXR1cm4gXCJzZWNvbmRcIjtcblxuICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgIHJldHVybiBcIm1pbnV0ZVwiO1xuXG4gICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgcmV0dXJuIFwiaG91clwiO1xuXG4gICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgcmV0dXJuIFwiZGF5XCI7XG5cbiAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICByZXR1cm4gXCJtb250aFwiO1xuXG4gICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgcmV0dXJuIFwieWVhclwiO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgdG9rZW5Ub1N0cmluZyA9IGZ1bmN0aW9uIHRva2VuVG9TdHJpbmcobGlsZHVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHZhciBtYXBwZWQgPSB0b2tlblRvRmllbGQodG9rZW4pO1xuXG4gICAgICAgIGlmIChtYXBwZWQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLm51bShsaWxkdXIuZ2V0KG1hcHBlZCksIHRva2VuLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgICAgIHRva2VucyA9IEZvcm1hdHRlci5wYXJzZUZvcm1hdChmbXQpLFxuICAgICAgICByZWFsVG9rZW5zID0gdG9rZW5zLnJlZHVjZShmdW5jdGlvbiAoZm91bmQsIF9yZWYpIHtcbiAgICAgIHZhciBsaXRlcmFsID0gX3JlZi5saXRlcmFsLFxuICAgICAgICAgIHZhbCA9IF9yZWYudmFsO1xuICAgICAgcmV0dXJuIGxpdGVyYWwgPyBmb3VuZCA6IGZvdW5kLmNvbmNhdCh2YWwpO1xuICAgIH0sIFtdKSxcbiAgICAgICAgY29sbGFwc2VkID0gZHVyLnNoaWZ0VG8uYXBwbHkoZHVyLCByZWFsVG9rZW5zLm1hcCh0b2tlblRvRmllbGQpLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIHN0cmluZ2lmeVRva2Vucyh0b2tlbnMsIHRva2VuVG9TdHJpbmcoY29sbGFwc2VkKSk7XG4gIH07XG5cbiAgcmV0dXJuIEZvcm1hdHRlcjtcbn0oKTtcblxudmFyIEludmFsaWQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24pIHtcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLmV4cGxhbmF0aW9uID0gZXhwbGFuYXRpb247XG4gIH1cblxuICB2YXIgX3Byb3RvID0gSW52YWxpZC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvTWVzc2FnZSA9IGZ1bmN0aW9uIHRvTWVzc2FnZSgpIHtcbiAgICBpZiAodGhpcy5leHBsYW5hdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMucmVhc29uICsgXCI6IFwiICsgdGhpcy5leHBsYW5hdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucmVhc29uO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gSW52YWxpZDtcbn0oKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlXG4gKi9cblxudmFyIFpvbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBab25lKCkge31cblxuICB2YXIgX3Byb3RvID0gWm9uZS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldCdzIGNvbW1vbiBuYW1lIChzdWNoIGFzIEVTVCkgYXQgdGhlIHNwZWNpZmllZCB0aW1lc3RhbXBcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cyAtIEVwb2NoIG1pbGxpc2Vjb25kcyBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBuYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gT3B0aW9ucyB0byBhZmZlY3QgdGhlIGZvcm1hdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5mb3JtYXQgLSBXaGF0IHN0eWxlIG9mIG9mZnNldCB0byByZXR1cm4uIEFjY2VwdHMgJ2xvbmcnIG9yICdzaG9ydCcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmxvY2FsZSAtIFdoYXQgbG9jYWxlIHRvIHJldHVybiB0aGUgb2Zmc2V0IG5hbWUgaW4uXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIF9wcm90by5vZmZzZXROYW1lID0gZnVuY3Rpb24gb2Zmc2V0TmFtZSh0cywgb3B0cykge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldCdzIHZhbHVlIGFzIGEgc3RyaW5nXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gdHMgLSBFcG9jaCBtaWxsaXNlY29uZHMgZm9yIHdoaWNoIHRvIGdldCB0aGUgb2Zmc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQgLSBXaGF0IHN0eWxlIG9mIG9mZnNldCB0byByZXR1cm4uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBBY2NlcHRzICduYXJyb3cnLCAnc2hvcnQnLCBvciAndGVjaGllJy4gUmV0dXJuaW5nICcrNicsICcrMDY6MDAnLCBvciAnKzA2MDAnIHJlc3BlY3RpdmVseVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmZvcm1hdE9mZnNldCA9IGZ1bmN0aW9uIGZvcm1hdE9mZnNldCh0cywgZm9ybWF0KSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRoZSBvZmZzZXQgaW4gbWludXRlcyBmb3IgdGhpcyB6b25lIGF0IHRoZSBzcGVjaWZpZWQgdGltZXN0YW1wLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRzIC0gRXBvY2ggbWlsbGlzZWNvbmRzIGZvciB3aGljaCB0byBjb21wdXRlIHRoZSBvZmZzZXRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vZmZzZXQgPSBmdW5jdGlvbiBvZmZzZXQodHMpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIFpvbmUgaXMgZXF1YWwgdG8gYW5vdGhlciB6b25lXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge1pvbmV9IG90aGVyWm9uZSAtIHRoZSB6b25lIHRvIGNvbXBhcmVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyWm9uZSkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgWm9uZSBpcyB2YWxpZC5cbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgO1xuXG4gIF9jcmVhdGVDbGFzcyhab25lLCBbe1xuICAgIGtleTogXCJ0eXBlXCIsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB6b25lXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoaXMgem9uZS5cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmFtZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBvZmZzZXQgaXMga25vd24gdG8gYmUgZml4ZWQgZm9yIHRoZSB3aG9sZSB5ZWFyLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidW5pdmVyc2FsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1ZhbGlkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBab25lO1xufSgpO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgbG9jYWwgem9uZSBmb3IgdGhpcyBKYXZhc2NyaXB0IGVudmlyb25tZW50LlxuICogQGltcGxlbWVudHMge1pvbmV9XG4gKi9cblxudmFyIExvY2FsWm9uZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1pvbmUpIHtcbiAgX2luaGVyaXRzTG9vc2UoTG9jYWxab25lLCBfWm9uZSk7XG5cbiAgZnVuY3Rpb24gTG9jYWxab25lKCkge1xuICAgIHJldHVybiBfWm9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTG9jYWxab25lLnByb3RvdHlwZTtcblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBfcHJvdG8ub2Zmc2V0TmFtZSA9IGZ1bmN0aW9uIG9mZnNldE5hbWUodHMsIF9yZWYpIHtcbiAgICB2YXIgZm9ybWF0ID0gX3JlZi5mb3JtYXQsXG4gICAgICAgIGxvY2FsZSA9IF9yZWYubG9jYWxlO1xuICAgIHJldHVybiBwYXJzZVpvbmVJbmZvKHRzLCBmb3JtYXQsIGxvY2FsZSk7XG4gIH1cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgO1xuXG4gIF9wcm90by5mb3JtYXRPZmZzZXQgPSBmdW5jdGlvbiBmb3JtYXRPZmZzZXQkMSh0cywgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGZvcm1hdE9mZnNldCh0aGlzLm9mZnNldCh0cyksIGZvcm1hdCk7XG4gIH1cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgO1xuXG4gIF9wcm90by5vZmZzZXQgPSBmdW5jdGlvbiBvZmZzZXQodHMpIHtcbiAgICByZXR1cm4gLW5ldyBEYXRlKHRzKS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICB9XG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIDtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyWm9uZSkge1xuICAgIHJldHVybiBvdGhlclpvbmUudHlwZSA9PT0gXCJsb2NhbFwiO1xuICB9XG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIDtcblxuICBfY3JlYXRlQ2xhc3MoTG9jYWxab25lLCBbe1xuICAgIGtleTogXCJ0eXBlXCIsXG5cbiAgICAvKiogQG92ZXJyaWRlICoqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFwibG9jYWxcIjtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm5hbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmIChoYXNJbnRsKCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmU7XG4gICAgICB9IGVsc2UgcmV0dXJuIFwibG9jYWxcIjtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVuaXZlcnNhbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1ZhbGlkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJpbnN0YW5jZVwiLFxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIHRoZSBsb2NhbCB6b25lXG4gICAgICogQHJldHVybiB7TG9jYWxab25lfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKHNpbmdsZXRvbiA9PT0gbnVsbCkge1xuICAgICAgICBzaW5nbGV0b24gPSBuZXcgTG9jYWxab25lKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzaW5nbGV0b247XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExvY2FsWm9uZTtcbn0oWm9uZSk7XG5cbnZhciBtYXRjaGluZ1JlZ2V4ID0gUmVnRXhwKFwiXlwiICsgaWFuYVJlZ2V4LnNvdXJjZSArIFwiJFwiKTtcbnZhciBkdGZDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBtYWtlRFRGKHpvbmUpIHtcbiAgaWYgKCFkdGZDYWNoZVt6b25lXSkge1xuICAgIGR0ZkNhY2hlW3pvbmVdID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoXCJlbi1VU1wiLCB7XG4gICAgICBob3VyMTI6IGZhbHNlLFxuICAgICAgdGltZVpvbmU6IHpvbmUsXG4gICAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICAgIG1vbnRoOiBcIjItZGlnaXRcIixcbiAgICAgIGRheTogXCIyLWRpZ2l0XCIsXG4gICAgICBob3VyOiBcIjItZGlnaXRcIixcbiAgICAgIG1pbnV0ZTogXCIyLWRpZ2l0XCIsXG4gICAgICBzZWNvbmQ6IFwiMi1kaWdpdFwiXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZHRmQ2FjaGVbem9uZV07XG59XG5cbnZhciB0eXBlVG9Qb3MgPSB7XG4gIHllYXI6IDAsXG4gIG1vbnRoOiAxLFxuICBkYXk6IDIsXG4gIGhvdXI6IDMsXG4gIG1pbnV0ZTogNCxcbiAgc2Vjb25kOiA1XG59O1xuXG5mdW5jdGlvbiBoYWNreU9mZnNldChkdGYsIGRhdGUpIHtcbiAgdmFyIGZvcm1hdHRlZCA9IGR0Zi5mb3JtYXQoZGF0ZSkucmVwbGFjZSgvXFx1MjAwRS9nLCBcIlwiKSxcbiAgICAgIHBhcnNlZCA9IC8oXFxkKylcXC8oXFxkKylcXC8oXFxkKyksPyAoXFxkKyk6KFxcZCspOihcXGQrKS8uZXhlYyhmb3JtYXR0ZWQpLFxuICAgICAgZk1vbnRoID0gcGFyc2VkWzFdLFxuICAgICAgZkRheSA9IHBhcnNlZFsyXSxcbiAgICAgIGZZZWFyID0gcGFyc2VkWzNdLFxuICAgICAgZkhvdXIgPSBwYXJzZWRbNF0sXG4gICAgICBmTWludXRlID0gcGFyc2VkWzVdLFxuICAgICAgZlNlY29uZCA9IHBhcnNlZFs2XTtcbiAgcmV0dXJuIFtmWWVhciwgZk1vbnRoLCBmRGF5LCBmSG91ciwgZk1pbnV0ZSwgZlNlY29uZF07XG59XG5cbmZ1bmN0aW9uIHBhcnRzT2Zmc2V0KGR0ZiwgZGF0ZSkge1xuICB2YXIgZm9ybWF0dGVkID0gZHRmLmZvcm1hdFRvUGFydHMoZGF0ZSksXG4gICAgICBmaWxsZWQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcm1hdHRlZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfZm9ybWF0dGVkJGkgPSBmb3JtYXR0ZWRbaV0sXG4gICAgICAgIHR5cGUgPSBfZm9ybWF0dGVkJGkudHlwZSxcbiAgICAgICAgdmFsdWUgPSBfZm9ybWF0dGVkJGkudmFsdWUsXG4gICAgICAgIHBvcyA9IHR5cGVUb1Bvc1t0eXBlXTtcblxuICAgIGlmICghaXNVbmRlZmluZWQocG9zKSkge1xuICAgICAgZmlsbGVkW3Bvc10gPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaWxsZWQ7XG59XG5cbnZhciBpYW5hWm9uZUNhY2hlID0ge307XG4vKipcbiAqIEEgem9uZSBpZGVudGlmaWVkIGJ5IGFuIElBTkEgaWRlbnRpZmllciwgbGlrZSBBbWVyaWNhL05ld19Zb3JrXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuXG52YXIgSUFOQVpvbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9ab25lKSB7XG4gIF9pbmhlcml0c0xvb3NlKElBTkFab25lLCBfWm9uZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gWm9uZSBuYW1lXG4gICAqIEByZXR1cm4ge0lBTkFab25lfVxuICAgKi9cbiAgSUFOQVpvbmUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKG5hbWUpIHtcbiAgICBpZiAoIWlhbmFab25lQ2FjaGVbbmFtZV0pIHtcbiAgICAgIGlhbmFab25lQ2FjaGVbbmFtZV0gPSBuZXcgSUFOQVpvbmUobmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlhbmFab25lQ2FjaGVbbmFtZV07XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0IGxvY2FsIGNhY2hlcy4gU2hvdWxkIG9ubHkgYmUgbmVjZXNzYXJ5IGluIHRlc3Rpbmcgc2NlbmFyaW9zLlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgO1xuXG4gIElBTkFab25lLnJlc2V0Q2FjaGUgPSBmdW5jdGlvbiByZXNldENhY2hlKCkge1xuICAgIGlhbmFab25lQ2FjaGUgPSB7fTtcbiAgICBkdGZDYWNoZSA9IHt9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHN0cmluZyBpcyBhIHZhbGlkIHNwZWNpZmllci4gVGhpcyBvbmx5IGNoZWNrcyB0aGUgc3RyaW5nJ3MgZm9ybWF0LCBub3QgdGhhdCB0aGUgc3BlY2lmaWVyIGlkZW50aWZpZXMgYSBrbm93biB6b25lOyBzZWUgaXNWYWxpZFpvbmUgZm9yIHRoYXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzIC0gVGhlIHN0cmluZyB0byBjaGVjayB2YWxpZGl0eSBvblxuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkU3BlY2lmaWVyKFwiQW1lcmljYS9OZXdfWW9ya1wiKSAvLz0+IHRydWVcbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFNwZWNpZmllcihcIkZhbnRhc2lhL0Nhc3RsZVwiKSAvLz0+IHRydWVcbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFNwZWNpZmllcihcIlNwb3J0fn5ibG9ycFwiKSAvLz0+IGZhbHNlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICA7XG5cbiAgSUFOQVpvbmUuaXNWYWxpZFNwZWNpZmllciA9IGZ1bmN0aW9uIGlzVmFsaWRTcGVjaWZpZXIocykge1xuICAgIHJldHVybiAhIShzICYmIHMubWF0Y2gobWF0Y2hpbmdSZWdleCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHN0cmluZyBpZGVudGlmaWVzIGEgcmVhbCB6b25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6b25lIC0gVGhlIHN0cmluZyB0byBjaGVja1xuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShcIkFtZXJpY2EvTmV3X1lvcmtcIikgLy89PiB0cnVlXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRab25lKFwiRmFudGFzaWEvQ2FzdGxlXCIpIC8vPT4gZmFsc2VcbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFpvbmUoXCJTcG9ydH5+YmxvcnBcIikgLy89PiBmYWxzZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgO1xuXG4gIElBTkFab25lLmlzVmFsaWRab25lID0gZnVuY3Rpb24gaXNWYWxpZFpvbmUoem9uZSkge1xuICAgIHRyeSB7XG4gICAgICBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHtcbiAgICAgICAgdGltZVpvbmU6IHpvbmVcbiAgICAgIH0pLmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSAvLyBFdGMvR01UKzggLT4gLTQ4MFxuXG4gIC8qKiBAaWdub3JlICovXG4gIDtcblxuICBJQU5BWm9uZS5wYXJzZUdNVE9mZnNldCA9IGZ1bmN0aW9uIHBhcnNlR01UT2Zmc2V0KHNwZWNpZmllcikge1xuICAgIGlmIChzcGVjaWZpZXIpIHtcbiAgICAgIHZhciBtYXRjaCA9IHNwZWNpZmllci5tYXRjaCgvXkV0Y1xcL0dNVChbKy1dXFxkezEsMn0pJC9pKTtcblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiAtNjAgKiBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgZnVuY3Rpb24gSUFOQVpvbmUobmFtZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1pvbmUuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIC8qKiBAcHJpdmF0ZSAqKi9cblxuICAgIF90aGlzLnpvbmVOYW1lID0gbmFtZTtcbiAgICAvKiogQHByaXZhdGUgKiovXG5cbiAgICBfdGhpcy52YWxpZCA9IElBTkFab25lLmlzVmFsaWRab25lKG5hbWUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKiogQG92ZXJyaWRlICoqL1xuXG5cbiAgdmFyIF9wcm90byA9IElBTkFab25lLnByb3RvdHlwZTtcblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBfcHJvdG8ub2Zmc2V0TmFtZSA9IGZ1bmN0aW9uIG9mZnNldE5hbWUodHMsIF9yZWYpIHtcbiAgICB2YXIgZm9ybWF0ID0gX3JlZi5mb3JtYXQsXG4gICAgICAgIGxvY2FsZSA9IF9yZWYubG9jYWxlO1xuICAgIHJldHVybiBwYXJzZVpvbmVJbmZvKHRzLCBmb3JtYXQsIGxvY2FsZSwgdGhpcy5uYW1lKTtcbiAgfVxuICAvKiogQG92ZXJyaWRlICoqL1xuICA7XG5cbiAgX3Byb3RvLmZvcm1hdE9mZnNldCA9IGZ1bmN0aW9uIGZvcm1hdE9mZnNldCQxKHRzLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHRoaXMub2Zmc2V0KHRzKSwgZm9ybWF0KTtcbiAgfVxuICAvKiogQG92ZXJyaWRlICoqL1xuICA7XG5cbiAgX3Byb3RvLm9mZnNldCA9IGZ1bmN0aW9uIG9mZnNldCh0cykge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUodHMpLFxuICAgICAgICBkdGYgPSBtYWtlRFRGKHRoaXMubmFtZSksXG4gICAgICAgIF9yZWYyID0gZHRmLmZvcm1hdFRvUGFydHMgPyBwYXJ0c09mZnNldChkdGYsIGRhdGUpIDogaGFja3lPZmZzZXQoZHRmLCBkYXRlKSxcbiAgICAgICAgeWVhciA9IF9yZWYyWzBdLFxuICAgICAgICBtb250aCA9IF9yZWYyWzFdLFxuICAgICAgICBkYXkgPSBfcmVmMlsyXSxcbiAgICAgICAgaG91ciA9IF9yZWYyWzNdLFxuICAgICAgICBtaW51dGUgPSBfcmVmMls0XSxcbiAgICAgICAgc2Vjb25kID0gX3JlZjJbNV0sXG4gICAgICAgIGFkanVzdGVkSG91ciA9IGhvdXIgPT09IDI0ID8gMCA6IGhvdXI7XG5cbiAgICB2YXIgYXNVVEMgPSBvYmpUb0xvY2FsVFMoe1xuICAgICAgeWVhcjogeWVhcixcbiAgICAgIG1vbnRoOiBtb250aCxcbiAgICAgIGRheTogZGF5LFxuICAgICAgaG91cjogYWRqdXN0ZWRIb3VyLFxuICAgICAgbWludXRlOiBtaW51dGUsXG4gICAgICBzZWNvbmQ6IHNlY29uZCxcbiAgICAgIG1pbGxpc2Vjb25kOiAwXG4gICAgfSk7XG4gICAgdmFyIGFzVFMgPSArZGF0ZTtcbiAgICB2YXIgb3ZlciA9IGFzVFMgJSAxMDAwO1xuICAgIGFzVFMgLT0gb3ZlciA+PSAwID8gb3ZlciA6IDEwMDAgKyBvdmVyO1xuICAgIHJldHVybiAoYXNVVEMgLSBhc1RTKSAvICg2MCAqIDEwMDApO1xuICB9XG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIDtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyWm9uZSkge1xuICAgIHJldHVybiBvdGhlclpvbmUudHlwZSA9PT0gXCJpYW5hXCIgJiYgb3RoZXJab25lLm5hbWUgPT09IHRoaXMubmFtZTtcbiAgfVxuICAvKiogQG92ZXJyaWRlICoqL1xuICA7XG5cbiAgX2NyZWF0ZUNsYXNzKElBTkFab25lLCBbe1xuICAgIGtleTogXCJ0eXBlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gXCJpYW5hXCI7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKiovXG5cbiAgfSwge1xuICAgIGtleTogXCJuYW1lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy56b25lTmFtZTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVuaXZlcnNhbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1ZhbGlkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWxpZDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSUFOQVpvbmU7XG59KFpvbmUpO1xuXG52YXIgc2luZ2xldG9uJDEgPSBudWxsO1xuLyoqXG4gKiBBIHpvbmUgd2l0aCBhIGZpeGVkIG9mZnNldCAobWVhbmluZyBubyBEU1QpXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuXG52YXIgRml4ZWRPZmZzZXRab25lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfWm9uZSkge1xuICBfaW5oZXJpdHNMb29zZShGaXhlZE9mZnNldFpvbmUsIF9ab25lKTtcblxuICAvKipcbiAgICogR2V0IGFuIGluc3RhbmNlIHdpdGggYSBzcGVjaWZpZWQgb2Zmc2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGluIG1pbnV0ZXNcbiAgICogQHJldHVybiB7Rml4ZWRPZmZzZXRab25lfVxuICAgKi9cbiAgRml4ZWRPZmZzZXRab25lLmluc3RhbmNlID0gZnVuY3Rpb24gaW5zdGFuY2Uob2Zmc2V0KSB7XG4gICAgcmV0dXJuIG9mZnNldCA9PT0gMCA/IEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZSA6IG5ldyBGaXhlZE9mZnNldFpvbmUob2Zmc2V0KTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFuIGluc3RhbmNlIG9mIEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIGEgVVRDIG9mZnNldCBzdHJpbmcsIGxpa2UgXCJVVEMrNlwiXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzIC0gVGhlIG9mZnNldCBzdHJpbmcgdG8gcGFyc2VcbiAgICogQGV4YW1wbGUgRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKFwiVVRDKzZcIilcbiAgICogQGV4YW1wbGUgRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKFwiVVRDKzA2XCIpXG4gICAqIEBleGFtcGxlIEZpeGVkT2Zmc2V0Wm9uZS5wYXJzZVNwZWNpZmllcihcIlVUQy02OjAwXCIpXG4gICAqIEByZXR1cm4ge0ZpeGVkT2Zmc2V0Wm9uZX1cbiAgICovXG4gIDtcblxuICBGaXhlZE9mZnNldFpvbmUucGFyc2VTcGVjaWZpZXIgPSBmdW5jdGlvbiBwYXJzZVNwZWNpZmllcihzKSB7XG4gICAgaWYgKHMpIHtcbiAgICAgIHZhciByID0gcy5tYXRjaCgvXnV0Yyg/OihbKy1dXFxkezEsMn0pKD86OihcXGR7Mn0pKT8pPyQvaSk7XG5cbiAgICAgIGlmIChyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWRPZmZzZXRab25lKHNpZ25lZE9mZnNldChyWzFdLCByWzJdKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKEZpeGVkT2Zmc2V0Wm9uZSwgbnVsbCwgW3tcbiAgICBrZXk6IFwidXRjSW5zdGFuY2VcIixcblxuICAgIC8qKlxuICAgICAqIEdldCBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBVVENcbiAgICAgKiBAcmV0dXJuIHtGaXhlZE9mZnNldFpvbmV9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoc2luZ2xldG9uJDEgPT09IG51bGwpIHtcbiAgICAgICAgc2luZ2xldG9uJDEgPSBuZXcgRml4ZWRPZmZzZXRab25lKDApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2luZ2xldG9uJDE7XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gRml4ZWRPZmZzZXRab25lKG9mZnNldCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1pvbmUuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIC8qKiBAcHJpdmF0ZSAqKi9cblxuICAgIF90aGlzLmZpeGVkID0gb2Zmc2V0O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKiogQG92ZXJyaWRlICoqL1xuXG5cbiAgdmFyIF9wcm90byA9IEZpeGVkT2Zmc2V0Wm9uZS5wcm90b3R5cGU7XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgX3Byb3RvLm9mZnNldE5hbWUgPSBmdW5jdGlvbiBvZmZzZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgO1xuXG4gIF9wcm90by5mb3JtYXRPZmZzZXQgPSBmdW5jdGlvbiBmb3JtYXRPZmZzZXQkMSh0cywgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGZvcm1hdE9mZnNldCh0aGlzLmZpeGVkLCBmb3JtYXQpO1xuICB9XG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIDtcblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBfcHJvdG8ub2Zmc2V0ID0gZnVuY3Rpb24gb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmZpeGVkO1xuICB9XG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIDtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyWm9uZSkge1xuICAgIHJldHVybiBvdGhlclpvbmUudHlwZSA9PT0gXCJmaXhlZFwiICYmIG90aGVyWm9uZS5maXhlZCA9PT0gdGhpcy5maXhlZDtcbiAgfVxuICAvKiogQG92ZXJyaWRlICoqL1xuICA7XG5cbiAgX2NyZWF0ZUNsYXNzKEZpeGVkT2Zmc2V0Wm9uZSwgW3tcbiAgICBrZXk6IFwidHlwZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFwiZml4ZWRcIjtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm5hbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpeGVkID09PSAwID8gXCJVVENcIiA6IFwiVVRDXCIgKyBmb3JtYXRPZmZzZXQodGhpcy5maXhlZCwgXCJuYXJyb3dcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuaXZlcnNhbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVmFsaWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGaXhlZE9mZnNldFpvbmU7XG59KFpvbmUpO1xuXG4vKipcbiAqIEEgem9uZSB0aGF0IGZhaWxlZCB0byBwYXJzZS4gWW91IHNob3VsZCBuZXZlciBuZWVkIHRvIGluc3RhbnRpYXRlIHRoaXMuXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuXG52YXIgSW52YWxpZFpvbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9ab25lKSB7XG4gIF9pbmhlcml0c0xvb3NlKEludmFsaWRab25lLCBfWm9uZSk7XG5cbiAgZnVuY3Rpb24gSW52YWxpZFpvbmUoem9uZU5hbWUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9ab25lLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAvKiogIEBwcml2YXRlICovXG5cbiAgICBfdGhpcy56b25lTmFtZSA9IHpvbmVOYW1lO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKiogQG92ZXJyaWRlICoqL1xuXG5cbiAgdmFyIF9wcm90byA9IEludmFsaWRab25lLnByb3RvdHlwZTtcblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBfcHJvdG8ub2Zmc2V0TmFtZSA9IGZ1bmN0aW9uIG9mZnNldE5hbWUoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgO1xuXG4gIF9wcm90by5mb3JtYXRPZmZzZXQgPSBmdW5jdGlvbiBmb3JtYXRPZmZzZXQoKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgO1xuXG4gIF9wcm90by5vZmZzZXQgPSBmdW5jdGlvbiBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuICAvKiogQG92ZXJyaWRlICoqL1xuICA7XG5cbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgO1xuXG4gIF9jcmVhdGVDbGFzcyhJbnZhbGlkWm9uZSwgW3tcbiAgICBrZXk6IFwidHlwZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFwiaW52YWxpZFwiO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmFtZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuem9uZU5hbWU7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKiovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1bml2ZXJzYWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNWYWxpZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbnZhbGlkWm9uZTtcbn0oWm9uZSk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplWm9uZShpbnB1dCwgZGVmYXVsdFpvbmUpIHtcbiAgdmFyIG9mZnNldDtcblxuICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpIHx8IGlucHV0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRab25lO1xuICB9IGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgWm9uZSkge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfSBlbHNlIGlmIChpc1N0cmluZyhpbnB1dCkpIHtcbiAgICB2YXIgbG93ZXJlZCA9IGlucHV0LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxvd2VyZWQgPT09IFwibG9jYWxcIikgcmV0dXJuIGRlZmF1bHRab25lO2Vsc2UgaWYgKGxvd2VyZWQgPT09IFwidXRjXCIgfHwgbG93ZXJlZCA9PT0gXCJnbXRcIikgcmV0dXJuIEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZTtlbHNlIGlmICgob2Zmc2V0ID0gSUFOQVpvbmUucGFyc2VHTVRPZmZzZXQoaW5wdXQpKSAhPSBudWxsKSB7XG4gICAgICAvLyBoYW5kbGUgRXRjL0dNVC00LCB3aGljaCBWOCBjaG9rZXMgb25cbiAgICAgIHJldHVybiBGaXhlZE9mZnNldFpvbmUuaW5zdGFuY2Uob2Zmc2V0KTtcbiAgICB9IGVsc2UgaWYgKElBTkFab25lLmlzVmFsaWRTcGVjaWZpZXIobG93ZXJlZCkpIHJldHVybiBJQU5BWm9uZS5jcmVhdGUoaW5wdXQpO2Vsc2UgcmV0dXJuIEZpeGVkT2Zmc2V0Wm9uZS5wYXJzZVNwZWNpZmllcihsb3dlcmVkKSB8fCBuZXcgSW52YWxpZFpvbmUoaW5wdXQpO1xuICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgIHJldHVybiBGaXhlZE9mZnNldFpvbmUuaW5zdGFuY2UoaW5wdXQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIiAmJiBpbnB1dC5vZmZzZXQgJiYgdHlwZW9mIGlucHV0Lm9mZnNldCA9PT0gXCJudW1iZXJcIikge1xuICAgIC8vIFRoaXMgaXMgZHVtYiwgYnV0IHRoZSBpbnN0YW5jZW9mIGNoZWNrIGFib3ZlIGRvZXNuJ3Qgc2VlbSB0byByZWFsbHkgd29ya1xuICAgIC8vIHNvIHdlJ3JlIGR1Y2sgY2hlY2tpbmcgaXRcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBJbnZhbGlkWm9uZShpbnB1dCk7XG4gIH1cbn1cblxudmFyIG5vdyA9IGZ1bmN0aW9uIG5vdygpIHtcbiAgcmV0dXJuIERhdGUubm93KCk7XG59LFxuICAgIGRlZmF1bHRab25lID0gbnVsbCxcbiAgICAvLyBub3Qgc2V0dGluZyB0aGlzIGRpcmVjdGx5IHRvIExvY2FsWm9uZS5pbnN0YW5jZSBiYyBsb2FkaW5nIG9yZGVyIGlzc3Vlc1xuZGVmYXVsdExvY2FsZSA9IG51bGwsXG4gICAgZGVmYXVsdE51bWJlcmluZ1N5c3RlbSA9IG51bGwsXG4gICAgZGVmYXVsdE91dHB1dENhbGVuZGFyID0gbnVsbCxcbiAgICB0aHJvd09uSW52YWxpZCA9IGZhbHNlO1xuLyoqXG4gKiBTZXR0aW5ncyBjb250YWlucyBzdGF0aWMgZ2V0dGVycyBhbmQgc2V0dGVycyB0aGF0IGNvbnRyb2wgTHV4b24ncyBvdmVyYWxsIGJlaGF2aW9yLiBMdXhvbiBpcyBhIHNpbXBsZSBsaWJyYXJ5IHdpdGggZmV3IG9wdGlvbnMsIGJ1dCB0aGUgb25lcyBpdCBkb2VzIGhhdmUgbGl2ZSBoZXJlLlxuICovXG5cblxudmFyIFNldHRpbmdzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2V0dGluZ3MoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXNldCBMdXhvbidzIGdsb2JhbCBjYWNoZXMuIFNob3VsZCBvbmx5IGJlIG5lY2Vzc2FyeSBpbiB0ZXN0aW5nIHNjZW5hcmlvcy5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIFNldHRpbmdzLnJlc2V0Q2FjaGVzID0gZnVuY3Rpb24gcmVzZXRDYWNoZXMoKSB7XG4gICAgTG9jYWxlLnJlc2V0Q2FjaGUoKTtcbiAgICBJQU5BWm9uZS5yZXNldENhY2hlKCk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFNldHRpbmdzLCBudWxsLCBbe1xuICAgIGtleTogXCJub3dcIixcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2FsbGJhY2sgZm9yIHJldHVybmluZyB0aGUgY3VycmVudCB0aW1lc3RhbXAuXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIG5vdztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjYWxsYmFjayBmb3IgcmV0dXJuaW5nIHRoZSBjdXJyZW50IHRpbWVzdGFtcC5cbiAgICAgKiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIG51bWJlciwgd2hpY2ggd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBhbiBFcG9jaCBtaWxsaXNlY29uZCBjb3VudFxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKiBAZXhhbXBsZSBTZXR0aW5ncy5ub3cgPSAoKSA9PiBEYXRlLm5vdygpICsgMzAwMCAvLyBwcmV0ZW5kIGl0IGlzIDMgc2Vjb25kcyBpbiB0aGUgZnV0dXJlXG4gICAgICogQGV4YW1wbGUgU2V0dGluZ3Mubm93ID0gKCkgPT4gMCAvLyBhbHdheXMgcHJldGVuZCBpdCdzIEphbiAxLCAxOTcwIGF0IG1pZG5pZ2h0IGluIFVUQyB0aW1lXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG4pIHtcbiAgICAgIG5vdyA9IG47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGVmYXVsdCB0aW1lIHpvbmUgdG8gY3JlYXRlIERhdGVUaW1lcyBpbi5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVmYXVsdFpvbmVOYW1lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gU2V0dGluZ3MuZGVmYXVsdFpvbmUubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBkZWZhdWx0IHRpbWUgem9uZSB0byBjcmVhdGUgRGF0ZVRpbWVzIGluLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHopIHtcbiAgICAgIGlmICgheikge1xuICAgICAgICBkZWZhdWx0Wm9uZSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZhdWx0Wm9uZSA9IG5vcm1hbGl6ZVpvbmUoeik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGVmYXVsdCB0aW1lIHpvbmUgb2JqZWN0IHRvIGNyZWF0ZSBEYXRlVGltZXMgaW4uIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAgICogQHR5cGUge1pvbmV9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZWZhdWx0Wm9uZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRab25lIHx8IExvY2FsWm9uZS5pbnN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkZWZhdWx0IGxvY2FsZSB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlZmF1bHRMb2NhbGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0TG9jYWxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGRlZmF1bHQgbG9jYWxlIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChsb2NhbGUpIHtcbiAgICAgIGRlZmF1bHRMb2NhbGUgPSBsb2NhbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGVmYXVsdCBudW1iZXJpbmcgc3lzdGVtIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVmYXVsdE51bWJlcmluZ1N5c3RlbVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHROdW1iZXJpbmdTeXN0ZW07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZGVmYXVsdCBudW1iZXJpbmcgc3lzdGVtIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChudW1iZXJpbmdTeXN0ZW0pIHtcbiAgICAgIGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0gPSBudW1iZXJpbmdTeXN0ZW07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGVmYXVsdCBvdXRwdXQgY2FsZW5kYXIgdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZWZhdWx0T3V0cHV0Q2FsZW5kYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0T3V0cHV0Q2FsZW5kYXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZGVmYXVsdCBvdXRwdXQgY2FsZW5kYXIgdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG91dHB1dENhbGVuZGFyKSB7XG4gICAgICBkZWZhdWx0T3V0cHV0Q2FsZW5kYXIgPSBvdXRwdXRDYWxlbmRhcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHdoZXRoZXIgTHV4b24gd2lsbCB0aHJvdyB3aGVuIGl0IGVuY291bnRlcnMgaW52YWxpZCBEYXRlVGltZXMsIER1cmF0aW9ucywgb3IgSW50ZXJ2YWxzXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0aHJvd09uSW52YWxpZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRocm93T25JbnZhbGlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgd2hldGhlciBMdXhvbiB3aWxsIHRocm93IHdoZW4gaXQgZW5jb3VudGVycyBpbnZhbGlkIERhdGVUaW1lcywgRHVyYXRpb25zLCBvciBJbnRlcnZhbHNcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodCkge1xuICAgICAgdGhyb3dPbkludmFsaWQgPSB0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTZXR0aW5ncztcbn0oKTtcblxudmFyIGludGxEVENhY2hlID0ge307XG5cbmZ1bmN0aW9uIGdldENhY2hlZERURihsb2NTdHJpbmcsIG9wdHMpIHtcbiAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIHZhciBrZXkgPSBKU09OLnN0cmluZ2lmeShbbG9jU3RyaW5nLCBvcHRzXSk7XG4gIHZhciBkdGYgPSBpbnRsRFRDYWNoZVtrZXldO1xuXG4gIGlmICghZHRmKSB7XG4gICAgZHRmID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsRFRDYWNoZVtrZXldID0gZHRmO1xuICB9XG5cbiAgcmV0dXJuIGR0Zjtcbn1cblxudmFyIGludGxOdW1DYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDYWNoZWRJTkYobG9jU3RyaW5nLCBvcHRzKSB7XG4gIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICBvcHRzID0ge307XG4gIH1cblxuICB2YXIga2V5ID0gSlNPTi5zdHJpbmdpZnkoW2xvY1N0cmluZywgb3B0c10pO1xuICB2YXIgaW5mID0gaW50bE51bUNhY2hlW2tleV07XG5cbiAgaWYgKCFpbmYpIHtcbiAgICBpbmYgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsTnVtQ2FjaGVba2V5XSA9IGluZjtcbiAgfVxuXG4gIHJldHVybiBpbmY7XG59XG5cbnZhciBpbnRsUmVsQ2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q2FjaGVkUlRGKGxvY1N0cmluZywgb3B0cykge1xuICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRzID0gb3B0cyxcbiAgICAgIGJhc2UgPSBfb3B0cy5iYXNlLFxuICAgICAgY2FjaGVLZXlPcHRzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX29wdHMsIFtcImJhc2VcIl0pOyAvLyBleGNsdWRlIGBiYXNlYCBmcm9tIHRoZSBvcHRpb25zXG5cblxuICB2YXIga2V5ID0gSlNPTi5zdHJpbmdpZnkoW2xvY1N0cmluZywgY2FjaGVLZXlPcHRzXSk7XG4gIHZhciBpbmYgPSBpbnRsUmVsQ2FjaGVba2V5XTtcblxuICBpZiAoIWluZikge1xuICAgIGluZiA9IG5ldyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdChsb2NTdHJpbmcsIG9wdHMpO1xuICAgIGludGxSZWxDYWNoZVtrZXldID0gaW5mO1xuICB9XG5cbiAgcmV0dXJuIGluZjtcbn1cblxudmFyIHN5c0xvY2FsZUNhY2hlID0gbnVsbDtcblxuZnVuY3Rpb24gc3lzdGVtTG9jYWxlKCkge1xuICBpZiAoc3lzTG9jYWxlQ2FjaGUpIHtcbiAgICByZXR1cm4gc3lzTG9jYWxlQ2FjaGU7XG4gIH0gZWxzZSBpZiAoaGFzSW50bCgpKSB7XG4gICAgdmFyIGNvbXB1dGVkU3lzID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS5sb2NhbGU7IC8vIG5vZGUgc29tZXRpbWVzIGRlZmF1bHRzIHRvIFwidW5kXCIuIE92ZXJyaWRlIHRoYXQgYmVjYXVzZSB0aGF0IGlzIGR1bWJcblxuICAgIHN5c0xvY2FsZUNhY2hlID0gIWNvbXB1dGVkU3lzIHx8IGNvbXB1dGVkU3lzID09PSBcInVuZFwiID8gXCJlbi1VU1wiIDogY29tcHV0ZWRTeXM7XG4gICAgcmV0dXJuIHN5c0xvY2FsZUNhY2hlO1xuICB9IGVsc2Uge1xuICAgIHN5c0xvY2FsZUNhY2hlID0gXCJlbi1VU1wiO1xuICAgIHJldHVybiBzeXNMb2NhbGVDYWNoZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZUxvY2FsZVN0cmluZyhsb2NhbGVTdHIpIHtcbiAgLy8gSSByZWFsbHkgd2FudCB0byBhdm9pZCB3cml0aW5nIGEgQkNQIDQ3IHBhcnNlclxuICAvLyBzZWUsIGUuZy4gaHR0cHM6Ly9naXRodWIuY29tL3dvb29ybS9iY3AtNDdcbiAgLy8gSW5zdGVhZCwgd2UnbGwgZG8gdGhpczpcbiAgLy8gYSkgaWYgdGhlIHN0cmluZyBoYXMgbm8gLXUgZXh0ZW5zaW9ucywganVzdCBsZWF2ZSBpdCBhbG9uZVxuICAvLyBiKSBpZiBpdCBkb2VzLCB1c2UgSW50bCB0byByZXNvbHZlIGV2ZXJ5dGhpbmdcbiAgLy8gYykgaWYgSW50bCBmYWlscywgdHJ5IGFnYWluIHdpdGhvdXQgdGhlIC11XG4gIHZhciB1SW5kZXggPSBsb2NhbGVTdHIuaW5kZXhPZihcIi11LVwiKTtcblxuICBpZiAodUluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiBbbG9jYWxlU3RyXTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgb3B0aW9ucztcbiAgICB2YXIgc21hbGxlciA9IGxvY2FsZVN0ci5zdWJzdHJpbmcoMCwgdUluZGV4KTtcblxuICAgIHRyeSB7XG4gICAgICBvcHRpb25zID0gZ2V0Q2FjaGVkRFRGKGxvY2FsZVN0cikucmVzb2x2ZWRPcHRpb25zKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb3B0aW9ucyA9IGdldENhY2hlZERURihzbWFsbGVyKS5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgICB9XG5cbiAgICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgICBudW1iZXJpbmdTeXN0ZW0gPSBfb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIGNhbGVuZGFyID0gX29wdGlvbnMuY2FsZW5kYXI7IC8vIHJldHVybiB0aGUgc21hbGxlciBvbmUgc28gdGhhdCB3ZSBjYW4gYXBwZW5kIHRoZSBjYWxlbmRhciBhbmQgbnVtYmVyaW5nIG92ZXJyaWRlcyB0byBpdFxuXG4gICAgcmV0dXJuIFtzbWFsbGVyLCBudW1iZXJpbmdTeXN0ZW0sIGNhbGVuZGFyXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRsQ29uZmlnU3RyaW5nKGxvY2FsZVN0ciwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcikge1xuICBpZiAoaGFzSW50bCgpKSB7XG4gICAgaWYgKG91dHB1dENhbGVuZGFyIHx8IG51bWJlcmluZ1N5c3RlbSkge1xuICAgICAgbG9jYWxlU3RyICs9IFwiLXVcIjtcblxuICAgICAgaWYgKG91dHB1dENhbGVuZGFyKSB7XG4gICAgICAgIGxvY2FsZVN0ciArPSBcIi1jYS1cIiArIG91dHB1dENhbGVuZGFyO1xuICAgICAgfVxuXG4gICAgICBpZiAobnVtYmVyaW5nU3lzdGVtKSB7XG4gICAgICAgIGxvY2FsZVN0ciArPSBcIi1udS1cIiArIG51bWJlcmluZ1N5c3RlbTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxvY2FsZVN0cjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxvY2FsZVN0cjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcE1vbnRocyhmKSB7XG4gIHZhciBtcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IDEyOyBpKyspIHtcbiAgICB2YXIgZHQgPSBEYXRlVGltZS51dGMoMjAxNiwgaSwgMSk7XG4gICAgbXMucHVzaChmKGR0KSk7XG4gIH1cblxuICByZXR1cm4gbXM7XG59XG5cbmZ1bmN0aW9uIG1hcFdlZWtkYXlzKGYpIHtcbiAgdmFyIG1zID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gNzsgaSsrKSB7XG4gICAgdmFyIGR0ID0gRGF0ZVRpbWUudXRjKDIwMTYsIDExLCAxMyArIGkpO1xuICAgIG1zLnB1c2goZihkdCkpO1xuICB9XG5cbiAgcmV0dXJuIG1zO1xufVxuXG5mdW5jdGlvbiBsaXN0U3R1ZmYobG9jLCBsZW5ndGgsIGRlZmF1bHRPSywgZW5nbGlzaEZuLCBpbnRsRm4pIHtcbiAgdmFyIG1vZGUgPSBsb2MubGlzdGluZ01vZGUoZGVmYXVsdE9LKTtcblxuICBpZiAobW9kZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAobW9kZSA9PT0gXCJlblwiKSB7XG4gICAgcmV0dXJuIGVuZ2xpc2hGbihsZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpbnRsRm4obGVuZ3RoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdXBwb3J0c0Zhc3ROdW1iZXJzKGxvYykge1xuICBpZiAobG9jLm51bWJlcmluZ1N5c3RlbSAmJiBsb2MubnVtYmVyaW5nU3lzdGVtICE9PSBcImxhdG5cIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbG9jLm51bWJlcmluZ1N5c3RlbSA9PT0gXCJsYXRuXCIgfHwgIWxvYy5sb2NhbGUgfHwgbG9jLmxvY2FsZS5zdGFydHNXaXRoKFwiZW5cIikgfHwgaGFzSW50bCgpICYmIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvYy5pbnRsKS5yZXNvbHZlZE9wdGlvbnMoKS5udW1iZXJpbmdTeXN0ZW0gPT09IFwibGF0blwiO1xuICB9XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuXG52YXIgUG9seU51bWJlckZvcm1hdHRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBvbHlOdW1iZXJGb3JtYXR0ZXIoaW50bCwgZm9yY2VTaW1wbGUsIG9wdHMpIHtcbiAgICB0aGlzLnBhZFRvID0gb3B0cy5wYWRUbyB8fCAwO1xuICAgIHRoaXMuZmxvb3IgPSBvcHRzLmZsb29yIHx8IGZhbHNlO1xuXG4gICAgaWYgKCFmb3JjZVNpbXBsZSAmJiBoYXNJbnRsKCkpIHtcbiAgICAgIHZhciBpbnRsT3B0cyA9IHtcbiAgICAgICAgdXNlR3JvdXBpbmc6IGZhbHNlXG4gICAgICB9O1xuICAgICAgaWYgKG9wdHMucGFkVG8gPiAwKSBpbnRsT3B0cy5taW5pbXVtSW50ZWdlckRpZ2l0cyA9IG9wdHMucGFkVG87XG4gICAgICB0aGlzLmluZiA9IGdldENhY2hlZElORihpbnRsLCBpbnRsT3B0cyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIF9wcm90byA9IFBvbHlOdW1iZXJGb3JtYXR0ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5mb3JtYXQgPSBmdW5jdGlvbiBmb3JtYXQoaSkge1xuICAgIGlmICh0aGlzLmluZikge1xuICAgICAgdmFyIGZpeGVkID0gdGhpcy5mbG9vciA/IE1hdGguZmxvb3IoaSkgOiBpO1xuICAgICAgcmV0dXJuIHRoaXMuaW5mLmZvcm1hdChmaXhlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRvIG1hdGNoIHRoZSBicm93c2VyJ3MgbnVtYmVyZm9ybWF0dGVyIGRlZmF1bHRzXG4gICAgICB2YXIgX2ZpeGVkID0gdGhpcy5mbG9vciA/IE1hdGguZmxvb3IoaSkgOiByb3VuZFRvKGksIDMpO1xuXG4gICAgICByZXR1cm4gcGFkU3RhcnQoX2ZpeGVkLCB0aGlzLnBhZFRvKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFBvbHlOdW1iZXJGb3JtYXR0ZXI7XG59KCk7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuXG52YXIgUG9seURhdGVGb3JtYXR0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQb2x5RGF0ZUZvcm1hdHRlcihkdCwgaW50bCwgb3B0cykge1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5oYXNJbnRsID0gaGFzSW50bCgpO1xuICAgIHZhciB6O1xuXG4gICAgaWYgKGR0LnpvbmUudW5pdmVyc2FsICYmIHRoaXMuaGFzSW50bCkge1xuICAgICAgLy8gQ2hyb21pdW0gZG9lc24ndCBzdXBwb3J0IGZpeGVkLW9mZnNldCB6b25lcyBsaWtlIEV0Yy9HTVQrOCBpbiBpdHMgZm9ybWF0dGVyLFxuICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM2NDM3NC5cbiAgICAgIC8vIFNvIHdlIGhhdmUgdG8gbWFrZSBkby4gVHdvIGNhc2VzOlxuICAgICAgLy8gMS4gVGhlIGZvcm1hdCBvcHRpb25zIHRlbGwgdXMgdG8gc2hvdyB0aGUgem9uZS4gV2UgY2FuJ3QgZG8gdGhhdCwgc28gdGhlIGJlc3RcbiAgICAgIC8vIHdlIGNhbiBkbyBpcyBmb3JtYXQgdGhlIGRhdGUgaW4gVVRDLlxuICAgICAgLy8gMi4gVGhlIGZvcm1hdCBvcHRpb25zIGRvbid0IHRlbGwgdXMgdG8gc2hvdyB0aGUgem9uZS4gVGhlbiB3ZSBjYW4gYWRqdXN0IHRoZW1cbiAgICAgIC8vIHRoZSB0aW1lIGFuZCB0ZWxsIHRoZSBmb3JtYXR0ZXIgdG8gc2hvdyBpdCB0byB1cyBpbiBVVEMsIHNvIHRoYXQgdGhlIHRpbWUgaXMgcmlnaHRcbiAgICAgIC8vIGFuZCB0aGUgYmFkIHpvbmUgZG9lc24ndCBzaG93IHVwLlxuICAgICAgLy8gV2UgY2FuIGNsZWFuIGFsbCB0aGlzIHVwIHdoZW4gQ2hyb21lIGZpeGVzIHRoaXMuXG4gICAgICB6ID0gXCJVVENcIjtcblxuICAgICAgaWYgKG9wdHMudGltZVpvbmVOYW1lKSB7XG4gICAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZHQgPSBkdC5vZmZzZXQgPT09IDAgPyBkdCA6IERhdGVUaW1lLmZyb21NaWxsaXMoZHQudHMgKyBkdC5vZmZzZXQgKiA2MCAqIDEwMDApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZHQuem9uZS50eXBlID09PSBcImxvY2FsXCIpIHtcbiAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kdCA9IGR0O1xuICAgICAgeiA9IGR0LnpvbmUubmFtZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNJbnRsKSB7XG4gICAgICB2YXIgaW50bE9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMpO1xuXG4gICAgICBpZiAoeikge1xuICAgICAgICBpbnRsT3B0cy50aW1lWm9uZSA9IHo7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZHRmID0gZ2V0Q2FjaGVkRFRGKGludGwsIGludGxPcHRzKTtcbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IFBvbHlEYXRlRm9ybWF0dGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8yLmZvcm1hdCA9IGZ1bmN0aW9uIGZvcm1hdCgpIHtcbiAgICBpZiAodGhpcy5oYXNJbnRsKSB7XG4gICAgICByZXR1cm4gdGhpcy5kdGYuZm9ybWF0KHRoaXMuZHQudG9KU0RhdGUoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0b2tlbkZvcm1hdCA9IGZvcm1hdFN0cmluZyh0aGlzLm9wdHMpLFxuICAgICAgICAgIGxvYyA9IExvY2FsZS5jcmVhdGUoXCJlbi1VU1wiKTtcbiAgICAgIHJldHVybiBGb3JtYXR0ZXIuY3JlYXRlKGxvYykuZm9ybWF0RGF0ZVRpbWVGcm9tU3RyaW5nKHRoaXMuZHQsIHRva2VuRm9ybWF0KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvMi5mb3JtYXRUb1BhcnRzID0gZnVuY3Rpb24gZm9ybWF0VG9QYXJ0cygpIHtcbiAgICBpZiAodGhpcy5oYXNJbnRsICYmIGhhc0Zvcm1hdFRvUGFydHMoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZHRmLmZvcm1hdFRvUGFydHModGhpcy5kdC50b0pTRGF0ZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBraW5kIG9mIGEgY29wIG91dC4gV2UgYWN0dWFsbHkgY291bGQgZG8gdGhpcyBmb3IgRW5nbGlzaC4gSG93ZXZlciwgd2UgY291bGRuJ3QgZG8gaXQgZm9yIGludGwgc3RyaW5nc1xuICAgICAgLy8gYW5kIElNTyBpdCdzIHRvbyB3ZWlyZCB0byBoYXZlIGFuIHVuY2FubnkgdmFsbGV5IGxpa2UgdGhhdFxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8yLnJlc29sdmVkT3B0aW9ucyA9IGZ1bmN0aW9uIHJlc29sdmVkT3B0aW9ucygpIHtcbiAgICBpZiAodGhpcy5oYXNJbnRsKSB7XG4gICAgICByZXR1cm4gdGhpcy5kdGYucmVzb2x2ZWRPcHRpb25zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxvY2FsZTogXCJlbi1VU1wiLFxuICAgICAgICBudW1iZXJpbmdTeXN0ZW06IFwibGF0blwiLFxuICAgICAgICBvdXRwdXRDYWxlbmRhcjogXCJncmVnb3J5XCJcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBQb2x5RGF0ZUZvcm1hdHRlcjtcbn0oKTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5cbnZhciBQb2x5UmVsRm9ybWF0dGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUG9seVJlbEZvcm1hdHRlcihpbnRsLCBpc0VuZ2xpc2gsIG9wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHN0eWxlOiBcImxvbmdcIlxuICAgIH0sIG9wdHMpO1xuXG4gICAgaWYgKCFpc0VuZ2xpc2ggJiYgaGFzUmVsYXRpdmUoKSkge1xuICAgICAgdGhpcy5ydGYgPSBnZXRDYWNoZWRSVEYoaW50bCwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIF9wcm90bzMgPSBQb2x5UmVsRm9ybWF0dGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8zLmZvcm1hdCA9IGZ1bmN0aW9uIGZvcm1hdChjb3VudCwgdW5pdCkge1xuICAgIGlmICh0aGlzLnJ0Zikge1xuICAgICAgcmV0dXJuIHRoaXMucnRmLmZvcm1hdChjb3VudCwgdW5pdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmb3JtYXRSZWxhdGl2ZVRpbWUodW5pdCwgY291bnQsIHRoaXMub3B0cy5udW1lcmljLCB0aGlzLm9wdHMuc3R5bGUgIT09IFwibG9uZ1wiKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvMy5mb3JtYXRUb1BhcnRzID0gZnVuY3Rpb24gZm9ybWF0VG9QYXJ0cyhjb3VudCwgdW5pdCkge1xuICAgIGlmICh0aGlzLnJ0Zikge1xuICAgICAgcmV0dXJuIHRoaXMucnRmLmZvcm1hdFRvUGFydHMoY291bnQsIHVuaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBQb2x5UmVsRm9ybWF0dGVyO1xufSgpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cblxudmFyIExvY2FsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIExvY2FsZS5mcm9tT3B0cyA9IGZ1bmN0aW9uIGZyb21PcHRzKG9wdHMpIHtcbiAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShvcHRzLmxvY2FsZSwgb3B0cy5udW1iZXJpbmdTeXN0ZW0sIG9wdHMub3V0cHV0Q2FsZW5kYXIsIG9wdHMuZGVmYXVsdFRvRU4pO1xuICB9O1xuXG4gIExvY2FsZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyLCBkZWZhdWx0VG9FTikge1xuICAgIGlmIChkZWZhdWx0VG9FTiA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWZhdWx0VG9FTiA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzcGVjaWZpZWRMb2NhbGUgPSBsb2NhbGUgfHwgU2V0dGluZ3MuZGVmYXVsdExvY2FsZSxcbiAgICAgICAgLy8gdGhlIHN5c3RlbSBsb2NhbGUgaXMgdXNlZnVsIGZvciBodW1hbiByZWFkYWJsZSBzdHJpbmdzIGJ1dCBhbm5veWluZyBmb3IgcGFyc2luZy9mb3JtYXR0aW5nIGtub3duIGZvcm1hdHNcbiAgICBsb2NhbGVSID0gc3BlY2lmaWVkTG9jYWxlIHx8IChkZWZhdWx0VG9FTiA/IFwiZW4tVVNcIiA6IHN5c3RlbUxvY2FsZSgpKSxcbiAgICAgICAgbnVtYmVyaW5nU3lzdGVtUiA9IG51bWJlcmluZ1N5c3RlbSB8fCBTZXR0aW5ncy5kZWZhdWx0TnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBvdXRwdXRDYWxlbmRhclIgPSBvdXRwdXRDYWxlbmRhciB8fCBTZXR0aW5ncy5kZWZhdWx0T3V0cHV0Q2FsZW5kYXI7XG4gICAgcmV0dXJuIG5ldyBMb2NhbGUobG9jYWxlUiwgbnVtYmVyaW5nU3lzdGVtUiwgb3V0cHV0Q2FsZW5kYXJSLCBzcGVjaWZpZWRMb2NhbGUpO1xuICB9O1xuXG4gIExvY2FsZS5yZXNldENhY2hlID0gZnVuY3Rpb24gcmVzZXRDYWNoZSgpIHtcbiAgICBzeXNMb2NhbGVDYWNoZSA9IG51bGw7XG4gICAgaW50bERUQ2FjaGUgPSB7fTtcbiAgICBpbnRsTnVtQ2FjaGUgPSB7fTtcbiAgICBpbnRsUmVsQ2FjaGUgPSB7fTtcbiAgfTtcblxuICBMb2NhbGUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3QoX3RlbXApIHtcbiAgICB2YXIgX3JlZiA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLFxuICAgICAgICBsb2NhbGUgPSBfcmVmLmxvY2FsZSxcbiAgICAgICAgbnVtYmVyaW5nU3lzdGVtID0gX3JlZi5udW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIG91dHB1dENhbGVuZGFyID0gX3JlZi5vdXRwdXRDYWxlbmRhcjtcblxuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcik7XG4gIH07XG5cbiAgZnVuY3Rpb24gTG9jYWxlKGxvY2FsZSwgbnVtYmVyaW5nLCBvdXRwdXRDYWxlbmRhciwgc3BlY2lmaWVkTG9jYWxlKSB7XG4gICAgdmFyIF9wYXJzZUxvY2FsZVN0cmluZyA9IHBhcnNlTG9jYWxlU3RyaW5nKGxvY2FsZSksXG4gICAgICAgIHBhcnNlZExvY2FsZSA9IF9wYXJzZUxvY2FsZVN0cmluZ1swXSxcbiAgICAgICAgcGFyc2VkTnVtYmVyaW5nU3lzdGVtID0gX3BhcnNlTG9jYWxlU3RyaW5nWzFdLFxuICAgICAgICBwYXJzZWRPdXRwdXRDYWxlbmRhciA9IF9wYXJzZUxvY2FsZVN0cmluZ1syXTtcblxuICAgIHRoaXMubG9jYWxlID0gcGFyc2VkTG9jYWxlO1xuICAgIHRoaXMubnVtYmVyaW5nU3lzdGVtID0gbnVtYmVyaW5nIHx8IHBhcnNlZE51bWJlcmluZ1N5c3RlbSB8fCBudWxsO1xuICAgIHRoaXMub3V0cHV0Q2FsZW5kYXIgPSBvdXRwdXRDYWxlbmRhciB8fCBwYXJzZWRPdXRwdXRDYWxlbmRhciB8fCBudWxsO1xuICAgIHRoaXMuaW50bCA9IGludGxDb25maWdTdHJpbmcodGhpcy5sb2NhbGUsIHRoaXMubnVtYmVyaW5nU3lzdGVtLCB0aGlzLm91dHB1dENhbGVuZGFyKTtcbiAgICB0aGlzLndlZWtkYXlzQ2FjaGUgPSB7XG4gICAgICBmb3JtYXQ6IHt9LFxuICAgICAgc3RhbmRhbG9uZToge31cbiAgICB9O1xuICAgIHRoaXMubW9udGhzQ2FjaGUgPSB7XG4gICAgICBmb3JtYXQ6IHt9LFxuICAgICAgc3RhbmRhbG9uZToge31cbiAgICB9O1xuICAgIHRoaXMubWVyaWRpZW1DYWNoZSA9IG51bGw7XG4gICAgdGhpcy5lcmFDYWNoZSA9IHt9O1xuICAgIHRoaXMuc3BlY2lmaWVkTG9jYWxlID0gc3BlY2lmaWVkTG9jYWxlO1xuICAgIHRoaXMuZmFzdE51bWJlcnNDYWNoZWQgPSBudWxsO1xuICB9XG5cbiAgdmFyIF9wcm90bzQgPSBMb2NhbGUucHJvdG90eXBlO1xuXG4gIF9wcm90bzQubGlzdGluZ01vZGUgPSBmdW5jdGlvbiBsaXN0aW5nTW9kZShkZWZhdWx0T0spIHtcbiAgICBpZiAoZGVmYXVsdE9LID09PSB2b2lkIDApIHtcbiAgICAgIGRlZmF1bHRPSyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGludGwgPSBoYXNJbnRsKCksXG4gICAgICAgIGhhc0ZUUCA9IGludGwgJiYgaGFzRm9ybWF0VG9QYXJ0cygpLFxuICAgICAgICBpc0FjdHVhbGx5RW4gPSB0aGlzLmlzRW5nbGlzaCgpLFxuICAgICAgICBoYXNOb1dlaXJkbmVzcyA9ICh0aGlzLm51bWJlcmluZ1N5c3RlbSA9PT0gbnVsbCB8fCB0aGlzLm51bWJlcmluZ1N5c3RlbSA9PT0gXCJsYXRuXCIpICYmICh0aGlzLm91dHB1dENhbGVuZGFyID09PSBudWxsIHx8IHRoaXMub3V0cHV0Q2FsZW5kYXIgPT09IFwiZ3JlZ29yeVwiKTtcblxuICAgIGlmICghaGFzRlRQICYmICEoaXNBY3R1YWxseUVuICYmIGhhc05vV2VpcmRuZXNzKSAmJiAhZGVmYXVsdE9LKSB7XG4gICAgICByZXR1cm4gXCJlcnJvclwiO1xuICAgIH0gZWxzZSBpZiAoIWhhc0ZUUCB8fCBpc0FjdHVhbGx5RW4gJiYgaGFzTm9XZWlyZG5lc3MpIHtcbiAgICAgIHJldHVybiBcImVuXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcImludGxcIjtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvNC5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKGFsdHMpIHtcbiAgICBpZiAoIWFsdHMgfHwgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYWx0cykubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIExvY2FsZS5jcmVhdGUoYWx0cy5sb2NhbGUgfHwgdGhpcy5zcGVjaWZpZWRMb2NhbGUsIGFsdHMubnVtYmVyaW5nU3lzdGVtIHx8IHRoaXMubnVtYmVyaW5nU3lzdGVtLCBhbHRzLm91dHB1dENhbGVuZGFyIHx8IHRoaXMub3V0cHV0Q2FsZW5kYXIsIGFsdHMuZGVmYXVsdFRvRU4gfHwgZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG80LnJlZGVmYXVsdFRvRU4gPSBmdW5jdGlvbiByZWRlZmF1bHRUb0VOKGFsdHMpIHtcbiAgICBpZiAoYWx0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBhbHRzID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoT2JqZWN0LmFzc2lnbih7fSwgYWx0cywge1xuICAgICAgZGVmYXVsdFRvRU46IHRydWVcbiAgICB9KSk7XG4gIH07XG5cbiAgX3Byb3RvNC5yZWRlZmF1bHRUb1N5c3RlbSA9IGZ1bmN0aW9uIHJlZGVmYXVsdFRvU3lzdGVtKGFsdHMpIHtcbiAgICBpZiAoYWx0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBhbHRzID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoT2JqZWN0LmFzc2lnbih7fSwgYWx0cywge1xuICAgICAgZGVmYXVsdFRvRU46IGZhbHNlXG4gICAgfSkpO1xuICB9O1xuXG4gIF9wcm90bzQubW9udGhzID0gZnVuY3Rpb24gbW9udGhzJDEobGVuZ3RoLCBmb3JtYXQsIGRlZmF1bHRPSykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoZm9ybWF0ID09PSB2b2lkIDApIHtcbiAgICAgIGZvcm1hdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChkZWZhdWx0T0sgPT09IHZvaWQgMCkge1xuICAgICAgZGVmYXVsdE9LID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdFN0dWZmKHRoaXMsIGxlbmd0aCwgZGVmYXVsdE9LLCBtb250aHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpbnRsID0gZm9ybWF0ID8ge1xuICAgICAgICBtb250aDogbGVuZ3RoLFxuICAgICAgICBkYXk6IFwibnVtZXJpY1wiXG4gICAgICB9IDoge1xuICAgICAgICBtb250aDogbGVuZ3RoXG4gICAgICB9LFxuICAgICAgICAgIGZvcm1hdFN0ciA9IGZvcm1hdCA/IFwiZm9ybWF0XCIgOiBcInN0YW5kYWxvbmVcIjtcblxuICAgICAgaWYgKCFfdGhpcy5tb250aHNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0pIHtcbiAgICAgICAgX3RoaXMubW9udGhzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdID0gbWFwTW9udGhzKGZ1bmN0aW9uIChkdCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5leHRyYWN0KGR0LCBpbnRsLCBcIm1vbnRoXCIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzLm1vbnRoc0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG80LndlZWtkYXlzID0gZnVuY3Rpb24gd2Vla2RheXMkMShsZW5ndGgsIGZvcm1hdCwgZGVmYXVsdE9LKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAoZm9ybWF0ID09PSB2b2lkIDApIHtcbiAgICAgIGZvcm1hdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChkZWZhdWx0T0sgPT09IHZvaWQgMCkge1xuICAgICAgZGVmYXVsdE9LID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdFN0dWZmKHRoaXMsIGxlbmd0aCwgZGVmYXVsdE9LLCB3ZWVrZGF5cywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGludGwgPSBmb3JtYXQgPyB7XG4gICAgICAgIHdlZWtkYXk6IGxlbmd0aCxcbiAgICAgICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgICAgIG1vbnRoOiBcImxvbmdcIixcbiAgICAgICAgZGF5OiBcIm51bWVyaWNcIlxuICAgICAgfSA6IHtcbiAgICAgICAgd2Vla2RheTogbGVuZ3RoXG4gICAgICB9LFxuICAgICAgICAgIGZvcm1hdFN0ciA9IGZvcm1hdCA/IFwiZm9ybWF0XCIgOiBcInN0YW5kYWxvbmVcIjtcblxuICAgICAgaWYgKCFfdGhpczIud2Vla2RheXNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0pIHtcbiAgICAgICAgX3RoaXMyLndlZWtkYXlzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdID0gbWFwV2Vla2RheXMoZnVuY3Rpb24gKGR0KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5leHRyYWN0KGR0LCBpbnRsLCBcIndlZWtkYXlcIik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXMyLndlZWtkYXlzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90bzQubWVyaWRpZW1zID0gZnVuY3Rpb24gbWVyaWRpZW1zJDEoZGVmYXVsdE9LKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICBpZiAoZGVmYXVsdE9LID09PSB2b2lkIDApIHtcbiAgICAgIGRlZmF1bHRPSyA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpc3RTdHVmZih0aGlzLCB1bmRlZmluZWQsIGRlZmF1bHRPSywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG1lcmlkaWVtcztcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBJbiB0aGVvcnkgdGhlcmUgY291bGQgYmUgYXJpYml0cmFyeSBkYXkgcGVyaW9kcy4gV2UncmUgZ29ubmEgYXNzdW1lIHRoZXJlIGFyZSBleGFjdGx5IHR3b1xuICAgICAgLy8gZm9yIEFNIGFuZCBQTS4gVGhpcyBpcyBwcm9iYWJseSB3cm9uZywgYnV0IGl0J3MgbWFrZXMgcGFyc2luZyB3YXkgZWFzaWVyLlxuICAgICAgaWYgKCFfdGhpczMubWVyaWRpZW1DYWNoZSkge1xuICAgICAgICB2YXIgaW50bCA9IHtcbiAgICAgICAgICBob3VyOiBcIm51bWVyaWNcIixcbiAgICAgICAgICBob3VyMTI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMzLm1lcmlkaWVtQ2FjaGUgPSBbRGF0ZVRpbWUudXRjKDIwMTYsIDExLCAxMywgOSksIERhdGVUaW1lLnV0YygyMDE2LCAxMSwgMTMsIDE5KV0ubWFwKGZ1bmN0aW9uIChkdCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczMuZXh0cmFjdChkdCwgaW50bCwgXCJkYXlwZXJpb2RcIik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXMzLm1lcmlkaWVtQ2FjaGU7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvNC5lcmFzID0gZnVuY3Rpb24gZXJhcyQxKGxlbmd0aCwgZGVmYXVsdE9LKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICBpZiAoZGVmYXVsdE9LID09PSB2b2lkIDApIHtcbiAgICAgIGRlZmF1bHRPSyA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpc3RTdHVmZih0aGlzLCBsZW5ndGgsIGRlZmF1bHRPSywgZXJhcywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGludGwgPSB7XG4gICAgICAgIGVyYTogbGVuZ3RoXG4gICAgICB9OyAvLyBUaGlzIGlzIHV0dGVyIGJ1bGxzaGl0LiBEaWZmZXJlbnQgY2FsZW5kYXJzIGFyZSBnb2luZyB0byBkZWZpbmUgZXJhcyB0b3RhbGx5IGRpZmZlcmVudGx5LiBXaGF0IEkgbmVlZCBpcyB0aGUgbWluaW11bSBzZXQgb2YgZGF0ZXNcbiAgICAgIC8vIHRvIGRlZmluaXRlbHkgZW51bWVyYXRlIHRoZW0uXG5cbiAgICAgIGlmICghX3RoaXM0LmVyYUNhY2hlW2xlbmd0aF0pIHtcbiAgICAgICAgX3RoaXM0LmVyYUNhY2hlW2xlbmd0aF0gPSBbRGF0ZVRpbWUudXRjKC00MCwgMSwgMSksIERhdGVUaW1lLnV0YygyMDE3LCAxLCAxKV0ubWFwKGZ1bmN0aW9uIChkdCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczQuZXh0cmFjdChkdCwgaW50bCwgXCJlcmFcIik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXM0LmVyYUNhY2hlW2xlbmd0aF07XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvNC5leHRyYWN0ID0gZnVuY3Rpb24gZXh0cmFjdChkdCwgaW50bE9wdHMsIGZpZWxkKSB7XG4gICAgdmFyIGRmID0gdGhpcy5kdEZvcm1hdHRlcihkdCwgaW50bE9wdHMpLFxuICAgICAgICByZXN1bHRzID0gZGYuZm9ybWF0VG9QYXJ0cygpLFxuICAgICAgICBtYXRjaGluZyA9IHJlc3VsdHMuZmluZChmdW5jdGlvbiAobSkge1xuICAgICAgcmV0dXJuIG0udHlwZS50b0xvd2VyQ2FzZSgpID09PSBmaWVsZDtcbiAgICB9KTtcbiAgICByZXR1cm4gbWF0Y2hpbmcgPyBtYXRjaGluZy52YWx1ZSA6IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvNC5udW1iZXJGb3JtYXR0ZXIgPSBmdW5jdGlvbiBudW1iZXJGb3JtYXR0ZXIob3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyB0aGlzIGZvcmNlc2ltcGxlIG9wdGlvbiBpcyBuZXZlciB1c2VkICh0aGUgb25seSBjYWxsZXIgc2hvcnQtY2lyY3VpdHMgb24gaXQsIGJ1dCBpdCBzZWVtcyBzYWZlciB0byBsZWF2ZSlcbiAgICAvLyAoaW4gY29udHJhc3QsIHRoZSByZXN0IG9mIHRoZSBjb25kaXRpb24gaXMgdXNlZCBoZWF2aWx5KVxuICAgIHJldHVybiBuZXcgUG9seU51bWJlckZvcm1hdHRlcih0aGlzLmludGwsIG9wdHMuZm9yY2VTaW1wbGUgfHwgdGhpcy5mYXN0TnVtYmVycywgb3B0cyk7XG4gIH07XG5cbiAgX3Byb3RvNC5kdEZvcm1hdHRlciA9IGZ1bmN0aW9uIGR0Rm9ybWF0dGVyKGR0LCBpbnRsT3B0cykge1xuICAgIGlmIChpbnRsT3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBpbnRsT3B0cyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUG9seURhdGVGb3JtYXR0ZXIoZHQsIHRoaXMuaW50bCwgaW50bE9wdHMpO1xuICB9O1xuXG4gIF9wcm90bzQucmVsRm9ybWF0dGVyID0gZnVuY3Rpb24gcmVsRm9ybWF0dGVyKG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQb2x5UmVsRm9ybWF0dGVyKHRoaXMuaW50bCwgdGhpcy5pc0VuZ2xpc2goKSwgb3B0cyk7XG4gIH07XG5cbiAgX3Byb3RvNC5pc0VuZ2xpc2ggPSBmdW5jdGlvbiBpc0VuZ2xpc2goKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlID09PSBcImVuXCIgfHwgdGhpcy5sb2NhbGUudG9Mb3dlckNhc2UoKSA9PT0gXCJlbi11c1wiIHx8IGhhc0ludGwoKSAmJiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh0aGlzLmludGwpLnJlc29sdmVkT3B0aW9ucygpLmxvY2FsZS5zdGFydHNXaXRoKFwiZW4tdXNcIik7XG4gIH07XG5cbiAgX3Byb3RvNC5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGUgPT09IG90aGVyLmxvY2FsZSAmJiB0aGlzLm51bWJlcmluZ1N5c3RlbSA9PT0gb3RoZXIubnVtYmVyaW5nU3lzdGVtICYmIHRoaXMub3V0cHV0Q2FsZW5kYXIgPT09IG90aGVyLm91dHB1dENhbGVuZGFyO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhMb2NhbGUsIFt7XG4gICAga2V5OiBcImZhc3ROdW1iZXJzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5mYXN0TnVtYmVyc0NhY2hlZCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZmFzdE51bWJlcnNDYWNoZWQgPSBzdXBwb3J0c0Zhc3ROdW1iZXJzKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5mYXN0TnVtYmVyc0NhY2hlZDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTG9jYWxlO1xufSgpO1xuXG4vKlxuICogVGhpcyBmaWxlIGhhbmRsZXMgcGFyc2luZyBmb3Igd2VsbC1zcGVjaWZpZWQgZm9ybWF0cy4gSGVyZSdzIGhvdyBpdCB3b3JrczpcbiAqIFR3byB0aGluZ3MgZ28gaW50byBwYXJzaW5nOiBhIHJlZ2V4IHRvIG1hdGNoIHdpdGggYW5kIGFuIGV4dHJhY3RvciB0byB0YWtlIGFwYXJ0IHRoZSBncm91cHMgaW4gdGhlIG1hdGNoLlxuICogQW4gZXh0cmFjdG9yIGlzIGp1c3QgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgcmVnZXggbWF0Y2ggYXJyYXkgYW5kIHJldHVybnMgYSB7IHllYXI6IC4uLiwgbW9udGg6IC4uLiB9IG9iamVjdFxuICogcGFyc2UoKSBkb2VzIHRoZSB3b3JrIG9mIGV4ZWN1dGluZyB0aGUgcmVnZXggYW5kIGFwcGx5aW5nIHRoZSBleHRyYWN0b3IuIEl0IHRha2VzIG11bHRpcGxlIHJlZ2V4L2V4dHJhY3RvciBwYWlycyB0byB0cnkgaW4gc2VxdWVuY2UuXG4gKiBFeHRyYWN0b3JzIGNhbiB0YWtlIGEgXCJjdXJzb3JcIiByZXByZXNlbnRpbmcgdGhlIG9mZnNldCBpbiB0aGUgbWF0Y2ggdG8gbG9vayBhdC4gVGhpcyBtYWtlcyBpdCBlYXN5IHRvIGNvbWJpbmUgZXh0cmFjdG9ycy5cbiAqIGNvbWJpbmVFeHRyYWN0b3JzKCkgZG9lcyB0aGUgd29yayBvZiBjb21iaW5pbmcgdGhlbSwga2VlcGluZyB0cmFjayBvZiB0aGUgY3Vyc29yIHRocm91Z2ggbXVsdGlwbGUgZXh0cmFjdGlvbnMuXG4gKiBTb21lIGV4dHJhY3Rpb25zIGFyZSBzdXBlciBkdW1iIGFuZCBzaW1wbGVQYXJzZSBhbmQgZnJvbVN0cmluZ3MgaGVscCBEUlkgdGhlbS5cbiAqL1xuXG5mdW5jdGlvbiBjb21iaW5lUmVnZXhlcygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlZ2V4ZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcmVnZXhlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciBmdWxsID0gcmVnZXhlcy5yZWR1Y2UoZnVuY3Rpb24gKGYsIHIpIHtcbiAgICByZXR1cm4gZiArIHIuc291cmNlO1xuICB9LCBcIlwiKTtcbiAgcmV0dXJuIFJlZ0V4cChcIl5cIiArIGZ1bGwgKyBcIiRcIik7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVFeHRyYWN0b3JzKCkge1xuICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGV4dHJhY3RvcnMgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBleHRyYWN0b3JzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gZXh0cmFjdG9ycy5yZWR1Y2UoZnVuY3Rpb24gKF9yZWYsIGV4KSB7XG4gICAgICB2YXIgbWVyZ2VkVmFscyA9IF9yZWZbMF0sXG4gICAgICAgICAgbWVyZ2VkWm9uZSA9IF9yZWZbMV0sXG4gICAgICAgICAgY3Vyc29yID0gX3JlZlsyXTtcblxuICAgICAgdmFyIF9leCA9IGV4KG0sIGN1cnNvciksXG4gICAgICAgICAgdmFsID0gX2V4WzBdLFxuICAgICAgICAgIHpvbmUgPSBfZXhbMV0sXG4gICAgICAgICAgbmV4dCA9IF9leFsyXTtcblxuICAgICAgcmV0dXJuIFtPYmplY3QuYXNzaWduKG1lcmdlZFZhbHMsIHZhbCksIG1lcmdlZFpvbmUgfHwgem9uZSwgbmV4dF07XG4gICAgfSwgW3t9LCBudWxsLCAxXSkuc2xpY2UoMCwgMik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlKHMpIHtcbiAgaWYgKHMgPT0gbnVsbCkge1xuICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gIH1cblxuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhdHRlcm5zID0gbmV3IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICBwYXR0ZXJuc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgfVxuXG4gIGZvciAodmFyIF9pID0gMCwgX3BhdHRlcm5zID0gcGF0dGVybnM7IF9pIDwgX3BhdHRlcm5zLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBfcGF0dGVybnMkX2kgPSBfcGF0dGVybnNbX2ldLFxuICAgICAgICByZWdleCA9IF9wYXR0ZXJucyRfaVswXSxcbiAgICAgICAgZXh0cmFjdG9yID0gX3BhdHRlcm5zJF9pWzFdO1xuICAgIHZhciBtID0gcmVnZXguZXhlYyhzKTtcblxuICAgIGlmIChtKSB7XG4gICAgICByZXR1cm4gZXh0cmFjdG9yKG0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbbnVsbCwgbnVsbF07XG59XG5cbmZ1bmN0aW9uIHNpbXBsZVBhcnNlKCkge1xuICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGtleXMgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICBrZXlzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKG1hdGNoLCBjdXJzb3IpIHtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmV0W2tleXNbaV1dID0gcGFyc2VJbnRlZ2VyKG1hdGNoW2N1cnNvciArIGldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3JldCwgbnVsbCwgY3Vyc29yICsgaV07XG4gIH07XG59IC8vIElTTyBhbmQgU1FMIHBhcnNpbmdcblxuXG52YXIgb2Zmc2V0UmVnZXggPSAvKD86KFopfChbKy1dXFxkXFxkKSg/Ojo/KFxcZFxcZCkpPykvLFxuICAgIGlzb1RpbWVCYXNlUmVnZXggPSAvKFxcZFxcZCkoPzo6PyhcXGRcXGQpKD86Oj8oXFxkXFxkKSg/OlsuLF0oXFxkezEsMzB9KSk/KT8pPy8sXG4gICAgaXNvVGltZVJlZ2V4ID0gUmVnRXhwKFwiXCIgKyBpc29UaW1lQmFzZVJlZ2V4LnNvdXJjZSArIG9mZnNldFJlZ2V4LnNvdXJjZSArIFwiP1wiKSxcbiAgICBpc29UaW1lRXh0ZW5zaW9uUmVnZXggPSBSZWdFeHAoXCIoPzpUXCIgKyBpc29UaW1lUmVnZXguc291cmNlICsgXCIpP1wiKSxcbiAgICBpc29ZbWRSZWdleCA9IC8oWystXVxcZHs2fXxcXGR7NH0pKD86LT8oXFxkXFxkKSg/Oi0/KFxcZFxcZCkpPyk/LyxcbiAgICBpc29XZWVrUmVnZXggPSAvKFxcZHs0fSktP1coXFxkXFxkKSg/Oi0/KFxcZCkpPy8sXG4gICAgaXNvT3JkaW5hbFJlZ2V4ID0gLyhcXGR7NH0pLT8oXFxkezN9KS8sXG4gICAgZXh0cmFjdElTT1dlZWtEYXRhID0gc2ltcGxlUGFyc2UoXCJ3ZWVrWWVhclwiLCBcIndlZWtOdW1iZXJcIiwgXCJ3ZWVrRGF5XCIpLFxuICAgIGV4dHJhY3RJU09PcmRpbmFsRGF0YSA9IHNpbXBsZVBhcnNlKFwieWVhclwiLCBcIm9yZGluYWxcIiksXG4gICAgc3FsWW1kUmVnZXggPSAvKFxcZHs0fSktKFxcZFxcZCktKFxcZFxcZCkvLFxuICAgIC8vIGR1bWJlZC1kb3duIHZlcnNpb24gb2YgdGhlIElTTyBvbmVcbnNxbFRpbWVSZWdleCA9IFJlZ0V4cChpc29UaW1lQmFzZVJlZ2V4LnNvdXJjZSArIFwiID8oPzpcIiArIG9mZnNldFJlZ2V4LnNvdXJjZSArIFwifChcIiArIGlhbmFSZWdleC5zb3VyY2UgKyBcIikpP1wiKSxcbiAgICBzcWxUaW1lRXh0ZW5zaW9uUmVnZXggPSBSZWdFeHAoXCIoPzogXCIgKyBzcWxUaW1lUmVnZXguc291cmNlICsgXCIpP1wiKTtcblxuZnVuY3Rpb24gaW50KG1hdGNoLCBwb3MsIGZhbGxiYWNrKSB7XG4gIHZhciBtID0gbWF0Y2hbcG9zXTtcbiAgcmV0dXJuIGlzVW5kZWZpbmVkKG0pID8gZmFsbGJhY2sgOiBwYXJzZUludGVnZXIobSk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09ZbWQobWF0Y2gsIGN1cnNvcikge1xuICB2YXIgaXRlbSA9IHtcbiAgICB5ZWFyOiBpbnQobWF0Y2gsIGN1cnNvciksXG4gICAgbW9udGg6IGludChtYXRjaCwgY3Vyc29yICsgMSwgMSksXG4gICAgZGF5OiBpbnQobWF0Y2gsIGN1cnNvciArIDIsIDEpXG4gIH07XG4gIHJldHVybiBbaXRlbSwgbnVsbCwgY3Vyc29yICsgM107XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09UaW1lKG1hdGNoLCBjdXJzb3IpIHtcbiAgdmFyIGl0ZW0gPSB7XG4gICAgaG91cjogaW50KG1hdGNoLCBjdXJzb3IsIDApLFxuICAgIG1pbnV0ZTogaW50KG1hdGNoLCBjdXJzb3IgKyAxLCAwKSxcbiAgICBzZWNvbmQ6IGludChtYXRjaCwgY3Vyc29yICsgMiwgMCksXG4gICAgbWlsbGlzZWNvbmQ6IHBhcnNlTWlsbGlzKG1hdGNoW2N1cnNvciArIDNdKVxuICB9O1xuICByZXR1cm4gW2l0ZW0sIG51bGwsIGN1cnNvciArIDRdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SVNPT2Zmc2V0KG1hdGNoLCBjdXJzb3IpIHtcbiAgdmFyIGxvY2FsID0gIW1hdGNoW2N1cnNvcl0gJiYgIW1hdGNoW2N1cnNvciArIDFdLFxuICAgICAgZnVsbE9mZnNldCA9IHNpZ25lZE9mZnNldChtYXRjaFtjdXJzb3IgKyAxXSwgbWF0Y2hbY3Vyc29yICsgMl0pLFxuICAgICAgem9uZSA9IGxvY2FsID8gbnVsbCA6IEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShmdWxsT2Zmc2V0KTtcbiAgcmV0dXJuIFt7fSwgem9uZSwgY3Vyc29yICsgM107XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJQU5BWm9uZShtYXRjaCwgY3Vyc29yKSB7XG4gIHZhciB6b25lID0gbWF0Y2hbY3Vyc29yXSA/IElBTkFab25lLmNyZWF0ZShtYXRjaFtjdXJzb3JdKSA6IG51bGw7XG4gIHJldHVybiBbe30sIHpvbmUsIGN1cnNvciArIDFdO1xufSAvLyBJU08gZHVyYXRpb24gcGFyc2luZ1xuXG5cbnZhciBpc29EdXJhdGlvbiA9IC9eLT9QKD86KD86KC0/XFxkezEsOX0pWSk/KD86KC0/XFxkezEsOX0pTSk/KD86KC0/XFxkezEsOX0pVyk/KD86KC0/XFxkezEsOX0pRCk/KD86VCg/OigtP1xcZHsxLDl9KUgpPyg/OigtP1xcZHsxLDl9KU0pPyg/OigtP1xcZHsxLDIwfSkoPzpbLixdKC0/XFxkezEsOX0pKT9TKT8pPykkLztcblxuZnVuY3Rpb24gZXh0cmFjdElTT0R1cmF0aW9uKG1hdGNoKSB7XG4gIHZhciBzID0gbWF0Y2hbMF0sXG4gICAgICB5ZWFyU3RyID0gbWF0Y2hbMV0sXG4gICAgICBtb250aFN0ciA9IG1hdGNoWzJdLFxuICAgICAgd2Vla1N0ciA9IG1hdGNoWzNdLFxuICAgICAgZGF5U3RyID0gbWF0Y2hbNF0sXG4gICAgICBob3VyU3RyID0gbWF0Y2hbNV0sXG4gICAgICBtaW51dGVTdHIgPSBtYXRjaFs2XSxcbiAgICAgIHNlY29uZFN0ciA9IG1hdGNoWzddLFxuICAgICAgbWlsbGlzZWNvbmRzU3RyID0gbWF0Y2hbOF07XG4gIHZhciBoYXNOZWdhdGl2ZVByZWZpeCA9IHNbMF0gPT09IFwiLVwiO1xuXG4gIHZhciBtYXliZU5lZ2F0ZSA9IGZ1bmN0aW9uIG1heWJlTmVnYXRlKG51bSkge1xuICAgIHJldHVybiBudW0gJiYgaGFzTmVnYXRpdmVQcmVmaXggPyAtbnVtIDogbnVtO1xuICB9O1xuXG4gIHJldHVybiBbe1xuICAgIHllYXJzOiBtYXliZU5lZ2F0ZShwYXJzZUludGVnZXIoeWVhclN0cikpLFxuICAgIG1vbnRoczogbWF5YmVOZWdhdGUocGFyc2VJbnRlZ2VyKG1vbnRoU3RyKSksXG4gICAgd2Vla3M6IG1heWJlTmVnYXRlKHBhcnNlSW50ZWdlcih3ZWVrU3RyKSksXG4gICAgZGF5czogbWF5YmVOZWdhdGUocGFyc2VJbnRlZ2VyKGRheVN0cikpLFxuICAgIGhvdXJzOiBtYXliZU5lZ2F0ZShwYXJzZUludGVnZXIoaG91clN0cikpLFxuICAgIG1pbnV0ZXM6IG1heWJlTmVnYXRlKHBhcnNlSW50ZWdlcihtaW51dGVTdHIpKSxcbiAgICBzZWNvbmRzOiBtYXliZU5lZ2F0ZShwYXJzZUludGVnZXIoc2Vjb25kU3RyKSksXG4gICAgbWlsbGlzZWNvbmRzOiBtYXliZU5lZ2F0ZShwYXJzZU1pbGxpcyhtaWxsaXNlY29uZHNTdHIpKVxuICB9XTtcbn0gLy8gVGhlc2UgYXJlIGEgbGl0dGxlIGJyYWluZGVhZC4gRURUICpzaG91bGQqIHRlbGwgdXMgdGhhdCB3ZSdyZSBpbiwgc2F5LCBBbWVyaWNhL05ld19Zb3JrXG4vLyBhbmQgbm90IGp1c3QgdGhhdCB3ZSdyZSBpbiAtMjQwICpyaWdodCBub3cqLiBCdXQgc2luY2UgSSBkb24ndCB0aGluayB0aGVzZSBhcmUgdXNlZCB0aGF0IG9mdGVuXG4vLyBJJ20ganVzdCBnb2luZyB0byBpZ25vcmUgdGhhdFxuXG5cbnZhciBvYnNPZmZzZXRzID0ge1xuICBHTVQ6IDAsXG4gIEVEVDogLTQgKiA2MCxcbiAgRVNUOiAtNSAqIDYwLFxuICBDRFQ6IC01ICogNjAsXG4gIENTVDogLTYgKiA2MCxcbiAgTURUOiAtNiAqIDYwLFxuICBNU1Q6IC03ICogNjAsXG4gIFBEVDogLTcgKiA2MCxcbiAgUFNUOiAtOCAqIDYwXG59O1xuXG5mdW5jdGlvbiBmcm9tU3RyaW5ncyh3ZWVrZGF5U3RyLCB5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cikge1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIHllYXI6IHllYXJTdHIubGVuZ3RoID09PSAyID8gdW50cnVuY2F0ZVllYXIocGFyc2VJbnRlZ2VyKHllYXJTdHIpKSA6IHBhcnNlSW50ZWdlcih5ZWFyU3RyKSxcbiAgICBtb250aDogbW9udGhzU2hvcnQuaW5kZXhPZihtb250aFN0cikgKyAxLFxuICAgIGRheTogcGFyc2VJbnRlZ2VyKGRheVN0ciksXG4gICAgaG91cjogcGFyc2VJbnRlZ2VyKGhvdXJTdHIpLFxuICAgIG1pbnV0ZTogcGFyc2VJbnRlZ2VyKG1pbnV0ZVN0cilcbiAgfTtcbiAgaWYgKHNlY29uZFN0cikgcmVzdWx0LnNlY29uZCA9IHBhcnNlSW50ZWdlcihzZWNvbmRTdHIpO1xuXG4gIGlmICh3ZWVrZGF5U3RyKSB7XG4gICAgcmVzdWx0LndlZWtkYXkgPSB3ZWVrZGF5U3RyLmxlbmd0aCA+IDMgPyB3ZWVrZGF5c0xvbmcuaW5kZXhPZih3ZWVrZGF5U3RyKSArIDEgOiB3ZWVrZGF5c1Nob3J0LmluZGV4T2Yod2Vla2RheVN0cikgKyAxO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0gLy8gUkZDIDI4MjIvNTMyMlxuXG5cbnZhciByZmMyODIyID0gL14oPzooTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSxcXHMpPyhcXGR7MSwyfSlcXHMoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpXFxzKFxcZHsyLDR9KVxccyhcXGRcXGQpOihcXGRcXGQpKD86OihcXGRcXGQpKT9cXHMoPzooVVR8R01UfFtFQ01QXVtTRF1UKXwoW1p6XSl8KD86KFsrLV1cXGRcXGQpKFxcZFxcZCkpKSQvO1xuXG5mdW5jdGlvbiBleHRyYWN0UkZDMjgyMihtYXRjaCkge1xuICB2YXIgd2Vla2RheVN0ciA9IG1hdGNoWzFdLFxuICAgICAgZGF5U3RyID0gbWF0Y2hbMl0sXG4gICAgICBtb250aFN0ciA9IG1hdGNoWzNdLFxuICAgICAgeWVhclN0ciA9IG1hdGNoWzRdLFxuICAgICAgaG91clN0ciA9IG1hdGNoWzVdLFxuICAgICAgbWludXRlU3RyID0gbWF0Y2hbNl0sXG4gICAgICBzZWNvbmRTdHIgPSBtYXRjaFs3XSxcbiAgICAgIG9ic09mZnNldCA9IG1hdGNoWzhdLFxuICAgICAgbWlsT2Zmc2V0ID0gbWF0Y2hbOV0sXG4gICAgICBvZmZIb3VyU3RyID0gbWF0Y2hbMTBdLFxuICAgICAgb2ZmTWludXRlU3RyID0gbWF0Y2hbMTFdLFxuICAgICAgcmVzdWx0ID0gZnJvbVN0cmluZ3Mod2Vla2RheVN0ciwgeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpO1xuICB2YXIgb2Zmc2V0O1xuXG4gIGlmIChvYnNPZmZzZXQpIHtcbiAgICBvZmZzZXQgPSBvYnNPZmZzZXRzW29ic09mZnNldF07XG4gIH0gZWxzZSBpZiAobWlsT2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gMDtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXQgPSBzaWduZWRPZmZzZXQob2ZmSG91clN0ciwgb2ZmTWludXRlU3RyKTtcbiAgfVxuXG4gIHJldHVybiBbcmVzdWx0LCBuZXcgRml4ZWRPZmZzZXRab25lKG9mZnNldCldO1xufVxuXG5mdW5jdGlvbiBwcmVwcm9jZXNzUkZDMjgyMihzKSB7XG4gIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gIHJldHVybiBzLnJlcGxhY2UoL1xcKFteKV0qXFwpfFtcXG5cXHRdL2csIFwiIFwiKS5yZXBsYWNlKC8oXFxzXFxzKykvZywgXCIgXCIpLnRyaW0oKTtcbn0gLy8gaHR0cCBkYXRlXG5cblxudmFyIHJmYzExMjMgPSAvXihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pLCAoXFxkXFxkKSAoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpIChcXGR7NH0pIChcXGRcXGQpOihcXGRcXGQpOihcXGRcXGQpIEdNVCQvLFxuICAgIHJmYzg1MCA9IC9eKE1vbmRheXxUdWVzZGF5fFdlZHNkYXl8VGh1cnNkYXl8RnJpZGF5fFNhdHVyZGF5fFN1bmRheSksIChcXGRcXGQpLShKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYyktKFxcZFxcZCkgKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkgR01UJC8sXG4gICAgYXNjaWkgPSAvXihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pIChKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYykgKCBcXGR8XFxkXFxkKSAoXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKSAoXFxkezR9KSQvO1xuXG5mdW5jdGlvbiBleHRyYWN0UkZDMTEyM09yODUwKG1hdGNoKSB7XG4gIHZhciB3ZWVrZGF5U3RyID0gbWF0Y2hbMV0sXG4gICAgICBkYXlTdHIgPSBtYXRjaFsyXSxcbiAgICAgIG1vbnRoU3RyID0gbWF0Y2hbM10sXG4gICAgICB5ZWFyU3RyID0gbWF0Y2hbNF0sXG4gICAgICBob3VyU3RyID0gbWF0Y2hbNV0sXG4gICAgICBtaW51dGVTdHIgPSBtYXRjaFs2XSxcbiAgICAgIHNlY29uZFN0ciA9IG1hdGNoWzddLFxuICAgICAgcmVzdWx0ID0gZnJvbVN0cmluZ3Mod2Vla2RheVN0ciwgeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpO1xuICByZXR1cm4gW3Jlc3VsdCwgRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlXTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEFTQ0lJKG1hdGNoKSB7XG4gIHZhciB3ZWVrZGF5U3RyID0gbWF0Y2hbMV0sXG4gICAgICBtb250aFN0ciA9IG1hdGNoWzJdLFxuICAgICAgZGF5U3RyID0gbWF0Y2hbM10sXG4gICAgICBob3VyU3RyID0gbWF0Y2hbNF0sXG4gICAgICBtaW51dGVTdHIgPSBtYXRjaFs1XSxcbiAgICAgIHNlY29uZFN0ciA9IG1hdGNoWzZdLFxuICAgICAgeWVhclN0ciA9IG1hdGNoWzddLFxuICAgICAgcmVzdWx0ID0gZnJvbVN0cmluZ3Mod2Vla2RheVN0ciwgeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpO1xuICByZXR1cm4gW3Jlc3VsdCwgRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlXTtcbn1cblxudmFyIGlzb1ltZFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXggPSBjb21iaW5lUmVnZXhlcyhpc29ZbWRSZWdleCwgaXNvVGltZUV4dGVuc2lvblJlZ2V4KTtcbnZhciBpc29XZWVrV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKGlzb1dlZWtSZWdleCwgaXNvVGltZUV4dGVuc2lvblJlZ2V4KTtcbnZhciBpc29PcmRpbmFsV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKGlzb09yZGluYWxSZWdleCwgaXNvVGltZUV4dGVuc2lvblJlZ2V4KTtcbnZhciBpc29UaW1lQ29tYmluZWRSZWdleCA9IGNvbWJpbmVSZWdleGVzKGlzb1RpbWVSZWdleCk7XG52YXIgZXh0cmFjdElTT1ltZFRpbWVBbmRPZmZzZXQgPSBjb21iaW5lRXh0cmFjdG9ycyhleHRyYWN0SVNPWW1kLCBleHRyYWN0SVNPVGltZSwgZXh0cmFjdElTT09mZnNldCk7XG52YXIgZXh0cmFjdElTT1dlZWtUaW1lQW5kT2Zmc2V0ID0gY29tYmluZUV4dHJhY3RvcnMoZXh0cmFjdElTT1dlZWtEYXRhLCBleHRyYWN0SVNPVGltZSwgZXh0cmFjdElTT09mZnNldCk7XG52YXIgZXh0cmFjdElTT09yZGluYWxEYXRhQW5kVGltZSA9IGNvbWJpbmVFeHRyYWN0b3JzKGV4dHJhY3RJU09PcmRpbmFsRGF0YSwgZXh0cmFjdElTT1RpbWUpO1xudmFyIGV4dHJhY3RJU09UaW1lQW5kT2Zmc2V0ID0gY29tYmluZUV4dHJhY3RvcnMoZXh0cmFjdElTT1RpbWUsIGV4dHJhY3RJU09PZmZzZXQpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlSVNPRGF0ZShzKSB7XG4gIHJldHVybiBwYXJzZShzLCBbaXNvWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCwgZXh0cmFjdElTT1ltZFRpbWVBbmRPZmZzZXRdLCBbaXNvV2Vla1dpdGhUaW1lRXh0ZW5zaW9uUmVnZXgsIGV4dHJhY3RJU09XZWVrVGltZUFuZE9mZnNldF0sIFtpc29PcmRpbmFsV2l0aFRpbWVFeHRlbnNpb25SZWdleCwgZXh0cmFjdElTT09yZGluYWxEYXRhQW5kVGltZV0sIFtpc29UaW1lQ29tYmluZWRSZWdleCwgZXh0cmFjdElTT1RpbWVBbmRPZmZzZXRdKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUkZDMjgyMkRhdGUocykge1xuICByZXR1cm4gcGFyc2UocHJlcHJvY2Vzc1JGQzI4MjIocyksIFtyZmMyODIyLCBleHRyYWN0UkZDMjgyMl0pO1xufVxuZnVuY3Rpb24gcGFyc2VIVFRQRGF0ZShzKSB7XG4gIHJldHVybiBwYXJzZShzLCBbcmZjMTEyMywgZXh0cmFjdFJGQzExMjNPcjg1MF0sIFtyZmM4NTAsIGV4dHJhY3RSRkMxMTIzT3I4NTBdLCBbYXNjaWksIGV4dHJhY3RBU0NJSV0pO1xufVxuZnVuY3Rpb24gcGFyc2VJU09EdXJhdGlvbihzKSB7XG4gIHJldHVybiBwYXJzZShzLCBbaXNvRHVyYXRpb24sIGV4dHJhY3RJU09EdXJhdGlvbl0pO1xufVxudmFyIHNxbFltZFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXggPSBjb21iaW5lUmVnZXhlcyhzcWxZbWRSZWdleCwgc3FsVGltZUV4dGVuc2lvblJlZ2V4KTtcbnZhciBzcWxUaW1lQ29tYmluZWRSZWdleCA9IGNvbWJpbmVSZWdleGVzKHNxbFRpbWVSZWdleCk7XG52YXIgZXh0cmFjdElTT1ltZFRpbWVPZmZzZXRBbmRJQU5BWm9uZSA9IGNvbWJpbmVFeHRyYWN0b3JzKGV4dHJhY3RJU09ZbWQsIGV4dHJhY3RJU09UaW1lLCBleHRyYWN0SVNPT2Zmc2V0LCBleHRyYWN0SUFOQVpvbmUpO1xudmFyIGV4dHJhY3RJU09UaW1lT2Zmc2V0QW5kSUFOQVpvbmUgPSBjb21iaW5lRXh0cmFjdG9ycyhleHRyYWN0SVNPVGltZSwgZXh0cmFjdElTT09mZnNldCwgZXh0cmFjdElBTkFab25lKTtcbmZ1bmN0aW9uIHBhcnNlU1FMKHMpIHtcbiAgcmV0dXJuIHBhcnNlKHMsIFtzcWxZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4LCBleHRyYWN0SVNPWW1kVGltZU9mZnNldEFuZElBTkFab25lXSwgW3NxbFRpbWVDb21iaW5lZFJlZ2V4LCBleHRyYWN0SVNPVGltZU9mZnNldEFuZElBTkFab25lXSk7XG59XG5cbnZhciBJTlZBTElEID0gXCJJbnZhbGlkIER1cmF0aW9uXCI7IC8vIHVuaXQgY29udmVyc2lvbiBjb25zdGFudHNcblxudmFyIGxvd09yZGVyTWF0cml4ID0ge1xuICB3ZWVrczoge1xuICAgIGRheXM6IDcsXG4gICAgaG91cnM6IDcgKiAyNCxcbiAgICBtaW51dGVzOiA3ICogMjQgKiA2MCxcbiAgICBzZWNvbmRzOiA3ICogMjQgKiA2MCAqIDYwLFxuICAgIG1pbGxpc2Vjb25kczogNyAqIDI0ICogNjAgKiA2MCAqIDEwMDBcbiAgfSxcbiAgZGF5czoge1xuICAgIGhvdXJzOiAyNCxcbiAgICBtaW51dGVzOiAyNCAqIDYwLFxuICAgIHNlY29uZHM6IDI0ICogNjAgKiA2MCxcbiAgICBtaWxsaXNlY29uZHM6IDI0ICogNjAgKiA2MCAqIDEwMDBcbiAgfSxcbiAgaG91cnM6IHtcbiAgICBtaW51dGVzOiA2MCxcbiAgICBzZWNvbmRzOiA2MCAqIDYwLFxuICAgIG1pbGxpc2Vjb25kczogNjAgKiA2MCAqIDEwMDBcbiAgfSxcbiAgbWludXRlczoge1xuICAgIHNlY29uZHM6IDYwLFxuICAgIG1pbGxpc2Vjb25kczogNjAgKiAxMDAwXG4gIH0sXG4gIHNlY29uZHM6IHtcbiAgICBtaWxsaXNlY29uZHM6IDEwMDBcbiAgfVxufSxcbiAgICBjYXN1YWxNYXRyaXggPSBPYmplY3QuYXNzaWduKHtcbiAgeWVhcnM6IHtcbiAgICBxdWFydGVyczogNCxcbiAgICBtb250aHM6IDEyLFxuICAgIHdlZWtzOiA1MixcbiAgICBkYXlzOiAzNjUsXG4gICAgaG91cnM6IDM2NSAqIDI0LFxuICAgIG1pbnV0ZXM6IDM2NSAqIDI0ICogNjAsXG4gICAgc2Vjb25kczogMzY1ICogMjQgKiA2MCAqIDYwLFxuICAgIG1pbGxpc2Vjb25kczogMzY1ICogMjQgKiA2MCAqIDYwICogMTAwMFxuICB9LFxuICBxdWFydGVyczoge1xuICAgIG1vbnRoczogMyxcbiAgICB3ZWVrczogMTMsXG4gICAgZGF5czogOTEsXG4gICAgaG91cnM6IDkxICogMjQsXG4gICAgbWludXRlczogOTEgKiAyNCAqIDYwLFxuICAgIHNlY29uZHM6IDkxICogMjQgKiA2MCAqIDYwLFxuICAgIG1pbGxpc2Vjb25kczogOTEgKiAyNCAqIDYwICogNjAgKiAxMDAwXG4gIH0sXG4gIG1vbnRoczoge1xuICAgIHdlZWtzOiA0LFxuICAgIGRheXM6IDMwLFxuICAgIGhvdXJzOiAzMCAqIDI0LFxuICAgIG1pbnV0ZXM6IDMwICogMjQgKiA2MCxcbiAgICBzZWNvbmRzOiAzMCAqIDI0ICogNjAgKiA2MCxcbiAgICBtaWxsaXNlY29uZHM6IDMwICogMjQgKiA2MCAqIDYwICogMTAwMFxuICB9XG59LCBsb3dPcmRlck1hdHJpeCksXG4gICAgZGF5c0luWWVhckFjY3VyYXRlID0gMTQ2MDk3LjAgLyA0MDAsXG4gICAgZGF5c0luTW9udGhBY2N1cmF0ZSA9IDE0NjA5Ny4wIC8gNDgwMCxcbiAgICBhY2N1cmF0ZU1hdHJpeCA9IE9iamVjdC5hc3NpZ24oe1xuICB5ZWFyczoge1xuICAgIHF1YXJ0ZXJzOiA0LFxuICAgIG1vbnRoczogMTIsXG4gICAgd2Vla3M6IGRheXNJblllYXJBY2N1cmF0ZSAvIDcsXG4gICAgZGF5czogZGF5c0luWWVhckFjY3VyYXRlLFxuICAgIGhvdXJzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCxcbiAgICBtaW51dGVzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwLFxuICAgIHNlY29uZHM6IGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCxcbiAgICBtaWxsaXNlY29uZHM6IGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCAqIDEwMDBcbiAgfSxcbiAgcXVhcnRlcnM6IHtcbiAgICBtb250aHM6IDMsXG4gICAgd2Vla3M6IGRheXNJblllYXJBY2N1cmF0ZSAvIDI4LFxuICAgIGRheXM6IGRheXNJblllYXJBY2N1cmF0ZSAvIDQsXG4gICAgaG91cnM6IGRheXNJblllYXJBY2N1cmF0ZSAqIDI0IC8gNCxcbiAgICBtaW51dGVzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwIC8gNCxcbiAgICBzZWNvbmRzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwICogNjAgLyA0LFxuICAgIG1pbGxpc2Vjb25kczogZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwICogMTAwMCAvIDRcbiAgfSxcbiAgbW9udGhzOiB7XG4gICAgd2Vla3M6IGRheXNJbk1vbnRoQWNjdXJhdGUgLyA3LFxuICAgIGRheXM6IGRheXNJbk1vbnRoQWNjdXJhdGUsXG4gICAgaG91cnM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCxcbiAgICBtaW51dGVzOiBkYXlzSW5Nb250aEFjY3VyYXRlICogMjQgKiA2MCxcbiAgICBzZWNvbmRzOiBkYXlzSW5Nb250aEFjY3VyYXRlICogMjQgKiA2MCAqIDYwLFxuICAgIG1pbGxpc2Vjb25kczogZGF5c0luTW9udGhBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCAqIDEwMDBcbiAgfVxufSwgbG93T3JkZXJNYXRyaXgpOyAvLyB1bml0cyBvcmRlcmVkIGJ5IHNpemVcblxudmFyIG9yZGVyZWRVbml0cyA9IFtcInllYXJzXCIsIFwicXVhcnRlcnNcIiwgXCJtb250aHNcIiwgXCJ3ZWVrc1wiLCBcImRheXNcIiwgXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCIsIFwibWlsbGlzZWNvbmRzXCJdO1xudmFyIHJldmVyc2VVbml0cyA9IG9yZGVyZWRVbml0cy5zbGljZSgwKS5yZXZlcnNlKCk7IC8vIGNsb25lIHJlYWxseSBtZWFucyBcImNyZWF0ZSBhbm90aGVyIGluc3RhbmNlIGp1c3QgbGlrZSB0aGlzIG9uZSwgYnV0IHdpdGggdGhlc2UgY2hhbmdlc1wiXG5cbmZ1bmN0aW9uIGNsb25lKGR1ciwgYWx0cywgY2xlYXIpIHtcbiAgaWYgKGNsZWFyID09PSB2b2lkIDApIHtcbiAgICBjbGVhciA9IGZhbHNlO1xuICB9XG5cbiAgLy8gZGVlcCBtZXJnZSBmb3IgdmFsc1xuICB2YXIgY29uZiA9IHtcbiAgICB2YWx1ZXM6IGNsZWFyID8gYWx0cy52YWx1ZXMgOiBPYmplY3QuYXNzaWduKHt9LCBkdXIudmFsdWVzLCBhbHRzLnZhbHVlcyB8fCB7fSksXG4gICAgbG9jOiBkdXIubG9jLmNsb25lKGFsdHMubG9jKSxcbiAgICBjb252ZXJzaW9uQWNjdXJhY3k6IGFsdHMuY29udmVyc2lvbkFjY3VyYWN5IHx8IGR1ci5jb252ZXJzaW9uQWNjdXJhY3lcbiAgfTtcbiAgcmV0dXJuIG5ldyBEdXJhdGlvbihjb25mKTtcbn1cblxuZnVuY3Rpb24gYW50aVRydW5jKG4pIHtcbiAgcmV0dXJuIG4gPCAwID8gTWF0aC5mbG9vcihuKSA6IE1hdGguY2VpbChuKTtcbn0gLy8gTkI6IG11dGF0ZXMgcGFyYW1ldGVyc1xuXG5cbmZ1bmN0aW9uIGNvbnZlcnQobWF0cml4LCBmcm9tTWFwLCBmcm9tVW5pdCwgdG9NYXAsIHRvVW5pdCkge1xuICB2YXIgY29udiA9IG1hdHJpeFt0b1VuaXRdW2Zyb21Vbml0XSxcbiAgICAgIHJhdyA9IGZyb21NYXBbZnJvbVVuaXRdIC8gY29udixcbiAgICAgIHNhbWVTaWduID0gTWF0aC5zaWduKHJhdykgPT09IE1hdGguc2lnbih0b01hcFt0b1VuaXRdKSxcbiAgICAgIC8vIG9rLCBzbyB0aGlzIGlzIHdpbGQsIGJ1dCBzZWUgdGhlIG1hdHJpeCBpbiB0aGUgdGVzdHNcbiAgYWRkZWQgPSAhc2FtZVNpZ24gJiYgdG9NYXBbdG9Vbml0XSAhPT0gMCAmJiBNYXRoLmFicyhyYXcpIDw9IDEgPyBhbnRpVHJ1bmMocmF3KSA6IE1hdGgudHJ1bmMocmF3KTtcbiAgdG9NYXBbdG9Vbml0XSArPSBhZGRlZDtcbiAgZnJvbU1hcFtmcm9tVW5pdF0gLT0gYWRkZWQgKiBjb252O1xufSAvLyBOQjogbXV0YXRlcyBwYXJhbWV0ZXJzXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWVzKG1hdHJpeCwgdmFscykge1xuICByZXZlcnNlVW5pdHMucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91cywgY3VycmVudCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodmFsc1tjdXJyZW50XSkpIHtcbiAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICBjb252ZXJ0KG1hdHJpeCwgdmFscywgcHJldmlvdXMsIHZhbHMsIGN1cnJlbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHByZXZpb3VzO1xuICAgIH1cbiAgfSwgbnVsbCk7XG59XG4vKipcbiAqIEEgRHVyYXRpb24gb2JqZWN0IHJlcHJlc2VudHMgYSBwZXJpb2Qgb2YgdGltZSwgbGlrZSBcIjIgbW9udGhzXCIgb3IgXCIxIGRheSwgMSBob3VyXCIuIENvbmNlcHR1YWxseSwgaXQncyBqdXN0IGEgbWFwIG9mIHVuaXRzIHRvIHRoZWlyIHF1YW50aXRpZXMsIGFjY29tcGFuaWVkIGJ5IHNvbWUgYWRkaXRpb25hbCBjb25maWd1cmF0aW9uIGFuZCBtZXRob2RzIGZvciBjcmVhdGluZywgcGFyc2luZywgaW50ZXJyb2dhdGluZywgdHJhbnNmb3JtaW5nLCBhbmQgZm9ybWF0dGluZyB0aGVtLiBUaGV5IGNhbiBiZSB1c2VkIG9uIHRoZWlyIG93biBvciBpbiBjb25qdW5jdGlvbiB3aXRoIG90aGVyIEx1eG9uIHR5cGVzOyBmb3IgZXhhbXBsZSwgeW91IGNhbiB1c2Uge0BsaW5rIERhdGVUaW1lLnBsdXN9IHRvIGFkZCBhIER1cmF0aW9uIG9iamVjdCB0byBhIERhdGVUaW1lLCBwcm9kdWNpbmcgYW5vdGhlciBEYXRlVGltZS5cbiAqXG4gKiBIZXJlIGlzIGEgYnJpZWYgb3ZlcnZpZXcgb2YgY29tbW9ubHkgdXNlZCBtZXRob2RzIGFuZCBnZXR0ZXJzIGluIER1cmF0aW9uOlxuICpcbiAqICogKipDcmVhdGlvbioqIFRvIGNyZWF0ZSBhIER1cmF0aW9uLCB1c2Uge0BsaW5rIER1cmF0aW9uLmZyb21NaWxsaXN9LCB7QGxpbmsgRHVyYXRpb24uZnJvbU9iamVjdH0sIG9yIHtAbGluayBEdXJhdGlvbi5mcm9tSVNPfS5cbiAqICogKipVbml0IHZhbHVlcyoqIFNlZSB0aGUge0BsaW5rIER1cmF0aW9uLnllYXJzfSwge0BsaW5rIER1cmF0aW9uLm1vbnRoc30sIHtAbGluayBEdXJhdGlvbi53ZWVrc30sIHtAbGluayBEdXJhdGlvbi5kYXlzfSwge0BsaW5rIER1cmF0aW9uLmhvdXJzfSwge0BsaW5rIER1cmF0aW9uLm1pbnV0ZXN9LCB7QGxpbmsgRHVyYXRpb24uc2Vjb25kc30sIHtAbGluayBEdXJhdGlvbi5taWxsaXNlY29uZHN9IGFjY2Vzc29ycy5cbiAqICogKipDb25maWd1cmF0aW9uKiogU2VlICB7QGxpbmsgRHVyYXRpb24ubG9jYWxlfSBhbmQge0BsaW5rIER1cmF0aW9uLm51bWJlcmluZ1N5c3RlbX0gYWNjZXNzb3JzLlxuICogKiAqKlRyYW5zZm9ybWF0aW9uKiogVG8gY3JlYXRlIG5ldyBEdXJhdGlvbnMgb3V0IG9mIG9sZCBvbmVzIHVzZSB7QGxpbmsgRHVyYXRpb24ucGx1c30sIHtAbGluayBEdXJhdGlvbi5taW51c30sIHtAbGluayBEdXJhdGlvbi5ub3JtYWxpemV9LCB7QGxpbmsgRHVyYXRpb24uc2V0fSwge0BsaW5rIER1cmF0aW9uLnJlY29uZmlndXJlfSwge0BsaW5rIER1cmF0aW9uLnNoaWZ0VG99LCBhbmQge0BsaW5rIER1cmF0aW9uLm5lZ2F0ZX0uXG4gKiAqICoqT3V0cHV0KiogVG8gY29udmVydCB0aGUgRHVyYXRpb24gaW50byBvdGhlciByZXByZXNlbnRhdGlvbnMsIHNlZSB7QGxpbmsgRHVyYXRpb24uYXN9LCB7QGxpbmsgRHVyYXRpb24udG9JU099LCB7QGxpbmsgRHVyYXRpb24udG9Gb3JtYXR9LCBhbmQge0BsaW5rIER1cmF0aW9uLnRvSlNPTn1cbiAqXG4gKiBUaGVyZSdzIGFyZSBtb3JlIG1ldGhvZHMgZG9jdW1lbnRlZCBiZWxvdy4gSW4gYWRkaXRpb24sIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHN1YnRsZXIgdG9waWNzIGxpa2UgaW50ZXJuYXRpb25hbGl6YXRpb24gYW5kIHZhbGlkaXR5LCBzZWUgdGhlIGV4dGVybmFsIGRvY3VtZW50YXRpb24uXG4gKi9cblxuXG52YXIgRHVyYXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIER1cmF0aW9uKGNvbmZpZykge1xuICAgIHZhciBhY2N1cmF0ZSA9IGNvbmZpZy5jb252ZXJzaW9uQWNjdXJhY3kgPT09IFwibG9uZ3Rlcm1cIiB8fCBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMudmFsdWVzID0gY29uZmlnLnZhbHVlcztcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMubG9jID0gY29uZmlnLmxvYyB8fCBMb2NhbGUuY3JlYXRlKCk7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG5cbiAgICB0aGlzLmNvbnZlcnNpb25BY2N1cmFjeSA9IGFjY3VyYXRlID8gXCJsb25ndGVybVwiIDogXCJjYXN1YWxcIjtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuaW52YWxpZCA9IGNvbmZpZy5pbnZhbGlkIHx8IG51bGw7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG5cbiAgICB0aGlzLm1hdHJpeCA9IGFjY3VyYXRlID8gYWNjdXJhdGVNYXRyaXggOiBjYXN1YWxNYXRyaXg7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG5cbiAgICB0aGlzLmlzTHV4b25EdXJhdGlvbiA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBEdXJhdGlvbiBmcm9tIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IG9mIG1pbGxpc2Vjb25kc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuXG5cbiAgRHVyYXRpb24uZnJvbU1pbGxpcyA9IGZ1bmN0aW9uIGZyb21NaWxsaXMoY291bnQsIG9wdHMpIHtcbiAgICByZXR1cm4gRHVyYXRpb24uZnJvbU9iamVjdChPYmplY3QuYXNzaWduKHtcbiAgICAgIG1pbGxpc2Vjb25kczogY291bnRcbiAgICB9LCBvcHRzKSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIER1cmF0aW9uIGZyb20gYSBKYXZhc2NyaXB0IG9iamVjdCB3aXRoIGtleXMgbGlrZSAneWVhcnMnIGFuZCAnaG91cnMuXG4gICAqIElmIHRoaXMgb2JqZWN0IGlzIGVtcHR5IHRoZW4gYSB6ZXJvIG1pbGxpc2Vjb25kcyBkdXJhdGlvbiBpcyByZXR1cm5lZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHRoZSBvYmplY3QgdG8gY3JlYXRlIHRoZSBEYXRlVGltZSBmcm9tXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoueWVhcnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5xdWFydGVyc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1vbnRoc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouZGF5c1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmhvdXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubWludXRlc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnNlY29uZHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvYmoubG9jYWxlPSdlbi1VUyddIC0gdGhlIGxvY2FsZSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9iai5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvYmouY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICA7XG5cbiAgRHVyYXRpb24uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIkR1cmF0aW9uLmZyb21PYmplY3Q6IGFyZ3VtZW50IGV4cGVjdGVkIHRvIGJlIGFuIG9iamVjdCwgZ290IFwiICsgKG9iaiA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIG9iaikpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRHVyYXRpb24oe1xuICAgICAgdmFsdWVzOiBub3JtYWxpemVPYmplY3Qob2JqLCBEdXJhdGlvbi5ub3JtYWxpemVVbml0LCBbXCJsb2NhbGVcIiwgXCJudW1iZXJpbmdTeXN0ZW1cIiwgXCJjb252ZXJzaW9uQWNjdXJhY3lcIiwgXCJ6b25lXCIgLy8gYSBiaXQgb2YgZGVidDsgaXQncyBzdXBlciBpbmNvbnZlbmllbnQgaW50ZXJuYWxseSBub3QgdG8gYmUgYWJsZSB0byBibGluZGx5IHBhc3MgdGhpc1xuICAgICAgXSksXG4gICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9iaiksXG4gICAgICBjb252ZXJzaW9uQWNjdXJhY3k6IG9iai5jb252ZXJzaW9uQWNjdXJhY3lcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgRHVyYXRpb24gZnJvbSBhbiBJU08gODYwMSBkdXJhdGlvbiBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGV4dCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNEdXJhdGlvbnNcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTTygnUDNZNk0xVzREVDEySDMwTTVTJykudG9PYmplY3QoKSAvLz0+IHsgeWVhcnM6IDMsIG1vbnRoczogNiwgd2Vla3M6IDEsIGRheXM6IDQsIGhvdXJzOiAxMiwgbWludXRlczogMzAsIHNlY29uZHM6IDUgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPKCdQVDIzSCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAyMyB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU08oJ1A1WTNNJykudG9PYmplY3QoKSAvLz0+IHsgeWVhcnM6IDUsIG1vbnRoczogMyB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgO1xuXG4gIER1cmF0aW9uLmZyb21JU08gPSBmdW5jdGlvbiBmcm9tSVNPKHRleHQsIG9wdHMpIHtcbiAgICB2YXIgX3BhcnNlSVNPRHVyYXRpb24gPSBwYXJzZUlTT0R1cmF0aW9uKHRleHQpLFxuICAgICAgICBwYXJzZWQgPSBfcGFyc2VJU09EdXJhdGlvblswXTtcblxuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIHZhciBvYmogPSBPYmplY3QuYXNzaWduKHBhcnNlZCwgb3B0cyk7XG4gICAgICByZXR1cm4gRHVyYXRpb24uZnJvbU9iamVjdChvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uaW52YWxpZChcInVucGFyc2FibGVcIiwgXCJ0aGUgaW5wdXQgXFxcIlwiICsgdGV4dCArIFwiXFxcIiBjYW4ndCBiZSBwYXJzZWQgYXMgSVNPIDg2MDFcIik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW52YWxpZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiAtIHNpbXBsZSBzdHJpbmcgb2Ygd2h5IHRoaXMgZGF0ZXRpbWUgaXMgaW52YWxpZC4gU2hvdWxkIG5vdCBjb250YWluIHBhcmFtZXRlcnMgb3IgYW55dGhpbmcgZWxzZSBkYXRhLWRlcGVuZGVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2V4cGxhbmF0aW9uPW51bGxdIC0gbG9uZ2VyIGV4cGxhbmF0aW9uLCBtYXkgaW5jbHVkZSBwYXJhbWV0ZXJzIGFuZCBvdGhlciB1c2VmdWwgZGVidWdnaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgO1xuXG4gIER1cmF0aW9uLmludmFsaWQgPSBmdW5jdGlvbiBpbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24pIHtcbiAgICBpZiAoZXhwbGFuYXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgZXhwbGFuYXRpb24gPSBudWxsO1xuICAgIH1cblxuICAgIGlmICghcmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJuZWVkIHRvIHNwZWNpZnkgYSByZWFzb24gdGhlIER1cmF0aW9uIGlzIGludmFsaWRcIik7XG4gICAgfVxuXG4gICAgdmFyIGludmFsaWQgPSByZWFzb24gaW5zdGFuY2VvZiBJbnZhbGlkID8gcmVhc29uIDogbmV3IEludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbik7XG5cbiAgICBpZiAoU2V0dGluZ3MudGhyb3dPbkludmFsaWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkRHVyYXRpb25FcnJvcihpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbih7XG4gICAgICAgIGludmFsaWQ6IGludmFsaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIDtcblxuICBEdXJhdGlvbi5ub3JtYWxpemVVbml0ID0gZnVuY3Rpb24gbm9ybWFsaXplVW5pdCh1bml0KSB7XG4gICAgdmFyIG5vcm1hbGl6ZWQgPSB7XG4gICAgICB5ZWFyOiBcInllYXJzXCIsXG4gICAgICB5ZWFyczogXCJ5ZWFyc1wiLFxuICAgICAgcXVhcnRlcjogXCJxdWFydGVyc1wiLFxuICAgICAgcXVhcnRlcnM6IFwicXVhcnRlcnNcIixcbiAgICAgIG1vbnRoOiBcIm1vbnRoc1wiLFxuICAgICAgbW9udGhzOiBcIm1vbnRoc1wiLFxuICAgICAgd2VlazogXCJ3ZWVrc1wiLFxuICAgICAgd2Vla3M6IFwid2Vla3NcIixcbiAgICAgIGRheTogXCJkYXlzXCIsXG4gICAgICBkYXlzOiBcImRheXNcIixcbiAgICAgIGhvdXI6IFwiaG91cnNcIixcbiAgICAgIGhvdXJzOiBcImhvdXJzXCIsXG4gICAgICBtaW51dGU6IFwibWludXRlc1wiLFxuICAgICAgbWludXRlczogXCJtaW51dGVzXCIsXG4gICAgICBzZWNvbmQ6IFwic2Vjb25kc1wiLFxuICAgICAgc2Vjb25kczogXCJzZWNvbmRzXCIsXG4gICAgICBtaWxsaXNlY29uZDogXCJtaWxsaXNlY29uZHNcIixcbiAgICAgIG1pbGxpc2Vjb25kczogXCJtaWxsaXNlY29uZHNcIlxuICAgIH1bdW5pdCA/IHVuaXQudG9Mb3dlckNhc2UoKSA6IHVuaXRdO1xuICAgIGlmICghbm9ybWFsaXplZCkgdGhyb3cgbmV3IEludmFsaWRVbml0RXJyb3IodW5pdCk7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBhIER1cmF0aW9uLiBXb3JrcyBhY3Jvc3MgY29udGV4dCBib3VuZGFyaWVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICA7XG5cbiAgRHVyYXRpb24uaXNEdXJhdGlvbiA9IGZ1bmN0aW9uIGlzRHVyYXRpb24obykge1xuICAgIHJldHVybiBvICYmIG8uaXNMdXhvbkR1cmF0aW9uIHx8IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgIHRoZSBsb2NhbGUgb2YgYSBEdXJhdGlvbiwgc3VjaCAnZW4tR0InXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICA7XG5cbiAgdmFyIF9wcm90byA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBmb3JtYXQgc3RyaW5nLiBZb3UgbWF5IHVzZSB0aGVzZSB0b2tlbnM6XG4gICAqICogYFNgIGZvciBtaWxsaXNlY29uZHNcbiAgICogKiBgc2AgZm9yIHNlY29uZHNcbiAgICogKiBgbWAgZm9yIG1pbnV0ZXNcbiAgICogKiBgaGAgZm9yIGhvdXJzXG4gICAqICogYGRgIGZvciBkYXlzXG4gICAqICogYE1gIGZvciBtb250aHNcbiAgICogKiBgeWAgZm9yIHllYXJzXG4gICAqIE5vdGVzOlxuICAgKiAqIEFkZCBwYWRkaW5nIGJ5IHJlcGVhdGluZyB0aGUgdG9rZW4sIGUuZy4gXCJ5eVwiIHBhZHMgdGhlIHllYXJzIHRvIHR3byBkaWdpdHMsIFwiaGhoaFwiIHBhZHMgdGhlIGhvdXJzIG91dCB0byBmb3VyIGRpZ2l0c1xuICAgKiAqIFRoZSBkdXJhdGlvbiB3aWxsIGJlIGNvbnZlcnRlZCB0byB0aGUgc2V0IG9mIHVuaXRzIGluIHRoZSBmb3JtYXQgc3RyaW5nIHVzaW5nIHtAbGluayBEdXJhdGlvbi5zaGlmdFRvfSBhbmQgdGhlIER1cmF0aW9ucydzIGNvbnZlcnNpb24gYWNjdXJhY3kgc2V0dGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgc3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmZsb29yPXRydWVdIC0gZmxvb3IgbnVtZXJpY2FsIHZhbHVlc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9Gb3JtYXQoXCJ5IGQgc1wiKSAvLz0+IFwiMSA2IDJcIlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9Gb3JtYXQoXCJ5eSBkZCBzc3NcIikgLy89PiBcIjAxIDA2IDAwMlwiXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b0Zvcm1hdChcIk0gU1wiKSAvLz0+IFwiMTIgNTE4NDAyMDAwXCJcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgX3Byb3RvLnRvRm9ybWF0ID0gZnVuY3Rpb24gdG9Gb3JtYXQoZm10LCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cblxuICAgIC8vIHJldmVyc2UtY29tcGF0IHNpbmNlIDEuMjsgd2UgYWx3YXlzIHJvdW5kIGRvd24gbm93LCBuZXZlciB1cCwgYW5kIHdlIGRvIGl0IGJ5IGRlZmF1bHRcbiAgICB2YXIgZm10T3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMsIHtcbiAgICAgIGZsb29yOiBvcHRzLnJvdW5kICE9PSBmYWxzZSAmJiBvcHRzLmZsb29yICE9PSBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLCBmbXRPcHRzKS5mb3JtYXREdXJhdGlvbkZyb21TdHJpbmcodGhpcywgZm10KSA6IElOVkFMSUQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKYXZhc2NyaXB0IG9iamVjdCB3aXRoIHRoaXMgRHVyYXRpb24ncyB2YWx1ZXMuXG4gICAqIEBwYXJhbSBvcHRzIC0gb3B0aW9ucyBmb3IgZ2VuZXJhdGluZyB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZUNvbmZpZz1mYWxzZV0gLSBpbmNsdWRlIGNvbmZpZ3VyYXRpb24gYXR0cmlidXRlcyBpbiB0aGUgb3V0cHV0XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4ge307XG4gICAgdmFyIGJhc2UgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnZhbHVlcyk7XG5cbiAgICBpZiAob3B0cy5pbmNsdWRlQ29uZmlnKSB7XG4gICAgICBiYXNlLmNvbnZlcnNpb25BY2N1cmFjeSA9IHRoaXMuY29udmVyc2lvbkFjY3VyYWN5O1xuICAgICAgYmFzZS5udW1iZXJpbmdTeXN0ZW0gPSB0aGlzLmxvYy5udW1iZXJpbmdTeXN0ZW07XG4gICAgICBiYXNlLmxvY2FsZSA9IHRoaXMubG9jLmxvY2FsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24uXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjRHVyYXRpb25zXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMywgc2Vjb25kczogNDUgfSkudG9JU08oKSAvLz0+ICdQM1lUNDVTJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbW9udGhzOiA0LCBzZWNvbmRzOiA0NSB9KS50b0lTTygpIC8vPT4gJ1A0TVQ0NVMnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtb250aHM6IDUgfSkudG9JU08oKSAvLz0+ICdQNU0nXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtaW51dGVzOiA1IH0pLnRvSVNPKCkgLy89PiAnUFQ1TSdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbGxpc2Vjb25kczogNiB9KS50b0lTTygpIC8vPT4gJ1BUMC4wMDZTJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvSVNPID0gZnVuY3Rpb24gdG9JU08oKSB7XG4gICAgLy8gd2UgY291bGQgdXNlIHRoZSBmb3JtYXR0ZXIsIGJ1dCB0aGlzIGlzIGFuIGVhc2llciB3YXkgdG8gZ2V0IHRoZSBtaW5pbXVtIHN0cmluZ1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgcyA9IFwiUFwiO1xuICAgIGlmICh0aGlzLnllYXJzICE9PSAwKSBzICs9IHRoaXMueWVhcnMgKyBcIllcIjtcbiAgICBpZiAodGhpcy5tb250aHMgIT09IDAgfHwgdGhpcy5xdWFydGVycyAhPT0gMCkgcyArPSB0aGlzLm1vbnRocyArIHRoaXMucXVhcnRlcnMgKiAzICsgXCJNXCI7XG4gICAgaWYgKHRoaXMud2Vla3MgIT09IDApIHMgKz0gdGhpcy53ZWVrcyArIFwiV1wiO1xuICAgIGlmICh0aGlzLmRheXMgIT09IDApIHMgKz0gdGhpcy5kYXlzICsgXCJEXCI7XG4gICAgaWYgKHRoaXMuaG91cnMgIT09IDAgfHwgdGhpcy5taW51dGVzICE9PSAwIHx8IHRoaXMuc2Vjb25kcyAhPT0gMCB8fCB0aGlzLm1pbGxpc2Vjb25kcyAhPT0gMCkgcyArPSBcIlRcIjtcbiAgICBpZiAodGhpcy5ob3VycyAhPT0gMCkgcyArPSB0aGlzLmhvdXJzICsgXCJIXCI7XG4gICAgaWYgKHRoaXMubWludXRlcyAhPT0gMCkgcyArPSB0aGlzLm1pbnV0ZXMgKyBcIk1cIjtcbiAgICBpZiAodGhpcy5zZWNvbmRzICE9PSAwIHx8IHRoaXMubWlsbGlzZWNvbmRzICE9PSAwKSAvLyB0aGlzIHdpbGwgaGFuZGxlIFwiZmxvYXRpbmcgcG9pbnQgbWFkbmVzc1wiIGJ5IHJlbW92aW5nIGV4dHJhIGRlY2ltYWwgcGxhY2VzXG4gICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81ODgwMDQvaXMtZmxvYXRpbmctcG9pbnQtbWF0aC1icm9rZW5cbiAgICAgIHMgKz0gcm91bmRUbyh0aGlzLnNlY29uZHMgKyB0aGlzLm1pbGxpc2Vjb25kcyAvIDEwMDAsIDMpICsgXCJTXCI7XG4gICAgaWYgKHMgPT09IFwiUFwiKSBzICs9IFwiVDBTXCI7XG4gICAgcmV0dXJuIHM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIEpTT04uXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvSVNPKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIGRlYnVnZ2luZy5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnRvSVNPKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gbWlsbGlzZWNvbmRzIHZhbHVlIG9mIHRoaXMgRHVyYXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIDtcblxuICBfcHJvdG8udmFsdWVPZiA9IGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXMoXCJtaWxsaXNlY29uZHNcIik7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2UgdGhpcyBEdXJhdGlvbiBsb25nZXIgYnkgdGhlIHNwZWNpZmllZCBhbW91bnQuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGFtb3VudCB0byBhZGQuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wbHVzID0gZnVuY3Rpb24gcGx1cyhkdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICB2YXIgZHVyID0gZnJpZW5kbHlEdXJhdGlvbihkdXJhdGlvbiksXG4gICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvcmRlcmVkVW5pdHMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgdmFyIGsgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgaWYgKGhhc093blByb3BlcnR5KGR1ci52YWx1ZXMsIGspIHx8IGhhc093blByb3BlcnR5KHRoaXMudmFsdWVzLCBrKSkge1xuICAgICAgICByZXN1bHRba10gPSBkdXIuZ2V0KGspICsgdGhpcy5nZXQoayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHtcbiAgICAgIHZhbHVlczogcmVzdWx0XG4gICAgfSwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2UgdGhpcyBEdXJhdGlvbiBzaG9ydGVyIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gc3VidHJhY3QuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5taW51cyA9IGZ1bmN0aW9uIG1pbnVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHZhciBkdXIgPSBmcmllbmRseUR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5wbHVzKGR1ci5uZWdhdGUoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFNjYWxlIHRoaXMgRHVyYXRpb24gYnkgdGhlIHNwZWNpZmllZCBhbW91bnQuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIHVuaXQuIEFyaXR5IGlzIDEgb3IgMjogdGhlIHZhbHVlIG9mIHRoZSB1bml0IGFuZCwgb3B0aW9uYWxseSwgdGhlIHVuaXQgbmFtZS4gTXVzdCByZXR1cm4gYSBudW1iZXIuXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSwgbWludXRlczogMzAgfSkubWFwVW5pdCh4ID0+IHggKiAyKSAvLz0+IHsgaG91cnM6IDIsIG1pbnV0ZXM6IDYwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBtaW51dGVzOiAzMCB9KS5tYXBVbml0KCh4LCB1KSA9PiB1ID09PSBcImhvdXJcIiA/IHggKiAyIDogeCkgLy89PiB7IGhvdXJzOiAyLCBtaW51dGVzOiAzMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5tYXBVbml0cyA9IGZ1bmN0aW9uIG1hcFVuaXRzKGZuKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgIGZvciAodmFyIF9pID0gMCwgX09iamVjdCRrZXlzID0gT2JqZWN0LmtleXModGhpcy52YWx1ZXMpOyBfaSA8IF9PYmplY3Qka2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBrID0gX09iamVjdCRrZXlzW19pXTtcbiAgICAgIHJlc3VsdFtrXSA9IGFzTnVtYmVyKGZuKHRoaXMudmFsdWVzW2tdLCBrKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHtcbiAgICAgIHZhbHVlczogcmVzdWx0XG4gICAgfSwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBhIHVuaXQgc3VjaCBhcyAnbWludXRlJyBvciAnZGF5J1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMiwgZGF5czogM30pLnllYXJzIC8vPT4gMlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMiwgZGF5czogM30pLm1vbnRocyAvLz0+IDBcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDIsIGRheXM6IDN9KS5kYXlzIC8vPT4gM1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldCh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXNbRHVyYXRpb24ubm9ybWFsaXplVW5pdCh1bml0KV07XG4gIH1cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIHZhbHVlcyBvZiBzcGVjaWZpZWQgdW5pdHMuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gYSBtYXBwaW5nIG9mIHVuaXRzIHRvIG51bWJlcnNcbiAgICogQGV4YW1wbGUgZHVyLnNldCh7IHllYXJzOiAyMDE3IH0pXG4gICAqIEBleGFtcGxlIGR1ci5zZXQoeyBob3VyczogOCwgbWludXRlczogMzAgfSlcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNldCA9IGZ1bmN0aW9uIHNldCh2YWx1ZXMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgdmFyIG1peGVkID0gT2JqZWN0LmFzc2lnbih0aGlzLnZhbHVlcywgbm9ybWFsaXplT2JqZWN0KHZhbHVlcywgRHVyYXRpb24ubm9ybWFsaXplVW5pdCwgW10pKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywge1xuICAgICAgdmFsdWVzOiBtaXhlZFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBsb2NhbGUgYW5kL29yIG51bWJlcmluZ1N5c3RlbS4gIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQGV4YW1wbGUgZHVyLnJlY29uZmlndXJlKHsgbG9jYWxlOiAnZW4tR0InIH0pXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZWNvbmZpZ3VyZSA9IGZ1bmN0aW9uIHJlY29uZmlndXJlKF90ZW1wKSB7XG4gICAgdmFyIF9yZWYgPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcCxcbiAgICAgICAgbG9jYWxlID0gX3JlZi5sb2NhbGUsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSA9IF9yZWYubnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBjb252ZXJzaW9uQWNjdXJhY3kgPSBfcmVmLmNvbnZlcnNpb25BY2N1cmFjeTtcblxuICAgIHZhciBsb2MgPSB0aGlzLmxvYy5jbG9uZSh7XG4gICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgIG51bWJlcmluZ1N5c3RlbTogbnVtYmVyaW5nU3lzdGVtXG4gICAgfSksXG4gICAgICAgIG9wdHMgPSB7XG4gICAgICBsb2M6IGxvY1xuICAgIH07XG5cbiAgICBpZiAoY29udmVyc2lvbkFjY3VyYWN5KSB7XG4gICAgICBvcHRzLmNvbnZlcnNpb25BY2N1cmFjeSA9IGNvbnZlcnNpb25BY2N1cmFjeTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmUodGhpcywgb3B0cyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBkdXJhdGlvbiBpbiB0aGUgc3BlY2lmaWVkIHVuaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gYSB1bml0IHN1Y2ggYXMgJ21pbnV0ZXMnIG9yICdkYXlzJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMX0pLmFzKCdkYXlzJykgLy89PiAzNjVcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDF9KS5hcygnbW9udGhzJykgLy89PiAxMlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHtob3VyczogNjB9KS5hcygnZGF5cycpIC8vPT4gMi41XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYXMgPSBmdW5jdGlvbiBhcyh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuc2hpZnRUbyh1bml0KS5nZXQodW5pdCkgOiBOYU47XG4gIH1cbiAgLyoqXG4gICAqIFJlZHVjZSB0aGlzIER1cmF0aW9uIHRvIGl0cyBjYW5vbmljYWwgcmVwcmVzZW50YXRpb24gaW4gaXRzIGN1cnJlbnQgdW5pdHMuXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMiwgZGF5czogNTAwMCB9KS5ub3JtYWxpemUoKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMTUsIGRheXM6IDI1NSB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTIsIG1pbnV0ZXM6IC00NSB9KS5ub3JtYWxpemUoKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDE1IH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgdmFyIHZhbHMgPSB0aGlzLnRvT2JqZWN0KCk7XG4gICAgbm9ybWFsaXplVmFsdWVzKHRoaXMubWF0cml4LCB2YWxzKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywge1xuICAgICAgdmFsdWVzOiB2YWxzXG4gICAgfSwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhpcyBEdXJhdGlvbiBpbnRvIGl0cyByZXByZXNlbnRhdGlvbiBpbiBhIGRpZmZlcmVudCBzZXQgb2YgdW5pdHMuXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSwgc2Vjb25kczogMzAgfSkuc2hpZnRUbygnbWludXRlcycsICdtaWxsaXNlY29uZHMnKS50b09iamVjdCgpIC8vPT4geyBtaW51dGVzOiA2MCwgbWlsbGlzZWNvbmRzOiAzMDAwMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zaGlmdFRvID0gZnVuY3Rpb24gc2hpZnRUbygpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdW5pdHMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICB1bml0c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAodW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB1bml0cyA9IHVuaXRzLm1hcChmdW5jdGlvbiAodSkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQodSk7XG4gICAgfSk7XG4gICAgdmFyIGJ1aWx0ID0ge30sXG4gICAgICAgIGFjY3VtdWxhdGVkID0ge30sXG4gICAgICAgIHZhbHMgPSB0aGlzLnRvT2JqZWN0KCk7XG4gICAgdmFyIGxhc3RVbml0O1xuXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2Uob3JkZXJlZFVuaXRzKSwgX3N0ZXAyOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIoKSkuZG9uZTspIHtcbiAgICAgIHZhciBrID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICBpZiAodW5pdHMuaW5kZXhPZihrKSA+PSAwKSB7XG4gICAgICAgIGxhc3RVbml0ID0gaztcbiAgICAgICAgdmFyIG93biA9IDA7IC8vIGFueXRoaW5nIHdlIGhhdmVuJ3QgYm9pbGVkIGRvd24geWV0IHNob3VsZCBnZXQgYm9pbGVkIHRvIHRoaXMgdW5pdFxuXG4gICAgICAgIGZvciAodmFyIGFrIGluIGFjY3VtdWxhdGVkKSB7XG4gICAgICAgICAgb3duICs9IHRoaXMubWF0cml4W2FrXVtrXSAqIGFjY3VtdWxhdGVkW2FrXTtcbiAgICAgICAgICBhY2N1bXVsYXRlZFtha10gPSAwO1xuICAgICAgICB9IC8vIHBsdXMgYW55dGhpbmcgdGhhdCdzIGFscmVhZHkgaW4gdGhpcyB1bml0XG5cblxuICAgICAgICBpZiAoaXNOdW1iZXIodmFsc1trXSkpIHtcbiAgICAgICAgICBvd24gKz0gdmFsc1trXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gTWF0aC50cnVuYyhvd24pO1xuICAgICAgICBidWlsdFtrXSA9IGk7XG4gICAgICAgIGFjY3VtdWxhdGVkW2tdID0gb3duIC0gaTsgLy8gd2UnZCBsaWtlIHRvIGFic29yYiB0aGVzZSBmcmFjdGlvbnMgaW4gYW5vdGhlciB1bml0XG4gICAgICAgIC8vIHBsdXMgYW55dGhpbmcgZnVydGhlciBkb3duIHRoZSBjaGFpbiB0aGF0IHNob3VsZCBiZSByb2xsZWQgdXAgaW4gdG8gdGhpc1xuXG4gICAgICAgIGZvciAodmFyIGRvd24gaW4gdmFscykge1xuICAgICAgICAgIGlmIChvcmRlcmVkVW5pdHMuaW5kZXhPZihkb3duKSA+IG9yZGVyZWRVbml0cy5pbmRleE9mKGspKSB7XG4gICAgICAgICAgICBjb252ZXJ0KHRoaXMubWF0cml4LCB2YWxzLCBkb3duLCBidWlsdCwgayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIG90aGVyd2lzZSwga2VlcCBpdCBpbiB0aGUgd2luZ3MgdG8gYm9pbCBpdCBsYXRlclxuXG4gICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKHZhbHNba10pKSB7XG4gICAgICAgIGFjY3VtdWxhdGVkW2tdID0gdmFsc1trXTtcbiAgICAgIH1cbiAgICB9IC8vIGFueXRoaW5nIGxlZnRvdmVyIGJlY29tZXMgdGhlIGRlY2ltYWwgZm9yIHRoZSBsYXN0IHVuaXRcbiAgICAvLyBsYXN0VW5pdCBtdXN0IGJlIGRlZmluZWQgc2luY2UgdW5pdHMgaXMgbm90IGVtcHR5XG5cblxuICAgIGZvciAodmFyIGtleSBpbiBhY2N1bXVsYXRlZCkge1xuICAgICAgaWYgKGFjY3VtdWxhdGVkW2tleV0gIT09IDApIHtcbiAgICAgICAgYnVpbHRbbGFzdFVuaXRdICs9IGtleSA9PT0gbGFzdFVuaXQgPyBhY2N1bXVsYXRlZFtrZXldIDogYWNjdW11bGF0ZWRba2V5XSAvIHRoaXMubWF0cml4W2xhc3RVbml0XVtrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7XG4gICAgICB2YWx1ZXM6IGJ1aWx0XG4gICAgfSwgdHJ1ZSkubm9ybWFsaXplKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbmVnYXRpdmUgb2YgdGhpcyBEdXJhdGlvbi5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBzZWNvbmRzOiAzMCB9KS5uZWdhdGUoKS50b09iamVjdCgpIC8vPT4geyBob3VyczogLTEsIHNlY29uZHM6IC0zMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5uZWdhdGUgPSBmdW5jdGlvbiBuZWdhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHZhciBuZWdhdGVkID0ge307XG5cbiAgICBmb3IgKHZhciBfaTIgPSAwLCBfT2JqZWN0JGtleXMyID0gT2JqZWN0LmtleXModGhpcy52YWx1ZXMpOyBfaTIgPCBfT2JqZWN0JGtleXMyLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIHZhciBrID0gX09iamVjdCRrZXlzMltfaTJdO1xuICAgICAgbmVnYXRlZFtrXSA9IC10aGlzLnZhbHVlc1trXTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmUodGhpcywge1xuICAgICAgdmFsdWVzOiBuZWdhdGVkXG4gICAgfSwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgeWVhcnMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICA7XG5cbiAgLyoqXG4gICAqIEVxdWFsaXR5IGNoZWNrXG4gICAqIFR3byBEdXJhdGlvbnMgYXJlIGVxdWFsIGlmZiB0aGV5IGhhdmUgdGhlIHNhbWUgdW5pdHMgYW5kIHRoZSBzYW1lIHZhbHVlcyBmb3IgZWFjaCB1bml0LlxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFvdGhlci5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmxvYy5lcXVhbHMob3RoZXIubG9jKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG9yZGVyZWRVbml0cyksIF9zdGVwMzsgIShfc3RlcDMgPSBfaXRlcmF0b3IzKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgdSA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgaWYgKHRoaXMudmFsdWVzW3VdICE9PSBvdGhlci52YWx1ZXNbdV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhEdXJhdGlvbiwgW3tcbiAgICBrZXk6IFwibG9jYWxlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubG9jYWxlIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBudW1iZXJpbmcgc3lzdGVtIG9mIGEgRHVyYXRpb24sIHN1Y2ggJ2JlbmcnLiBUaGUgbnVtYmVyaW5nIHN5c3RlbSBpcyB1c2VkIHdoZW4gZm9ybWF0dGluZyB0aGUgRHVyYXRpb25cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJudW1iZXJpbmdTeXN0ZW1cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmxvYy5udW1iZXJpbmdTeXN0ZW0gOiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ5ZWFyc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLnllYXJzIHx8IDAgOiBOYU47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcXVhcnRlcnMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInF1YXJ0ZXJzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMucXVhcnRlcnMgfHwgMCA6IE5hTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBtb250aHMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1vbnRoc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLm1vbnRocyB8fCAwIDogTmFOO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHdlZWtzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndlZWtzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMud2Vla3MgfHwgMCA6IE5hTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkYXlzLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkYXlzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMuZGF5cyB8fCAwIDogTmFOO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGhvdXJzLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJob3Vyc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLmhvdXJzIHx8IDAgOiBOYU47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbWludXRlcy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibWludXRlc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLm1pbnV0ZXMgfHwgMCA6IE5hTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzZWNvbmRzLlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNlY29uZHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5zZWNvbmRzIHx8IDAgOiBOYU47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbWlsbGlzZWNvbmRzLlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1pbGxpc2Vjb25kc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLm1pbGxpc2Vjb25kcyB8fCAwIDogTmFOO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIER1cmF0aW9uIGlzIGludmFsaWQuIEludmFsaWQgZHVyYXRpb25zIGFyZSByZXR1cm5lZCBieSBkaWZmIG9wZXJhdGlvbnNcbiAgICAgKiBvbiBpbnZhbGlkIERhdGVUaW1lcyBvciBJbnRlcnZhbHMuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzVmFsaWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmludmFsaWQgPT09IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gZXJyb3IgY29kZSBpZiB0aGlzIER1cmF0aW9uIGJlY2FtZSBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBEdXJhdGlvbiBpcyB2YWxpZFxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImludmFsaWRSZWFzb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQucmVhc29uIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBEdXJhdGlvbiBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgRHVyYXRpb24gaXMgdmFsaWRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW52YWxpZEV4cGxhbmF0aW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLmV4cGxhbmF0aW9uIDogbnVsbDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRHVyYXRpb247XG59KCk7XG5mdW5jdGlvbiBmcmllbmRseUR1cmF0aW9uKGR1cmF0aW9uaXNoKSB7XG4gIGlmIChpc051bWJlcihkdXJhdGlvbmlzaCkpIHtcbiAgICByZXR1cm4gRHVyYXRpb24uZnJvbU1pbGxpcyhkdXJhdGlvbmlzaCk7XG4gIH0gZWxzZSBpZiAoRHVyYXRpb24uaXNEdXJhdGlvbihkdXJhdGlvbmlzaCkpIHtcbiAgICByZXR1cm4gZHVyYXRpb25pc2g7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uaXNoID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIER1cmF0aW9uLmZyb21PYmplY3QoZHVyYXRpb25pc2gpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIlVua25vd24gZHVyYXRpb24gYXJndW1lbnQgXCIgKyBkdXJhdGlvbmlzaCArIFwiIG9mIHR5cGUgXCIgKyB0eXBlb2YgZHVyYXRpb25pc2gpO1xuICB9XG59XG5cbnZhciBJTlZBTElEJDEgPSBcIkludmFsaWQgSW50ZXJ2YWxcIjsgLy8gY2hlY2tzIGlmIHRoZSBzdGFydCBpcyBlcXVhbCB0byBvciBiZWZvcmUgdGhlIGVuZFxuXG5mdW5jdGlvbiB2YWxpZGF0ZVN0YXJ0RW5kKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCB8fCAhc3RhcnQuaXNWYWxpZCkge1xuICAgIHJldHVybiBJbnRlcnZhbC5pbnZhbGlkKFwibWlzc2luZyBvciBpbnZhbGlkIHN0YXJ0XCIpO1xuICB9IGVsc2UgaWYgKCFlbmQgfHwgIWVuZC5pc1ZhbGlkKSB7XG4gICAgcmV0dXJuIEludGVydmFsLmludmFsaWQoXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kXCIpO1xuICB9IGVsc2UgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgcmV0dXJuIEludGVydmFsLmludmFsaWQoXCJlbmQgYmVmb3JlIHN0YXJ0XCIsIFwiVGhlIGVuZCBvZiBhbiBpbnRlcnZhbCBtdXN0IGJlIGFmdGVyIGl0cyBzdGFydCwgYnV0IHlvdSBoYWQgc3RhcnQ9XCIgKyBzdGFydC50b0lTTygpICsgXCIgYW5kIGVuZD1cIiArIGVuZC50b0lTTygpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuLyoqXG4gKiBBbiBJbnRlcnZhbCBvYmplY3QgcmVwcmVzZW50cyBhIGhhbGYtb3BlbiBpbnRlcnZhbCBvZiB0aW1lLCB3aGVyZSBlYWNoIGVuZHBvaW50IGlzIGEge0BsaW5rIERhdGVUaW1lfS4gQ29uY2VwdHVhbGx5LCBpdCdzIGEgY29udGFpbmVyIGZvciB0aG9zZSB0d28gZW5kcG9pbnRzLCBhY2NvbXBhbmllZCBieSBtZXRob2RzIGZvciBjcmVhdGluZywgcGFyc2luZywgaW50ZXJyb2dhdGluZywgY29tcGFyaW5nLCB0cmFuc2Zvcm1pbmcsIGFuZCBmb3JtYXR0aW5nIHRoZW0uXG4gKlxuICogSGVyZSBpcyBhIGJyaWVmIG92ZXJ2aWV3IG9mIHRoZSBtb3N0IGNvbW1vbmx5IHVzZWQgbWV0aG9kcyBhbmQgZ2V0dGVycyBpbiBJbnRlcnZhbDpcbiAqXG4gKiAqICoqQ3JlYXRpb24qKiBUbyBjcmVhdGUgYW4gSW50ZXJ2YWwsIHVzZSB7QGxpbmsgZnJvbURhdGVUaW1lc30sIHtAbGluayBhZnRlcn0sIHtAbGluayBiZWZvcmV9LCBvciB7QGxpbmsgZnJvbUlTT30uXG4gKiAqICoqQWNjZXNzb3JzKiogVXNlIHtAbGluayBzdGFydH0gYW5kIHtAbGluayBlbmR9IHRvIGdldCB0aGUgc3RhcnQgYW5kIGVuZC5cbiAqICogKipJbnRlcnJvZ2F0aW9uKiogVG8gYW5hbHl6ZSB0aGUgSW50ZXJ2YWwsIHVzZSB7QGxpbmsgY291bnR9LCB7QGxpbmsgbGVuZ3RofSwge0BsaW5rIGhhc1NhbWV9LCB7QGxpbmsgY29udGFpbnN9LCB7QGxpbmsgaXNBZnRlcn0sIG9yIHtAbGluayBpc0JlZm9yZX0uXG4gKiAqICoqVHJhbnNmb3JtYXRpb24qKiBUbyBjcmVhdGUgb3RoZXIgSW50ZXJ2YWxzIG91dCBvZiB0aGlzIG9uZSwgdXNlIHtAbGluayBzZXR9LCB7QGxpbmsgc3BsaXRBdH0sIHtAbGluayBzcGxpdEJ5fSwge0BsaW5rIGRpdmlkZUVxdWFsbHl9LCB7QGxpbmsgbWVyZ2V9LCB7QGxpbmsgeG9yfSwge0BsaW5rIHVuaW9ufSwge0BsaW5rIGludGVyc2VjdGlvbn0sIG9yIHtAbGluayBkaWZmZXJlbmNlfS5cbiAqICogKipDb21wYXJpc29uKiogVG8gY29tcGFyZSB0aGlzIEludGVydmFsIHRvIGFub3RoZXIgb25lLCB1c2Uge0BsaW5rIGVxdWFsc30sIHtAbGluayBvdmVybGFwc30sIHtAbGluayBhYnV0c1N0YXJ0fSwge0BsaW5rIGFidXRzRW5kfSwge0BsaW5rIGVuZ3VsZnN9LlxuICogKiAqKk91dHB1dCoqIFRvIGNvbnZlcnQgdGhlIEludGVydmFsIGludG8gb3RoZXIgcmVwcmVzZW50YXRpb25zLCBzZWUge0BsaW5rIHRvU3RyaW5nfSwge0BsaW5rIHRvSVNPfSwge0BsaW5rIHRvSVNPRGF0ZX0sIHtAbGluayB0b0lTT1RpbWV9LCB7QGxpbmsgdG9Gb3JtYXR9LCBhbmQge0BsaW5rIHRvRHVyYXRpb259LlxuICovXG5cblxudmFyIEludGVydmFsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBJbnRlcnZhbChjb25maWcpIHtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnMgPSBjb25maWcuc3RhcnQ7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG5cbiAgICB0aGlzLmUgPSBjb25maWcuZW5kO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5pbnZhbGlkID0gY29uZmlnLmludmFsaWQgfHwgbnVsbDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuaXNMdXhvbkludGVydmFsID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuIGludmFsaWQgSW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gLSBzaW1wbGUgc3RyaW5nIG9mIHdoeSB0aGlzIEludGVydmFsIGlzIGludmFsaWQuIFNob3VsZCBub3QgY29udGFpbiBwYXJhbWV0ZXJzIG9yIGFueXRoaW5nIGVsc2UgZGF0YS1kZXBlbmRlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtleHBsYW5hdGlvbj1udWxsXSAtIGxvbmdlciBleHBsYW5hdGlvbiwgbWF5IGluY2x1ZGUgcGFyYW1ldGVycyBhbmQgb3RoZXIgdXNlZnVsIGRlYnVnZ2luZyBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG5cblxuICBJbnRlcnZhbC5pbnZhbGlkID0gZnVuY3Rpb24gaW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uKSB7XG4gICAgaWYgKGV4cGxhbmF0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIGV4cGxhbmF0aW9uID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibmVlZCB0byBzcGVjaWZ5IGEgcmVhc29uIHRoZSBJbnRlcnZhbCBpcyBpbnZhbGlkXCIpO1xuICAgIH1cblxuICAgIHZhciBpbnZhbGlkID0gcmVhc29uIGluc3RhbmNlb2YgSW52YWxpZCA/IHJlYXNvbiA6IG5ldyBJbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24pO1xuXG4gICAgaWYgKFNldHRpbmdzLnRocm93T25JbnZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEludGVydmFsRXJyb3IoaW52YWxpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgSW50ZXJ2YWwoe1xuICAgICAgICBpbnZhbGlkOiBpbnZhbGlkXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGEgc3RhcnQgRGF0ZVRpbWUgYW5kIGFuIGVuZCBEYXRlVGltZS4gSW5jbHVzaXZlIG9mIHRoZSBzdGFydCBidXQgbm90IHRoZSBlbmQuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IHN0YXJ0XG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IGVuZFxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIDtcblxuICBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzID0gZnVuY3Rpb24gZnJvbURhdGVUaW1lcyhzdGFydCwgZW5kKSB7XG4gICAgdmFyIGJ1aWx0U3RhcnQgPSBmcmllbmRseURhdGVUaW1lKHN0YXJ0KSxcbiAgICAgICAgYnVpbHRFbmQgPSBmcmllbmRseURhdGVUaW1lKGVuZCk7XG4gICAgdmFyIHZhbGlkYXRlRXJyb3IgPSB2YWxpZGF0ZVN0YXJ0RW5kKGJ1aWx0U3RhcnQsIGJ1aWx0RW5kKTtcblxuICAgIGlmICh2YWxpZGF0ZUVycm9yID09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgSW50ZXJ2YWwoe1xuICAgICAgICBzdGFydDogYnVpbHRTdGFydCxcbiAgICAgICAgZW5kOiBidWlsdEVuZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWxpZGF0ZUVycm9yO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuIEludGVydmFsIGZyb20gYSBzdGFydCBEYXRlVGltZSBhbmQgYSBEdXJhdGlvbiB0byBleHRlbmQgdG8uXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IHN0YXJ0XG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSB0aGUgbGVuZ3RoIG9mIHRoZSBJbnRlcnZhbC5cbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICA7XG5cbiAgSW50ZXJ2YWwuYWZ0ZXIgPSBmdW5jdGlvbiBhZnRlcihzdGFydCwgZHVyYXRpb24pIHtcbiAgICB2YXIgZHVyID0gZnJpZW5kbHlEdXJhdGlvbihkdXJhdGlvbiksXG4gICAgICAgIGR0ID0gZnJpZW5kbHlEYXRlVGltZShzdGFydCk7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQsIGR0LnBsdXMoZHVyKSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGFuIGVuZCBEYXRlVGltZSBhbmQgYSBEdXJhdGlvbiB0byBleHRlbmQgYmFja3dhcmRzIHRvLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfERhdGV8T2JqZWN0fSBlbmRcbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIHRoZSBsZW5ndGggb2YgdGhlIEludGVydmFsLlxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIDtcblxuICBJbnRlcnZhbC5iZWZvcmUgPSBmdW5jdGlvbiBiZWZvcmUoZW5kLCBkdXJhdGlvbikge1xuICAgIHZhciBkdXIgPSBmcmllbmRseUR1cmF0aW9uKGR1cmF0aW9uKSxcbiAgICAgICAgZHQgPSBmcmllbmRseURhdGVUaW1lKGVuZCk7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQubWludXMoZHVyKSwgZHQpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gSW50ZXJ2YWwgZnJvbSBhbiBJU08gODYwMSBzdHJpbmcuXG4gICAqIEFjY2VwdHMgYDxzdGFydD4vPGVuZD5gLCBgPHN0YXJ0Pi88ZHVyYXRpb24+YCwgYW5kIGA8ZHVyYXRpb24+LzxlbmQ+YCBmb3JtYXRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBJU08gc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBvcHRpb25zIHRvIHBhc3Mge0BsaW5rIERhdGVUaW1lLmZyb21JU099IGFuZCBvcHRpb25hbGx5IHtAbGluayBEdXJhdGlvbi5mcm9tSVNPfVxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVfaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgO1xuXG4gIEludGVydmFsLmZyb21JU08gPSBmdW5jdGlvbiBmcm9tSVNPKHRleHQsIG9wdHMpIHtcbiAgICB2YXIgX3NwbGl0ID0gKHRleHQgfHwgXCJcIikuc3BsaXQoXCIvXCIsIDIpLFxuICAgICAgICBzID0gX3NwbGl0WzBdLFxuICAgICAgICBlID0gX3NwbGl0WzFdO1xuXG4gICAgaWYgKHMgJiYgZSkge1xuICAgICAgdmFyIHN0YXJ0LCBzdGFydElzVmFsaWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHN0YXJ0ID0gRGF0ZVRpbWUuZnJvbUlTTyhzLCBvcHRzKTtcbiAgICAgICAgc3RhcnRJc1ZhbGlkID0gc3RhcnQuaXNWYWxpZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc3RhcnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbmQsIGVuZElzVmFsaWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGVuZCA9IERhdGVUaW1lLmZyb21JU08oZSwgb3B0cyk7XG4gICAgICAgIGVuZElzVmFsaWQgPSBlbmQuaXNWYWxpZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZW5kSXNWYWxpZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnRJc1ZhbGlkICYmIGVuZElzVmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoc3RhcnQsIGVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydElzVmFsaWQpIHtcbiAgICAgICAgdmFyIGR1ciA9IER1cmF0aW9uLmZyb21JU08oZSwgb3B0cyk7XG5cbiAgICAgICAgaWYgKGR1ci5pc1ZhbGlkKSB7XG4gICAgICAgICAgcmV0dXJuIEludGVydmFsLmFmdGVyKHN0YXJ0LCBkdXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVuZElzVmFsaWQpIHtcbiAgICAgICAgdmFyIF9kdXIgPSBEdXJhdGlvbi5mcm9tSVNPKHMsIG9wdHMpO1xuXG4gICAgICAgIGlmIChfZHVyLmlzVmFsaWQpIHtcbiAgICAgICAgICByZXR1cm4gSW50ZXJ2YWwuYmVmb3JlKGVuZCwgX2R1cik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gSW50ZXJ2YWwuaW52YWxpZChcInVucGFyc2FibGVcIiwgXCJ0aGUgaW5wdXQgXFxcIlwiICsgdGV4dCArIFwiXFxcIiBjYW4ndCBiZSBwYXJzZWQgYXMgSVNPIDg2MDFcIik7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBhbiBJbnRlcnZhbC4gV29ya3MgYWNyb3NzIGNvbnRleHQgYm91bmRhcmllc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgO1xuXG4gIEludGVydmFsLmlzSW50ZXJ2YWwgPSBmdW5jdGlvbiBpc0ludGVydmFsKG8pIHtcbiAgICByZXR1cm4gbyAmJiBvLmlzTHV4b25JbnRlcnZhbCB8fCBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RhcnQgb2YgdGhlIEludGVydmFsXG4gICAqIEB0eXBlIHtEYXRlVGltZX1cbiAgICovXG4gIDtcblxuICB2YXIgX3Byb3RvID0gSW50ZXJ2YWwucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIEludGVydmFsIGluIHRoZSBzcGVjaWZpZWQgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSB0aGUgdW5pdCAoc3VjaCBhcyAnaG91cnMnIG9yICdkYXlzJykgdG8gcmV0dXJuIHRoZSBsZW5ndGggaW4uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIF9wcm90by5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgodW5pdCkge1xuICAgIGlmICh1bml0ID09PSB2b2lkIDApIHtcbiAgICAgIHVuaXQgPSBcIm1pbGxpc2Vjb25kc1wiO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRvRHVyYXRpb24uYXBwbHkodGhpcywgW3VuaXRdKS5nZXQodW5pdCkgOiBOYU47XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvdW50IG9mIG1pbnV0ZXMsIGhvdXJzLCBkYXlzLCBtb250aHMsIG9yIHllYXJzIGluY2x1ZGVkIGluIHRoZSBJbnRlcnZhbCwgZXZlbiBpbiBwYXJ0LlxuICAgKiBVbmxpa2Uge0BsaW5rIGxlbmd0aH0gdGhpcyBjb3VudHMgc2VjdGlvbnMgb2YgdGhlIGNhbGVuZGFyLCBub3QgcGVyaW9kcyBvZiB0aW1lLCBlLmcuIHNwZWNpZnlpbmcgJ2RheSdcbiAgICogYXNrcyAnd2hhdCBkYXRlcyBhcmUgaW5jbHVkZWQgaW4gdGhpcyBpbnRlcnZhbD8nLCBub3QgJ2hvdyBtYW55IGRheXMgbG9uZyBpcyB0aGlzIGludGVydmFsPydcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt1bml0PSdtaWxsaXNlY29uZHMnXSAtIHRoZSB1bml0IG9mIHRpbWUgdG8gY291bnQuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIDtcblxuICBfcHJvdG8uY291bnQgPSBmdW5jdGlvbiBjb3VudCh1bml0KSB7XG4gICAgaWYgKHVuaXQgPT09IHZvaWQgMCkge1xuICAgICAgdW5pdCA9IFwibWlsbGlzZWNvbmRzXCI7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBOYU47XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydC5zdGFydE9mKHVuaXQpLFxuICAgICAgICBlbmQgPSB0aGlzLmVuZC5zdGFydE9mKHVuaXQpO1xuICAgIHJldHVybiBNYXRoLmZsb29yKGVuZC5kaWZmKHN0YXJ0LCB1bml0KS5nZXQodW5pdCkpICsgMTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBzdGFydCBhbmQgZW5kIGFyZSBib3RoIGluIHRoZSBzYW1lIHVuaXQgb2YgdGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIHRoZSB1bml0IG9mIHRpbWUgdG8gY2hlY2sgc2FtZW5lc3Mgb25cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaGFzU2FtZSA9IGZ1bmN0aW9uIGhhc1NhbWUodW5pdCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmlzRW1wdHkoKSB8fCB0aGlzLmUubWludXMoMSkuaGFzU2FtZSh0aGlzLnMsIHVuaXQpIDogZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgaGFzIHRoZSBzYW1lIHN0YXJ0IGFuZCBlbmQgRGF0ZVRpbWVzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5zLnZhbHVlT2YoKSA9PT0gdGhpcy5lLnZhbHVlT2YoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIHN0YXJ0IGlzIGFmdGVyIHRoZSBzcGVjaWZpZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IGRhdGVUaW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmlzQWZ0ZXIgPSBmdW5jdGlvbiBpc0FmdGVyKGRhdGVUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5zID4gZGF0ZVRpbWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBlbmQgaXMgYmVmb3JlIHRoZSBzcGVjaWZpZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IGRhdGVUaW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmlzQmVmb3JlID0gZnVuY3Rpb24gaXNCZWZvcmUoZGF0ZVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLmUgPD0gZGF0ZVRpbWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgY29udGFpbnMgdGhlIHNwZWNpZmllZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gZGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIDtcblxuICBfcHJvdG8uY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyhkYXRlVGltZSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucyA8PSBkYXRlVGltZSAmJiB0aGlzLmUgPiBkYXRlVGltZTtcbiAgfVxuICAvKipcbiAgICogXCJTZXRzXCIgdGhlIHN0YXJ0IGFuZC9vciBlbmQgZGF0ZXMuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBJbnRlcnZhbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcyAtIHRoZSB2YWx1ZXMgdG8gc2V0XG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IHZhbHVlcy5zdGFydCAtIHRoZSBzdGFydGluZyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSB2YWx1ZXMuZW5kIC0gdGhlIGVuZGluZyBEYXRlVGltZVxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIDtcblxuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KF90ZW1wKSB7XG4gICAgdmFyIF9yZWYgPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcCxcbiAgICAgICAgc3RhcnQgPSBfcmVmLnN0YXJ0LFxuICAgICAgICBlbmQgPSBfcmVmLmVuZDtcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzdGFydCB8fCB0aGlzLnMsIGVuZCB8fCB0aGlzLmUpO1xuICB9XG4gIC8qKlxuICAgKiBTcGxpdCB0aGlzIEludGVydmFsIGF0IGVhY2ggb2YgdGhlIHNwZWNpZmllZCBEYXRlVGltZXNcbiAgICogQHBhcmFtIHsuLi5bRGF0ZVRpbWVdfSBkYXRlVGltZXMgLSB0aGUgdW5pdCBvZiB0aW1lIHRvIGNvdW50LlxuICAgKiBAcmV0dXJuIHtbSW50ZXJ2YWxdfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zcGxpdEF0ID0gZnVuY3Rpb24gc3BsaXRBdCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBbXTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBkYXRlVGltZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBkYXRlVGltZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIHNvcnRlZCA9IGRhdGVUaW1lcy5tYXAoZnJpZW5kbHlEYXRlVGltZSkuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gX3RoaXMuY29udGFpbnMoZCk7XG4gICAgfSkuc29ydCgpLFxuICAgICAgICByZXN1bHRzID0gW107XG4gICAgdmFyIHMgPSB0aGlzLnMsXG4gICAgICAgIGkgPSAwO1xuXG4gICAgd2hpbGUgKHMgPCB0aGlzLmUpIHtcbiAgICAgIHZhciBhZGRlZCA9IHNvcnRlZFtpXSB8fCB0aGlzLmUsXG4gICAgICAgICAgbmV4dCA9ICthZGRlZCA+ICt0aGlzLmUgPyB0aGlzLmUgOiBhZGRlZDtcbiAgICAgIHJlc3VsdHMucHVzaChJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIG5leHQpKTtcbiAgICAgIHMgPSBuZXh0O1xuICAgICAgaSArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG4gIC8qKlxuICAgKiBTcGxpdCB0aGlzIEludGVydmFsIGludG8gc21hbGxlciBJbnRlcnZhbHMsIGVhY2ggb2YgdGhlIHNwZWNpZmllZCBsZW5ndGguXG4gICAqIExlZnQgb3ZlciB0aW1lIGlzIGdyb3VwZWQgaW50byBhIHNtYWxsZXIgaW50ZXJ2YWxcbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBsZW5ndGggb2YgZWFjaCByZXN1bHRpbmcgaW50ZXJ2YWwuXG4gICAqIEByZXR1cm4ge1tJbnRlcnZhbF19XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNwbGl0QnkgPSBmdW5jdGlvbiBzcGxpdEJ5KGR1cmF0aW9uKSB7XG4gICAgdmFyIGR1ciA9IGZyaWVuZGx5RHVyYXRpb24oZHVyYXRpb24pO1xuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgIWR1ci5pc1ZhbGlkIHx8IGR1ci5hcyhcIm1pbGxpc2Vjb25kc1wiKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBzID0gdGhpcy5zLFxuICAgICAgICBhZGRlZCxcbiAgICAgICAgbmV4dDtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgd2hpbGUgKHMgPCB0aGlzLmUpIHtcbiAgICAgIGFkZGVkID0gcy5wbHVzKGR1cik7XG4gICAgICBuZXh0ID0gK2FkZGVkID4gK3RoaXMuZSA/IHRoaXMuZSA6IGFkZGVkO1xuICAgICAgcmVzdWx0cy5wdXNoKEludGVydmFsLmZyb21EYXRlVGltZXMocywgbmV4dCkpO1xuICAgICAgcyA9IG5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgLyoqXG4gICAqIFNwbGl0IHRoaXMgSW50ZXJ2YWwgaW50byB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBzbWFsbGVyIGludGVydmFscy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlck9mUGFydHMgLSBUaGUgbnVtYmVyIG9mIEludGVydmFscyB0byBkaXZpZGUgdGhlIEludGVydmFsIGludG8uXG4gICAqIEByZXR1cm4ge1tJbnRlcnZhbF19XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRpdmlkZUVxdWFsbHkgPSBmdW5jdGlvbiBkaXZpZGVFcXVhbGx5KG51bWJlck9mUGFydHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiB0aGlzLnNwbGl0QnkodGhpcy5sZW5ndGgoKSAvIG51bWJlck9mUGFydHMpLnNsaWNlKDAsIG51bWJlck9mUGFydHMpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsIG92ZXJsYXBzIHdpdGggdGhlIHNwZWNpZmllZCBJbnRlcnZhbFxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vdmVybGFwcyA9IGZ1bmN0aW9uIG92ZXJsYXBzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZSA+IG90aGVyLnMgJiYgdGhpcy5zIDwgb3RoZXIuZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIGVuZCBpcyBhZGphY2VudCB0byB0aGUgc3BlY2lmaWVkIEludGVydmFsJ3Mgc3RhcnQuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmFidXRzU3RhcnQgPSBmdW5jdGlvbiBhYnV0c1N0YXJ0KG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gK3RoaXMuZSA9PT0gK290aGVyLnM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBzdGFydCBpcyBhZGphY2VudCB0byB0aGUgc3BlY2lmaWVkIEludGVydmFsJ3MgZW5kLlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5hYnV0c0VuZCA9IGZ1bmN0aW9uIGFidXRzRW5kKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gK290aGVyLmUgPT09ICt0aGlzLnM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgZW5ndWxmcyB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgc3BlY2lmaWVkIEludGVydmFsLlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5lbmd1bGZzID0gZnVuY3Rpb24gZW5ndWxmcyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucyA8PSBvdGhlci5zICYmIHRoaXMuZSA+PSBvdGhlci5lO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsIGhhcyB0aGUgc2FtZSBzdGFydCBhbmQgZW5kIGFzIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFvdGhlci5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucy5lcXVhbHMob3RoZXIucykgJiYgdGhpcy5lLmVxdWFscyhvdGhlci5lKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFuIEludGVydmFsIHJlcHJlc2VudGluZyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoaXMgSW50ZXJ2YWwgYW5kIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwuXG4gICAqIFNwZWNpZmljYWxseSwgdGhlIHJlc3VsdGluZyBJbnRlcnZhbCBoYXMgdGhlIG1heGltdW0gc3RhcnQgdGltZSBhbmQgdGhlIG1pbmltdW0gZW5kIHRpbWUgb2YgdGhlIHR3byBJbnRlcnZhbHMuXG4gICAqIFJldHVybnMgbnVsbCBpZiB0aGUgaW50ZXJzZWN0aW9uIGlzIGVtcHR5LCBtZWFuaW5nLCB0aGUgaW50ZXJ2YWxzIGRvbid0IGludGVyc2VjdC5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGludGVyc2VjdGlvbihvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICB2YXIgcyA9IHRoaXMucyA+IG90aGVyLnMgPyB0aGlzLnMgOiBvdGhlci5zLFxuICAgICAgICBlID0gdGhpcy5lIDwgb3RoZXIuZSA/IHRoaXMuZSA6IG90aGVyLmU7XG5cbiAgICBpZiAocyA+IGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzLCBlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhbiBJbnRlcnZhbCByZXByZXNlbnRpbmcgdGhlIHVuaW9uIG9mIHRoaXMgSW50ZXJ2YWwgYW5kIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwuXG4gICAqIFNwZWNpZmljYWxseSwgdGhlIHJlc3VsdGluZyBJbnRlcnZhbCBoYXMgdGhlIG1pbmltdW0gc3RhcnQgdGltZSBhbmQgdGhlIG1heGltdW0gZW5kIHRpbWUgb2YgdGhlIHR3byBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51bmlvbiA9IGZ1bmN0aW9uIHVuaW9uKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHZhciBzID0gdGhpcy5zIDwgb3RoZXIucyA/IHRoaXMucyA6IG90aGVyLnMsXG4gICAgICAgIGUgPSB0aGlzLmUgPiBvdGhlci5lID8gdGhpcy5lIDogb3RoZXIuZTtcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzLCBlKTtcbiAgfVxuICAvKipcbiAgICogTWVyZ2UgYW4gYXJyYXkgb2YgSW50ZXJ2YWxzIGludG8gYSBlcXVpdmFsZW50IG1pbmltYWwgc2V0IG9mIEludGVydmFscy5cbiAgICogQ29tYmluZXMgb3ZlcmxhcHBpbmcgYW5kIGFkamFjZW50IEludGVydmFscy5cbiAgICogQHBhcmFtIHtbSW50ZXJ2YWxdfSBpbnRlcnZhbHNcbiAgICogQHJldHVybiB7W0ludGVydmFsXX1cbiAgICovXG4gIDtcblxuICBJbnRlcnZhbC5tZXJnZSA9IGZ1bmN0aW9uIG1lcmdlKGludGVydmFscykge1xuICAgIHZhciBfaW50ZXJ2YWxzJHNvcnQkcmVkdWMgPSBpbnRlcnZhbHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEucyAtIGIucztcbiAgICB9KS5yZWR1Y2UoZnVuY3Rpb24gKF9yZWYyLCBpdGVtKSB7XG4gICAgICB2YXIgc29mYXIgPSBfcmVmMlswXSxcbiAgICAgICAgICBjdXJyZW50ID0gX3JlZjJbMV07XG5cbiAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICByZXR1cm4gW3NvZmFyLCBpdGVtXTtcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudC5vdmVybGFwcyhpdGVtKSB8fCBjdXJyZW50LmFidXRzU3RhcnQoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuIFtzb2ZhciwgY3VycmVudC51bmlvbihpdGVtKV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW3NvZmFyLmNvbmNhdChbY3VycmVudF0pLCBpdGVtXTtcbiAgICAgIH1cbiAgICB9LCBbW10sIG51bGxdKSxcbiAgICAgICAgZm91bmQgPSBfaW50ZXJ2YWxzJHNvcnQkcmVkdWNbMF0sXG4gICAgICAgIGZpbmFsID0gX2ludGVydmFscyRzb3J0JHJlZHVjWzFdO1xuXG4gICAgaWYgKGZpbmFsKSB7XG4gICAgICBmb3VuZC5wdXNoKGZpbmFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm91bmQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBJbnRlcnZhbHMgcmVwcmVzZW50aW5nIHRoZSBzcGFucyBvZiB0aW1lIHRoYXQgb25seSBhcHBlYXIgaW4gb25lIG9mIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWxzLlxuICAgKiBAcGFyYW0ge1tJbnRlcnZhbF19IGludGVydmFsc1xuICAgKiBAcmV0dXJuIHtbSW50ZXJ2YWxdfVxuICAgKi9cbiAgO1xuXG4gIEludGVydmFsLnhvciA9IGZ1bmN0aW9uIHhvcihpbnRlcnZhbHMpIHtcbiAgICB2YXIgX0FycmF5JHByb3RvdHlwZTtcblxuICAgIHZhciBzdGFydCA9IG51bGwsXG4gICAgICAgIGN1cnJlbnRDb3VudCA9IDA7XG5cbiAgICB2YXIgcmVzdWx0cyA9IFtdLFxuICAgICAgICBlbmRzID0gaW50ZXJ2YWxzLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHRpbWU6IGkucyxcbiAgICAgICAgdHlwZTogXCJzXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdGltZTogaS5lLFxuICAgICAgICB0eXBlOiBcImVcIlxuICAgICAgfV07XG4gICAgfSksXG4gICAgICAgIGZsYXR0ZW5lZCA9IChfQXJyYXkkcHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlKS5jb25jYXQuYXBwbHkoX0FycmF5JHByb3RvdHlwZSwgZW5kcyksXG4gICAgICAgIGFyciA9IGZsYXR0ZW5lZC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS50aW1lIC0gYi50aW1lO1xuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShhcnIpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgdmFyIGkgPSBfc3RlcC52YWx1ZTtcbiAgICAgIGN1cnJlbnRDb3VudCArPSBpLnR5cGUgPT09IFwic1wiID8gMSA6IC0xO1xuXG4gICAgICBpZiAoY3VycmVudENvdW50ID09PSAxKSB7XG4gICAgICAgIHN0YXJ0ID0gaS50aW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0YXJ0ICYmICtzdGFydCAhPT0gK2kudGltZSkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHN0YXJ0LCBpLnRpbWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gSW50ZXJ2YWwubWVyZ2UocmVzdWx0cyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhbiBJbnRlcnZhbCByZXByZXNlbnRpbmcgdGhlIHNwYW4gb2YgdGltZSBpbiB0aGlzIEludGVydmFsIHRoYXQgZG9lc24ndCBvdmVybGFwIHdpdGggYW55IG9mIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWxzLlxuICAgKiBAcGFyYW0gey4uLkludGVydmFsfSBpbnRlcnZhbHNcbiAgICogQHJldHVybiB7W0ludGVydmFsXX1cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uIGRpZmZlcmVuY2UoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGludGVydmFscyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgaW50ZXJ2YWxzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcmV0dXJuIEludGVydmFsLnhvcihbdGhpc10uY29uY2F0KGludGVydmFscykpLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIF90aGlzMi5pbnRlcnNlY3Rpb24oaSk7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gaSAmJiAhaS5pc0VtcHR5KCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBJbnRlcnZhbCBhcHByb3ByaWF0ZSBmb3IgZGVidWdnaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEJDE7XG4gICAgcmV0dXJuIFwiW1wiICsgdGhpcy5zLnRvSVNPKCkgKyBcIiBcXHUyMDEzIFwiICsgdGhpcy5lLnRvSVNPKCkgKyBcIilcIjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgSW50ZXJ2YWwuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZV9pbnRlcnZhbHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgc2FtZSBvcHRpb25zIGFzIHtAbGluayBEYXRlVGltZS50b0lTT31cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b0lTTyA9IGZ1bmN0aW9uIHRvSVNPKG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQkMTtcbiAgICByZXR1cm4gdGhpcy5zLnRvSVNPKG9wdHMpICsgXCIvXCIgKyB0aGlzLmUudG9JU08ob3B0cyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBkYXRlIG9mIHRoaXMgSW50ZXJ2YWwuXG4gICAqIFRoZSB0aW1lIGNvbXBvbmVudHMgYXJlIGlnbm9yZWQuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZV9pbnRlcnZhbHNcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b0lTT0RhdGUgPSBmdW5jdGlvbiB0b0lTT0RhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEJDE7XG4gICAgcmV0dXJuIHRoaXMucy50b0lTT0RhdGUoKSArIFwiL1wiICsgdGhpcy5lLnRvSVNPRGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGltZSBvZiB0aGlzIEludGVydmFsLlxuICAgKiBUaGUgZGF0ZSBjb21wb25lbnRzIGFyZSBpZ25vcmVkLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVfaW50ZXJ2YWxzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIHNhbWUgb3B0aW9ucyBhcyB7QGxpbmsgRGF0ZVRpbWUudG9JU099XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9JU09UaW1lID0gZnVuY3Rpb24gdG9JU09UaW1lKG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQkMTtcbiAgICByZXR1cm4gdGhpcy5zLnRvSVNPVGltZShvcHRzKSArIFwiL1wiICsgdGhpcy5lLnRvSVNPVGltZShvcHRzKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEludGVydmFsIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBmb3JtYXQgc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0ZUZvcm1hdCAtIHRoZSBmb3JtYXQgc3RyaW5nLiBUaGlzIHN0cmluZyBmb3JtYXRzIHRoZSBzdGFydCBhbmQgZW5kIHRpbWUuIFNlZSB7QGxpbmsgRGF0ZVRpbWUudG9Gb3JtYXR9IGZvciBkZXRhaWxzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnNlcGFyYXRvciA9ICAnIOKAkyAnXSAtIGEgc2VwYXJhdG9yIHRvIHBsYWNlIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgcmVwcmVzZW50YXRpb25zXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9Gb3JtYXQgPSBmdW5jdGlvbiB0b0Zvcm1hdChkYXRlRm9ybWF0LCBfdGVtcDIpIHtcbiAgICB2YXIgX3JlZjMgPSBfdGVtcDIgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAyLFxuICAgICAgICBfcmVmMyRzZXBhcmF0b3IgPSBfcmVmMy5zZXBhcmF0b3IsXG4gICAgICAgIHNlcGFyYXRvciA9IF9yZWYzJHNlcGFyYXRvciA9PT0gdm9pZCAwID8gXCIg4oCTIFwiIDogX3JlZjMkc2VwYXJhdG9yO1xuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEJDE7XG4gICAgcmV0dXJuIFwiXCIgKyB0aGlzLnMudG9Gb3JtYXQoZGF0ZUZvcm1hdCkgKyBzZXBhcmF0b3IgKyB0aGlzLmUudG9Gb3JtYXQoZGF0ZUZvcm1hdCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhIER1cmF0aW9uIHJlcHJlc2VudGluZyB0aGUgdGltZSBzcGFubmVkIGJ5IHRoaXMgaW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbdW5pdD1bJ21pbGxpc2Vjb25kcyddXSAtIHRoZSB1bml0IG9yIHVuaXRzIChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byBpbmNsdWRlIGluIHRoZSBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBjcmVhdGlvbiBvZiB0aGUgRHVyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oKS50b09iamVjdCgpIC8vPT4geyBtaWxsaXNlY29uZHM6IDg4NDg5MjU3IH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbignZGF5cycpLnRvT2JqZWN0KCkgLy89PiB7IGRheXM6IDEuMDI0MTgxMjE1Mjc3Nzc3OCB9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oWydob3VycycsICdtaW51dGVzJ10pLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAyNCwgbWludXRlczogMzQuODIwOTUgfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKFsnaG91cnMnLCAnbWludXRlcycsICdzZWNvbmRzJ10pLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAyNCwgbWludXRlczogMzQsIHNlY29uZHM6IDQ5LjI1NyB9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oJ3NlY29uZHMnKS50b09iamVjdCgpIC8vPT4geyBzZWNvbmRzOiA4ODQ4OS4yNTcgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9EdXJhdGlvbiA9IGZ1bmN0aW9uIHRvRHVyYXRpb24odW5pdCwgb3B0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uaW52YWxpZCh0aGlzLmludmFsaWRSZWFzb24pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmUuZGlmZih0aGlzLnMsIHVuaXQsIG9wdHMpO1xuICB9XG4gIC8qKlxuICAgKiBSdW4gbWFwRm4gb24gdGhlIGludGVydmFsIHN0YXJ0IGFuZCBlbmQsIHJldHVybmluZyBhIG5ldyBJbnRlcnZhbCBmcm9tIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWVzXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1hcEZuXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS5tYXBFbmRwb2ludHMoZW5kcG9pbnQgPT4gZW5kcG9pbnQudG9VVEMoKSlcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikubWFwRW5kcG9pbnRzKGVuZHBvaW50ID0+IGVuZHBvaW50LnBsdXMoeyBob3VyczogMiB9KSlcbiAgICovXG4gIDtcblxuICBfcHJvdG8ubWFwRW5kcG9pbnRzID0gZnVuY3Rpb24gbWFwRW5kcG9pbnRzKG1hcEZuKSB7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMobWFwRm4odGhpcy5zKSwgbWFwRm4odGhpcy5lKSk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKEludGVydmFsLCBbe1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMucyA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGVuZCBvZiB0aGUgSW50ZXJ2YWxcbiAgICAgKiBAdHlwZSB7RGF0ZVRpbWV9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmUgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIGVuZCBpcyBhdCBsZWFzdCBpdHMgc3RhcnQsIG1lYW5pbmcgdGhhdCB0aGUgSW50ZXJ2YWwgaXNuJ3QgJ2JhY2t3YXJkcycuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc1ZhbGlkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnZhbGlkUmVhc29uID09PSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGVycm9yIGNvZGUgaWYgdGhpcyBJbnRlcnZhbCBpcyBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBJbnRlcnZhbCBpcyB2YWxpZFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpbnZhbGlkUmVhc29uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLnJlYXNvbiA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gZXhwbGFuYXRpb24gb2Ygd2h5IHRoaXMgSW50ZXJ2YWwgYmVjYW1lIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIEludGVydmFsIGlzIHZhbGlkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImludmFsaWRFeHBsYW5hdGlvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5leHBsYW5hdGlvbiA6IG51bGw7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEludGVydmFsO1xufSgpO1xuXG4vKipcbiAqIFRoZSBJbmZvIGNsYXNzIGNvbnRhaW5zIHN0YXRpYyBtZXRob2RzIGZvciByZXRyaWV2aW5nIGdlbmVyYWwgdGltZSBhbmQgZGF0ZSByZWxhdGVkIGRhdGEuIEZvciBleGFtcGxlLCBpdCBoYXMgbWV0aG9kcyBmb3IgZmluZGluZyBvdXQgaWYgYSB0aW1lIHpvbmUgaGFzIGEgRFNULCBmb3IgbGlzdGluZyB0aGUgbW9udGhzIGluIGFueSBzdXBwb3J0ZWQgbG9jYWxlLCBhbmQgZm9yIGRpc2NvdmVyaW5nIHdoaWNoIG9mIEx1eG9uIGZlYXR1cmVzIGFyZSBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuXG4gKi9cblxudmFyIEluZm8gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbmZvKCkge31cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhlIHNwZWNpZmllZCB6b25lIGNvbnRhaW5zIGEgRFNULlxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbem9uZT0nbG9jYWwnXSAtIFpvbmUgdG8gY2hlY2suIERlZmF1bHRzIHRvIHRoZSBlbnZpcm9ubWVudCdzIGxvY2FsIHpvbmUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBJbmZvLmhhc0RTVCA9IGZ1bmN0aW9uIGhhc0RTVCh6b25lKSB7XG4gICAgaWYgKHpvbmUgPT09IHZvaWQgMCkge1xuICAgICAgem9uZSA9IFNldHRpbmdzLmRlZmF1bHRab25lO1xuICAgIH1cblxuICAgIHZhciBwcm90byA9IERhdGVUaW1lLmxvY2FsKCkuc2V0Wm9uZSh6b25lKS5zZXQoe1xuICAgICAgbW9udGg6IDEyXG4gICAgfSk7XG4gICAgcmV0dXJuICF6b25lLnVuaXZlcnNhbCAmJiBwcm90by5vZmZzZXQgIT09IHByb3RvLnNldCh7XG4gICAgICBtb250aDogNlxuICAgIH0pLm9mZnNldDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhlIHNwZWNpZmllZCB6b25lIGlzIGEgdmFsaWQgSUFOQSBzcGVjaWZpZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6b25lIC0gWm9uZSB0byBjaGVja1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgO1xuXG4gIEluZm8uaXNWYWxpZElBTkFab25lID0gZnVuY3Rpb24gaXNWYWxpZElBTkFab25lKHpvbmUpIHtcbiAgICByZXR1cm4gSUFOQVpvbmUuaXNWYWxpZFNwZWNpZmllcih6b25lKSAmJiBJQU5BWm9uZS5pc1ZhbGlkWm9uZSh6b25lKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGlucHV0IGludG8gYSB7QGxpbmsgWm9uZX0gaW5zdGFuY2UuXG4gICAqXG4gICAqICogSWYgYGlucHV0YCBpcyBhbHJlYWR5IGEgWm9uZSBpbnN0YW5jZSwgaXQgaXMgcmV0dXJuZWQgdW5jaGFuZ2VkLlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYSBzdHJpbmcgY29udGFpbmluZyBhIHZhbGlkIHRpbWUgem9uZSBuYW1lLCBhIFpvbmUgaW5zdGFuY2VcbiAgICogICB3aXRoIHRoYXQgbmFtZSBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXRgIGlzIGEgc3RyaW5nIHRoYXQgZG9lc24ndCByZWZlciB0byBhIGtub3duIHRpbWUgem9uZSwgYSBab25lXG4gICAqICAgaW5zdGFuY2Ugd2l0aCB7QGxpbmsgWm9uZS5pc1ZhbGlkfSA9PSBmYWxzZSBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXQgaXMgYSBudW1iZXIsIGEgWm9uZSBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgZml4ZWQgb2Zmc2V0XG4gICAqICAgaW4gbWludXRlcyBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXRgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYCwgdGhlIGRlZmF1bHQgem9uZSBpcyByZXR1cm5lZC5cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZXxudW1iZXJ9IFtpbnB1dF0gLSB0aGUgdmFsdWUgdG8gYmUgY29udmVydGVkXG4gICAqIEByZXR1cm4ge1pvbmV9XG4gICAqL1xuICA7XG5cbiAgSW5mby5ub3JtYWxpemVab25lID0gZnVuY3Rpb24gbm9ybWFsaXplWm9uZSQxKGlucHV0KSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVpvbmUoaW5wdXQsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIHN0YW5kYWxvbmUgbW9udGggbmFtZXMuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIG1vbnRoIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibnVtZXJpY1wiLCBcIjItZGlnaXRcIiwgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbT1udWxsXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5vdXRwdXRDYWxlbmRhcj0nZ3JlZ29yeSddIC0gdGhlIGNhbGVuZGFyXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKClbMF0gLy89PiAnSmFudWFyeSdcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ3Nob3J0JylbMF0gLy89PiAnSmFuJ1xuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygnbnVtZXJpYycpWzBdIC8vPT4gJzEnXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdzaG9ydCcsIHsgbG9jYWxlOiAnZnItQ0EnIH0gKVswXSAvLz0+ICdqYW52LidcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ251bWVyaWMnLCB7IGxvY2FsZTogJ2FyJyB9KVswXSAvLz0+ICfZoSdcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ2xvbmcnLCB7IG91dHB1dENhbGVuZGFyOiAnaXNsYW1pYycgfSlbMF0gLy89PiAnUmFiacq7IEknXG4gICAqIEByZXR1cm4ge1tzdHJpbmddfVxuICAgKi9cbiAgO1xuXG4gIEluZm8ubW9udGhzID0gZnVuY3Rpb24gbW9udGhzKGxlbmd0aCwgX3RlbXApIHtcbiAgICBpZiAobGVuZ3RoID09PSB2b2lkIDApIHtcbiAgICAgIGxlbmd0aCA9IFwibG9uZ1wiO1xuICAgIH1cblxuICAgIHZhciBfcmVmID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICAgIF9yZWYkbG9jYWxlID0gX3JlZi5sb2NhbGUsXG4gICAgICAgIGxvY2FsZSA9IF9yZWYkbG9jYWxlID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRsb2NhbGUsXG4gICAgICAgIF9yZWYkbnVtYmVyaW5nU3lzdGVtID0gX3JlZi5udW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSA9IF9yZWYkbnVtYmVyaW5nU3lzdGVtID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRudW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIF9yZWYkb3V0cHV0Q2FsZW5kYXIgPSBfcmVmLm91dHB1dENhbGVuZGFyLFxuICAgICAgICBvdXRwdXRDYWxlbmRhciA9IF9yZWYkb3V0cHV0Q2FsZW5kYXIgPT09IHZvaWQgMCA/IFwiZ3JlZ29yeVwiIDogX3JlZiRvdXRwdXRDYWxlbmRhcjtcblxuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcikubW9udGhzKGxlbmd0aCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBmb3JtYXQgbW9udGggbmFtZXMuXG4gICAqIEZvcm1hdCBtb250aHMgZGlmZmVyIGZyb20gc3RhbmRhbG9uZSBtb250aHMgaW4gdGhhdCB0aGV5J3JlIG1lYW50IHRvIGFwcGVhciBuZXh0IHRvIHRoZSBkYXkgb2YgdGhlIG1vbnRoLiBJbiBzb21lIGxhbmd1YWdlcywgdGhhdFxuICAgKiBjaGFuZ2VzIHRoZSBzdHJpbmcuXG4gICAqIFNlZSB7QGxpbmsgbW9udGhzfVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nbG9uZyddIC0gdGhlIGxlbmd0aCBvZiB0aGUgbW9udGggcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJudW1lcmljXCIsIFwiMi1kaWdpdFwiLCBcIm5hcnJvd1wiLCBcInNob3J0XCIsIFwibG9uZ1wiXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtPW51bGxdIC0gdGhlIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm91dHB1dENhbGVuZGFyPSdncmVnb3J5J10gLSB0aGUgY2FsZW5kYXJcbiAgICogQHJldHVybiB7W3N0cmluZ119XG4gICAqL1xuICA7XG5cbiAgSW5mby5tb250aHNGb3JtYXQgPSBmdW5jdGlvbiBtb250aHNGb3JtYXQobGVuZ3RoLCBfdGVtcDIpIHtcbiAgICBpZiAobGVuZ3RoID09PSB2b2lkIDApIHtcbiAgICAgIGxlbmd0aCA9IFwibG9uZ1wiO1xuICAgIH1cblxuICAgIHZhciBfcmVmMiA9IF90ZW1wMiA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDIsXG4gICAgICAgIF9yZWYyJGxvY2FsZSA9IF9yZWYyLmxvY2FsZSxcbiAgICAgICAgbG9jYWxlID0gX3JlZjIkbG9jYWxlID09PSB2b2lkIDAgPyBudWxsIDogX3JlZjIkbG9jYWxlLFxuICAgICAgICBfcmVmMiRudW1iZXJpbmdTeXN0ZW0gPSBfcmVmMi5udW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSA9IF9yZWYyJG51bWJlcmluZ1N5c3RlbSA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYyJG51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgX3JlZjIkb3V0cHV0Q2FsZW5kYXIgPSBfcmVmMi5vdXRwdXRDYWxlbmRhcixcbiAgICAgICAgb3V0cHV0Q2FsZW5kYXIgPSBfcmVmMiRvdXRwdXRDYWxlbmRhciA9PT0gdm9pZCAwID8gXCJncmVnb3J5XCIgOiBfcmVmMiRvdXRwdXRDYWxlbmRhcjtcblxuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcikubW9udGhzKGxlbmd0aCwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBzdGFuZGFsb25lIHdlZWsgbmFtZXMuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIHdlZWtkYXkgcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW09bnVsbF0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAZXhhbXBsZSBJbmZvLndlZWtkYXlzKClbMF0gLy89PiAnTW9uZGF5J1xuICAgKiBAZXhhbXBsZSBJbmZvLndlZWtkYXlzKCdzaG9ydCcpWzBdIC8vPT4gJ01vbidcbiAgICogQGV4YW1wbGUgSW5mby53ZWVrZGF5cygnc2hvcnQnLCB7IGxvY2FsZTogJ2ZyLUNBJyB9KVswXSAvLz0+ICdsdW4uJ1xuICAgKiBAZXhhbXBsZSBJbmZvLndlZWtkYXlzKCdzaG9ydCcsIHsgbG9jYWxlOiAnYXInIH0pWzBdIC8vPT4gJ9in2YTYp9ir2YbZitmGJ1xuICAgKiBAcmV0dXJuIHtbc3RyaW5nXX1cbiAgICovXG4gIDtcblxuICBJbmZvLndlZWtkYXlzID0gZnVuY3Rpb24gd2Vla2RheXMobGVuZ3RoLCBfdGVtcDMpIHtcbiAgICBpZiAobGVuZ3RoID09PSB2b2lkIDApIHtcbiAgICAgIGxlbmd0aCA9IFwibG9uZ1wiO1xuICAgIH1cblxuICAgIHZhciBfcmVmMyA9IF90ZW1wMyA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDMsXG4gICAgICAgIF9yZWYzJGxvY2FsZSA9IF9yZWYzLmxvY2FsZSxcbiAgICAgICAgbG9jYWxlID0gX3JlZjMkbG9jYWxlID09PSB2b2lkIDAgPyBudWxsIDogX3JlZjMkbG9jYWxlLFxuICAgICAgICBfcmVmMyRudW1iZXJpbmdTeXN0ZW0gPSBfcmVmMy5udW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSA9IF9yZWYzJG51bWJlcmluZ1N5c3RlbSA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYzJG51bWJlcmluZ1N5c3RlbTtcblxuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBudWxsKS53ZWVrZGF5cyhsZW5ndGgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgZm9ybWF0IHdlZWsgbmFtZXMuXG4gICAqIEZvcm1hdCB3ZWVrZGF5cyBkaWZmZXIgZnJvbSBzdGFuZGFsb25lIHdlZWtkYXlzIGluIHRoYXQgdGhleSdyZSBtZWFudCB0byBhcHBlYXIgbmV4dCB0byBtb3JlIGRhdGUgaW5mb3JtYXRpb24uIEluIHNvbWUgbGFuZ3VhZ2VzLCB0aGF0XG4gICAqIGNoYW5nZXMgdGhlIHN0cmluZy5cbiAgICogU2VlIHtAbGluayB3ZWVrZGF5c31cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIHdlZWtkYXkgcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9bnVsbF0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbT1udWxsXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEByZXR1cm4ge1tzdHJpbmddfVxuICAgKi9cbiAgO1xuXG4gIEluZm8ud2Vla2RheXNGb3JtYXQgPSBmdW5jdGlvbiB3ZWVrZGF5c0Zvcm1hdChsZW5ndGgsIF90ZW1wNCkge1xuICAgIGlmIChsZW5ndGggPT09IHZvaWQgMCkge1xuICAgICAgbGVuZ3RoID0gXCJsb25nXCI7XG4gICAgfVxuXG4gICAgdmFyIF9yZWY0ID0gX3RlbXA0ID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wNCxcbiAgICAgICAgX3JlZjQkbG9jYWxlID0gX3JlZjQubG9jYWxlLFxuICAgICAgICBsb2NhbGUgPSBfcmVmNCRsb2NhbGUgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmNCRsb2NhbGUsXG4gICAgICAgIF9yZWY0JG51bWJlcmluZ1N5c3RlbSA9IF9yZWY0Lm51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgbnVtYmVyaW5nU3lzdGVtID0gX3JlZjQkbnVtYmVyaW5nU3lzdGVtID09PSB2b2lkIDAgPyBudWxsIDogX3JlZjQkbnVtYmVyaW5nU3lzdGVtO1xuXG4gICAgcmV0dXJuIExvY2FsZS5jcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG51bGwpLndlZWtkYXlzKGxlbmd0aCwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBtZXJpZGllbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAZXhhbXBsZSBJbmZvLm1lcmlkaWVtcygpIC8vPT4gWyAnQU0nLCAnUE0nIF1cbiAgICogQGV4YW1wbGUgSW5mby5tZXJpZGllbXMoeyBsb2NhbGU6ICdteScgfSkgLy89PiBbICfhgJThgLbhgJThgIDhgLonLCAn4YCK4YCU4YCxJyBdXG4gICAqIEByZXR1cm4ge1tzdHJpbmddfVxuICAgKi9cbiAgO1xuXG4gIEluZm8ubWVyaWRpZW1zID0gZnVuY3Rpb24gbWVyaWRpZW1zKF90ZW1wNSkge1xuICAgIHZhciBfcmVmNSA9IF90ZW1wNSA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDUsXG4gICAgICAgIF9yZWY1JGxvY2FsZSA9IF9yZWY1LmxvY2FsZSxcbiAgICAgICAgbG9jYWxlID0gX3JlZjUkbG9jYWxlID09PSB2b2lkIDAgPyBudWxsIDogX3JlZjUkbG9jYWxlO1xuXG4gICAgcmV0dXJuIExvY2FsZS5jcmVhdGUobG9jYWxlKS5tZXJpZGllbXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIGVyYXMsIHN1Y2ggYXMgWydCQycsICdBRCddLiBUaGUgbG9jYWxlIGNhbiBiZSBzcGVjaWZpZWQsIGJ1dCB0aGUgY2FsZW5kYXIgc3lzdGVtIGlzIGFsd2F5cyBHcmVnb3JpYW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdzaG9ydCddIC0gdGhlIGxlbmd0aCBvZiB0aGUgZXJhIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwic2hvcnRcIiBvciBcImxvbmdcIi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBleGFtcGxlIEluZm8uZXJhcygpIC8vPT4gWyAnQkMnLCAnQUQnIF1cbiAgICogQGV4YW1wbGUgSW5mby5lcmFzKCdsb25nJykgLy89PiBbICdCZWZvcmUgQ2hyaXN0JywgJ0Fubm8gRG9taW5pJyBdXG4gICAqIEBleGFtcGxlIEluZm8uZXJhcygnbG9uZycsIHsgbG9jYWxlOiAnZnInIH0pIC8vPT4gWyAnYXZhbnQgSsOpc3VzLUNocmlzdCcsICdhcHLDqHMgSsOpc3VzLUNocmlzdCcgXVxuICAgKiBAcmV0dXJuIHtbc3RyaW5nXX1cbiAgICovXG4gIDtcblxuICBJbmZvLmVyYXMgPSBmdW5jdGlvbiBlcmFzKGxlbmd0aCwgX3RlbXA2KSB7XG4gICAgaWYgKGxlbmd0aCA9PT0gdm9pZCAwKSB7XG4gICAgICBsZW5ndGggPSBcInNob3J0XCI7XG4gICAgfVxuXG4gICAgdmFyIF9yZWY2ID0gX3RlbXA2ID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wNixcbiAgICAgICAgX3JlZjYkbG9jYWxlID0gX3JlZjYubG9jYWxlLFxuICAgICAgICBsb2NhbGUgPSBfcmVmNiRsb2NhbGUgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmNiRsb2NhbGU7XG5cbiAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bGwsIFwiZ3JlZ29yeVwiKS5lcmFzKGxlbmd0aCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc2V0IG9mIGF2YWlsYWJsZSBmZWF0dXJlcyBpbiB0aGlzIGVudmlyb25tZW50LlxuICAgKiBTb21lIGZlYXR1cmVzIG9mIEx1eG9uIGFyZSBub3QgYXZhaWxhYmxlIGluIGFsbCBlbnZpcm9ubWVudHMuIEZvciBleGFtcGxlLCBvbiBvbGRlciBicm93c2VycywgdGltZXpvbmUgc3VwcG9ydCBpcyBub3QgYXZhaWxhYmxlLiBVc2UgdGhpcyBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IGlmIHRoYXQncyB0aGUgY2FzZS5cbiAgICogS2V5czpcbiAgICogKiBgem9uZXNgOiB3aGV0aGVyIHRoaXMgZW52aXJvbm1lbnQgc3VwcG9ydHMgSUFOQSB0aW1lem9uZXNcbiAgICogKiBgaW50bFRva2Vuc2A6IHdoZXRoZXIgdGhpcyBlbnZpcm9ubWVudCBzdXBwb3J0cyBpbnRlcm5hdGlvbmFsaXplZCB0b2tlbi1iYXNlZCBmb3JtYXR0aW5nL3BhcnNpbmdcbiAgICogKiBgaW50bGA6IHdoZXRoZXIgdGhpcyBlbnZpcm9ubWVudCBzdXBwb3J0cyBnZW5lcmFsIGludGVybmF0aW9uYWxpemF0aW9uXG4gICAqICogYHJlbGF0aXZlYDogd2hldGhlciB0aGlzIGVudmlyb25tZW50IHN1cHBvcnRzIHJlbGF0aXZlIHRpbWUgZm9ybWF0dGluZ1xuICAgKiBAZXhhbXBsZSBJbmZvLmZlYXR1cmVzKCkgLy89PiB7IGludGw6IHRydWUsIGludGxUb2tlbnM6IGZhbHNlLCB6b25lczogdHJ1ZSwgcmVsYXRpdmU6IGZhbHNlIH1cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgO1xuXG4gIEluZm8uZmVhdHVyZXMgPSBmdW5jdGlvbiBmZWF0dXJlcygpIHtcbiAgICB2YXIgaW50bCA9IGZhbHNlLFxuICAgICAgICBpbnRsVG9rZW5zID0gZmFsc2UsXG4gICAgICAgIHpvbmVzID0gZmFsc2UsXG4gICAgICAgIHJlbGF0aXZlID0gZmFsc2U7XG5cbiAgICBpZiAoaGFzSW50bCgpKSB7XG4gICAgICBpbnRsID0gdHJ1ZTtcbiAgICAgIGludGxUb2tlbnMgPSBoYXNGb3JtYXRUb1BhcnRzKCk7XG4gICAgICByZWxhdGl2ZSA9IGhhc1JlbGF0aXZlKCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHpvbmVzID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoXCJlblwiLCB7XG4gICAgICAgICAgdGltZVpvbmU6IFwiQW1lcmljYS9OZXdfWW9ya1wiXG4gICAgICAgIH0pLnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lID09PSBcIkFtZXJpY2EvTmV3X1lvcmtcIjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgem9uZXMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaW50bDogaW50bCxcbiAgICAgIGludGxUb2tlbnM6IGludGxUb2tlbnMsXG4gICAgICB6b25lczogem9uZXMsXG4gICAgICByZWxhdGl2ZTogcmVsYXRpdmVcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBJbmZvO1xufSgpO1xuXG5mdW5jdGlvbiBkYXlEaWZmKGVhcmxpZXIsIGxhdGVyKSB7XG4gIHZhciB1dGNEYXlTdGFydCA9IGZ1bmN0aW9uIHV0Y0RheVN0YXJ0KGR0KSB7XG4gICAgcmV0dXJuIGR0LnRvVVRDKDAsIHtcbiAgICAgIGtlZXBMb2NhbFRpbWU6IHRydWVcbiAgICB9KS5zdGFydE9mKFwiZGF5XCIpLnZhbHVlT2YoKTtcbiAgfSxcbiAgICAgIG1zID0gdXRjRGF5U3RhcnQobGF0ZXIpIC0gdXRjRGF5U3RhcnQoZWFybGllcik7XG5cbiAgcmV0dXJuIE1hdGguZmxvb3IoRHVyYXRpb24uZnJvbU1pbGxpcyhtcykuYXMoXCJkYXlzXCIpKTtcbn1cblxuZnVuY3Rpb24gaGlnaE9yZGVyRGlmZnMoY3Vyc29yLCBsYXRlciwgdW5pdHMpIHtcbiAgdmFyIGRpZmZlcnMgPSBbW1wieWVhcnNcIiwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi55ZWFyIC0gYS55ZWFyO1xuICB9XSwgW1wibW9udGhzXCIsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIubW9udGggLSBhLm1vbnRoICsgKGIueWVhciAtIGEueWVhcikgKiAxMjtcbiAgfV0sIFtcIndlZWtzXCIsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGRheXMgPSBkYXlEaWZmKGEsIGIpO1xuICAgIHJldHVybiAoZGF5cyAtIGRheXMgJSA3KSAvIDc7XG4gIH1dLCBbXCJkYXlzXCIsIGRheURpZmZdXTtcbiAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgdmFyIGxvd2VzdE9yZGVyLCBoaWdoV2F0ZXI7XG5cbiAgZm9yICh2YXIgX2kgPSAwLCBfZGlmZmVycyA9IGRpZmZlcnM7IF9pIDwgX2RpZmZlcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIF9kaWZmZXJzJF9pID0gX2RpZmZlcnNbX2ldLFxuICAgICAgICB1bml0ID0gX2RpZmZlcnMkX2lbMF0sXG4gICAgICAgIGRpZmZlciA9IF9kaWZmZXJzJF9pWzFdO1xuXG4gICAgaWYgKHVuaXRzLmluZGV4T2YodW5pdCkgPj0gMCkge1xuICAgICAgdmFyIF9jdXJzb3IkcGx1cztcblxuICAgICAgbG93ZXN0T3JkZXIgPSB1bml0O1xuICAgICAgdmFyIGRlbHRhID0gZGlmZmVyKGN1cnNvciwgbGF0ZXIpO1xuICAgICAgaGlnaFdhdGVyID0gY3Vyc29yLnBsdXMoKF9jdXJzb3IkcGx1cyA9IHt9LCBfY3Vyc29yJHBsdXNbdW5pdF0gPSBkZWx0YSwgX2N1cnNvciRwbHVzKSk7XG5cbiAgICAgIGlmIChoaWdoV2F0ZXIgPiBsYXRlcikge1xuICAgICAgICB2YXIgX2N1cnNvciRwbHVzMjtcblxuICAgICAgICBjdXJzb3IgPSBjdXJzb3IucGx1cygoX2N1cnNvciRwbHVzMiA9IHt9LCBfY3Vyc29yJHBsdXMyW3VuaXRdID0gZGVsdGEgLSAxLCBfY3Vyc29yJHBsdXMyKSk7XG4gICAgICAgIGRlbHRhIC09IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJzb3IgPSBoaWdoV2F0ZXI7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdHNbdW5pdF0gPSBkZWx0YTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW2N1cnNvciwgcmVzdWx0cywgaGlnaFdhdGVyLCBsb3dlc3RPcmRlcl07XG59XG5cbmZ1bmN0aW9uIF9kaWZmIChlYXJsaWVyLCBsYXRlciwgdW5pdHMsIG9wdHMpIHtcbiAgdmFyIF9oaWdoT3JkZXJEaWZmcyA9IGhpZ2hPcmRlckRpZmZzKGVhcmxpZXIsIGxhdGVyLCB1bml0cyksXG4gICAgICBjdXJzb3IgPSBfaGlnaE9yZGVyRGlmZnNbMF0sXG4gICAgICByZXN1bHRzID0gX2hpZ2hPcmRlckRpZmZzWzFdLFxuICAgICAgaGlnaFdhdGVyID0gX2hpZ2hPcmRlckRpZmZzWzJdLFxuICAgICAgbG93ZXN0T3JkZXIgPSBfaGlnaE9yZGVyRGlmZnNbM107XG5cbiAgdmFyIHJlbWFpbmluZ01pbGxpcyA9IGxhdGVyIC0gY3Vyc29yO1xuICB2YXIgbG93ZXJPcmRlclVuaXRzID0gdW5pdHMuZmlsdGVyKGZ1bmN0aW9uICh1KSB7XG4gICAgcmV0dXJuIFtcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIiwgXCJtaWxsaXNlY29uZHNcIl0uaW5kZXhPZih1KSA+PSAwO1xuICB9KTtcblxuICBpZiAobG93ZXJPcmRlclVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChoaWdoV2F0ZXIgPCBsYXRlcikge1xuICAgICAgdmFyIF9jdXJzb3IkcGx1czM7XG5cbiAgICAgIGhpZ2hXYXRlciA9IGN1cnNvci5wbHVzKChfY3Vyc29yJHBsdXMzID0ge30sIF9jdXJzb3IkcGx1czNbbG93ZXN0T3JkZXJdID0gMSwgX2N1cnNvciRwbHVzMykpO1xuICAgIH1cblxuICAgIGlmIChoaWdoV2F0ZXIgIT09IGN1cnNvcikge1xuICAgICAgcmVzdWx0c1tsb3dlc3RPcmRlcl0gPSAocmVzdWx0c1tsb3dlc3RPcmRlcl0gfHwgMCkgKyByZW1haW5pbmdNaWxsaXMgLyAoaGlnaFdhdGVyIC0gY3Vyc29yKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZHVyYXRpb24gPSBEdXJhdGlvbi5mcm9tT2JqZWN0KE9iamVjdC5hc3NpZ24ocmVzdWx0cywgb3B0cykpO1xuXG4gIGlmIChsb3dlck9yZGVyVW5pdHMubGVuZ3RoID4gMCkge1xuICAgIHZhciBfRHVyYXRpb24kZnJvbU1pbGxpcztcblxuICAgIHJldHVybiAoX0R1cmF0aW9uJGZyb21NaWxsaXMgPSBEdXJhdGlvbi5mcm9tTWlsbGlzKHJlbWFpbmluZ01pbGxpcywgb3B0cykpLnNoaWZ0VG8uYXBwbHkoX0R1cmF0aW9uJGZyb21NaWxsaXMsIGxvd2VyT3JkZXJVbml0cykucGx1cyhkdXJhdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGR1cmF0aW9uO1xuICB9XG59XG5cbnZhciBudW1iZXJpbmdTeXN0ZW1zID0ge1xuICBhcmFiOiBcIltcXHUwNjYwLVxcdTA2NjldXCIsXG4gIGFyYWJleHQ6IFwiW1xcdTA2RjAtXFx1MDZGOV1cIixcbiAgYmFsaTogXCJbXFx1MUI1MC1cXHUxQjU5XVwiLFxuICBiZW5nOiBcIltcXHUwOUU2LVxcdTA5RUZdXCIsXG4gIGRldmE6IFwiW1xcdTA5NjYtXFx1MDk2Rl1cIixcbiAgZnVsbHdpZGU6IFwiW1xcdUZGMTAtXFx1RkYxOV1cIixcbiAgZ3VqcjogXCJbXFx1MEFFNi1cXHUwQUVGXVwiLFxuICBoYW5pZGVjOiBcIlvjgId85LiAfOS6jHzkuIl85ZubfOS6lHzlha185LiDfOWFq3zkuZ1dXCIsXG4gIGtobXI6IFwiW1xcdTE3RTAtXFx1MTdFOV1cIixcbiAga25kYTogXCJbXFx1MENFNi1cXHUwQ0VGXVwiLFxuICBsYW9vOiBcIltcXHUwRUQwLVxcdTBFRDldXCIsXG4gIGxpbWI6IFwiW1xcdTE5NDYtXFx1MTk0Rl1cIixcbiAgbWx5bTogXCJbXFx1MEQ2Ni1cXHUwRDZGXVwiLFxuICBtb25nOiBcIltcXHUxODEwLVxcdTE4MTldXCIsXG4gIG15bXI6IFwiW1xcdTEwNDAtXFx1MTA0OV1cIixcbiAgb3J5YTogXCJbXFx1MEI2Ni1cXHUwQjZGXVwiLFxuICB0YW1sZGVjOiBcIltcXHUwQkU2LVxcdTBCRUZdXCIsXG4gIHRlbHU6IFwiW1xcdTBDNjYtXFx1MEM2Rl1cIixcbiAgdGhhaTogXCJbXFx1MEU1MC1cXHUwRTU5XVwiLFxuICB0aWJ0OiBcIltcXHUwRjIwLVxcdTBGMjldXCIsXG4gIGxhdG46IFwiXFxcXGRcIlxufTtcbnZhciBudW1iZXJpbmdTeXN0ZW1zVVRGMTYgPSB7XG4gIGFyYWI6IFsxNjMyLCAxNjQxXSxcbiAgYXJhYmV4dDogWzE3NzYsIDE3ODVdLFxuICBiYWxpOiBbNjk5MiwgNzAwMV0sXG4gIGJlbmc6IFsyNTM0LCAyNTQzXSxcbiAgZGV2YTogWzI0MDYsIDI0MTVdLFxuICBmdWxsd2lkZTogWzY1Mjk2LCA2NTMwM10sXG4gIGd1anI6IFsyNzkwLCAyNzk5XSxcbiAga2htcjogWzYxMTIsIDYxMjFdLFxuICBrbmRhOiBbMzMwMiwgMzMxMV0sXG4gIGxhb286IFszNzkyLCAzODAxXSxcbiAgbGltYjogWzY0NzAsIDY0NzldLFxuICBtbHltOiBbMzQzMCwgMzQzOV0sXG4gIG1vbmc6IFs2MTYwLCA2MTY5XSxcbiAgbXltcjogWzQxNjAsIDQxNjldLFxuICBvcnlhOiBbMjkxOCwgMjkyN10sXG4gIHRhbWxkZWM6IFszMDQ2LCAzMDU1XSxcbiAgdGVsdTogWzMxNzQsIDMxODNdLFxuICB0aGFpOiBbMzY2NCwgMzY3M10sXG4gIHRpYnQ6IFszODcyLCAzODgxXVxufTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbnZhciBoYW5pZGVjQ2hhcnMgPSBudW1iZXJpbmdTeXN0ZW1zLmhhbmlkZWMucmVwbGFjZSgvW1xcW3xcXF1dL2csIFwiXCIpLnNwbGl0KFwiXCIpO1xuZnVuY3Rpb24gcGFyc2VEaWdpdHMoc3RyKSB7XG4gIHZhciB2YWx1ZSA9IHBhcnNlSW50KHN0ciwgMTApO1xuXG4gIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IFwiXCI7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgICAgaWYgKHN0cltpXS5zZWFyY2gobnVtYmVyaW5nU3lzdGVtcy5oYW5pZGVjKSAhPT0gLTEpIHtcbiAgICAgICAgdmFsdWUgKz0gaGFuaWRlY0NoYXJzLmluZGV4T2Yoc3RyW2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBudW1iZXJpbmdTeXN0ZW1zVVRGMTYpIHtcbiAgICAgICAgICB2YXIgX251bWJlcmluZ1N5c3RlbXNVVEYgPSBudW1iZXJpbmdTeXN0ZW1zVVRGMTZba2V5XSxcbiAgICAgICAgICAgICAgbWluID0gX251bWJlcmluZ1N5c3RlbXNVVEZbMF0sXG4gICAgICAgICAgICAgIG1heCA9IF9udW1iZXJpbmdTeXN0ZW1zVVRGWzFdO1xuXG4gICAgICAgICAgaWYgKGNvZGUgPj0gbWluICYmIGNvZGUgPD0gbWF4KSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBjb2RlIC0gbWluO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gZGlnaXRSZWdleChfcmVmLCBhcHBlbmQpIHtcbiAgdmFyIG51bWJlcmluZ1N5c3RlbSA9IF9yZWYubnVtYmVyaW5nU3lzdGVtO1xuXG4gIGlmIChhcHBlbmQgPT09IHZvaWQgMCkge1xuICAgIGFwcGVuZCA9IFwiXCI7XG4gIH1cblxuICByZXR1cm4gbmV3IFJlZ0V4cChcIlwiICsgbnVtYmVyaW5nU3lzdGVtc1tudW1iZXJpbmdTeXN0ZW0gfHwgXCJsYXRuXCJdICsgYXBwZW5kKTtcbn1cblxudmFyIE1JU1NJTkdfRlRQID0gXCJtaXNzaW5nIEludGwuRGF0ZVRpbWVGb3JtYXQuZm9ybWF0VG9QYXJ0cyBzdXBwb3J0XCI7XG5cbmZ1bmN0aW9uIGludFVuaXQocmVnZXgsIHBvc3QpIHtcbiAgaWYgKHBvc3QgPT09IHZvaWQgMCkge1xuICAgIHBvc3QgPSBmdW5jdGlvbiBwb3N0KGkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlZ2V4OiByZWdleCxcbiAgICBkZXNlcjogZnVuY3Rpb24gZGVzZXIoX3JlZikge1xuICAgICAgdmFyIHMgPSBfcmVmWzBdO1xuICAgICAgcmV0dXJuIHBvc3QocGFyc2VEaWdpdHMocykpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIE5CU1AgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDE2MCk7XG52YXIgc3BhY2VPck5CU1AgPSBcIiggfFwiICsgTkJTUCArIFwiKVwiO1xudmFyIHNwYWNlT3JOQlNQUmVnRXhwID0gbmV3IFJlZ0V4cChzcGFjZU9yTkJTUCwgXCJnXCIpO1xuXG5mdW5jdGlvbiBmaXhMaXN0UmVnZXgocykge1xuICAvLyBtYWtlIGRvdHMgb3B0aW9uYWwgYW5kIGFsc28gbWFrZSB0aGVtIGxpdGVyYWxcbiAgLy8gbWFrZSBzcGFjZSBhbmQgbm9uIGJyZWFrYWJsZSBzcGFjZSBjaGFyYWN0ZXJzIGludGVyY2hhbmdlYWJsZVxuICByZXR1cm4gcy5yZXBsYWNlKC9cXC4vZywgXCJcXFxcLj9cIikucmVwbGFjZShzcGFjZU9yTkJTUFJlZ0V4cCwgc3BhY2VPck5CU1ApO1xufVxuXG5mdW5jdGlvbiBzdHJpcEluc2Vuc2l0aXZpdGllcyhzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1xcLi9nLCBcIlwiKSAvLyBpZ25vcmUgZG90cyB0aGF0IHdlcmUgbWFkZSBvcHRpb25hbFxuICAucmVwbGFjZShzcGFjZU9yTkJTUFJlZ0V4cCwgXCIgXCIpIC8vIGludGVyY2hhbmdlIHNwYWNlIGFuZCBuYnNwXG4gIC50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBvbmVPZihzdHJpbmdzLCBzdGFydEluZGV4KSB7XG4gIGlmIChzdHJpbmdzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZ2V4OiBSZWdFeHAoc3RyaW5ncy5tYXAoZml4TGlzdFJlZ2V4KS5qb2luKFwifFwiKSksXG4gICAgICBkZXNlcjogZnVuY3Rpb24gZGVzZXIoX3JlZjIpIHtcbiAgICAgICAgdmFyIHMgPSBfcmVmMlswXTtcbiAgICAgICAgcmV0dXJuIHN0cmluZ3MuZmluZEluZGV4KGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmlwSW5zZW5zaXRpdml0aWVzKHMpID09PSBzdHJpcEluc2Vuc2l0aXZpdGllcyhpKTtcbiAgICAgICAgfSkgKyBzdGFydEluZGV4O1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gb2Zmc2V0KHJlZ2V4LCBncm91cHMpIHtcbiAgcmV0dXJuIHtcbiAgICByZWdleDogcmVnZXgsXG4gICAgZGVzZXI6IGZ1bmN0aW9uIGRlc2VyKF9yZWYzKSB7XG4gICAgICB2YXIgaCA9IF9yZWYzWzFdLFxuICAgICAgICAgIG0gPSBfcmVmM1syXTtcbiAgICAgIHJldHVybiBzaWduZWRPZmZzZXQoaCwgbSk7XG4gICAgfSxcbiAgICBncm91cHM6IGdyb3Vwc1xuICB9O1xufVxuXG5mdW5jdGlvbiBzaW1wbGUocmVnZXgpIHtcbiAgcmV0dXJuIHtcbiAgICByZWdleDogcmVnZXgsXG4gICAgZGVzZXI6IGZ1bmN0aW9uIGRlc2VyKF9yZWY0KSB7XG4gICAgICB2YXIgcyA9IF9yZWY0WzBdO1xuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBlc2NhcGVUb2tlbih2YWx1ZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1tcXC1cXFtcXF17fSgpKis/LixcXFxcXFxeJHwjXFxzXS9nLCBcIlxcXFwkJlwiKTtcbn1cblxuZnVuY3Rpb24gdW5pdEZvclRva2VuKHRva2VuLCBsb2MpIHtcbiAgdmFyIG9uZSA9IGRpZ2l0UmVnZXgobG9jKSxcbiAgICAgIHR3byA9IGRpZ2l0UmVnZXgobG9jLCBcInsyfVwiKSxcbiAgICAgIHRocmVlID0gZGlnaXRSZWdleChsb2MsIFwiezN9XCIpLFxuICAgICAgZm91ciA9IGRpZ2l0UmVnZXgobG9jLCBcIns0fVwiKSxcbiAgICAgIHNpeCA9IGRpZ2l0UmVnZXgobG9jLCBcIns2fVwiKSxcbiAgICAgIG9uZU9yVHdvID0gZGlnaXRSZWdleChsb2MsIFwiezEsMn1cIiksXG4gICAgICBvbmVUb1RocmVlID0gZGlnaXRSZWdleChsb2MsIFwiezEsM31cIiksXG4gICAgICBvbmVUb1NpeCA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDZ9XCIpLFxuICAgICAgb25lVG9OaW5lID0gZGlnaXRSZWdleChsb2MsIFwiezEsOX1cIiksXG4gICAgICB0d29Ub0ZvdXIgPSBkaWdpdFJlZ2V4KGxvYywgXCJ7Miw0fVwiKSxcbiAgICAgIGZvdXJUb1NpeCA9IGRpZ2l0UmVnZXgobG9jLCBcIns0LDZ9XCIpLFxuICAgICAgbGl0ZXJhbCA9IGZ1bmN0aW9uIGxpdGVyYWwodCkge1xuICAgIHJldHVybiB7XG4gICAgICByZWdleDogUmVnRXhwKGVzY2FwZVRva2VuKHQudmFsKSksXG4gICAgICBkZXNlcjogZnVuY3Rpb24gZGVzZXIoX3JlZjUpIHtcbiAgICAgICAgdmFyIHMgPSBfcmVmNVswXTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9LFxuICAgICAgbGl0ZXJhbDogdHJ1ZVxuICAgIH07XG4gIH0sXG4gICAgICB1bml0YXRlID0gZnVuY3Rpb24gdW5pdGF0ZSh0KSB7XG4gICAgaWYgKHRva2VuLmxpdGVyYWwpIHtcbiAgICAgIHJldHVybiBsaXRlcmFsKHQpO1xuICAgIH1cblxuICAgIHN3aXRjaCAodC52YWwpIHtcbiAgICAgIC8vIGVyYVxuICAgICAgY2FzZSBcIkdcIjpcbiAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5lcmFzKFwic2hvcnRcIiwgZmFsc2UpLCAwKTtcblxuICAgICAgY2FzZSBcIkdHXCI6XG4gICAgICAgIHJldHVybiBvbmVPZihsb2MuZXJhcyhcImxvbmdcIiwgZmFsc2UpLCAwKTtcbiAgICAgIC8vIHllYXJzXG5cbiAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KG9uZVRvU2l4KTtcblxuICAgICAgY2FzZSBcInl5XCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KHR3b1RvRm91ciwgdW50cnVuY2F0ZVllYXIpO1xuXG4gICAgICBjYXNlIFwieXl5eVwiOlxuICAgICAgICByZXR1cm4gaW50VW5pdChmb3VyKTtcblxuICAgICAgY2FzZSBcInl5eXl5XCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KGZvdXJUb1NpeCk7XG5cbiAgICAgIGNhc2UgXCJ5eXl5eXlcIjpcbiAgICAgICAgcmV0dXJuIGludFVuaXQoc2l4KTtcbiAgICAgIC8vIG1vbnRoc1xuXG4gICAgICBjYXNlIFwiTVwiOlxuICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG5cbiAgICAgIGNhc2UgXCJNTVwiOlxuICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuXG4gICAgICBjYXNlIFwiTU1NXCI6XG4gICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwic2hvcnRcIiwgdHJ1ZSwgZmFsc2UpLCAxKTtcblxuICAgICAgY2FzZSBcIk1NTU1cIjpcbiAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tb250aHMoXCJsb25nXCIsIHRydWUsIGZhbHNlKSwgMSk7XG5cbiAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcblxuICAgICAgY2FzZSBcIkxMXCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG5cbiAgICAgIGNhc2UgXCJMTExcIjpcbiAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tb250aHMoXCJzaG9ydFwiLCBmYWxzZSwgZmFsc2UpLCAxKTtcblxuICAgICAgY2FzZSBcIkxMTExcIjpcbiAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tb250aHMoXCJsb25nXCIsIGZhbHNlLCBmYWxzZSksIDEpO1xuICAgICAgLy8gZGF0ZXNcblxuICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuXG4gICAgICBjYXNlIFwiZGRcIjpcbiAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgIC8vIG9yZGluYWxzXG5cbiAgICAgIGNhc2UgXCJvXCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KG9uZVRvVGhyZWUpO1xuXG4gICAgICBjYXNlIFwib29vXCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KHRocmVlKTtcbiAgICAgIC8vIHRpbWVcblxuICAgICAgY2FzZSBcIkhIXCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG5cbiAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcblxuICAgICAgY2FzZSBcImhoXCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG5cbiAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcblxuICAgICAgY2FzZSBcIm1tXCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG5cbiAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcblxuICAgICAgY2FzZSBcInFcIjpcbiAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuXG4gICAgICBjYXNlIFwicXFcIjpcbiAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcblxuICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuXG4gICAgICBjYXNlIFwic3NcIjpcbiAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcblxuICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgcmV0dXJuIGludFVuaXQob25lVG9UaHJlZSk7XG5cbiAgICAgIGNhc2UgXCJTU1NcIjpcbiAgICAgICAgcmV0dXJuIGludFVuaXQodGhyZWUpO1xuXG4gICAgICBjYXNlIFwidVwiOlxuICAgICAgICByZXR1cm4gc2ltcGxlKG9uZVRvTmluZSk7XG4gICAgICAvLyBtZXJpZGllbVxuXG4gICAgICBjYXNlIFwiYVwiOlxuICAgICAgICByZXR1cm4gb25lT2YobG9jLm1lcmlkaWVtcygpLCAwKTtcbiAgICAgIC8vIHdlZWtZZWFyIChrKVxuXG4gICAgICBjYXNlIFwia2tra1wiOlxuICAgICAgICByZXR1cm4gaW50VW5pdChmb3VyKTtcblxuICAgICAgY2FzZSBcImtrXCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KHR3b1RvRm91ciwgdW50cnVuY2F0ZVllYXIpO1xuICAgICAgLy8gd2Vla051bWJlciAoVylcblxuICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuXG4gICAgICBjYXNlIFwiV1dcIjpcbiAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgIC8vIHdlZWtkYXlzXG5cbiAgICAgIGNhc2UgXCJFXCI6XG4gICAgICBjYXNlIFwiY1wiOlxuICAgICAgICByZXR1cm4gaW50VW5pdChvbmUpO1xuXG4gICAgICBjYXNlIFwiRUVFXCI6XG4gICAgICAgIHJldHVybiBvbmVPZihsb2Mud2Vla2RheXMoXCJzaG9ydFwiLCBmYWxzZSwgZmFsc2UpLCAxKTtcblxuICAgICAgY2FzZSBcIkVFRUVcIjpcbiAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy53ZWVrZGF5cyhcImxvbmdcIiwgZmFsc2UsIGZhbHNlKSwgMSk7XG5cbiAgICAgIGNhc2UgXCJjY2NcIjpcbiAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy53ZWVrZGF5cyhcInNob3J0XCIsIHRydWUsIGZhbHNlKSwgMSk7XG5cbiAgICAgIGNhc2UgXCJjY2NjXCI6XG4gICAgICAgIHJldHVybiBvbmVPZihsb2Mud2Vla2RheXMoXCJsb25nXCIsIHRydWUsIGZhbHNlKSwgMSk7XG4gICAgICAvLyBvZmZzZXQvem9uZVxuXG4gICAgICBjYXNlIFwiWlwiOlxuICAgICAgY2FzZSBcIlpaXCI6XG4gICAgICAgIHJldHVybiBvZmZzZXQobmV3IFJlZ0V4cChcIihbKy1dXCIgKyBvbmVPclR3by5zb3VyY2UgKyBcIikoPzo6KFwiICsgdHdvLnNvdXJjZSArIFwiKSk/XCIpLCAyKTtcblxuICAgICAgY2FzZSBcIlpaWlwiOlxuICAgICAgICByZXR1cm4gb2Zmc2V0KG5ldyBSZWdFeHAoXCIoWystXVwiICsgb25lT3JUd28uc291cmNlICsgXCIpKFwiICsgdHdvLnNvdXJjZSArIFwiKT9cIiksIDIpO1xuICAgICAgLy8gd2UgZG9uJ3Qgc3VwcG9ydCBaWlpaIChQU1QpIG9yIFpaWlpaIChQYWNpZmljIFN0YW5kYXJkIFRpbWUpIGluIHBhcnNpbmdcbiAgICAgIC8vIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhbnkgd2F5IHRvIGZpZ3VyZSBvdXQgd2hhdCB0aGV5IGFyZVxuXG4gICAgICBjYXNlIFwielwiOlxuICAgICAgICByZXR1cm4gc2ltcGxlKC9bYS16XystL117MSwyNTZ9Py9pKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxpdGVyYWwodCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciB1bml0ID0gdW5pdGF0ZSh0b2tlbikgfHwge1xuICAgIGludmFsaWRSZWFzb246IE1JU1NJTkdfRlRQXG4gIH07XG4gIHVuaXQudG9rZW4gPSB0b2tlbjtcbiAgcmV0dXJuIHVuaXQ7XG59XG5cbnZhciBwYXJ0VHlwZVN0eWxlVG9Ub2tlblZhbCA9IHtcbiAgeWVhcjoge1xuICAgIFwiMi1kaWdpdFwiOiBcInl5XCIsXG4gICAgbnVtZXJpYzogXCJ5eXl5eVwiXG4gIH0sXG4gIG1vbnRoOiB7XG4gICAgbnVtZXJpYzogXCJNXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwiTU1cIixcbiAgICBzaG9ydDogXCJNTU1cIixcbiAgICBsb25nOiBcIk1NTU1cIlxuICB9LFxuICBkYXk6IHtcbiAgICBudW1lcmljOiBcImRcIixcbiAgICBcIjItZGlnaXRcIjogXCJkZFwiXG4gIH0sXG4gIHdlZWtkYXk6IHtcbiAgICBzaG9ydDogXCJFRUVcIixcbiAgICBsb25nOiBcIkVFRUVcIlxuICB9LFxuICBkYXlwZXJpb2Q6IFwiYVwiLFxuICBkYXlQZXJpb2Q6IFwiYVwiLFxuICBob3VyOiB7XG4gICAgbnVtZXJpYzogXCJoXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwiaGhcIlxuICB9LFxuICBtaW51dGU6IHtcbiAgICBudW1lcmljOiBcIm1cIixcbiAgICBcIjItZGlnaXRcIjogXCJtbVwiXG4gIH0sXG4gIHNlY29uZDoge1xuICAgIG51bWVyaWM6IFwic1wiLFxuICAgIFwiMi1kaWdpdFwiOiBcInNzXCJcbiAgfVxufTtcblxuZnVuY3Rpb24gdG9rZW5Gb3JQYXJ0KHBhcnQsIGxvY2FsZSwgZm9ybWF0T3B0cykge1xuICB2YXIgdHlwZSA9IHBhcnQudHlwZSxcbiAgICAgIHZhbHVlID0gcGFydC52YWx1ZTtcblxuICBpZiAodHlwZSA9PT0gXCJsaXRlcmFsXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl0ZXJhbDogdHJ1ZSxcbiAgICAgIHZhbDogdmFsdWVcbiAgICB9O1xuICB9XG5cbiAgdmFyIHN0eWxlID0gZm9ybWF0T3B0c1t0eXBlXTtcbiAgdmFyIHZhbCA9IHBhcnRUeXBlU3R5bGVUb1Rva2VuVmFsW3R5cGVdO1xuXG4gIGlmICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiKSB7XG4gICAgdmFsID0gdmFsW3N0eWxlXTtcbiAgfVxuXG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl0ZXJhbDogZmFsc2UsXG4gICAgICB2YWw6IHZhbFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBidWlsZFJlZ2V4KHVuaXRzKSB7XG4gIHZhciByZSA9IHVuaXRzLm1hcChmdW5jdGlvbiAodSkge1xuICAgIHJldHVybiB1LnJlZ2V4O1xuICB9KS5yZWR1Y2UoZnVuY3Rpb24gKGYsIHIpIHtcbiAgICByZXR1cm4gZiArIFwiKFwiICsgci5zb3VyY2UgKyBcIilcIjtcbiAgfSwgXCJcIik7XG4gIHJldHVybiBbXCJeXCIgKyByZSArIFwiJFwiLCB1bml0c107XG59XG5cbmZ1bmN0aW9uIG1hdGNoKGlucHV0LCByZWdleCwgaGFuZGxlcnMpIHtcbiAgdmFyIG1hdGNoZXMgPSBpbnB1dC5tYXRjaChyZWdleCk7XG5cbiAgaWYgKG1hdGNoZXMpIHtcbiAgICB2YXIgYWxsID0ge307XG4gICAgdmFyIG1hdGNoSW5kZXggPSAxO1xuXG4gICAgZm9yICh2YXIgaSBpbiBoYW5kbGVycykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KGhhbmRsZXJzLCBpKSkge1xuICAgICAgICB2YXIgaCA9IGhhbmRsZXJzW2ldLFxuICAgICAgICAgICAgZ3JvdXBzID0gaC5ncm91cHMgPyBoLmdyb3VwcyArIDEgOiAxO1xuXG4gICAgICAgIGlmICghaC5saXRlcmFsICYmIGgudG9rZW4pIHtcbiAgICAgICAgICBhbGxbaC50b2tlbi52YWxbMF1dID0gaC5kZXNlcihtYXRjaGVzLnNsaWNlKG1hdGNoSW5kZXgsIG1hdGNoSW5kZXggKyBncm91cHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hdGNoSW5kZXggKz0gZ3JvdXBzO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbbWF0Y2hlcywgYWxsXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW21hdGNoZXMsIHt9XTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkYXRlVGltZUZyb21NYXRjaGVzKG1hdGNoZXMpIHtcbiAgdmFyIHRvRmllbGQgPSBmdW5jdGlvbiB0b0ZpZWxkKHRva2VuKSB7XG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgcmV0dXJuIFwibWlsbGlzZWNvbmRcIjtcblxuICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgcmV0dXJuIFwic2Vjb25kXCI7XG5cbiAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgIHJldHVybiBcIm1pbnV0ZVwiO1xuXG4gICAgICBjYXNlIFwiaFwiOlxuICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgcmV0dXJuIFwiaG91clwiO1xuXG4gICAgICBjYXNlIFwiZFwiOlxuICAgICAgICByZXR1cm4gXCJkYXlcIjtcblxuICAgICAgY2FzZSBcIm9cIjpcbiAgICAgICAgcmV0dXJuIFwib3JkaW5hbFwiO1xuXG4gICAgICBjYXNlIFwiTFwiOlxuICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgcmV0dXJuIFwibW9udGhcIjtcblxuICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgcmV0dXJuIFwieWVhclwiO1xuXG4gICAgICBjYXNlIFwiRVwiOlxuICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla2RheVwiO1xuXG4gICAgICBjYXNlIFwiV1wiOlxuICAgICAgICByZXR1cm4gXCJ3ZWVrTnVtYmVyXCI7XG5cbiAgICAgIGNhc2UgXCJrXCI6XG4gICAgICAgIHJldHVybiBcIndlZWtZZWFyXCI7XG5cbiAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgIHJldHVybiBcInF1YXJ0ZXJcIjtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIHZhciB6b25lO1xuXG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy5aKSkge1xuICAgIHpvbmUgPSBuZXcgRml4ZWRPZmZzZXRab25lKG1hdGNoZXMuWik7XG4gIH0gZWxzZSBpZiAoIWlzVW5kZWZpbmVkKG1hdGNoZXMueikpIHtcbiAgICB6b25lID0gSUFOQVpvbmUuY3JlYXRlKG1hdGNoZXMueik7XG4gIH0gZWxzZSB7XG4gICAgem9uZSA9IG51bGw7XG4gIH1cblxuICBpZiAoIWlzVW5kZWZpbmVkKG1hdGNoZXMucSkpIHtcbiAgICBtYXRjaGVzLk0gPSAobWF0Y2hlcy5xIC0gMSkgKiAzICsgMTtcbiAgfVxuXG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy5oKSkge1xuICAgIGlmIChtYXRjaGVzLmggPCAxMiAmJiBtYXRjaGVzLmEgPT09IDEpIHtcbiAgICAgIG1hdGNoZXMuaCArPSAxMjtcbiAgICB9IGVsc2UgaWYgKG1hdGNoZXMuaCA9PT0gMTIgJiYgbWF0Y2hlcy5hID09PSAwKSB7XG4gICAgICBtYXRjaGVzLmggPSAwO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtYXRjaGVzLkcgPT09IDAgJiYgbWF0Y2hlcy55KSB7XG4gICAgbWF0Y2hlcy55ID0gLW1hdGNoZXMueTtcbiAgfVxuXG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy51KSkge1xuICAgIG1hdGNoZXMuUyA9IHBhcnNlTWlsbGlzKG1hdGNoZXMudSk7XG4gIH1cblxuICB2YXIgdmFscyA9IE9iamVjdC5rZXlzKG1hdGNoZXMpLnJlZHVjZShmdW5jdGlvbiAociwgaykge1xuICAgIHZhciBmID0gdG9GaWVsZChrKTtcblxuICAgIGlmIChmKSB7XG4gICAgICByW2ZdID0gbWF0Y2hlc1trXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfSwge30pO1xuICByZXR1cm4gW3ZhbHMsIHpvbmVdO1xufVxuXG52YXIgZHVtbXlEYXRlVGltZUNhY2hlID0gbnVsbDtcblxuZnVuY3Rpb24gZ2V0RHVtbXlEYXRlVGltZSgpIHtcbiAgaWYgKCFkdW1teURhdGVUaW1lQ2FjaGUpIHtcbiAgICBkdW1teURhdGVUaW1lQ2FjaGUgPSBEYXRlVGltZS5mcm9tTWlsbGlzKDE1NTU1NTU1NTU1NTUpO1xuICB9XG5cbiAgcmV0dXJuIGR1bW15RGF0ZVRpbWVDYWNoZTtcbn1cblxuZnVuY3Rpb24gbWF5YmVFeHBhbmRNYWNyb1Rva2VuKHRva2VuLCBsb2NhbGUpIHtcbiAgaWYgKHRva2VuLmxpdGVyYWwpIHtcbiAgICByZXR1cm4gdG9rZW47XG4gIH1cblxuICB2YXIgZm9ybWF0T3B0cyA9IEZvcm1hdHRlci5tYWNyb1Rva2VuVG9Gb3JtYXRPcHRzKHRva2VuLnZhbCk7XG5cbiAgaWYgKCFmb3JtYXRPcHRzKSB7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgdmFyIGZvcm1hdHRlciA9IEZvcm1hdHRlci5jcmVhdGUobG9jYWxlLCBmb3JtYXRPcHRzKTtcbiAgdmFyIHBhcnRzID0gZm9ybWF0dGVyLmZvcm1hdERhdGVUaW1lUGFydHMoZ2V0RHVtbXlEYXRlVGltZSgpKTtcbiAgdmFyIHRva2VucyA9IHBhcnRzLm1hcChmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiB0b2tlbkZvclBhcnQocCwgbG9jYWxlLCBmb3JtYXRPcHRzKTtcbiAgfSk7XG5cbiAgaWYgKHRva2Vucy5pbmNsdWRlcyh1bmRlZmluZWQpKSB7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgcmV0dXJuIHRva2Vucztcbn1cblxuZnVuY3Rpb24gZXhwYW5kTWFjcm9Ub2tlbnModG9rZW5zLCBsb2NhbGUpIHtcbiAgdmFyIF9BcnJheSRwcm90b3R5cGU7XG5cbiAgcmV0dXJuIChfQXJyYXkkcHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlKS5jb25jYXQuYXBwbHkoX0FycmF5JHByb3RvdHlwZSwgdG9rZW5zLm1hcChmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBtYXliZUV4cGFuZE1hY3JvVG9rZW4odCwgbG9jYWxlKTtcbiAgfSkpO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gZXhwbGFpbkZyb21Ub2tlbnMobG9jYWxlLCBpbnB1dCwgZm9ybWF0KSB7XG4gIHZhciB0b2tlbnMgPSBleHBhbmRNYWNyb1Rva2VucyhGb3JtYXR0ZXIucGFyc2VGb3JtYXQoZm9ybWF0KSwgbG9jYWxlKSxcbiAgICAgIHVuaXRzID0gdG9rZW5zLm1hcChmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB1bml0Rm9yVG9rZW4odCwgbG9jYWxlKTtcbiAgfSksXG4gICAgICBkaXNxdWFsaWZ5aW5nVW5pdCA9IHVuaXRzLmZpbmQoZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdC5pbnZhbGlkUmVhc29uO1xuICB9KTtcblxuICBpZiAoZGlzcXVhbGlmeWluZ1VuaXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXQ6IGlucHV0LFxuICAgICAgdG9rZW5zOiB0b2tlbnMsXG4gICAgICBpbnZhbGlkUmVhc29uOiBkaXNxdWFsaWZ5aW5nVW5pdC5pbnZhbGlkUmVhc29uXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX2J1aWxkUmVnZXggPSBidWlsZFJlZ2V4KHVuaXRzKSxcbiAgICAgICAgcmVnZXhTdHJpbmcgPSBfYnVpbGRSZWdleFswXSxcbiAgICAgICAgaGFuZGxlcnMgPSBfYnVpbGRSZWdleFsxXSxcbiAgICAgICAgcmVnZXggPSBSZWdFeHAocmVnZXhTdHJpbmcsIFwiaVwiKSxcbiAgICAgICAgX21hdGNoID0gbWF0Y2goaW5wdXQsIHJlZ2V4LCBoYW5kbGVycyksXG4gICAgICAgIHJhd01hdGNoZXMgPSBfbWF0Y2hbMF0sXG4gICAgICAgIG1hdGNoZXMgPSBfbWF0Y2hbMV0sXG4gICAgICAgIF9yZWY2ID0gbWF0Y2hlcyA/IGRhdGVUaW1lRnJvbU1hdGNoZXMobWF0Y2hlcykgOiBbbnVsbCwgbnVsbF0sXG4gICAgICAgIHJlc3VsdCA9IF9yZWY2WzBdLFxuICAgICAgICB6b25lID0gX3JlZjZbMV07XG5cbiAgICBpZiAoaGFzT3duUHJvcGVydHkobWF0Y2hlcywgXCJhXCIpICYmIGhhc093blByb3BlcnR5KG1hdGNoZXMsIFwiSFwiKSkge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFwiQ2FuJ3QgaW5jbHVkZSBtZXJpZGllbSB3aGVuIHNwZWNpZnlpbmcgMjQtaG91ciBmb3JtYXRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0OiBpbnB1dCxcbiAgICAgIHRva2VuczogdG9rZW5zLFxuICAgICAgcmVnZXg6IHJlZ2V4LFxuICAgICAgcmF3TWF0Y2hlczogcmF3TWF0Y2hlcyxcbiAgICAgIG1hdGNoZXM6IG1hdGNoZXMsXG4gICAgICByZXN1bHQ6IHJlc3VsdCxcbiAgICAgIHpvbmU6IHpvbmVcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZUZyb21Ub2tlbnMobG9jYWxlLCBpbnB1dCwgZm9ybWF0KSB7XG4gIHZhciBfZXhwbGFpbkZyb21Ub2tlbnMgPSBleHBsYWluRnJvbVRva2Vucyhsb2NhbGUsIGlucHV0LCBmb3JtYXQpLFxuICAgICAgcmVzdWx0ID0gX2V4cGxhaW5Gcm9tVG9rZW5zLnJlc3VsdCxcbiAgICAgIHpvbmUgPSBfZXhwbGFpbkZyb21Ub2tlbnMuem9uZSxcbiAgICAgIGludmFsaWRSZWFzb24gPSBfZXhwbGFpbkZyb21Ub2tlbnMuaW52YWxpZFJlYXNvbjtcblxuICByZXR1cm4gW3Jlc3VsdCwgem9uZSwgaW52YWxpZFJlYXNvbl07XG59XG5cbnZhciBub25MZWFwTGFkZGVyID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XSxcbiAgICBsZWFwTGFkZGVyID0gWzAsIDMxLCA2MCwgOTEsIDEyMSwgMTUyLCAxODIsIDIxMywgMjQ0LCAyNzQsIDMwNSwgMzM1XTtcblxuZnVuY3Rpb24gdW5pdE91dE9mUmFuZ2UodW5pdCwgdmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBJbnZhbGlkKFwidW5pdCBvdXQgb2YgcmFuZ2VcIiwgXCJ5b3Ugc3BlY2lmaWVkIFwiICsgdmFsdWUgKyBcIiAob2YgdHlwZSBcIiArIHR5cGVvZiB2YWx1ZSArIFwiKSBhcyBhIFwiICsgdW5pdCArIFwiLCB3aGljaCBpcyBpbnZhbGlkXCIpO1xufVxuXG5mdW5jdGlvbiBkYXlPZldlZWsoeWVhciwgbW9udGgsIGRheSkge1xuICB2YXIganMgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCAtIDEsIGRheSkpLmdldFVUQ0RheSgpO1xuICByZXR1cm4ganMgPT09IDAgPyA3IDoganM7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVPcmRpbmFsKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgcmV0dXJuIGRheSArIChpc0xlYXBZZWFyKHllYXIpID8gbGVhcExhZGRlciA6IG5vbkxlYXBMYWRkZXIpW21vbnRoIC0gMV07XG59XG5cbmZ1bmN0aW9uIHVuY29tcHV0ZU9yZGluYWwoeWVhciwgb3JkaW5hbCkge1xuICB2YXIgdGFibGUgPSBpc0xlYXBZZWFyKHllYXIpID8gbGVhcExhZGRlciA6IG5vbkxlYXBMYWRkZXIsXG4gICAgICBtb250aDAgPSB0YWJsZS5maW5kSW5kZXgoZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gaSA8IG9yZGluYWw7XG4gIH0pLFxuICAgICAgZGF5ID0gb3JkaW5hbCAtIHRhYmxlW21vbnRoMF07XG4gIHJldHVybiB7XG4gICAgbW9udGg6IG1vbnRoMCArIDEsXG4gICAgZGF5OiBkYXlcbiAgfTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGdyZWdvcmlhblRvV2VlayhncmVnT2JqKSB7XG4gIHZhciB5ZWFyID0gZ3JlZ09iai55ZWFyLFxuICAgICAgbW9udGggPSBncmVnT2JqLm1vbnRoLFxuICAgICAgZGF5ID0gZ3JlZ09iai5kYXksXG4gICAgICBvcmRpbmFsID0gY29tcHV0ZU9yZGluYWwoeWVhciwgbW9udGgsIGRheSksXG4gICAgICB3ZWVrZGF5ID0gZGF5T2ZXZWVrKHllYXIsIG1vbnRoLCBkYXkpO1xuICB2YXIgd2Vla051bWJlciA9IE1hdGguZmxvb3IoKG9yZGluYWwgLSB3ZWVrZGF5ICsgMTApIC8gNyksXG4gICAgICB3ZWVrWWVhcjtcblxuICBpZiAod2Vla051bWJlciA8IDEpIHtcbiAgICB3ZWVrWWVhciA9IHllYXIgLSAxO1xuICAgIHdlZWtOdW1iZXIgPSB3ZWVrc0luV2Vla1llYXIod2Vla1llYXIpO1xuICB9IGVsc2UgaWYgKHdlZWtOdW1iZXIgPiB3ZWVrc0luV2Vla1llYXIoeWVhcikpIHtcbiAgICB3ZWVrWWVhciA9IHllYXIgKyAxO1xuICAgIHdlZWtOdW1iZXIgPSAxO1xuICB9IGVsc2Uge1xuICAgIHdlZWtZZWFyID0geWVhcjtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICB3ZWVrWWVhcjogd2Vla1llYXIsXG4gICAgd2Vla051bWJlcjogd2Vla051bWJlcixcbiAgICB3ZWVrZGF5OiB3ZWVrZGF5XG4gIH0sIHRpbWVPYmplY3QoZ3JlZ09iaikpO1xufVxuZnVuY3Rpb24gd2Vla1RvR3JlZ29yaWFuKHdlZWtEYXRhKSB7XG4gIHZhciB3ZWVrWWVhciA9IHdlZWtEYXRhLndlZWtZZWFyLFxuICAgICAgd2Vla051bWJlciA9IHdlZWtEYXRhLndlZWtOdW1iZXIsXG4gICAgICB3ZWVrZGF5ID0gd2Vla0RhdGEud2Vla2RheSxcbiAgICAgIHdlZWtkYXlPZkphbjQgPSBkYXlPZldlZWsod2Vla1llYXIsIDEsIDQpLFxuICAgICAgeWVhckluRGF5cyA9IGRheXNJblllYXIod2Vla1llYXIpO1xuICB2YXIgb3JkaW5hbCA9IHdlZWtOdW1iZXIgKiA3ICsgd2Vla2RheSAtIHdlZWtkYXlPZkphbjQgLSAzLFxuICAgICAgeWVhcjtcblxuICBpZiAob3JkaW5hbCA8IDEpIHtcbiAgICB5ZWFyID0gd2Vla1llYXIgLSAxO1xuICAgIG9yZGluYWwgKz0gZGF5c0luWWVhcih5ZWFyKTtcbiAgfSBlbHNlIGlmIChvcmRpbmFsID4geWVhckluRGF5cykge1xuICAgIHllYXIgPSB3ZWVrWWVhciArIDE7XG4gICAgb3JkaW5hbCAtPSBkYXlzSW5ZZWFyKHdlZWtZZWFyKTtcbiAgfSBlbHNlIHtcbiAgICB5ZWFyID0gd2Vla1llYXI7XG4gIH1cblxuICB2YXIgX3VuY29tcHV0ZU9yZGluYWwgPSB1bmNvbXB1dGVPcmRpbmFsKHllYXIsIG9yZGluYWwpLFxuICAgICAgbW9udGggPSBfdW5jb21wdXRlT3JkaW5hbC5tb250aCxcbiAgICAgIGRheSA9IF91bmNvbXB1dGVPcmRpbmFsLmRheTtcblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgeWVhcjogeWVhcixcbiAgICBtb250aDogbW9udGgsXG4gICAgZGF5OiBkYXlcbiAgfSwgdGltZU9iamVjdCh3ZWVrRGF0YSkpO1xufVxuZnVuY3Rpb24gZ3JlZ29yaWFuVG9PcmRpbmFsKGdyZWdEYXRhKSB7XG4gIHZhciB5ZWFyID0gZ3JlZ0RhdGEueWVhcixcbiAgICAgIG1vbnRoID0gZ3JlZ0RhdGEubW9udGgsXG4gICAgICBkYXkgPSBncmVnRGF0YS5kYXksXG4gICAgICBvcmRpbmFsID0gY29tcHV0ZU9yZGluYWwoeWVhciwgbW9udGgsIGRheSk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICB5ZWFyOiB5ZWFyLFxuICAgIG9yZGluYWw6IG9yZGluYWxcbiAgfSwgdGltZU9iamVjdChncmVnRGF0YSkpO1xufVxuZnVuY3Rpb24gb3JkaW5hbFRvR3JlZ29yaWFuKG9yZGluYWxEYXRhKSB7XG4gIHZhciB5ZWFyID0gb3JkaW5hbERhdGEueWVhcixcbiAgICAgIG9yZGluYWwgPSBvcmRpbmFsRGF0YS5vcmRpbmFsLFxuICAgICAgX3VuY29tcHV0ZU9yZGluYWwyID0gdW5jb21wdXRlT3JkaW5hbCh5ZWFyLCBvcmRpbmFsKSxcbiAgICAgIG1vbnRoID0gX3VuY29tcHV0ZU9yZGluYWwyLm1vbnRoLFxuICAgICAgZGF5ID0gX3VuY29tcHV0ZU9yZGluYWwyLmRheTtcblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgeWVhcjogeWVhcixcbiAgICBtb250aDogbW9udGgsXG4gICAgZGF5OiBkYXlcbiAgfSwgdGltZU9iamVjdChvcmRpbmFsRGF0YSkpO1xufVxuZnVuY3Rpb24gaGFzSW52YWxpZFdlZWtEYXRhKG9iaikge1xuICB2YXIgdmFsaWRZZWFyID0gaXNJbnRlZ2VyKG9iai53ZWVrWWVhciksXG4gICAgICB2YWxpZFdlZWsgPSBpbnRlZ2VyQmV0d2VlbihvYmoud2Vla051bWJlciwgMSwgd2Vla3NJbldlZWtZZWFyKG9iai53ZWVrWWVhcikpLFxuICAgICAgdmFsaWRXZWVrZGF5ID0gaW50ZWdlckJldHdlZW4ob2JqLndlZWtkYXksIDEsIDcpO1xuXG4gIGlmICghdmFsaWRZZWFyKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwid2Vla1llYXJcIiwgb2JqLndlZWtZZWFyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRXZWVrKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwid2Vla1wiLCBvYmoud2Vlayk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkV2Vla2RheSkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIndlZWtkYXlcIiwgb2JqLndlZWtkYXkpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaGFzSW52YWxpZE9yZGluYWxEYXRhKG9iaikge1xuICB2YXIgdmFsaWRZZWFyID0gaXNJbnRlZ2VyKG9iai55ZWFyKSxcbiAgICAgIHZhbGlkT3JkaW5hbCA9IGludGVnZXJCZXR3ZWVuKG9iai5vcmRpbmFsLCAxLCBkYXlzSW5ZZWFyKG9iai55ZWFyKSk7XG5cbiAgaWYgKCF2YWxpZFllYXIpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ5ZWFyXCIsIG9iai55ZWFyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRPcmRpbmFsKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwib3JkaW5hbFwiLCBvYmoub3JkaW5hbCk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YShvYmopIHtcbiAgdmFyIHZhbGlkWWVhciA9IGlzSW50ZWdlcihvYmoueWVhciksXG4gICAgICB2YWxpZE1vbnRoID0gaW50ZWdlckJldHdlZW4ob2JqLm1vbnRoLCAxLCAxMiksXG4gICAgICB2YWxpZERheSA9IGludGVnZXJCZXR3ZWVuKG9iai5kYXksIDEsIGRheXNJbk1vbnRoKG9iai55ZWFyLCBvYmoubW9udGgpKTtcblxuICBpZiAoIXZhbGlkWWVhcikge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcInllYXJcIiwgb2JqLnllYXIpO1xuICB9IGVsc2UgaWYgKCF2YWxpZE1vbnRoKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwibW9udGhcIiwgb2JqLm1vbnRoKTtcbiAgfSBlbHNlIGlmICghdmFsaWREYXkpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJkYXlcIiwgb2JqLmRheSk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBoYXNJbnZhbGlkVGltZURhdGEob2JqKSB7XG4gIHZhciBob3VyID0gb2JqLmhvdXIsXG4gICAgICBtaW51dGUgPSBvYmoubWludXRlLFxuICAgICAgc2Vjb25kID0gb2JqLnNlY29uZCxcbiAgICAgIG1pbGxpc2Vjb25kID0gb2JqLm1pbGxpc2Vjb25kO1xuICB2YXIgdmFsaWRIb3VyID0gaW50ZWdlckJldHdlZW4oaG91ciwgMCwgMjMpIHx8IGhvdXIgPT09IDI0ICYmIG1pbnV0ZSA9PT0gMCAmJiBzZWNvbmQgPT09IDAgJiYgbWlsbGlzZWNvbmQgPT09IDAsXG4gICAgICB2YWxpZE1pbnV0ZSA9IGludGVnZXJCZXR3ZWVuKG1pbnV0ZSwgMCwgNTkpLFxuICAgICAgdmFsaWRTZWNvbmQgPSBpbnRlZ2VyQmV0d2VlbihzZWNvbmQsIDAsIDU5KSxcbiAgICAgIHZhbGlkTWlsbGlzZWNvbmQgPSBpbnRlZ2VyQmV0d2VlbihtaWxsaXNlY29uZCwgMCwgOTk5KTtcblxuICBpZiAoIXZhbGlkSG91cikge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcImhvdXJcIiwgaG91cik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkTWludXRlKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwibWludXRlXCIsIG1pbnV0ZSk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkU2Vjb25kKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwic2Vjb25kXCIsIHNlY29uZCk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkTWlsbGlzZWNvbmQpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJtaWxsaXNlY29uZFwiLCBtaWxsaXNlY29uZCk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBJTlZBTElEJDIgPSBcIkludmFsaWQgRGF0ZVRpbWVcIjtcbnZhciBNQVhfREFURSA9IDguNjRlMTU7XG5cbmZ1bmN0aW9uIHVuc3VwcG9ydGVkWm9uZSh6b25lKSB7XG4gIHJldHVybiBuZXcgSW52YWxpZChcInVuc3VwcG9ydGVkIHpvbmVcIiwgXCJ0aGUgem9uZSBcXFwiXCIgKyB6b25lLm5hbWUgKyBcIlxcXCIgaXMgbm90IHN1cHBvcnRlZFwiKTtcbn0gLy8gd2UgY2FjaGUgd2VlayBkYXRhIG9uIHRoZSBEVCBvYmplY3QgYW5kIHRoaXMgaW50ZXJtZWRpYXRlcyB0aGUgY2FjaGVcblxuXG5mdW5jdGlvbiBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKGR0KSB7XG4gIGlmIChkdC53ZWVrRGF0YSA9PT0gbnVsbCkge1xuICAgIGR0LndlZWtEYXRhID0gZ3JlZ29yaWFuVG9XZWVrKGR0LmMpO1xuICB9XG5cbiAgcmV0dXJuIGR0LndlZWtEYXRhO1xufSAvLyBjbG9uZSByZWFsbHkgbWVhbnMsIFwibWFrZSBhIG5ldyBvYmplY3Qgd2l0aCB0aGVzZSBtb2RpZmljYXRpb25zXCIuIGFsbCBcInNldHRlcnNcIiByZWFsbHkgdXNlIHRoaXNcbi8vIHRvIGNyZWF0ZSBhIG5ldyBvYmplY3Qgd2hpbGUgb25seSBjaGFuZ2luZyBzb21lIG9mIHRoZSBwcm9wZXJ0aWVzXG5cblxuZnVuY3Rpb24gY2xvbmUkMShpbnN0LCBhbHRzKSB7XG4gIHZhciBjdXJyZW50ID0ge1xuICAgIHRzOiBpbnN0LnRzLFxuICAgIHpvbmU6IGluc3Quem9uZSxcbiAgICBjOiBpbnN0LmMsXG4gICAgbzogaW5zdC5vLFxuICAgIGxvYzogaW5zdC5sb2MsXG4gICAgaW52YWxpZDogaW5zdC5pbnZhbGlkXG4gIH07XG4gIHJldHVybiBuZXcgRGF0ZVRpbWUoT2JqZWN0LmFzc2lnbih7fSwgY3VycmVudCwgYWx0cywge1xuICAgIG9sZDogY3VycmVudFxuICB9KSk7XG59IC8vIGZpbmQgdGhlIHJpZ2h0IG9mZnNldCBhIGdpdmVuIGxvY2FsIHRpbWUuIFRoZSBvIGlucHV0IGlzIG91ciBndWVzcywgd2hpY2ggZGV0ZXJtaW5lcyB3aGljaFxuLy8gb2Zmc2V0IHdlJ2xsIHBpY2sgaW4gYW1iaWd1b3VzIGNhc2VzIChlLmcuIHRoZXJlIGFyZSB0d28gMyBBTXMgYi9jIEZhbGxiYWNrIERTVClcblxuXG5mdW5jdGlvbiBmaXhPZmZzZXQobG9jYWxUUywgbywgdHopIHtcbiAgLy8gT3VyIFVUQyB0aW1lIGlzIGp1c3QgYSBndWVzcyBiZWNhdXNlIG91ciBvZmZzZXQgaXMganVzdCBhIGd1ZXNzXG4gIHZhciB1dGNHdWVzcyA9IGxvY2FsVFMgLSBvICogNjAgKiAxMDAwOyAvLyBUZXN0IHdoZXRoZXIgdGhlIHpvbmUgbWF0Y2hlcyB0aGUgb2Zmc2V0IGZvciB0aGlzIHRzXG5cbiAgdmFyIG8yID0gdHoub2Zmc2V0KHV0Y0d1ZXNzKTsgLy8gSWYgc28sIG9mZnNldCBkaWRuJ3QgY2hhbmdlIGFuZCB3ZSdyZSBkb25lXG5cbiAgaWYgKG8gPT09IG8yKSB7XG4gICAgcmV0dXJuIFt1dGNHdWVzcywgb107XG4gIH0gLy8gSWYgbm90LCBjaGFuZ2UgdGhlIHRzIGJ5IHRoZSBkaWZmZXJlbmNlIGluIHRoZSBvZmZzZXRcblxuXG4gIHV0Y0d1ZXNzIC09IChvMiAtIG8pICogNjAgKiAxMDAwOyAvLyBJZiB0aGF0IGdpdmVzIHVzIHRoZSBsb2NhbCB0aW1lIHdlIHdhbnQsIHdlJ3JlIGRvbmVcblxuICB2YXIgbzMgPSB0ei5vZmZzZXQodXRjR3Vlc3MpO1xuXG4gIGlmIChvMiA9PT0gbzMpIHtcbiAgICByZXR1cm4gW3V0Y0d1ZXNzLCBvMl07XG4gIH0gLy8gSWYgaXQncyBkaWZmZXJlbnQsIHdlJ3JlIGluIGEgaG9sZSB0aW1lLiBUaGUgb2Zmc2V0IGhhcyBjaGFuZ2VkLCBidXQgdGhlIHdlIGRvbid0IGFkanVzdCB0aGUgdGltZVxuXG5cbiAgcmV0dXJuIFtsb2NhbFRTIC0gTWF0aC5taW4obzIsIG8zKSAqIDYwICogMTAwMCwgTWF0aC5tYXgobzIsIG8zKV07XG59IC8vIGNvbnZlcnQgYW4gZXBvY2ggdGltZXN0YW1wIGludG8gYSBjYWxlbmRhciBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gb2Zmc2V0XG5cblxuZnVuY3Rpb24gdHNUb09iaih0cywgb2Zmc2V0KSB7XG4gIHRzICs9IG9mZnNldCAqIDYwICogMTAwMDtcbiAgdmFyIGQgPSBuZXcgRGF0ZSh0cyk7XG4gIHJldHVybiB7XG4gICAgeWVhcjogZC5nZXRVVENGdWxsWWVhcigpLFxuICAgIG1vbnRoOiBkLmdldFVUQ01vbnRoKCkgKyAxLFxuICAgIGRheTogZC5nZXRVVENEYXRlKCksXG4gICAgaG91cjogZC5nZXRVVENIb3VycygpLFxuICAgIG1pbnV0ZTogZC5nZXRVVENNaW51dGVzKCksXG4gICAgc2Vjb25kOiBkLmdldFVUQ1NlY29uZHMoKSxcbiAgICBtaWxsaXNlY29uZDogZC5nZXRVVENNaWxsaXNlY29uZHMoKVxuICB9O1xufSAvLyBjb252ZXJ0IGEgY2FsZW5kYXIgb2JqZWN0IHRvIGEgZXBvY2ggdGltZXN0YW1wXG5cblxuZnVuY3Rpb24gb2JqVG9UUyhvYmosIG9mZnNldCwgem9uZSkge1xuICByZXR1cm4gZml4T2Zmc2V0KG9ialRvTG9jYWxUUyhvYmopLCBvZmZzZXQsIHpvbmUpO1xufSAvLyBjcmVhdGUgYSBuZXcgRFQgaW5zdGFuY2UgYnkgYWRkaW5nIGEgZHVyYXRpb24sIGFkanVzdGluZyBmb3IgRFNUc1xuXG5cbmZ1bmN0aW9uIGFkanVzdFRpbWUoaW5zdCwgZHVyKSB7XG4gIHZhciBvUHJlID0gaW5zdC5vLFxuICAgICAgeWVhciA9IGluc3QuYy55ZWFyICsgTWF0aC50cnVuYyhkdXIueWVhcnMpLFxuICAgICAgbW9udGggPSBpbnN0LmMubW9udGggKyBNYXRoLnRydW5jKGR1ci5tb250aHMpICsgTWF0aC50cnVuYyhkdXIucXVhcnRlcnMpICogMyxcbiAgICAgIGMgPSBPYmplY3QuYXNzaWduKHt9LCBpbnN0LmMsIHtcbiAgICB5ZWFyOiB5ZWFyLFxuICAgIG1vbnRoOiBtb250aCxcbiAgICBkYXk6IE1hdGgubWluKGluc3QuYy5kYXksIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSkgKyBNYXRoLnRydW5jKGR1ci5kYXlzKSArIE1hdGgudHJ1bmMoZHVyLndlZWtzKSAqIDdcbiAgfSksXG4gICAgICBtaWxsaXNUb0FkZCA9IER1cmF0aW9uLmZyb21PYmplY3Qoe1xuICAgIHllYXJzOiBkdXIueWVhcnMgLSBNYXRoLnRydW5jKGR1ci55ZWFycyksXG4gICAgcXVhcnRlcnM6IGR1ci5xdWFydGVycyAtIE1hdGgudHJ1bmMoZHVyLnF1YXJ0ZXJzKSxcbiAgICBtb250aHM6IGR1ci5tb250aHMgLSBNYXRoLnRydW5jKGR1ci5tb250aHMpLFxuICAgIHdlZWtzOiBkdXIud2Vla3MgLSBNYXRoLnRydW5jKGR1ci53ZWVrcyksXG4gICAgZGF5czogZHVyLmRheXMgLSBNYXRoLnRydW5jKGR1ci5kYXlzKSxcbiAgICBob3VyczogZHVyLmhvdXJzLFxuICAgIG1pbnV0ZXM6IGR1ci5taW51dGVzLFxuICAgIHNlY29uZHM6IGR1ci5zZWNvbmRzLFxuICAgIG1pbGxpc2Vjb25kczogZHVyLm1pbGxpc2Vjb25kc1xuICB9KS5hcyhcIm1pbGxpc2Vjb25kc1wiKSxcbiAgICAgIGxvY2FsVFMgPSBvYmpUb0xvY2FsVFMoYyk7XG5cbiAgdmFyIF9maXhPZmZzZXQgPSBmaXhPZmZzZXQobG9jYWxUUywgb1ByZSwgaW5zdC56b25lKSxcbiAgICAgIHRzID0gX2ZpeE9mZnNldFswXSxcbiAgICAgIG8gPSBfZml4T2Zmc2V0WzFdO1xuXG4gIGlmIChtaWxsaXNUb0FkZCAhPT0gMCkge1xuICAgIHRzICs9IG1pbGxpc1RvQWRkOyAvLyB0aGF0IGNvdWxkIGhhdmUgY2hhbmdlZCB0aGUgb2Zmc2V0IGJ5IGdvaW5nIG92ZXIgYSBEU1QsIGJ1dCB3ZSB3YW50IHRvIGtlZXAgdGhlIHRzIHRoZSBzYW1lXG5cbiAgICBvID0gaW5zdC56b25lLm9mZnNldCh0cyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRzOiB0cyxcbiAgICBvOiBvXG4gIH07XG59IC8vIGhlbHBlciB1c2VmdWwgaW4gdHVybmluZyB0aGUgcmVzdWx0cyBvZiBwYXJzaW5nIGludG8gcmVhbCBkYXRlc1xuLy8gYnkgaGFuZGxpbmcgdGhlIHpvbmUgb3B0aW9uc1xuXG5cbmZ1bmN0aW9uIHBhcnNlRGF0YVRvRGF0ZVRpbWUocGFyc2VkLCBwYXJzZWRab25lLCBvcHRzLCBmb3JtYXQsIHRleHQpIHtcbiAgdmFyIHNldFpvbmUgPSBvcHRzLnNldFpvbmUsXG4gICAgICB6b25lID0gb3B0cy56b25lO1xuXG4gIGlmIChwYXJzZWQgJiYgT2JqZWN0LmtleXMocGFyc2VkKS5sZW5ndGggIT09IDApIHtcbiAgICB2YXIgaW50ZXJwcmV0YXRpb25ab25lID0gcGFyc2VkWm9uZSB8fCB6b25lLFxuICAgICAgICBpbnN0ID0gRGF0ZVRpbWUuZnJvbU9iamVjdChPYmplY3QuYXNzaWduKHBhcnNlZCwgb3B0cywge1xuICAgICAgem9uZTogaW50ZXJwcmV0YXRpb25ab25lLFxuICAgICAgLy8gc2V0Wm9uZSBpcyBhIHZhbGlkIG9wdGlvbiBpbiB0aGUgY2FsbGluZyBtZXRob2RzLCBidXQgbm90IGluIGZyb21PYmplY3RcbiAgICAgIHNldFpvbmU6IHVuZGVmaW5lZFxuICAgIH0pKTtcbiAgICByZXR1cm4gc2V0Wm9uZSA/IGluc3QgOiBpbnN0LnNldFpvbmUoem9uZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQobmV3IEludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIFwidGhlIGlucHV0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgY2FuJ3QgYmUgcGFyc2VkIGFzIFwiICsgZm9ybWF0KSk7XG4gIH1cbn0gLy8gaWYgeW91IHdhbnQgdG8gb3V0cHV0IGEgdGVjaG5pY2FsIGZvcm1hdCAoZS5nLiBSRkMgMjgyMiksIHRoaXMgaGVscGVyXG4vLyBoZWxwcyBoYW5kbGUgdGhlIGRldGFpbHNcblxuXG5mdW5jdGlvbiB0b1RlY2hGb3JtYXQoZHQsIGZvcm1hdCwgYWxsb3daKSB7XG4gIGlmIChhbGxvd1ogPT09IHZvaWQgMCkge1xuICAgIGFsbG93WiA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gZHQuaXNWYWxpZCA/IEZvcm1hdHRlci5jcmVhdGUoTG9jYWxlLmNyZWF0ZShcImVuLVVTXCIpLCB7XG4gICAgYWxsb3daOiBhbGxvd1osXG4gICAgZm9yY2VTaW1wbGU6IHRydWVcbiAgfSkuZm9ybWF0RGF0ZVRpbWVGcm9tU3RyaW5nKGR0LCBmb3JtYXQpIDogbnVsbDtcbn0gLy8gdGVjaG5pY2FsIHRpbWUgZm9ybWF0cyAoZS5nLiB0aGUgdGltZSBwYXJ0IG9mIElTTyA4NjAxKSwgdGFrZSBzb21lIG9wdGlvbnNcbi8vIGFuZCB0aGlzIGNvbW1vbml6ZXMgdGhlaXIgaGFuZGxpbmdcblxuXG5mdW5jdGlvbiB0b1RlY2hUaW1lRm9ybWF0KGR0LCBfcmVmKSB7XG4gIHZhciBfcmVmJHN1cHByZXNzU2Vjb25kcyA9IF9yZWYuc3VwcHJlc3NTZWNvbmRzLFxuICAgICAgc3VwcHJlc3NTZWNvbmRzID0gX3JlZiRzdXBwcmVzc1NlY29uZHMgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRzdXBwcmVzc1NlY29uZHMsXG4gICAgICBfcmVmJHN1cHByZXNzTWlsbGlzZWMgPSBfcmVmLnN1cHByZXNzTWlsbGlzZWNvbmRzLFxuICAgICAgc3VwcHJlc3NNaWxsaXNlY29uZHMgPSBfcmVmJHN1cHByZXNzTWlsbGlzZWMgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRzdXBwcmVzc01pbGxpc2VjLFxuICAgICAgaW5jbHVkZU9mZnNldCA9IF9yZWYuaW5jbHVkZU9mZnNldCxcbiAgICAgIF9yZWYkaW5jbHVkZVpvbmUgPSBfcmVmLmluY2x1ZGVab25lLFxuICAgICAgaW5jbHVkZVpvbmUgPSBfcmVmJGluY2x1ZGVab25lID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkaW5jbHVkZVpvbmUsXG4gICAgICBfcmVmJHNwYWNlWm9uZSA9IF9yZWYuc3BhY2Vab25lLFxuICAgICAgc3BhY2Vab25lID0gX3JlZiRzcGFjZVpvbmUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRzcGFjZVpvbmUsXG4gICAgICBfcmVmJGZvcm1hdCA9IF9yZWYuZm9ybWF0LFxuICAgICAgZm9ybWF0ID0gX3JlZiRmb3JtYXQgPT09IHZvaWQgMCA/IFwiZXh0ZW5kZWRcIiA6IF9yZWYkZm9ybWF0O1xuICB2YXIgZm10ID0gZm9ybWF0ID09PSBcImJhc2ljXCIgPyBcIkhIbW1cIiA6IFwiSEg6bW1cIjtcblxuICBpZiAoIXN1cHByZXNzU2Vjb25kcyB8fCBkdC5zZWNvbmQgIT09IDAgfHwgZHQubWlsbGlzZWNvbmQgIT09IDApIHtcbiAgICBmbXQgKz0gZm9ybWF0ID09PSBcImJhc2ljXCIgPyBcInNzXCIgOiBcIjpzc1wiO1xuXG4gICAgaWYgKCFzdXBwcmVzc01pbGxpc2Vjb25kcyB8fCBkdC5taWxsaXNlY29uZCAhPT0gMCkge1xuICAgICAgZm10ICs9IFwiLlNTU1wiO1xuICAgIH1cbiAgfVxuXG4gIGlmICgoaW5jbHVkZVpvbmUgfHwgaW5jbHVkZU9mZnNldCkgJiYgc3BhY2Vab25lKSB7XG4gICAgZm10ICs9IFwiIFwiO1xuICB9XG5cbiAgaWYgKGluY2x1ZGVab25lKSB7XG4gICAgZm10ICs9IFwielwiO1xuICB9IGVsc2UgaWYgKGluY2x1ZGVPZmZzZXQpIHtcbiAgICBmbXQgKz0gZm9ybWF0ID09PSBcImJhc2ljXCIgPyBcIlpaWlwiIDogXCJaWlwiO1xuICB9XG5cbiAgcmV0dXJuIHRvVGVjaEZvcm1hdChkdCwgZm10KTtcbn0gLy8gZGVmYXVsdHMgZm9yIHVuc3BlY2lmaWVkIHVuaXRzIGluIHRoZSBzdXBwb3J0ZWQgY2FsZW5kYXJzXG5cblxudmFyIGRlZmF1bHRVbml0VmFsdWVzID0ge1xuICBtb250aDogMSxcbiAgZGF5OiAxLFxuICBob3VyOiAwLFxuICBtaW51dGU6IDAsXG4gIHNlY29uZDogMCxcbiAgbWlsbGlzZWNvbmQ6IDBcbn0sXG4gICAgZGVmYXVsdFdlZWtVbml0VmFsdWVzID0ge1xuICB3ZWVrTnVtYmVyOiAxLFxuICB3ZWVrZGF5OiAxLFxuICBob3VyOiAwLFxuICBtaW51dGU6IDAsXG4gIHNlY29uZDogMCxcbiAgbWlsbGlzZWNvbmQ6IDBcbn0sXG4gICAgZGVmYXVsdE9yZGluYWxVbml0VmFsdWVzID0ge1xuICBvcmRpbmFsOiAxLFxuICBob3VyOiAwLFxuICBtaW51dGU6IDAsXG4gIHNlY29uZDogMCxcbiAgbWlsbGlzZWNvbmQ6IDBcbn07IC8vIFVuaXRzIGluIHRoZSBzdXBwb3J0ZWQgY2FsZW5kYXJzLCBzb3J0ZWQgYnkgYmlnbmVzc1xuXG52YXIgb3JkZXJlZFVuaXRzJDEgPSBbXCJ5ZWFyXCIsIFwibW9udGhcIiwgXCJkYXlcIiwgXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIl0sXG4gICAgb3JkZXJlZFdlZWtVbml0cyA9IFtcIndlZWtZZWFyXCIsIFwid2Vla051bWJlclwiLCBcIndlZWtkYXlcIiwgXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIl0sXG4gICAgb3JkZXJlZE9yZGluYWxVbml0cyA9IFtcInllYXJcIiwgXCJvcmRpbmFsXCIsIFwiaG91clwiLCBcIm1pbnV0ZVwiLCBcInNlY29uZFwiLCBcIm1pbGxpc2Vjb25kXCJdOyAvLyBzdGFuZGFyZGl6ZSBjYXNlIGFuZCBwbHVyYWxpdHkgaW4gdW5pdHNcblxuZnVuY3Rpb24gbm9ybWFsaXplVW5pdCh1bml0KSB7XG4gIHZhciBub3JtYWxpemVkID0ge1xuICAgIHllYXI6IFwieWVhclwiLFxuICAgIHllYXJzOiBcInllYXJcIixcbiAgICBtb250aDogXCJtb250aFwiLFxuICAgIG1vbnRoczogXCJtb250aFwiLFxuICAgIGRheTogXCJkYXlcIixcbiAgICBkYXlzOiBcImRheVwiLFxuICAgIGhvdXI6IFwiaG91clwiLFxuICAgIGhvdXJzOiBcImhvdXJcIixcbiAgICBtaW51dGU6IFwibWludXRlXCIsXG4gICAgbWludXRlczogXCJtaW51dGVcIixcbiAgICBxdWFydGVyOiBcInF1YXJ0ZXJcIixcbiAgICBxdWFydGVyczogXCJxdWFydGVyXCIsXG4gICAgc2Vjb25kOiBcInNlY29uZFwiLFxuICAgIHNlY29uZHM6IFwic2Vjb25kXCIsXG4gICAgbWlsbGlzZWNvbmQ6IFwibWlsbGlzZWNvbmRcIixcbiAgICBtaWxsaXNlY29uZHM6IFwibWlsbGlzZWNvbmRcIixcbiAgICB3ZWVrZGF5OiBcIndlZWtkYXlcIixcbiAgICB3ZWVrZGF5czogXCJ3ZWVrZGF5XCIsXG4gICAgd2Vla251bWJlcjogXCJ3ZWVrTnVtYmVyXCIsXG4gICAgd2Vla3NudW1iZXI6IFwid2Vla051bWJlclwiLFxuICAgIHdlZWtudW1iZXJzOiBcIndlZWtOdW1iZXJcIixcbiAgICB3ZWVreWVhcjogXCJ3ZWVrWWVhclwiLFxuICAgIHdlZWt5ZWFyczogXCJ3ZWVrWWVhclwiLFxuICAgIG9yZGluYWw6IFwib3JkaW5hbFwiXG4gIH1bdW5pdC50b0xvd2VyQ2FzZSgpXTtcbiAgaWYgKCFub3JtYWxpemVkKSB0aHJvdyBuZXcgSW52YWxpZFVuaXRFcnJvcih1bml0KTtcbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59IC8vIHRoaXMgaXMgYSBkdW1iZWQgZG93biB2ZXJzaW9uIG9mIGZyb21PYmplY3QoKSB0aGF0IHJ1bnMgYWJvdXQgNjAlIGZhc3RlclxuLy8gYnV0IGRvZXNuJ3QgZG8gYW55IHZhbGlkYXRpb24sIG1ha2VzIGEgYnVuY2ggb2YgYXNzdW1wdGlvbnMgYWJvdXQgd2hhdCB1bml0c1xuLy8gYXJlIHByZXNlbnQsIGFuZCBzbyBvbi5cblxuXG5mdW5jdGlvbiBxdWlja0RUKG9iaiwgem9uZSkge1xuICAvLyBhc3N1bWUgd2UgaGF2ZSB0aGUgaGlnaGVyLW9yZGVyIHVuaXRzXG4gIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2Uob3JkZXJlZFVuaXRzJDEpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgIHZhciB1ID0gX3N0ZXAudmFsdWU7XG5cbiAgICBpZiAoaXNVbmRlZmluZWQob2JqW3VdKSkge1xuICAgICAgb2JqW3VdID0gZGVmYXVsdFVuaXRWYWx1ZXNbdV07XG4gICAgfVxuICB9XG5cbiAgdmFyIGludmFsaWQgPSBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YShvYmopIHx8IGhhc0ludmFsaWRUaW1lRGF0YShvYmopO1xuXG4gIGlmIChpbnZhbGlkKSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoaW52YWxpZCk7XG4gIH1cblxuICB2YXIgdHNOb3cgPSBTZXR0aW5ncy5ub3coKSxcbiAgICAgIG9mZnNldFByb3ZpcyA9IHpvbmUub2Zmc2V0KHRzTm93KSxcbiAgICAgIF9vYmpUb1RTID0gb2JqVG9UUyhvYmosIG9mZnNldFByb3Zpcywgem9uZSksXG4gICAgICB0cyA9IF9vYmpUb1RTWzBdLFxuICAgICAgbyA9IF9vYmpUb1RTWzFdO1xuXG4gIHJldHVybiBuZXcgRGF0ZVRpbWUoe1xuICAgIHRzOiB0cyxcbiAgICB6b25lOiB6b25lLFxuICAgIG86IG9cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRpZmZSZWxhdGl2ZShzdGFydCwgZW5kLCBvcHRzKSB7XG4gIHZhciByb3VuZCA9IGlzVW5kZWZpbmVkKG9wdHMucm91bmQpID8gdHJ1ZSA6IG9wdHMucm91bmQsXG4gICAgICBmb3JtYXQgPSBmdW5jdGlvbiBmb3JtYXQoYywgdW5pdCkge1xuICAgIGMgPSByb3VuZFRvKGMsIHJvdW5kIHx8IG9wdHMuY2FsZW5kYXJ5ID8gMCA6IDIsIHRydWUpO1xuICAgIHZhciBmb3JtYXR0ZXIgPSBlbmQubG9jLmNsb25lKG9wdHMpLnJlbEZvcm1hdHRlcihvcHRzKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdChjLCB1bml0KTtcbiAgfSxcbiAgICAgIGRpZmZlciA9IGZ1bmN0aW9uIGRpZmZlcih1bml0KSB7XG4gICAgaWYgKG9wdHMuY2FsZW5kYXJ5KSB7XG4gICAgICBpZiAoIWVuZC5oYXNTYW1lKHN0YXJ0LCB1bml0KSkge1xuICAgICAgICByZXR1cm4gZW5kLnN0YXJ0T2YodW5pdCkuZGlmZihzdGFydC5zdGFydE9mKHVuaXQpLCB1bml0KS5nZXQodW5pdCk7XG4gICAgICB9IGVsc2UgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbmQuZGlmZihzdGFydCwgdW5pdCkuZ2V0KHVuaXQpO1xuICAgIH1cbiAgfTtcblxuICBpZiAob3B0cy51bml0KSB7XG4gICAgcmV0dXJuIGZvcm1hdChkaWZmZXIob3B0cy51bml0KSwgb3B0cy51bml0KTtcbiAgfVxuXG4gIGZvciAodmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG9wdHMudW5pdHMpLCBfc3RlcDI7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMigpKS5kb25lOykge1xuICAgIHZhciB1bml0ID0gX3N0ZXAyLnZhbHVlO1xuICAgIHZhciBjb3VudCA9IGRpZmZlcih1bml0KTtcblxuICAgIGlmIChNYXRoLmFicyhjb3VudCkgPj0gMSkge1xuICAgICAgcmV0dXJuIGZvcm1hdChjb3VudCwgdW5pdCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvcm1hdCgwLCBvcHRzLnVuaXRzW29wdHMudW5pdHMubGVuZ3RoIC0gMV0pO1xufVxuLyoqXG4gKiBBIERhdGVUaW1lIGlzIGFuIGltbXV0YWJsZSBkYXRhIHN0cnVjdHVyZSByZXByZXNlbnRpbmcgYSBzcGVjaWZpYyBkYXRlIGFuZCB0aW1lIGFuZCBhY2NvbXBhbnlpbmcgbWV0aG9kcy4gSXQgY29udGFpbnMgY2xhc3MgYW5kIGluc3RhbmNlIG1ldGhvZHMgZm9yIGNyZWF0aW5nLCBwYXJzaW5nLCBpbnRlcnJvZ2F0aW5nLCB0cmFuc2Zvcm1pbmcsIGFuZCBmb3JtYXR0aW5nIHRoZW0uXG4gKlxuICogQSBEYXRlVGltZSBjb21wcmlzZXMgb2Y6XG4gKiAqIEEgdGltZXN0YW1wLiBFYWNoIERhdGVUaW1lIGluc3RhbmNlIHJlZmVycyB0byBhIHNwZWNpZmljIG1pbGxpc2Vjb25kIG9mIHRoZSBVbml4IGVwb2NoLlxuICogKiBBIHRpbWUgem9uZS4gRWFjaCBpbnN0YW5jZSBpcyBjb25zaWRlcmVkIGluIHRoZSBjb250ZXh0IG9mIGEgc3BlY2lmaWMgem9uZSAoYnkgZGVmYXVsdCB0aGUgbG9jYWwgc3lzdGVtJ3Mgem9uZSkuXG4gKiAqIENvbmZpZ3VyYXRpb24gcHJvcGVydGllcyB0aGF0IGVmZmVjdCBob3cgb3V0cHV0IHN0cmluZ3MgYXJlIGZvcm1hdHRlZCwgc3VjaCBhcyBgbG9jYWxlYCwgYG51bWJlcmluZ1N5c3RlbWAsIGFuZCBgb3V0cHV0Q2FsZW5kYXJgLlxuICpcbiAqIEhlcmUgaXMgYSBicmllZiBvdmVydmlldyBvZiB0aGUgbW9zdCBjb21tb25seSB1c2VkIGZ1bmN0aW9uYWxpdHkgaXQgcHJvdmlkZXM6XG4gKlxuICogKiAqKkNyZWF0aW9uKio6IFRvIGNyZWF0ZSBhIERhdGVUaW1lIGZyb20gaXRzIGNvbXBvbmVudHMsIHVzZSBvbmUgb2YgaXRzIGZhY3RvcnkgY2xhc3MgbWV0aG9kczoge0BsaW5rIGxvY2FsfSwge0BsaW5rIHV0Y30sIGFuZCAobW9zdCBmbGV4aWJseSkge0BsaW5rIGZyb21PYmplY3R9LiBUbyBjcmVhdGUgb25lIGZyb20gYSBzdGFuZGFyZCBzdHJpbmcgZm9ybWF0LCB1c2Uge0BsaW5rIGZyb21JU099LCB7QGxpbmsgZnJvbUhUVFB9LCBhbmQge0BsaW5rIGZyb21SRkMyODIyfS4gVG8gY3JlYXRlIG9uZSBmcm9tIGEgY3VzdG9tIHN0cmluZyBmb3JtYXQsIHVzZSB7QGxpbmsgZnJvbUZvcm1hdH0uIFRvIGNyZWF0ZSBvbmUgZnJvbSBhIG5hdGl2ZSBKUyBkYXRlLCB1c2Uge0BsaW5rIGZyb21KU0RhdGV9LlxuICogKiAqKkdyZWdvcmlhbiBjYWxlbmRhciBhbmQgdGltZSoqOiBUbyBleGFtaW5lIHRoZSBHcmVnb3JpYW4gcHJvcGVydGllcyBvZiBhIERhdGVUaW1lIGluZGl2aWR1YWxseSAoaS5lIGFzIG9wcG9zZWQgdG8gY29sbGVjdGl2ZWx5IHRocm91Z2gge0BsaW5rIHRvT2JqZWN0fSksIHVzZSB0aGUge0BsaW5rIHllYXJ9LCB7QGxpbmsgbW9udGh9LFxuICoge0BsaW5rIGRheX0sIHtAbGluayBob3VyfSwge0BsaW5rIG1pbnV0ZX0sIHtAbGluayBzZWNvbmR9LCB7QGxpbmsgbWlsbGlzZWNvbmR9IGFjY2Vzc29ycy5cbiAqICogKipXZWVrIGNhbGVuZGFyKio6IEZvciBJU08gd2VlayBjYWxlbmRhciBhdHRyaWJ1dGVzLCBzZWUgdGhlIHtAbGluayB3ZWVrWWVhcn0sIHtAbGluayB3ZWVrTnVtYmVyfSwgYW5kIHtAbGluayB3ZWVrZGF5fSBhY2Nlc3NvcnMuXG4gKiAqICoqQ29uZmlndXJhdGlvbioqIFNlZSB0aGUge0BsaW5rIGxvY2FsZX0gYW5kIHtAbGluayBudW1iZXJpbmdTeXN0ZW19IGFjY2Vzc29ycy5cbiAqICogKipUcmFuc2Zvcm1hdGlvbioqOiBUbyB0cmFuc2Zvcm0gdGhlIERhdGVUaW1lIGludG8gb3RoZXIgRGF0ZVRpbWVzLCB1c2Uge0BsaW5rIHNldH0sIHtAbGluayByZWNvbmZpZ3VyZX0sIHtAbGluayBzZXRab25lfSwge0BsaW5rIHNldExvY2FsZX0sIHtAbGluayBwbHVzfSwge0BsaW5rIG1pbnVzfSwge0BsaW5rIGVuZE9mfSwge0BsaW5rIHN0YXJ0T2Z9LCB7QGxpbmsgdG9VVEN9LCBhbmQge0BsaW5rIHRvTG9jYWx9LlxuICogKiAqKk91dHB1dCoqOiBUbyBjb252ZXJ0IHRoZSBEYXRlVGltZSB0byBvdGhlciByZXByZXNlbnRhdGlvbnMsIHVzZSB0aGUge0BsaW5rIHRvUmVsYXRpdmV9LCB7QGxpbmsgdG9SZWxhdGl2ZUNhbGVuZGFyfSwge0BsaW5rIHRvSlNPTn0sIHtAbGluayB0b0lTT30sIHtAbGluayB0b0hUVFB9LCB7QGxpbmsgdG9PYmplY3R9LCB7QGxpbmsgdG9SRkMyODIyfSwge0BsaW5rIHRvU3RyaW5nfSwge0BsaW5rIHRvTG9jYWxlU3RyaW5nfSwge0BsaW5rIHRvRm9ybWF0fSwge0BsaW5rIHRvTWlsbGlzfSBhbmQge0BsaW5rIHRvSlNEYXRlfS5cbiAqXG4gKiBUaGVyZSdzIHBsZW50eSBvdGhlcnMgZG9jdW1lbnRlZCBiZWxvdy4gSW4gYWRkaXRpb24sIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHN1YnRsZXIgdG9waWNzIGxpa2UgaW50ZXJuYXRpb25hbGl6YXRpb24sIHRpbWUgem9uZXMsIGFsdGVybmF0aXZlIGNhbGVuZGFycywgdmFsaWRpdHksIGFuZCBzbyBvbiwgc2VlIHRoZSBleHRlcm5hbCBkb2N1bWVudGF0aW9uLlxuICovXG5cblxudmFyIERhdGVUaW1lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gRGF0ZVRpbWUoY29uZmlnKSB7XG4gICAgdmFyIHpvbmUgPSBjb25maWcuem9uZSB8fCBTZXR0aW5ncy5kZWZhdWx0Wm9uZTtcbiAgICB2YXIgaW52YWxpZCA9IGNvbmZpZy5pbnZhbGlkIHx8IChOdW1iZXIuaXNOYU4oY29uZmlnLnRzKSA/IG5ldyBJbnZhbGlkKFwiaW52YWxpZCBpbnB1dFwiKSA6IG51bGwpIHx8ICghem9uZS5pc1ZhbGlkID8gdW5zdXBwb3J0ZWRab25lKHpvbmUpIDogbnVsbCk7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG5cbiAgICB0aGlzLnRzID0gaXNVbmRlZmluZWQoY29uZmlnLnRzKSA/IFNldHRpbmdzLm5vdygpIDogY29uZmlnLnRzO1xuICAgIHZhciBjID0gbnVsbCxcbiAgICAgICAgbyA9IG51bGw7XG5cbiAgICBpZiAoIWludmFsaWQpIHtcbiAgICAgIHZhciB1bmNoYW5nZWQgPSBjb25maWcub2xkICYmIGNvbmZpZy5vbGQudHMgPT09IHRoaXMudHMgJiYgY29uZmlnLm9sZC56b25lLmVxdWFscyh6b25lKTtcblxuICAgICAgaWYgKHVuY2hhbmdlZCkge1xuICAgICAgICB2YXIgX3JlZjIgPSBbY29uZmlnLm9sZC5jLCBjb25maWcub2xkLm9dO1xuICAgICAgICBjID0gX3JlZjJbMF07XG4gICAgICAgIG8gPSBfcmVmMlsxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvdCA9IHpvbmUub2Zmc2V0KHRoaXMudHMpO1xuICAgICAgICBjID0gdHNUb09iaih0aGlzLnRzLCBvdCk7XG4gICAgICAgIGludmFsaWQgPSBOdW1iZXIuaXNOYU4oYy55ZWFyKSA/IG5ldyBJbnZhbGlkKFwiaW52YWxpZCBpbnB1dFwiKSA6IG51bGw7XG4gICAgICAgIGMgPSBpbnZhbGlkID8gbnVsbCA6IGM7XG4gICAgICAgIG8gPSBpbnZhbGlkID8gbnVsbCA6IG90O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgdGhpcy5fem9uZSA9IHpvbmU7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG5cbiAgICB0aGlzLmxvYyA9IGNvbmZpZy5sb2MgfHwgTG9jYWxlLmNyZWF0ZSgpO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5pbnZhbGlkID0gaW52YWxpZDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMud2Vla0RhdGEgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5jID0gYztcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMubyA9IG87XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG5cbiAgICB0aGlzLmlzTHV4b25EYXRlVGltZSA9IHRydWU7XG4gIH0gLy8gQ09OU1RSVUNUXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGxvY2FsIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeWVhcl0gLSBUaGUgY2FsZW5kYXIgeWVhci4gSWYgb21pdHRlZCAoYXMgaW4sIGNhbGwgYGxvY2FsKClgIHdpdGggbm8gYXJndW1lbnRzKSwgdGhlIGN1cnJlbnQgdGltZSB3aWxsIGJlIHVzZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttb250aD0xXSAtIFRoZSBtb250aCwgMS1pbmRleGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF5PTFdIC0gVGhlIGRheSBvZiB0aGUgbW9udGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtob3VyPTBdIC0gVGhlIGhvdXIgb2YgdGhlIGRheSwgaW4gMjQtaG91ciB0aW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWludXRlPTBdIC0gVGhlIG1pbnV0ZSBvZiB0aGUgaG91ciwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kPTBdIC0gVGhlIHNlY29uZCBvZiB0aGUgbWludXRlLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaWxsaXNlY29uZD0wXSAtIFRoZSBtaWxsaXNlY29uZCBvZiB0aGUgc2Vjb25kLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgOTk5XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiBub3dcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNykgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDEtMDFUMDA6MDA6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMykgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMDFUMDA6MDA6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIpICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDA6MDA6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUpICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6MDA6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1KSAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCkgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCwgNzY1KSAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTAuNzY1XG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cblxuXG4gIERhdGVUaW1lLmxvY2FsID0gZnVuY3Rpb24gbG9jYWwoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kKSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKHllYXIpKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGVUaW1lKHtcbiAgICAgICAgdHM6IFNldHRpbmdzLm5vdygpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHF1aWNrRFQoe1xuICAgICAgICB5ZWFyOiB5ZWFyLFxuICAgICAgICBtb250aDogbW9udGgsXG4gICAgICAgIGRheTogZGF5LFxuICAgICAgICBob3VyOiBob3VyLFxuICAgICAgICBtaW51dGU6IG1pbnV0ZSxcbiAgICAgICAgc2Vjb25kOiBzZWNvbmQsXG4gICAgICAgIG1pbGxpc2Vjb25kOiBtaWxsaXNlY29uZFxuICAgICAgfSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgaW4gVVRDXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeWVhcl0gLSBUaGUgY2FsZW5kYXIgeWVhci4gSWYgb21pdHRlZCAoYXMgaW4sIGNhbGwgYHV0YygpYCB3aXRoIG5vIGFyZ3VtZW50cyksIHRoZSBjdXJyZW50IHRpbWUgd2lsbCBiZSB1c2VkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbW9udGg9MV0gLSBUaGUgbW9udGgsIDEtaW5kZXhlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RheT0xXSAtIFRoZSBkYXkgb2YgdGhlIG1vbnRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaG91cj0wXSAtIFRoZSBob3VyIG9mIHRoZSBkYXksIGluIDI0LWhvdXIgdGltZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbnV0ZT0wXSAtIFRoZSBtaW51dGUgb2YgdGhlIGhvdXIsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlY29uZD0wXSAtIFRoZSBzZWNvbmQgb2YgdGhlIG1pbnV0ZSwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWlsbGlzZWNvbmQ9MF0gLSBUaGUgbWlsbGlzZWNvbmQgb2YgdGhlIHNlY29uZCwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDk5OVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IG5vd1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNykgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDEtMDFUMDA6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzKSAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0wMVQwMDowMDowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyKSAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDAwOjAwOjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUpICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSwgNDUpICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NTowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1LCA0NSwgMTApICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjEwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCwgNzY1KSAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTAuNzY1WlxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIDtcblxuICBEYXRlVGltZS51dGMgPSBmdW5jdGlvbiB1dGMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kKSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKHllYXIpKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGVUaW1lKHtcbiAgICAgICAgdHM6IFNldHRpbmdzLm5vdygpLFxuICAgICAgICB6b25lOiBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcXVpY2tEVCh7XG4gICAgICAgIHllYXI6IHllYXIsXG4gICAgICAgIG1vbnRoOiBtb250aCxcbiAgICAgICAgZGF5OiBkYXksXG4gICAgICAgIGhvdXI6IGhvdXIsXG4gICAgICAgIG1pbnV0ZTogbWludXRlLFxuICAgICAgICBzZWNvbmQ6IHNlY29uZCxcbiAgICAgICAgbWlsbGlzZWNvbmQ6IG1pbGxpc2Vjb25kXG4gICAgICB9LCBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIEphdmFzY3JpcHQgRGF0ZSBvYmplY3QuIFVzZXMgdGhlIGRlZmF1bHQgem9uZS5cbiAgICogQHBhcmFtIHtEYXRlfSBkYXRlIC0gYSBKYXZhc2NyaXB0IERhdGUgb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdGlvbnMuem9uZT0nbG9jYWwnXSAtIHRoZSB6b25lIHRvIHBsYWNlIHRoZSBEYXRlVGltZSBpbnRvXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgO1xuXG4gIERhdGVUaW1lLmZyb21KU0RhdGUgPSBmdW5jdGlvbiBmcm9tSlNEYXRlKGRhdGUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIHRzID0gaXNEYXRlKGRhdGUpID8gZGF0ZS52YWx1ZU9mKCkgOiBOYU47XG5cbiAgICBpZiAoTnVtYmVyLmlzTmFOKHRzKSkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXCJpbnZhbGlkIGlucHV0XCIpO1xuICAgIH1cblxuICAgIHZhciB6b25lVG9Vc2UgPSBub3JtYWxpemVab25lKG9wdGlvbnMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuXG4gICAgaWYgKCF6b25lVG9Vc2UuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQodW5zdXBwb3J0ZWRab25lKHpvbmVUb1VzZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe1xuICAgICAgdHM6IHRzLFxuICAgICAgem9uZTogem9uZVRvVXNlLFxuICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRpb25zKVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2ggKG1lYW5pbmcgc2luY2UgMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS4gVXNlcyB0aGUgZGVmYXVsdCB6b25lLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWlsbGlzZWNvbmRzIC0gYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIDE5NzAgVVRDXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdGlvbnMuem9uZT0nbG9jYWwnXSAtIHRoZSB6b25lIHRvIHBsYWNlIHRoZSBEYXRlVGltZSBpbnRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGVdIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgO1xuXG4gIERhdGVUaW1lLmZyb21NaWxsaXMgPSBmdW5jdGlvbiBmcm9tTWlsbGlzKG1pbGxpc2Vjb25kcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoIWlzTnVtYmVyKG1pbGxpc2Vjb25kcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImZyb21NaWxsaXMgcmVxdWlyZXMgYSBudW1lcmljYWwgaW5wdXQsIGJ1dCByZWNlaXZlZCBhIFwiICsgdHlwZW9mIG1pbGxpc2Vjb25kcyArIFwiIHdpdGggdmFsdWUgXCIgKyBtaWxsaXNlY29uZHMpO1xuICAgIH0gZWxzZSBpZiAobWlsbGlzZWNvbmRzIDwgLU1BWF9EQVRFIHx8IG1pbGxpc2Vjb25kcyA+IE1BWF9EQVRFKSB7XG4gICAgICAvLyB0aGlzIGlzbid0IHBlcmZlY3QgYmVjYXVzZSBiZWNhdXNlIHdlIGNhbiBzdGlsbCBlbmQgdXAgb3V0IG9mIHJhbmdlIGJlY2F1c2Ugb2YgYWRkaXRpb25hbCBzaGlmdGluZywgYnV0IGl0J3MgYSBzdGFydFxuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXCJUaW1lc3RhbXAgb3V0IG9mIHJhbmdlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IERhdGVUaW1lKHtcbiAgICAgICAgdHM6IG1pbGxpc2Vjb25kcyxcbiAgICAgICAgem9uZTogbm9ybWFsaXplWm9uZShvcHRpb25zLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKSxcbiAgICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRpb25zKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgdGhlIGVwb2NoIChtZWFuaW5nIHNpbmNlIDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuIFVzZXMgdGhlIGRlZmF1bHQgem9uZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlY29uZHMgLSBhIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIDE5NzAgVVRDXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdGlvbnMuem9uZT0nbG9jYWwnXSAtIHRoZSB6b25lIHRvIHBsYWNlIHRoZSBEYXRlVGltZSBpbnRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGVdIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgO1xuXG4gIERhdGVUaW1lLmZyb21TZWNvbmRzID0gZnVuY3Rpb24gZnJvbVNlY29uZHMoc2Vjb25kcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoIWlzTnVtYmVyKHNlY29uZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJmcm9tU2Vjb25kcyByZXF1aXJlcyBhIG51bWVyaWNhbCBpbnB1dFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZSh7XG4gICAgICAgIHRzOiBzZWNvbmRzICogMTAwMCxcbiAgICAgICAgem9uZTogbm9ybWFsaXplWm9uZShvcHRpb25zLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKSxcbiAgICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRpb25zKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgSmF2YXNjcmlwdCBvYmplY3Qgd2l0aCBrZXlzIGxpa2UgJ3llYXInIGFuZCAnaG91cicgd2l0aCByZWFzb25hYmxlIGRlZmF1bHRzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gdGhlIG9iamVjdCB0byBjcmVhdGUgdGhlIERhdGVUaW1lIGZyb21cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai55ZWFyIC0gYSB5ZWFyLCBzdWNoIGFzIDE5ODdcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5tb250aCAtIGEgbW9udGgsIDEtMTJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5kYXkgLSBhIGRheSBvZiB0aGUgbW9udGgsIDEtMzEsIGRlcGVuZGluZyBvbiB0aGUgbW9udGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5vcmRpbmFsIC0gZGF5IG9mIHRoZSB5ZWFyLCAxLTM2NSBvciAzNjZcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai53ZWVrWWVhciAtIGFuIElTTyB3ZWVrIHllYXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai53ZWVrTnVtYmVyIC0gYW4gSVNPIHdlZWsgbnVtYmVyLCBiZXR3ZWVuIDEgYW5kIDUyIG9yIDUzLCBkZXBlbmRpbmcgb24gdGhlIHllYXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai53ZWVrZGF5IC0gYW4gSVNPIHdlZWtkYXksIDEtNywgd2hlcmUgMSBpcyBNb25kYXkgYW5kIDcgaXMgU3VuZGF5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouaG91ciAtIGhvdXIgb2YgdGhlIGRheSwgMC0yM1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1pbnV0ZSAtIG1pbnV0ZSBvZiB0aGUgaG91ciwgMC01OVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnNlY29uZCAtIHNlY29uZCBvZiB0aGUgbWludXRlLCAwLTU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubWlsbGlzZWNvbmQgLSBtaWxsaXNlY29uZCBvZiB0aGUgc2Vjb25kLCAwLTk5OVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb2JqLnpvbmU9J2xvY2FsJ10gLSBpbnRlcnByZXQgdGhlIG51bWJlcnMgaW4gdGhlIGNvbnRleHQgb2YgYSBwYXJ0aWN1bGFyIHpvbmUuIENhbiB0YWtlIGFueSB2YWx1ZSB0YWtlbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gc2V0Wm9uZSgpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb2JqLmxvY2FsZT0nc3lzdGVtJ3MgbG9jYWxlJ10gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2JqLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2JqLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB5ZWFyOiAxOTgyLCBtb250aDogNSwgZGF5OiAyNX0pLnRvSVNPRGF0ZSgpIC8vPT4gJzE5ODItMDUtMjUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB5ZWFyOiAxOTgyIH0pLnRvSVNPRGF0ZSgpIC8vPT4gJzE5ODItMDEtMDEnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0pIC8vfj4gdG9kYXkgYXQgMTA6MjY6MDZcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IGhvdXI6IDEwLCBtaW51dGU6IDI2LCBzZWNvbmQ6IDYsIHpvbmU6ICd1dGMnIH0pLFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgaG91cjogMTAsIG1pbnV0ZTogMjYsIHNlY29uZDogNiwgem9uZTogJ2xvY2FsJyB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgaG91cjogMTAsIG1pbnV0ZTogMjYsIHNlY29uZDogNiwgem9uZTogJ0FtZXJpY2EvTmV3X1lvcmsnIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB3ZWVrWWVhcjogMjAxNiwgd2Vla051bWJlcjogMiwgd2Vla2RheTogMyB9KS50b0lTT0RhdGUoKSAvLz0+ICcyMDE2LTAxLTEzJ1xuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIDtcblxuICBEYXRlVGltZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmopIHtcbiAgICB2YXIgem9uZVRvVXNlID0gbm9ybWFsaXplWm9uZShvYmouem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuXG4gICAgaWYgKCF6b25lVG9Vc2UuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQodW5zdXBwb3J0ZWRab25lKHpvbmVUb1VzZSkpO1xuICAgIH1cblxuICAgIHZhciB0c05vdyA9IFNldHRpbmdzLm5vdygpLFxuICAgICAgICBvZmZzZXRQcm92aXMgPSB6b25lVG9Vc2Uub2Zmc2V0KHRzTm93KSxcbiAgICAgICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZU9iamVjdChvYmosIG5vcm1hbGl6ZVVuaXQsIFtcInpvbmVcIiwgXCJsb2NhbGVcIiwgXCJvdXRwdXRDYWxlbmRhclwiLCBcIm51bWJlcmluZ1N5c3RlbVwiXSksXG4gICAgICAgIGNvbnRhaW5zT3JkaW5hbCA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLm9yZGluYWwpLFxuICAgICAgICBjb250YWluc0dyZWdvclllYXIgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC55ZWFyKSxcbiAgICAgICAgY29udGFpbnNHcmVnb3JNRCA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLm1vbnRoKSB8fCAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5kYXkpLFxuICAgICAgICBjb250YWluc0dyZWdvciA9IGNvbnRhaW5zR3JlZ29yWWVhciB8fCBjb250YWluc0dyZWdvck1ELFxuICAgICAgICBkZWZpbml0ZVdlZWtEZWYgPSBub3JtYWxpemVkLndlZWtZZWFyIHx8IG5vcm1hbGl6ZWQud2Vla051bWJlcixcbiAgICAgICAgbG9jID0gTG9jYWxlLmZyb21PYmplY3Qob2JqKTsgLy8gY2FzZXM6XG4gICAgLy8ganVzdCBhIHdlZWtkYXkgLT4gdGhpcyB3ZWVrJ3MgaW5zdGFuY2Ugb2YgdGhhdCB3ZWVrZGF5LCBubyB3b3JyaWVzXG4gICAgLy8gKGdyZWdvcmlhbiBkYXRhIG9yIG9yZGluYWwpICsgKHdlZWtZZWFyIG9yIHdlZWtOdW1iZXIpIC0+IGVycm9yXG4gICAgLy8gKGdyZWdvcmlhbiBtb250aCBvciBkYXkpICsgb3JkaW5hbCAtPiBlcnJvclxuICAgIC8vIG90aGVyd2lzZSBqdXN0IHVzZSB3ZWVrcyBvciBvcmRpbmFscyBvciBncmVnb3JpYW4sIGRlcGVuZGluZyBvbiB3aGF0J3Mgc3BlY2lmaWVkXG5cbiAgICBpZiAoKGNvbnRhaW5zR3JlZ29yIHx8IGNvbnRhaW5zT3JkaW5hbCkgJiYgZGVmaW5pdGVXZWVrRGVmKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXCJDYW4ndCBtaXggd2Vla1llYXIvd2Vla051bWJlciB1bml0cyB3aXRoIHllYXIvbW9udGgvZGF5IG9yIG9yZGluYWxzXCIpO1xuICAgIH1cblxuICAgIGlmIChjb250YWluc0dyZWdvck1EICYmIGNvbnRhaW5zT3JkaW5hbCkge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFwiQ2FuJ3QgbWl4IG9yZGluYWwgZGF0ZXMgd2l0aCBtb250aC9kYXlcIik7XG4gICAgfVxuXG4gICAgdmFyIHVzZVdlZWtEYXRhID0gZGVmaW5pdGVXZWVrRGVmIHx8IG5vcm1hbGl6ZWQud2Vla2RheSAmJiAhY29udGFpbnNHcmVnb3I7IC8vIGNvbmZpZ3VyZSBvdXJzZWx2ZXMgdG8gZGVhbCB3aXRoIGdyZWdvcmlhbiBkYXRlcyBvciB3ZWVrIHN0dWZmXG5cbiAgICB2YXIgdW5pdHMsXG4gICAgICAgIGRlZmF1bHRWYWx1ZXMsXG4gICAgICAgIG9iak5vdyA9IHRzVG9PYmoodHNOb3csIG9mZnNldFByb3Zpcyk7XG5cbiAgICBpZiAodXNlV2Vla0RhdGEpIHtcbiAgICAgIHVuaXRzID0gb3JkZXJlZFdlZWtVbml0cztcbiAgICAgIGRlZmF1bHRWYWx1ZXMgPSBkZWZhdWx0V2Vla1VuaXRWYWx1ZXM7XG4gICAgICBvYmpOb3cgPSBncmVnb3JpYW5Ub1dlZWsob2JqTm93KTtcbiAgICB9IGVsc2UgaWYgKGNvbnRhaW5zT3JkaW5hbCkge1xuICAgICAgdW5pdHMgPSBvcmRlcmVkT3JkaW5hbFVuaXRzO1xuICAgICAgZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRPcmRpbmFsVW5pdFZhbHVlcztcbiAgICAgIG9iak5vdyA9IGdyZWdvcmlhblRvT3JkaW5hbChvYmpOb3cpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bml0cyA9IG9yZGVyZWRVbml0cyQxO1xuICAgICAgZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRVbml0VmFsdWVzO1xuICAgIH0gLy8gc2V0IGRlZmF1bHQgdmFsdWVzIGZvciBtaXNzaW5nIHN0dWZmXG5cblxuICAgIHZhciBmb3VuZEZpcnN0ID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSh1bml0cyksIF9zdGVwMzsgIShfc3RlcDMgPSBfaXRlcmF0b3IzKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgdSA9IF9zdGVwMy52YWx1ZTtcbiAgICAgIHZhciB2ID0gbm9ybWFsaXplZFt1XTtcblxuICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2KSkge1xuICAgICAgICBmb3VuZEZpcnN0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZm91bmRGaXJzdCkge1xuICAgICAgICBub3JtYWxpemVkW3VdID0gZGVmYXVsdFZhbHVlc1t1XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vcm1hbGl6ZWRbdV0gPSBvYmpOb3dbdV07XG4gICAgICB9XG4gICAgfSAvLyBtYWtlIHN1cmUgdGhlIHZhbHVlcyB3ZSBoYXZlIGFyZSBpbiByYW5nZVxuXG5cbiAgICB2YXIgaGlnaGVyT3JkZXJJbnZhbGlkID0gdXNlV2Vla0RhdGEgPyBoYXNJbnZhbGlkV2Vla0RhdGEobm9ybWFsaXplZCkgOiBjb250YWluc09yZGluYWwgPyBoYXNJbnZhbGlkT3JkaW5hbERhdGEobm9ybWFsaXplZCkgOiBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YShub3JtYWxpemVkKSxcbiAgICAgICAgaW52YWxpZCA9IGhpZ2hlck9yZGVySW52YWxpZCB8fCBoYXNJbnZhbGlkVGltZURhdGEobm9ybWFsaXplZCk7XG5cbiAgICBpZiAoaW52YWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoaW52YWxpZCk7XG4gICAgfSAvLyBjb21wdXRlIHRoZSBhY3R1YWwgdGltZVxuXG5cbiAgICB2YXIgZ3JlZ29yaWFuID0gdXNlV2Vla0RhdGEgPyB3ZWVrVG9HcmVnb3JpYW4obm9ybWFsaXplZCkgOiBjb250YWluc09yZGluYWwgPyBvcmRpbmFsVG9HcmVnb3JpYW4obm9ybWFsaXplZCkgOiBub3JtYWxpemVkLFxuICAgICAgICBfb2JqVG9UUzIgPSBvYmpUb1RTKGdyZWdvcmlhbiwgb2Zmc2V0UHJvdmlzLCB6b25lVG9Vc2UpLFxuICAgICAgICB0c0ZpbmFsID0gX29ialRvVFMyWzBdLFxuICAgICAgICBvZmZzZXRGaW5hbCA9IF9vYmpUb1RTMlsxXSxcbiAgICAgICAgaW5zdCA9IG5ldyBEYXRlVGltZSh7XG4gICAgICB0czogdHNGaW5hbCxcbiAgICAgIHpvbmU6IHpvbmVUb1VzZSxcbiAgICAgIG86IG9mZnNldEZpbmFsLFxuICAgICAgbG9jOiBsb2NcbiAgICB9KTsgLy8gZ3JlZ29yaWFuIGRhdGEgKyB3ZWVrZGF5IHNlcnZlcyBvbmx5IHRvIHZhbGlkYXRlXG5cblxuICAgIGlmIChub3JtYWxpemVkLndlZWtkYXkgJiYgY29udGFpbnNHcmVnb3IgJiYgb2JqLndlZWtkYXkgIT09IGluc3Qud2Vla2RheSkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXCJtaXNtYXRjaGVkIHdlZWtkYXlcIiwgXCJ5b3UgY2FuJ3Qgc3BlY2lmeSBib3RoIGEgd2Vla2RheSBvZiBcIiArIG5vcm1hbGl6ZWQud2Vla2RheSArIFwiIGFuZCBhIGRhdGUgb2YgXCIgKyBpbnN0LnRvSVNPKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIElTTyA4NjAxIHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBJU08gc3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSB1c2UgdGhpcyB6b25lIGlmIG5vIG9mZnNldCBpcyBzcGVjaWZpZWQgaW4gdGhlIGlucHV0IHN0cmluZyBpdHNlbGYuIFdpbGwgYWxzbyBjb252ZXJ0IHRoZSB0aW1lIHRvIHRoaXMgem9uZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIGZpeGVkLW9mZnNldCB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgaWYgaXQgc3BlY2lmaWVzIG9uZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdzeXN0ZW0ncyBsb2NhbGUnXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LTA1LTI1VDA5OjA4OjM0LjEyMycpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtMDUtMjVUMDk6MDg6MzQuMTIzKzA2OjAwJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi0wNS0yNVQwOTowODozNC4xMjMrMDY6MDAnLCB7c2V0Wm9uZTogdHJ1ZX0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtMDUtMjVUMDk6MDg6MzQuMTIzJywge3pvbmU6ICd1dGMnfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi1XMDUtNCcpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgO1xuXG4gIERhdGVUaW1lLmZyb21JU08gPSBmdW5jdGlvbiBmcm9tSVNPKHRleHQsIG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuXG4gICAgdmFyIF9wYXJzZUlTT0RhdGUgPSBwYXJzZUlTT0RhdGUodGV4dCksXG4gICAgICAgIHZhbHMgPSBfcGFyc2VJU09EYXRlWzBdLFxuICAgICAgICBwYXJzZWRab25lID0gX3BhcnNlSVNPRGF0ZVsxXTtcblxuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiSVNPIDg2MDFcIiwgdGV4dCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYW4gUkZDIDI4MjIgc3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIFJGQyAyODIyIHN0cmluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gY29udmVydCB0aGUgdGltZSB0byB0aGlzIHpvbmUuIFNpbmNlIHRoZSBvZmZzZXQgaXMgYWx3YXlzIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgdGhpcyBoYXMgbm8gZWZmZWN0IG9uIHRoZSBpbnRlcnByZXRhdGlvbiBvZiBzdHJpbmcsIG1lcmVseSB0aGUgem9uZSB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGlzIGV4cHJlc3NlZCBpbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggYSBmaXhlZC1vZmZzZXQgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIGlmIGl0IHNwZWNpZmllcyBvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nc3lzdGVtJ3MgbG9jYWxlJ10gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVJGQzI4MjIoJzI1IE5vdiAyMDE2IDEzOjIzOjEyIEdNVCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21SRkMyODIyKCdGcmksIDI1IE5vdiAyMDE2IDEzOjIzOjEyICswNjAwJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVJGQzI4MjIoJzI1IE5vdiAyMDE2IDEzOjIzIFonKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIDtcblxuICBEYXRlVGltZS5mcm9tUkZDMjgyMiA9IGZ1bmN0aW9uIGZyb21SRkMyODIyKHRleHQsIG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuXG4gICAgdmFyIF9wYXJzZVJGQzI4MjJEYXRlID0gcGFyc2VSRkMyODIyRGF0ZSh0ZXh0KSxcbiAgICAgICAgdmFscyA9IF9wYXJzZVJGQzI4MjJEYXRlWzBdLFxuICAgICAgICBwYXJzZWRab25lID0gX3BhcnNlUkZDMjgyMkRhdGVbMV07XG5cbiAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBcIlJGQyAyODIyXCIsIHRleHQpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIEhUVFAgaGVhZGVyIGRhdGVcbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvUHJvdG9jb2xzL3JmYzI2MTYvcmZjMjYxNi1zZWMzLmh0bWwjc2VjMy4zLjFcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgSFRUUCBoZWFkZXIgZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gY29udmVydCB0aGUgdGltZSB0byB0aGlzIHpvbmUuIFNpbmNlIEhUVFAgZGF0ZXMgYXJlIGFsd2F5cyBpbiBVVEMsIHRoaXMgaGFzIG5vIGVmZmVjdCBvbiB0aGUgaW50ZXJwcmV0YXRpb24gb2Ygc3RyaW5nLCBtZXJlbHkgdGhlIHpvbmUgdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpcyBleHByZXNzZWQgaW4uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIHRoZSBmaXhlZC1vZmZzZXQgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZy4gRm9yIEhUVFAgZGF0ZXMsIHRoaXMgaXMgYWx3YXlzIFVUQywgc28gdGhpcyBvcHRpb24gaXMgZXF1aXZhbGVudCB0byBzZXR0aW5nIHRoZSBgem9uZWAgb3B0aW9uIHRvICd1dGMnLCBidXQgdGhpcyBvcHRpb24gaXMgaW5jbHVkZWQgZm9yIGNvbnNpc3RlbmN5IHdpdGggc2ltaWxhciBtZXRob2RzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdzeXN0ZW0ncyBsb2NhbGUnXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSFRUUCgnU3VuLCAwNiBOb3YgMTk5NCAwODo0OTozNyBHTVQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSFRUUCgnU3VuZGF5LCAwNi1Ob3YtOTQgMDg6NDk6MzcgR01UJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUhUVFAoJ1N1biBOb3YgIDYgMDg6NDk6MzcgMTk5NCcpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgO1xuXG4gIERhdGVUaW1lLmZyb21IVFRQID0gZnVuY3Rpb24gZnJvbUhUVFAodGV4dCwgb3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgX3BhcnNlSFRUUERhdGUgPSBwYXJzZUhUVFBEYXRlKHRleHQpLFxuICAgICAgICB2YWxzID0gX3BhcnNlSFRUUERhdGVbMF0sXG4gICAgICAgIHBhcnNlZFpvbmUgPSBfcGFyc2VIVFRQRGF0ZVsxXTtcblxuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiSFRUUFwiLCBvcHRzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBpbnB1dCBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmcuXG4gICAqIERlZmF1bHRzIHRvIGVuLVVTIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHN5c3RlbSdzIGxvY2FsZS5cbiAgICogQHNlZSBodHRwczovL21vbWVudC5naXRodWIuaW8vbHV4b24vZG9jcy9tYW51YWwvcGFyc2luZy5odG1sI3RhYmxlLW9mLXRva2Vuc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgdGhlIHN0cmluZyBpcyBleHBlY3RlZCB0byBiZSBpbiAoc2VlIHRoZSBsaW5rIGJlbG93IGZvciB0aGUgZm9ybWF0cylcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIHVzZSB0aGlzIHpvbmUgaWYgbm8gb2Zmc2V0IGlzIHNwZWNpZmllZCBpbiB0aGUgaW5wdXQgc3RyaW5nIGl0c2VsZi4gV2lsbCBhbHNvIGNvbnZlcnQgdGhlIERhdGVUaW1lIHRvIHRoaXMgem9uZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSBhIGxvY2FsZSBzdHJpbmcgdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyBsb2NhbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIHRvIHRoaXMgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICA7XG5cbiAgRGF0ZVRpbWUuZnJvbUZvcm1hdCA9IGZ1bmN0aW9uIGZyb21Gb3JtYXQodGV4dCwgZm10LCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChpc1VuZGVmaW5lZCh0ZXh0KSB8fCBpc1VuZGVmaW5lZChmbXQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJmcm9tRm9ybWF0IHJlcXVpcmVzIGFuIGlucHV0IHN0cmluZyBhbmQgYSBmb3JtYXRcIik7XG4gICAgfVxuXG4gICAgdmFyIF9vcHRzID0gb3B0cyxcbiAgICAgICAgX29wdHMkbG9jYWxlID0gX29wdHMubG9jYWxlLFxuICAgICAgICBsb2NhbGUgPSBfb3B0cyRsb2NhbGUgPT09IHZvaWQgMCA/IG51bGwgOiBfb3B0cyRsb2NhbGUsXG4gICAgICAgIF9vcHRzJG51bWJlcmluZ1N5c3RlbSA9IF9vcHRzLm51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgbnVtYmVyaW5nU3lzdGVtID0gX29wdHMkbnVtYmVyaW5nU3lzdGVtID09PSB2b2lkIDAgPyBudWxsIDogX29wdHMkbnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBsb2NhbGVUb1VzZSA9IExvY2FsZS5mcm9tT3B0cyh7XG4gICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgIG51bWJlcmluZ1N5c3RlbTogbnVtYmVyaW5nU3lzdGVtLFxuICAgICAgZGVmYXVsdFRvRU46IHRydWVcbiAgICB9KSxcbiAgICAgICAgX3BhcnNlRnJvbVRva2VucyA9IHBhcnNlRnJvbVRva2Vucyhsb2NhbGVUb1VzZSwgdGV4dCwgZm10KSxcbiAgICAgICAgdmFscyA9IF9wYXJzZUZyb21Ub2tlbnNbMF0sXG4gICAgICAgIHBhcnNlZFpvbmUgPSBfcGFyc2VGcm9tVG9rZW5zWzFdLFxuICAgICAgICBpbnZhbGlkID0gX3BhcnNlRnJvbVRva2Vuc1syXTtcblxuICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgXCJmb3JtYXQgXCIgKyBmbXQsIHRleHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGZyb21Gb3JtYXQgaW5zdGVhZFxuICAgKi9cbiAgO1xuXG4gIERhdGVUaW1lLmZyb21TdHJpbmcgPSBmdW5jdGlvbiBmcm9tU3RyaW5nKHRleHQsIGZtdCwgb3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbUZvcm1hdCh0ZXh0LCBmbXQsIG9wdHMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgU1FMIGRhdGUsIHRpbWUsIG9yIGRhdGV0aW1lXG4gICAqIERlZmF1bHRzIHRvIGVuLVVTIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHN5c3RlbSdzIGxvY2FsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIHVzZSB0aGlzIHpvbmUgaWYgbm8gb2Zmc2V0IGlzIHNwZWNpZmllZCBpbiB0aGUgaW5wdXQgc3RyaW5nIGl0c2VsZi4gV2lsbCBhbHNvIGNvbnZlcnQgdGhlIERhdGVUaW1lIHRvIHRoaXMgem9uZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSBhIGxvY2FsZSBzdHJpbmcgdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyBsb2NhbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIHRvIHRoaXMgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNScpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MicpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyKzA2OjAwJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDIgQW1lcmljYS9Mb3NfQW5nZWxlcycpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyIEFtZXJpY2EvTG9zX0FuZ2VsZXMnLCB7IHNldFpvbmU6IHRydWUgfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDInLCB7IHpvbmU6ICdBbWVyaWNhL0xvc19BbmdlbGVzJyB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcwOToxMjozNC4zNDInKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIDtcblxuICBEYXRlVGltZS5mcm9tU1FMID0gZnVuY3Rpb24gZnJvbVNRTCh0ZXh0LCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfcGFyc2VTUUwgPSBwYXJzZVNRTCh0ZXh0KSxcbiAgICAgICAgdmFscyA9IF9wYXJzZVNRTFswXSxcbiAgICAgICAgcGFyc2VkWm9uZSA9IF9wYXJzZVNRTFsxXTtcblxuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiU1FMXCIsIHRleHQpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW52YWxpZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiAtIHNpbXBsZSBzdHJpbmcgb2Ygd2h5IHRoaXMgRGF0ZVRpbWUgaXMgaW52YWxpZC4gU2hvdWxkIG5vdCBjb250YWluIHBhcmFtZXRlcnMgb3IgYW55dGhpbmcgZWxzZSBkYXRhLWRlcGVuZGVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2V4cGxhbmF0aW9uPW51bGxdIC0gbG9uZ2VyIGV4cGxhbmF0aW9uLCBtYXkgaW5jbHVkZSBwYXJhbWV0ZXJzIGFuZCBvdGhlciB1c2VmdWwgZGVidWdnaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgO1xuXG4gIERhdGVUaW1lLmludmFsaWQgPSBmdW5jdGlvbiBpbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24pIHtcbiAgICBpZiAoZXhwbGFuYXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgZXhwbGFuYXRpb24gPSBudWxsO1xuICAgIH1cblxuICAgIGlmICghcmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJuZWVkIHRvIHNwZWNpZnkgYSByZWFzb24gdGhlIERhdGVUaW1lIGlzIGludmFsaWRcIik7XG4gICAgfVxuXG4gICAgdmFyIGludmFsaWQgPSByZWFzb24gaW5zdGFuY2VvZiBJbnZhbGlkID8gcmVhc29uIDogbmV3IEludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbik7XG5cbiAgICBpZiAoU2V0dGluZ3MudGhyb3dPbkludmFsaWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkRGF0ZVRpbWVFcnJvcihpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZSh7XG4gICAgICAgIGludmFsaWQ6IGludmFsaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGEgRGF0ZVRpbWUuIFdvcmtzIGFjcm9zcyBjb250ZXh0IGJvdW5kYXJpZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIDtcblxuICBEYXRlVGltZS5pc0RhdGVUaW1lID0gZnVuY3Rpb24gaXNEYXRlVGltZShvKSB7XG4gICAgcmV0dXJuIG8gJiYgby5pc0x1eG9uRGF0ZVRpbWUgfHwgZmFsc2U7XG4gIH0gLy8gSU5GT1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIHVuaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gYSB1bml0IHN1Y2ggYXMgJ21pbnV0ZScgb3IgJ2RheSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNywgNCkuZ2V0KCdtb250aCcpOyAvLz0+IDdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNywgNCkuZ2V0KCdkYXknKTsgLy89PiA0XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIDtcblxuICB2YXIgX3Byb3RvID0gRGF0ZVRpbWUucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQodW5pdCkge1xuICAgIHJldHVybiB0aGlzW3VuaXRdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIERhdGVUaW1lIGlzIHZhbGlkLiBJbnZhbGlkIERhdGVUaW1lcyBvY2N1ciB3aGVuOlxuICAgKiAqIFRoZSBEYXRlVGltZSB3YXMgY3JlYXRlZCBmcm9tIGludmFsaWQgY2FsZW5kYXIgaW5mb3JtYXRpb24sIHN1Y2ggYXMgdGhlIDEzdGggbW9udGggb3IgRmVicnVhcnkgMzBcbiAgICogKiBUaGUgRGF0ZVRpbWUgd2FzIGNyZWF0ZWQgYnkgYW4gb3BlcmF0aW9uIG9uIGFub3RoZXIgaW52YWxpZCBkYXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXNvbHZlZCBJbnRsIG9wdGlvbnMgZm9yIHRoaXMgRGF0ZVRpbWUuXG4gICAqIFRoaXMgaXMgdXNlZnVsIGluIHVuZGVyc3RhbmRpbmcgdGhlIGJlaGF2aW9yIG9mIGZvcm1hdHRpbmcgbWV0aG9kc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIHRoZSBzYW1lIG9wdGlvbnMgYXMgdG9Mb2NhbGVTdHJpbmdcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgX3Byb3RvLnJlc29sdmVkTG9jYWxlT3B0cyA9IGZ1bmN0aW9uIHJlc29sdmVkTG9jYWxlT3B0cyhvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfRm9ybWF0dGVyJGNyZWF0ZSRyZXMgPSBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLmNsb25lKG9wdHMpLCBvcHRzKS5yZXNvbHZlZE9wdGlvbnModGhpcyksXG4gICAgICAgIGxvY2FsZSA9IF9Gb3JtYXR0ZXIkY3JlYXRlJHJlcy5sb2NhbGUsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSA9IF9Gb3JtYXR0ZXIkY3JlYXRlJHJlcy5udW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIGNhbGVuZGFyID0gX0Zvcm1hdHRlciRjcmVhdGUkcmVzLmNhbGVuZGFyO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgbnVtYmVyaW5nU3lzdGVtOiBudW1iZXJpbmdTeXN0ZW0sXG4gICAgICBvdXRwdXRDYWxlbmRhcjogY2FsZW5kYXJcbiAgICB9O1xuICB9IC8vIFRSQU5TRk9STVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gVVRDLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqXG4gICAqIEVxdWl2YWxlbnQgdG8ge0BsaW5rIHNldFpvbmV9KCd1dGMnKVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldD0wXSAtIG9wdGlvbmFsbHksIGFuIG9mZnNldCBmcm9tIFVUQyBpbiBtaW51dGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cz17fV0gLSBvcHRpb25zIHRvIHBhc3MgdG8gYHNldFpvbmUoKWBcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvVVRDID0gZnVuY3Rpb24gdG9VVEMob2Zmc2V0LCBvcHRzKSB7XG4gICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXRab25lKEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShvZmZzZXQpLCBvcHRzKTtcbiAgfVxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgRGF0ZVRpbWUncyB6b25lIHRvIHRoZSBob3N0J3MgbG9jYWwgem9uZS4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKlxuICAgKiBFcXVpdmFsZW50IHRvIGBzZXRab25lKCdsb2NhbCcpYFxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9Mb2NhbCA9IGZ1bmN0aW9uIHRvTG9jYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0Wm9uZShTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gIH1cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIERhdGVUaW1lJ3Mgem9uZSB0byBzcGVjaWZpZWQgem9uZS4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgc2V0dGVyIGtlZXBzIHRoZSB1bmRlcmx5aW5nIHRpbWUgdGhlIHNhbWUgKGFzIGluLCB0aGUgc2FtZSB0aW1lc3RhbXApLCBidXQgdGhlIG5ldyBpbnN0YW5jZSB3aWxsIHJlcG9ydCBkaWZmZXJlbnQgbG9jYWwgdGltZXMgYW5kIGNvbnNpZGVyIERTVHMgd2hlbiBtYWtpbmcgY29tcHV0YXRpb25zLCBhcyB3aXRoIHtAbGluayBwbHVzfS4gWW91IG1heSB3aXNoIHRvIHVzZSB7QGxpbmsgdG9Mb2NhbH0gYW5kIHtAbGluayB0b1VUQ30gd2hpY2ggcHJvdmlkZSBzaW1wbGUgY29udmVuaWVuY2Ugd3JhcHBlcnMgZm9yIGNvbW1vbmx5IHVzZWQgem9uZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFt6b25lPSdsb2NhbCddIC0gYSB6b25lIGlkZW50aWZpZXIuIEFzIGEgc3RyaW5nLCB0aGF0IGNhbiBiZSBhbnkgSUFOQSB6b25lIHN1cHBvcnRlZCBieSB0aGUgaG9zdCBlbnZpcm9ubWVudCwgb3IgYSBmaXhlZC1vZmZzZXQgbmFtZSBvZiB0aGUgZm9ybSAnVVRDKzMnLCBvciB0aGUgc3RyaW5ncyAnbG9jYWwnIG9yICd1dGMnLiBZb3UgbWF5IGFsc28gc3VwcGx5IGFuIGluc3RhbmNlIG9mIGEge0BsaW5rIFpvbmV9IGNsYXNzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5rZWVwTG9jYWxUaW1lPWZhbHNlXSAtIElmIHRydWUsIGFkanVzdCB0aGUgdW5kZXJseWluZyB0aW1lIHNvIHRoYXQgdGhlIGxvY2FsIHRpbWUgc3RheXMgdGhlIHNhbWUsIGJ1dCBpbiB0aGUgdGFyZ2V0IHpvbmUuIFlvdSBzaG91bGQgcmFyZWx5IG5lZWQgdGhpcy5cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNldFpvbmUgPSBmdW5jdGlvbiBzZXRab25lKHpvbmUsIF90ZW1wKSB7XG4gICAgdmFyIF9yZWYzID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICAgIF9yZWYzJGtlZXBMb2NhbFRpbWUgPSBfcmVmMy5rZWVwTG9jYWxUaW1lLFxuICAgICAgICBrZWVwTG9jYWxUaW1lID0gX3JlZjMka2VlcExvY2FsVGltZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMyRrZWVwTG9jYWxUaW1lLFxuICAgICAgICBfcmVmMyRrZWVwQ2FsZW5kYXJUaW0gPSBfcmVmMy5rZWVwQ2FsZW5kYXJUaW1lLFxuICAgICAgICBrZWVwQ2FsZW5kYXJUaW1lID0gX3JlZjMka2VlcENhbGVuZGFyVGltID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYzJGtlZXBDYWxlbmRhclRpbTtcblxuICAgIHpvbmUgPSBub3JtYWxpemVab25lKHpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcblxuICAgIGlmICh6b25lLmVxdWFscyh0aGlzLnpvbmUpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgaWYgKCF6b25lLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKHVuc3VwcG9ydGVkWm9uZSh6b25lKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXdUUyA9IHRoaXMudHM7XG5cbiAgICAgIGlmIChrZWVwTG9jYWxUaW1lIHx8IGtlZXBDYWxlbmRhclRpbWUpIHtcbiAgICAgICAgdmFyIG9mZnNldEd1ZXNzID0gem9uZS5vZmZzZXQodGhpcy50cyk7XG4gICAgICAgIHZhciBhc09iaiA9IHRoaXMudG9PYmplY3QoKTtcblxuICAgICAgICB2YXIgX29ialRvVFMzID0gb2JqVG9UUyhhc09iaiwgb2Zmc2V0R3Vlc3MsIHpvbmUpO1xuXG4gICAgICAgIG5ld1RTID0gX29ialRvVFMzWzBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvbmUkMSh0aGlzLCB7XG4gICAgICAgIHRzOiBuZXdUUyxcbiAgICAgICAgem9uZTogem9uZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3Igb3V0cHV0Q2FsZW5kYXIuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLSB0aGUgcHJvcGVydGllcyB0byBzZXRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLnJlY29uZmlndXJlKHsgbG9jYWxlOiAnZW4tR0InIH0pXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZWNvbmZpZ3VyZSA9IGZ1bmN0aW9uIHJlY29uZmlndXJlKF90ZW1wMikge1xuICAgIHZhciBfcmVmNCA9IF90ZW1wMiA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDIsXG4gICAgICAgIGxvY2FsZSA9IF9yZWY0LmxvY2FsZSxcbiAgICAgICAgbnVtYmVyaW5nU3lzdGVtID0gX3JlZjQubnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBvdXRwdXRDYWxlbmRhciA9IF9yZWY0Lm91dHB1dENhbGVuZGFyO1xuXG4gICAgdmFyIGxvYyA9IHRoaXMubG9jLmNsb25lKHtcbiAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgbnVtYmVyaW5nU3lzdGVtOiBudW1iZXJpbmdTeXN0ZW0sXG4gICAgICBvdXRwdXRDYWxlbmRhcjogb3V0cHV0Q2FsZW5kYXJcbiAgICB9KTtcbiAgICByZXR1cm4gY2xvbmUkMSh0aGlzLCB7XG4gICAgICBsb2M6IGxvY1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBsb2NhbGUuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICogSnVzdCBhIGNvbnZlbmllbnQgYWxpYXMgZm9yIHJlY29uZmlndXJlKHsgbG9jYWxlIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5zZXRMb2NhbGUoJ2VuLUdCJylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNldExvY2FsZSA9IGZ1bmN0aW9uIHNldExvY2FsZShsb2NhbGUpIHtcbiAgICByZXR1cm4gdGhpcy5yZWNvbmZpZ3VyZSh7XG4gICAgICBsb2NhbGU6IGxvY2FsZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSB2YWx1ZXMgb2Ygc3BlY2lmaWVkIHVuaXRzLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqIFlvdSBjYW4gb25seSBzZXQgdW5pdHMgd2l0aCB0aGlzIG1ldGhvZDsgZm9yIFwic2V0dGluZ1wiIG1ldGFkYXRhLCBzZWUge0BsaW5rIHJlY29uZmlndXJlfSBhbmQge0BsaW5rIHNldFpvbmV9LlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gYSBtYXBwaW5nIG9mIHVuaXRzIHRvIG51bWJlcnNcbiAgICogQGV4YW1wbGUgZHQuc2V0KHsgeWVhcjogMjAxNyB9KVxuICAgKiBAZXhhbXBsZSBkdC5zZXQoeyBob3VyOiA4LCBtaW51dGU6IDMwIH0pXG4gICAqIEBleGFtcGxlIGR0LnNldCh7IHdlZWtkYXk6IDUgfSlcbiAgICogQGV4YW1wbGUgZHQuc2V0KHsgeWVhcjogMjAwNSwgb3JkaW5hbDogMjM0IH0pXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zZXQgPSBmdW5jdGlvbiBzZXQodmFsdWVzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHZhciBub3JtYWxpemVkID0gbm9ybWFsaXplT2JqZWN0KHZhbHVlcywgbm9ybWFsaXplVW5pdCwgW10pLFxuICAgICAgICBzZXR0aW5nV2Vla1N0dWZmID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQud2Vla1llYXIpIHx8ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLndlZWtOdW1iZXIpIHx8ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLndlZWtkYXkpO1xuICAgIHZhciBtaXhlZDtcblxuICAgIGlmIChzZXR0aW5nV2Vla1N0dWZmKSB7XG4gICAgICBtaXhlZCA9IHdlZWtUb0dyZWdvcmlhbihPYmplY3QuYXNzaWduKGdyZWdvcmlhblRvV2Vlayh0aGlzLmMpLCBub3JtYWxpemVkKSk7XG4gICAgfSBlbHNlIGlmICghaXNVbmRlZmluZWQobm9ybWFsaXplZC5vcmRpbmFsKSkge1xuICAgICAgbWl4ZWQgPSBvcmRpbmFsVG9HcmVnb3JpYW4oT2JqZWN0LmFzc2lnbihncmVnb3JpYW5Ub09yZGluYWwodGhpcy5jKSwgbm9ybWFsaXplZCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaXhlZCA9IE9iamVjdC5hc3NpZ24odGhpcy50b09iamVjdCgpLCBub3JtYWxpemVkKTsgLy8gaWYgd2UgZGlkbid0IHNldCB0aGUgZGF5IGJ1dCB3ZSBlbmRlZCB1cCBvbiBhbiBvdmVyZmxvdyBkYXRlLFxuICAgICAgLy8gdXNlIHRoZSBsYXN0IGRheSBvZiB0aGUgcmlnaHQgbW9udGhcblxuICAgICAgaWYgKGlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQuZGF5KSkge1xuICAgICAgICBtaXhlZC5kYXkgPSBNYXRoLm1pbihkYXlzSW5Nb250aChtaXhlZC55ZWFyLCBtaXhlZC5tb250aCksIG1peGVkLmRheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9vYmpUb1RTNCA9IG9ialRvVFMobWl4ZWQsIHRoaXMubywgdGhpcy56b25lKSxcbiAgICAgICAgdHMgPSBfb2JqVG9UUzRbMF0sXG4gICAgICAgIG8gPSBfb2JqVG9UUzRbMV07XG5cbiAgICByZXR1cm4gY2xvbmUkMSh0aGlzLCB7XG4gICAgICB0czogdHMsXG4gICAgICBvOiBvXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIHBlcmlvZCBvZiB0aW1lIHRvIHRoaXMgRGF0ZVRpbWUgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lXG4gICAqXG4gICAqIEFkZGluZyBob3VycywgbWludXRlcywgc2Vjb25kcywgb3IgbWlsbGlzZWNvbmRzIGluY3JlYXNlcyB0aGUgdGltZXN0YW1wIGJ5IHRoZSByaWdodCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLiBBZGRpbmcgZGF5cywgbW9udGhzLCBvciB5ZWFycyBzaGlmdHMgdGhlIGNhbGVuZGFyLCBhY2NvdW50aW5nIGZvciBEU1RzIGFuZCBsZWFwIHllYXJzIGFsb25nIHRoZSB3YXkuIFRodXMsIGBkdC5wbHVzKHsgaG91cnM6IDI0IH0pYCBtYXkgcmVzdWx0IGluIGEgZGlmZmVyZW50IHRpbWUgdGhhbiBgZHQucGx1cyh7IGRheXM6IDEgfSlgIGlmIHRoZXJlJ3MgYSBEU1Qgc2hpZnQgaW4gYmV0d2Vlbi5cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gYWRkLiBFaXRoZXIgYSBMdXhvbiBEdXJhdGlvbiwgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCB0aGUgb2JqZWN0IGFyZ3VtZW50IHRvIER1cmF0aW9uLmZyb21PYmplY3QoKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgpLnBsdXMoMTIzKSAvL34+IGluIDEyMyBtaWxsaXNlY29uZHNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoKS5wbHVzKHsgbWludXRlczogMTUgfSkgLy9+PiBpbiAxNSBtaW51dGVzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKCkucGx1cyh7IGRheXM6IDEgfSkgLy9+PiB0aGlzIHRpbWUgdG9tb3Jyb3dcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoKS5wbHVzKHsgZGF5czogLTEgfSkgLy9+PiB0aGlzIHRpbWUgeWVzdGVyZGF5XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKCkucGx1cyh7IGhvdXJzOiAzLCBtaW51dGVzOiAxMyB9KSAvL34+IGluIDMgaHIsIDEzIG1pblxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgpLnBsdXMoRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAzLCBtaW51dGVzOiAxMyB9KSkgLy9+PiBpbiAzIGhyLCAxMyBtaW5cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBsdXMgPSBmdW5jdGlvbiBwbHVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHZhciBkdXIgPSBmcmllbmRseUR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICByZXR1cm4gY2xvbmUkMSh0aGlzLCBhZGp1c3RUaW1lKHRoaXMsIGR1cikpO1xuICB9XG4gIC8qKlxuICAgKiBTdWJ0cmFjdCBhIHBlcmlvZCBvZiB0aW1lIHRvIHRoaXMgRGF0ZVRpbWUgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lXG4gICAqIFNlZSB7QGxpbmsgcGx1c31cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gc3VidHJhY3QuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICBAcmV0dXJuIHtEYXRlVGltZX1cbiAgKi9cbiAgO1xuXG4gIF9wcm90by5taW51cyA9IGZ1bmN0aW9uIG1pbnVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHZhciBkdXIgPSBmcmllbmRseUR1cmF0aW9uKGR1cmF0aW9uKS5uZWdhdGUoKTtcbiAgICByZXR1cm4gY2xvbmUkMSh0aGlzLCBhZGp1c3RUaW1lKHRoaXMsIGR1cikpO1xuICB9XG4gIC8qKlxuICAgKiBcIlNldFwiIHRoaXMgRGF0ZVRpbWUgdG8gdGhlIGJlZ2lubmluZyBvZiBhIHVuaXQgb2YgdGltZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBUaGUgdW5pdCB0byBnbyB0byB0aGUgYmVnaW5uaW5nIG9mLiBDYW4gYmUgJ3llYXInLCAncXVhcnRlcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCBvciAnbWlsbGlzZWNvbmQnLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5zdGFydE9mKCdtb250aCcpLnRvSVNPRGF0ZSgpOyAvLz0+ICcyMDE0LTAzLTAxJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5zdGFydE9mKCd5ZWFyJykudG9JU09EYXRlKCk7IC8vPT4gJzIwMTQtMDEtMDEnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5zdGFydE9mKCdkYXknKS50b0lTT1RpbWUoKTsgLy89PiAnMDA6MDAuMDAwLTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzLCA1LCAzMCkuc3RhcnRPZignaG91cicpLnRvSVNPVGltZSgpOyAvLz0+ICcwNTowMDowMC4wMDAtMDU6MDAnXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zdGFydE9mID0gZnVuY3Rpb24gc3RhcnRPZih1bml0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHZhciBvID0ge30sXG4gICAgICAgIG5vcm1hbGl6ZWRVbml0ID0gRHVyYXRpb24ubm9ybWFsaXplVW5pdCh1bml0KTtcblxuICAgIHN3aXRjaCAobm9ybWFsaXplZFVuaXQpIHtcbiAgICAgIGNhc2UgXCJ5ZWFyc1wiOlxuICAgICAgICBvLm1vbnRoID0gMTtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcblxuICAgICAgY2FzZSBcInF1YXJ0ZXJzXCI6XG4gICAgICBjYXNlIFwibW9udGhzXCI6XG4gICAgICAgIG8uZGF5ID0gMTtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcblxuICAgICAgY2FzZSBcIndlZWtzXCI6XG4gICAgICBjYXNlIFwiZGF5c1wiOlxuICAgICAgICBvLmhvdXIgPSAwO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuXG4gICAgICBjYXNlIFwiaG91cnNcIjpcbiAgICAgICAgby5taW51dGUgPSAwO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuXG4gICAgICBjYXNlIFwibWludXRlc1wiOlxuICAgICAgICBvLnNlY29uZCA9IDA7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG5cbiAgICAgIGNhc2UgXCJzZWNvbmRzXCI6XG4gICAgICAgIG8ubWlsbGlzZWNvbmQgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIG5vIGRlZmF1bHQsIGludmFsaWQgdW5pdHMgdGhyb3cgaW4gbm9ybWFsaXplVW5pdCgpXG4gICAgfVxuXG4gICAgaWYgKG5vcm1hbGl6ZWRVbml0ID09PSBcIndlZWtzXCIpIHtcbiAgICAgIG8ud2Vla2RheSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKG5vcm1hbGl6ZWRVbml0ID09PSBcInF1YXJ0ZXJzXCIpIHtcbiAgICAgIHZhciBxID0gTWF0aC5jZWlsKHRoaXMubW9udGggLyAzKTtcbiAgICAgIG8ubW9udGggPSAocSAtIDEpICogMyArIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2V0KG8pO1xuICB9XG4gIC8qKlxuICAgKiBcIlNldFwiIHRoaXMgRGF0ZVRpbWUgdG8gdGhlIGVuZCAobWVhbmluZyB0aGUgbGFzdCBtaWxsaXNlY29uZCkgb2YgYSB1bml0IG9mIHRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBUaGUgdW5pdCB0byBnbyB0byB0aGUgZW5kIG9mLiBDYW4gYmUgJ3llYXInLCAnbW9udGgnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsIG9yICdtaWxsaXNlY29uZCcuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLmVuZE9mKCdtb250aCcpLnRvSVNPKCk7IC8vPT4gJzIwMTQtMDMtMzFUMjM6NTk6NTkuOTk5LTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5lbmRPZigneWVhcicpLnRvSVNPKCk7IC8vPT4gJzIwMTQtMTItMzFUMjM6NTk6NTkuOTk5LTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzLCA1LCAzMCkuZW5kT2YoJ2RheScpLnRvSVNPKCk7IC8vPT4gJzIwMTQtMDMtMDNUMjM6NTk6NTkuOTk5LTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzLCA1LCAzMCkuZW5kT2YoJ2hvdXInKS50b0lTTygpOyAvLz0+ICcyMDE0LTAzLTAzVDA1OjU5OjU5Ljk5OS0wNTowMCdcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmVuZE9mID0gZnVuY3Rpb24gZW5kT2YodW5pdCkge1xuICAgIHZhciBfdGhpcyRwbHVzO1xuXG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMucGx1cygoX3RoaXMkcGx1cyA9IHt9LCBfdGhpcyRwbHVzW3VuaXRdID0gMSwgX3RoaXMkcGx1cykpLnN0YXJ0T2YodW5pdCkubWludXMoMSkgOiB0aGlzO1xuICB9IC8vIE9VVFBVVFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGZvcm1hdCBzdHJpbmcuXG4gICAqICoqWW91IG1heSBub3Qgd2FudCB0aGlzLioqIFNlZSB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9IGZvciBhIG1vcmUgZmxleGlibGUgZm9ybWF0dGluZyB0b29sLiBGb3IgYSB0YWJsZSBvZiB0b2tlbnMgYW5kIHRoZWlyIGludGVycHJldGF0aW9ucywgc2VlIFtoZXJlXShodHRwczovL21vbWVudC5naXRodWIuaW8vbHV4b24vZG9jcy9tYW51YWwvZm9ybWF0dGluZy5odG1sI3RhYmxlLW9mLXRva2VucykuXG4gICAqIERlZmF1bHRzIHRvIGVuLVVTIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHN5c3RlbSdzIGxvY2FsZS5cbiAgICogQHNlZSBodHRwczovL21vbWVudC5naXRodWIuaW8vbHV4b24vZG9jcy9tYW51YWwvZm9ybWF0dGluZy5odG1sI3RhYmxlLW9mLXRva2Vuc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCBzdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRzIHRvIG92ZXJyaWRlIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoKS50b0Zvcm1hdCgneXl5eSBMTEwgZGQnKSAvLz0+ICcyMDE3IEFwciAyMidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoKS5zZXRMb2NhbGUoJ2ZyJykudG9Gb3JtYXQoJ3l5eXkgTExMIGRkJykgLy89PiAnMjAxNyBhdnIuIDIyJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgpLnRvRm9ybWF0KCd5eXl5IExMTCBkZCcsIHsgbG9jYWxlOiBcImZyXCIgfSkgLy89PiAnMjAxNyBhdnIuIDIyJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgpLnRvRm9ybWF0KFwiSEggJ2hvdXJzIGFuZCcgbW0gJ21pbnV0ZXMnXCIpIC8vPT4gJzIwIGhvdXJzIGFuZCA1NSBtaW51dGVzJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvRm9ybWF0ID0gZnVuY3Rpb24gdG9Gb3JtYXQoZm10LCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLnJlZGVmYXVsdFRvRU4ob3B0cykpLmZvcm1hdERhdGVUaW1lRnJvbVN0cmluZyh0aGlzLCBmbXQpIDogSU5WQUxJRCQyO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbG9jYWxpemVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhpcyBkYXRlLiBBY2NlcHRzIHRoZSBzYW1lIG9wdGlvbnMgYXMgdGhlIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3IgYW5kIGFueSBwcmVzZXRzIGRlZmluZWQgYnkgTHV4b24sIHN1Y2ggYXMgYERhdGVUaW1lLkRBVEVfRlVMTGAgb3IgYERhdGVUaW1lLlRJTUVfU0lNUExFYC5cbiAgICogVGhlIGV4YWN0IGJlaGF2aW9yIG9mIHRoaXMgbWV0aG9kIGlzIGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBpbiBnZW5lcmFsIGl0IHdpbGwgcmV0dXJuIGFuIGFwcHJvcHJpYXRlIHJlcHJlc2VudGF0aW9uXG4gICAqIG9mIHRoZSBEYXRlVGltZSBpbiB0aGUgYXNzaWduZWQgbG9jYWxlLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdFxuICAgKiBAcGFyYW0gb3B0cyB7T2JqZWN0fSAtIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3Igb3B0aW9ucyBhbmQgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKCkudG9Mb2NhbGVTdHJpbmcoKTsgLy89PiA0LzIwLzIwMTdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoKS5zZXRMb2NhbGUoJ2VuLWdiJykudG9Mb2NhbGVTdHJpbmcoKTsgLy89PiAnMjAvMDQvMjAxNydcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoKS50b0xvY2FsZVN0cmluZyh7IGxvY2FsZTogJ2VuLWdiJyB9KTsgLy89PiAnMjAvMDQvMjAxNydcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFX0ZVTEwpOyAvLz0+ICdBcHJpbCAyMCwgMjAxNydcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5USU1FX1NJTVBMRSk7IC8vPT4gJzExOjMyIEFNJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVUSU1FX1NIT1JUKTsgLy89PiAnNC8yMC8yMDE3LCAxMTozMiBBTSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoKS50b0xvY2FsZVN0cmluZyh7IHdlZWtkYXk6ICdsb25nJywgbW9udGg6ICdsb25nJywgZGF5OiAnMi1kaWdpdCcgfSk7IC8vPT4gJ1RodXJzZGF5LCBBcHJpbCAyMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoKS50b0xvY2FsZVN0cmluZyh7IHdlZWtkYXk6ICdzaG9ydCcsIG1vbnRoOiAnc2hvcnQnLCBkYXk6ICcyLWRpZ2l0JywgaG91cjogJzItZGlnaXQnLCBtaW51dGU6ICcyLWRpZ2l0JyB9KTsgLy89PiAnVGh1LCBBcHIgMjAsIDExOjI3IEFNJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgpLnRvTG9jYWxlU3RyaW5nKHsgaG91cjogJzItZGlnaXQnLCBtaW51dGU6ICcyLWRpZ2l0JywgaG91cjEyOiBmYWxzZSB9KTsgLy89PiAnMTE6MzInXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZyhvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0cyA9IERBVEVfU0hPUlQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5sb2MuY2xvbmUob3B0cyksIG9wdHMpLmZvcm1hdERhdGVUaW1lKHRoaXMpIDogSU5WQUxJRCQyO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGZvcm1hdCBcInBhcnRzXCIsIG1lYW5pbmcgaW5kaXZpZHVhbCB0b2tlbnMgYWxvbmcgd2l0aCBtZXRhZGF0YS4gVGhpcyBpcyBhbGxvd3MgY2FsbGVycyB0byBwb3N0LXByb2Nlc3MgaW5kaXZpZHVhbCBzZWN0aW9ucyBvZiB0aGUgZm9ybWF0dGVkIG91dHB1dC5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXQvZm9ybWF0VG9QYXJ0c1xuICAgKiBAcGFyYW0gb3B0cyB7T2JqZWN0fSAtIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3Igb3B0aW9ucywgc2FtZSBhcyBgdG9Mb2NhbGVTdHJpbmdgLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgpLnRvTG9jYWxlUGFydHMoKTsgLy89PiBbXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAnZGF5JywgdmFsdWU6ICcyNScgfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICdsaXRlcmFsJywgdmFsdWU6ICcvJyB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ21vbnRoJywgdmFsdWU6ICcwNScgfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICdsaXRlcmFsJywgdmFsdWU6ICcvJyB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ3llYXInLCB2YWx1ZTogJzE5ODInIH1cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gXVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b0xvY2FsZVBhcnRzID0gZnVuY3Rpb24gdG9Mb2NhbGVQYXJ0cyhvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLmNsb25lKG9wdHMpLCBvcHRzKS5mb3JtYXREYXRlVGltZVBhcnRzKHRoaXMpIDogW107XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzTWlsbGlzZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc1NlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0PXRydWVdIC0gaW5jbHVkZSB0aGUgb2Zmc2V0LCBzdWNoIGFzICdaJyBvciAnLTA0OjAwJ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZm9ybWF0PSdleHRlbmRlZCddIC0gY2hvb3NlIGJldHdlZW4gdGhlIGJhc2ljIGFuZCBleHRlbmRlZCBmb3JtYXRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDE5ODIsIDUsIDI1KS50b0lTTygpIC8vPT4gJzE5ODItMDUtMjVUMDA6MDA6MDAuMDAwWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoKS50b0lTTygpIC8vPT4gJzIwMTctMDQtMjJUMjA6NDc6MDUuMzM1LTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgpLnRvSVNPKHsgaW5jbHVkZU9mZnNldDogZmFsc2UgfSkgLy89PiAnMjAxNy0wNC0yMlQyMDo0NzowNS4zMzUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKCkudG9JU08oeyBmb3JtYXQ6ICdiYXNpYycgfSkgLy89PiAnMjAxNzA0MjJUMjA0NzA1LjMzNS0wNDAwJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvSVNPID0gZnVuY3Rpb24gdG9JU08ob3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudG9JU09EYXRlKG9wdHMpICsgXCJUXCIgKyB0aGlzLnRvSVNPVGltZShvcHRzKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUncyBkYXRlIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgyLCA1LCAyNSkudG9JU09EYXRlKCkgLy89PiAnMTk4Mi0wNS0yNSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDE5ODIsIDUsIDI1KS50b0lTT0RhdGUoeyBmb3JtYXQ6ICdiYXNpYycgfSkgLy89PiAnMTk4MjA1MjUnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9JU09EYXRlID0gZnVuY3Rpb24gdG9JU09EYXRlKF90ZW1wMykge1xuICAgIHZhciBfcmVmNSA9IF90ZW1wMyA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDMsXG4gICAgICAgIF9yZWY1JGZvcm1hdCA9IF9yZWY1LmZvcm1hdCxcbiAgICAgICAgZm9ybWF0ID0gX3JlZjUkZm9ybWF0ID09PSB2b2lkIDAgPyBcImV4dGVuZGVkXCIgOiBfcmVmNSRmb3JtYXQ7XG5cbiAgICB2YXIgZm10ID0gZm9ybWF0ID09PSBcImJhc2ljXCIgPyBcInl5eXlNTWRkXCIgOiBcInl5eXktTU0tZGRcIjtcblxuICAgIGlmICh0aGlzLnllYXIgPiA5OTk5KSB7XG4gICAgICBmbXQgPSBcIitcIiArIGZtdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9UZWNoRm9ybWF0KHRoaXMsIGZtdCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lJ3Mgd2VlayBkYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgyLCA1LCAyNSkudG9JU09XZWVrRGF0ZSgpIC8vPT4gJzE5ODItVzIxLTInXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9JU09XZWVrRGF0ZSA9IGZ1bmN0aW9uIHRvSVNPV2Vla0RhdGUoKSB7XG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLCBcImtra2stJ1cnV1ctY1wiKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUncyB0aW1lIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NTZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQgfSkudG9JU09UaW1lKCkgLy89PiAnMDc6MzQ6MTkuMzYxWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkuc2V0KHsgaG91cjogNywgbWludXRlOiAzNCwgc2Vjb25kczogMCwgbWlsbGlzZWNvbmRzOiAwIH0pLnRvSVNPVGltZSh7IHN1cHByZXNzU2Vjb25kczogdHJ1ZSB9KSAvLz0+ICcwNzozNFonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQgfSkudG9JU09UaW1lKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzA3MzQxOS4zNjFaJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvSVNPVGltZSA9IGZ1bmN0aW9uIHRvSVNPVGltZShfdGVtcDQpIHtcbiAgICB2YXIgX3JlZjYgPSBfdGVtcDQgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA0LFxuICAgICAgICBfcmVmNiRzdXBwcmVzc01pbGxpc2UgPSBfcmVmNi5zdXBwcmVzc01pbGxpc2Vjb25kcyxcbiAgICAgICAgc3VwcHJlc3NNaWxsaXNlY29uZHMgPSBfcmVmNiRzdXBwcmVzc01pbGxpc2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjYkc3VwcHJlc3NNaWxsaXNlLFxuICAgICAgICBfcmVmNiRzdXBwcmVzc1NlY29uZHMgPSBfcmVmNi5zdXBwcmVzc1NlY29uZHMsXG4gICAgICAgIHN1cHByZXNzU2Vjb25kcyA9IF9yZWY2JHN1cHByZXNzU2Vjb25kcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmNiRzdXBwcmVzc1NlY29uZHMsXG4gICAgICAgIF9yZWY2JGluY2x1ZGVPZmZzZXQgPSBfcmVmNi5pbmNsdWRlT2Zmc2V0LFxuICAgICAgICBpbmNsdWRlT2Zmc2V0ID0gX3JlZjYkaW5jbHVkZU9mZnNldCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWY2JGluY2x1ZGVPZmZzZXQsXG4gICAgICAgIF9yZWY2JGZvcm1hdCA9IF9yZWY2LmZvcm1hdCxcbiAgICAgICAgZm9ybWF0ID0gX3JlZjYkZm9ybWF0ID09PSB2b2lkIDAgPyBcImV4dGVuZGVkXCIgOiBfcmVmNiRmb3JtYXQ7XG5cbiAgICByZXR1cm4gdG9UZWNoVGltZUZvcm1hdCh0aGlzLCB7XG4gICAgICBzdXBwcmVzc1NlY29uZHM6IHN1cHByZXNzU2Vjb25kcyxcbiAgICAgIHN1cHByZXNzTWlsbGlzZWNvbmRzOiBzdXBwcmVzc01pbGxpc2Vjb25kcyxcbiAgICAgIGluY2x1ZGVPZmZzZXQ6IGluY2x1ZGVPZmZzZXQsXG4gICAgICBmb3JtYXQ6IGZvcm1hdFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIFJGQyAyODIyLWNvbXBhdGlibGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUsIGFsd2F5cyBpbiBVVENcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b1JGQzI4MjIoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDAwOjAwOjAwICswMDAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCA3LCAxMykudG9SRkMyODIyKCkgLy89PiAnU3VuLCAxMyBKdWwgMjAxNCAwMDowMDowMCAtMDQwMCdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1JGQzI4MjIgPSBmdW5jdGlvbiB0b1JGQzI4MjIoKSB7XG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLCBcIkVFRSwgZGQgTExMIHl5eXkgSEg6bW06c3MgWlpaXCIsIGZhbHNlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gSFRUUCBoZWFkZXJzLlxuICAgKiBTcGVjaWZpY2FsbHksIHRoZSBzdHJpbmcgY29uZm9ybXMgdG8gUkZDIDExMjMuXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1Byb3RvY29scy9yZmMyNjE2L3JmYzI2MTYtc2VjMy5odG1sI3NlYzMuMy4xXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMykudG9IVFRQKCkgLy89PiAnU3VuLCAxMyBKdWwgMjAxNCAwMDowMDowMCBHTVQnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMywgMTkpLnRvSFRUUCgpIC8vPT4gJ1N1biwgMTMgSnVsIDIwMTQgMTk6MDA6MDAgR01UJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvSFRUUCA9IGZ1bmN0aW9uIHRvSFRUUCgpIHtcbiAgICByZXR1cm4gdG9UZWNoRm9ybWF0KHRoaXMudG9VVEMoKSwgXCJFRUUsIGRkIExMTCB5eXl5IEhIOm1tOnNzICdHTVQnXCIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBTUUwgRGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMpLnRvU1FMRGF0ZSgpIC8vPT4gJzIwMTQtMDctMTMnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TUUxEYXRlID0gZnVuY3Rpb24gdG9TUUxEYXRlKCkge1xuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcywgXCJ5eXl5LU1NLWRkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBTUUwgVGltZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlWm9uZT1mYWxzZV0gLSBpbmNsdWRlIHRoZSB6b25lLCBzdWNoIGFzICdBbWVyaWNhL05ld19Zb3JrJy4gT3ZlcnJpZGVzIGluY2x1ZGVPZmZzZXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkudG9TUUwoKSAvLz0+ICcwNToxNToxNi4zNDUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKCkudG9TUUwoKSAvLz0+ICcwNToxNToxNi4zNDUgLTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgpLnRvU1FMKHsgaW5jbHVkZU9mZnNldDogZmFsc2UgfSkgLy89PiAnMDU6MTU6MTYuMzQ1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgpLnRvU1FMKHsgaW5jbHVkZVpvbmU6IGZhbHNlIH0pIC8vPT4gJzA1OjE1OjE2LjM0NSBBbWVyaWNhL05ld19Zb3JrJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvU1FMVGltZSA9IGZ1bmN0aW9uIHRvU1FMVGltZShfdGVtcDUpIHtcbiAgICB2YXIgX3JlZjcgPSBfdGVtcDUgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA1LFxuICAgICAgICBfcmVmNyRpbmNsdWRlT2Zmc2V0ID0gX3JlZjcuaW5jbHVkZU9mZnNldCxcbiAgICAgICAgaW5jbHVkZU9mZnNldCA9IF9yZWY3JGluY2x1ZGVPZmZzZXQgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmNyRpbmNsdWRlT2Zmc2V0LFxuICAgICAgICBfcmVmNyRpbmNsdWRlWm9uZSA9IF9yZWY3LmluY2x1ZGVab25lLFxuICAgICAgICBpbmNsdWRlWm9uZSA9IF9yZWY3JGluY2x1ZGVab25lID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWY3JGluY2x1ZGVab25lO1xuXG4gICAgcmV0dXJuIHRvVGVjaFRpbWVGb3JtYXQodGhpcywge1xuICAgICAgaW5jbHVkZU9mZnNldDogaW5jbHVkZU9mZnNldCxcbiAgICAgIGluY2x1ZGVab25lOiBpbmNsdWRlWm9uZSxcbiAgICAgIHNwYWNlWm9uZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBTUUwgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZVpvbmU9ZmFsc2VdIC0gaW5jbHVkZSB0aGUgem9uZSwgc3VjaCBhcyAnQW1lcmljYS9OZXdfWW9yaycuIE92ZXJyaWRlcyBpbmNsdWRlT2Zmc2V0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXQ9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJ1onIG9yICctMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMykudG9TUUwoKSAvLz0+ICcyMDE0LTA3LTEzIDAwOjAwOjAwLjAwMCBaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCA3LCAxMykudG9TUUwoKSAvLz0+ICcyMDE0LTA3LTEzIDAwOjAwOjAwLjAwMCAtMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1NRTCh7IGluY2x1ZGVPZmZzZXQ6IGZhbHNlIH0pIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCA3LCAxMykudG9TUUwoeyBpbmNsdWRlWm9uZTogdHJ1ZSB9KSAvLz0+ICcyMDE0LTA3LTEzIDAwOjAwOjAwLjAwMCBBbWVyaWNhL05ld19Zb3JrJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvU1FMID0gZnVuY3Rpb24gdG9TUUwob3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudG9TUUxEYXRlKCkgKyBcIiBcIiArIHRoaXMudG9TUUxUaW1lKG9wdHMpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIGRlYnVnZ2luZ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudG9JU08oKSA6IElOVkFMSUQkMjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXBvY2ggbWlsbGlzZWNvbmRzIG9mIHRoaXMgRGF0ZVRpbWUuIEFsaWFzIG9mIHtAbGluayB0b01pbGxpc31cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by52YWx1ZU9mID0gZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICByZXR1cm4gdGhpcy50b01pbGxpcygpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcG9jaCBtaWxsaXNlY29uZHMgb2YgdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b01pbGxpcyA9IGZ1bmN0aW9uIHRvTWlsbGlzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRzIDogTmFOO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcG9jaCBzZWNvbmRzIG9mIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TZWNvbmRzID0gZnVuY3Rpb24gdG9TZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRzIC8gMTAwMCA6IE5hTjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gSlNPTi5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9JU08oKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIEJTT04gc2VyaWFsaXphYmxlIGVxdWl2YWxlbnQgdG8gdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7RGF0ZX1cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9CU09OID0gZnVuY3Rpb24gdG9CU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvSlNEYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKYXZhc2NyaXB0IG9iamVjdCB3aXRoIHRoaXMgRGF0ZVRpbWUncyB5ZWFyLCBtb250aCwgZGF5LCBhbmQgc28gb24uXG4gICAqIEBwYXJhbSBvcHRzIC0gb3B0aW9ucyBmb3IgZ2VuZXJhdGluZyB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZUNvbmZpZz1mYWxzZV0gLSBpbmNsdWRlIGNvbmZpZ3VyYXRpb24gYXR0cmlidXRlcyBpbiB0aGUgb3V0cHV0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKCkudG9PYmplY3QoKSAvLz0+IHsgeWVhcjogMjAxNywgbW9udGg6IDQsIGRheTogMjIsIGhvdXI6IDIwLCBtaW51dGU6IDQ5LCBzZWNvbmQ6IDQyLCBtaWxsaXNlY29uZDogMjY4IH1cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB7fTtcbiAgICB2YXIgYmFzZSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYyk7XG5cbiAgICBpZiAob3B0cy5pbmNsdWRlQ29uZmlnKSB7XG4gICAgICBiYXNlLm91dHB1dENhbGVuZGFyID0gdGhpcy5vdXRwdXRDYWxlbmRhcjtcbiAgICAgIGJhc2UubnVtYmVyaW5nU3lzdGVtID0gdGhpcy5sb2MubnVtYmVyaW5nU3lzdGVtO1xuICAgICAgYmFzZS5sb2NhbGUgPSB0aGlzLmxvYy5sb2NhbGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKYXZhc2NyaXB0IERhdGUgZXF1aXZhbGVudCB0byB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtEYXRlfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b0pTRGF0ZSA9IGZ1bmN0aW9uIHRvSlNEYXRlKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLmlzVmFsaWQgPyB0aGlzLnRzIDogTmFOKTtcbiAgfSAvLyBDT01QQVJFXG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBEYXRlVGltZXMgYXMgYSBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXJEYXRlVGltZSAtIHRoZSBEYXRlVGltZSB0byBjb21wYXJlIHRoaXMgb25lIHRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbdW5pdD1bJ21pbGxpc2Vjb25kcyddXSAtIHRoZSB1bml0IG9yIGFycmF5IG9mIHVuaXRzIChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byBpbmNsdWRlIGluIHRoZSBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBjcmVhdGlvbiBvZiB0aGUgRHVyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBpMSA9IERhdGVUaW1lLmZyb21JU08oJzE5ODItMDUtMjVUMDk6NDUnKSxcbiAgICogICAgIGkyID0gRGF0ZVRpbWUuZnJvbUlTTygnMTk4My0xMC0xNFQxMDozMCcpO1xuICAgKiBpMi5kaWZmKGkxKS50b09iamVjdCgpIC8vPT4geyBtaWxsaXNlY29uZHM6IDQzODA3NTAwMDAwIH1cbiAgICogaTIuZGlmZihpMSwgJ2hvdXJzJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDEyMTY4Ljc1IH1cbiAgICogaTIuZGlmZihpMSwgWydtb250aHMnLCAnZGF5cyddKS50b09iamVjdCgpIC8vPT4geyBtb250aHM6IDE2LCBkYXlzOiAxOS4wMzEyNSB9XG4gICAqIGkyLmRpZmYoaTEsIFsnbW9udGhzJywgJ2RheXMnLCAnaG91cnMnXSkudG9PYmplY3QoKSAvLz0+IHsgbW9udGhzOiAxNiwgZGF5czogMTksIGhvdXJzOiAwLjc1IH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRpZmYgPSBmdW5jdGlvbiBkaWZmKG90aGVyRGF0ZVRpbWUsIHVuaXQsIG9wdHMpIHtcbiAgICBpZiAodW5pdCA9PT0gdm9pZCAwKSB7XG4gICAgICB1bml0ID0gXCJtaWxsaXNlY29uZHNcIjtcbiAgICB9XG5cbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgIW90aGVyRGF0ZVRpbWUuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQodGhpcy5pbnZhbGlkIHx8IG90aGVyRGF0ZVRpbWUuaW52YWxpZCwgXCJjcmVhdGVkIGJ5IGRpZmZpbmcgYW4gaW52YWxpZCBEYXRlVGltZVwiKTtcbiAgICB9XG5cbiAgICB2YXIgZHVyT3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZSxcbiAgICAgIG51bWJlcmluZ1N5c3RlbTogdGhpcy5udW1iZXJpbmdTeXN0ZW1cbiAgICB9LCBvcHRzKTtcblxuICAgIHZhciB1bml0cyA9IG1heWJlQXJyYXkodW5pdCkubWFwKER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQpLFxuICAgICAgICBvdGhlcklzTGF0ZXIgPSBvdGhlckRhdGVUaW1lLnZhbHVlT2YoKSA+IHRoaXMudmFsdWVPZigpLFxuICAgICAgICBlYXJsaWVyID0gb3RoZXJJc0xhdGVyID8gdGhpcyA6IG90aGVyRGF0ZVRpbWUsXG4gICAgICAgIGxhdGVyID0gb3RoZXJJc0xhdGVyID8gb3RoZXJEYXRlVGltZSA6IHRoaXMsXG4gICAgICAgIGRpZmZlZCA9IF9kaWZmKGVhcmxpZXIsIGxhdGVyLCB1bml0cywgZHVyT3B0cyk7XG5cbiAgICByZXR1cm4gb3RoZXJJc0xhdGVyID8gZGlmZmVkLm5lZ2F0ZSgpIDogZGlmZmVkO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGlzIERhdGVUaW1lIGFuZCByaWdodCBub3cuXG4gICAqIFNlZSB7QGxpbmsgZGlmZn1cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFt1bml0PVsnbWlsbGlzZWNvbmRzJ11dIC0gdGhlIHVuaXQgb3IgdW5pdHMgdW5pdHMgKHN1Y2ggYXMgJ2hvdXJzJyBvciAnZGF5cycpIHRvIGluY2x1ZGUgaW4gdGhlIGR1cmF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgY3JlYXRpb24gb2YgdGhlIER1cmF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGlmZk5vdyA9IGZ1bmN0aW9uIGRpZmZOb3codW5pdCwgb3B0cykge1xuICAgIGlmICh1bml0ID09PSB2b2lkIDApIHtcbiAgICAgIHVuaXQgPSBcIm1pbGxpc2Vjb25kc1wiO1xuICAgIH1cblxuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kaWZmKERhdGVUaW1lLmxvY2FsKCksIHVuaXQsIG9wdHMpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gSW50ZXJ2YWwgc3Bhbm5pbmcgYmV0d2VlbiB0aGlzIERhdGVUaW1lIGFuZCBhbm90aGVyIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IG90aGVyRGF0ZVRpbWUgLSB0aGUgb3RoZXIgZW5kIHBvaW50IG9mIHRoZSBJbnRlcnZhbFxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIDtcblxuICBfcHJvdG8udW50aWwgPSBmdW5jdGlvbiB1bnRpbChvdGhlckRhdGVUaW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEludGVydmFsLmZyb21EYXRlVGltZXModGhpcywgb3RoZXJEYXRlVGltZSkgOiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIERhdGVUaW1lIGlzIGluIHRoZSBzYW1lIHVuaXQgb2YgdGltZSBhcyBhbm90aGVyIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IG90aGVyRGF0ZVRpbWUgLSB0aGUgb3RoZXIgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSB0aGUgdW5pdCBvZiB0aW1lIHRvIGNoZWNrIHNhbWVuZXNzIG9uXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKCkuaGFzU2FtZShvdGhlckRULCAnZGF5Jyk7IC8vfj4gdHJ1ZSBpZiBib3RoIHRoZSBzYW1lIGNhbGVuZGFyIGRheVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5oYXNTYW1lID0gZnVuY3Rpb24gaGFzU2FtZShvdGhlckRhdGVUaW1lLCB1bml0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcblxuICAgIGlmICh1bml0ID09PSBcIm1pbGxpc2Vjb25kXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA9PT0gb3RoZXJEYXRlVGltZS52YWx1ZU9mKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpbnB1dE1zID0gb3RoZXJEYXRlVGltZS52YWx1ZU9mKCk7XG4gICAgICByZXR1cm4gdGhpcy5zdGFydE9mKHVuaXQpIDw9IGlucHV0TXMgJiYgaW5wdXRNcyA8PSB0aGlzLmVuZE9mKHVuaXQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRXF1YWxpdHkgY2hlY2tcbiAgICogVHdvIERhdGVUaW1lcyBhcmUgZXF1YWwgaWZmIHRoZXkgcmVwcmVzZW50IHRoZSBzYW1lIG1pbGxpc2Vjb25kLCBoYXZlIHRoZSBzYW1lIHpvbmUgYW5kIGxvY2F0aW9uLCBhbmQgYXJlIGJvdGggdmFsaWQuXG4gICAqIFRvIGNvbXBhcmUganVzdCB0aGUgbWlsbGlzZWNvbmQgdmFsdWVzLCB1c2UgYCtkdDEgPT09ICtkdDJgLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBvdGhlciAtIHRoZSBvdGhlciBEYXRlVGltZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkICYmIG90aGVyLmlzVmFsaWQgJiYgdGhpcy52YWx1ZU9mKCkgPT09IG90aGVyLnZhbHVlT2YoKSAmJiB0aGlzLnpvbmUuZXF1YWxzKG90aGVyLnpvbmUpICYmIHRoaXMubG9jLmVxdWFscyhvdGhlci5sb2MpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdGhpcyB0aW1lIHJlbGF0aXZlIHRvIG5vdywgc3VjaCBhcyBcImluIHR3byBkYXlzXCIuIENhbiBvbmx5IGludGVybmF0aW9uYWxpemUgaWYgeW91clxuICAgKiBwbGF0Zm9ybSBzdXBwb3J0cyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdC4gUm91bmRzIGRvd24gYnkgZGVmYXVsdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBvdXRwdXRcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gW29wdGlvbnMuYmFzZT1EYXRlVGltZS5sb2NhbCgpXSAtIHRoZSBEYXRlVGltZSB0byB1c2UgYXMgdGhlIGJhc2lzIHRvIHdoaWNoIHRoaXMgdGltZSBpcyBjb21wYXJlZC4gRGVmYXVsdHMgdG8gbm93LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3R5bGU9XCJsb25nXCJdIC0gdGhlIHN0eWxlIG9mIHVuaXRzLCBtdXN0IGJlIFwibG9uZ1wiLCBcInNob3J0XCIsIG9yIFwibmFycm93XCJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudW5pdCAtIHVzZSBhIHNwZWNpZmljIHVuaXQ7IGlmIG9taXR0ZWQsIHRoZSBtZXRob2Qgd2lsbCBwaWNrIHRoZSB1bml0LiBVc2Ugb25lIG9mIFwieWVhcnNcIiwgXCJxdWFydGVyc1wiLCBcIm1vbnRoc1wiLCBcIndlZWtzXCIsIFwiZGF5c1wiLCBcImhvdXJzXCIsIFwibWludXRlc1wiLCBvciBcInNlY29uZHNcIlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJvdW5kPXRydWVdIC0gd2hldGhlciB0byByb3VuZCB0aGUgbnVtYmVycyBpbiB0aGUgb3V0cHV0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnBhZGRpbmc9MF0gLSBwYWRkaW5nIGluIG1pbGxpc2Vjb25kcy4gVGhpcyBhbGxvd3MgeW91IHRvIHJvdW5kIHVwIHRoZSByZXN1bHQgaWYgaXQgZml0cyBpbnNpZGUgdGhlIHRocmVzaG9sZC4gRG9uJ3QgdXNlIGluIGNvbWJpbmF0aW9uIHdpdGgge3JvdW5kOiBmYWxzZX0gYmVjYXVzZSB0aGUgZGVjaW1hbCBvdXRwdXQgd2lsbCBpbmNsdWRlIHRoZSBwYWRkaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sb2NhbGUgLSBvdmVycmlkZSB0aGUgbG9jYWxlIG9mIHRoaXMgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gb3ZlcnJpZGUgdGhlIG51bWJlcmluZ1N5c3RlbSBvZiB0aGlzIERhdGVUaW1lLiBUaGUgSW50bCBzeXN0ZW0gbWF5IGNob29zZSBub3QgdG8gaG9ub3IgdGhpc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmUoKSAvLz0+IFwiaW4gMSBkYXlcIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgpLnNldExvY2FsZShcImVzXCIpLnRvUmVsYXRpdmUoeyBkYXlzOiAxIH0pIC8vPT4gXCJkZW50cm8gZGUgMSBkw61hXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlKHsgbG9jYWxlOiBcImZyXCIgfSkgLy89PiBcImRhbnMgMjMgaGV1cmVzXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoKS5taW51cyh7IGRheXM6IDIgfSkudG9SZWxhdGl2ZSgpIC8vPT4gXCIyIGRheXMgYWdvXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoKS5taW51cyh7IGRheXM6IDIgfSkudG9SZWxhdGl2ZSh7IHVuaXQ6IFwiaG91cnNcIiB9KSAvLz0+IFwiNDggaG91cnMgYWdvXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoKS5taW51cyh7IGhvdXJzOiAzNiB9KS50b1JlbGF0aXZlKHsgcm91bmQ6IGZhbHNlIH0pIC8vPT4gXCIxLjUgZGF5cyBhZ29cIlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1JlbGF0aXZlID0gZnVuY3Rpb24gdG9SZWxhdGl2ZShvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgYmFzZSA9IG9wdGlvbnMuYmFzZSB8fCBEYXRlVGltZS5mcm9tT2JqZWN0KHtcbiAgICAgIHpvbmU6IHRoaXMuem9uZVxuICAgIH0pLFxuICAgICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nID8gdGhpcyA8IGJhc2UgPyAtb3B0aW9ucy5wYWRkaW5nIDogb3B0aW9ucy5wYWRkaW5nIDogMDtcbiAgICByZXR1cm4gZGlmZlJlbGF0aXZlKGJhc2UsIHRoaXMucGx1cyhwYWRkaW5nKSwgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7XG4gICAgICBudW1lcmljOiBcImFsd2F5c1wiLFxuICAgICAgdW5pdHM6IFtcInllYXJzXCIsIFwibW9udGhzXCIsIFwiZGF5c1wiLCBcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIl1cbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBkYXRlIHJlbGF0aXZlIHRvIHRvZGF5LCBzdWNoIGFzIFwieWVzdGVyZGF5XCIgb3IgXCJuZXh0IG1vbnRoXCIuXG4gICAqIE9ubHkgaW50ZXJuYXRpb25hbGl6ZXMgb24gcGxhdGZvcm1zIHRoYXQgc3VwcG9ydHMgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgb3V0cHV0XG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IFtvcHRpb25zLmJhc2U9RGF0ZVRpbWUubG9jYWwoKV0gLSB0aGUgRGF0ZVRpbWUgdG8gdXNlIGFzIHRoZSBiYXNpcyB0byB3aGljaCB0aGlzIHRpbWUgaXMgY29tcGFyZWQuIERlZmF1bHRzIHRvIG5vdy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubG9jYWxlIC0gb3ZlcnJpZGUgdGhlIGxvY2FsZSBvZiB0aGlzIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnVuaXQgLSB1c2UgYSBzcGVjaWZpYyB1bml0OyBpZiBvbWl0dGVkLCB0aGUgbWV0aG9kIHdpbGwgcGljayB0aGUgdW5pdC4gVXNlIG9uZSBvZiBcInllYXJzXCIsIFwicXVhcnRlcnNcIiwgXCJtb250aHNcIiwgXCJ3ZWVrc1wiLCBvciBcImRheXNcIlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0gLSBvdmVycmlkZSB0aGUgbnVtYmVyaW5nU3lzdGVtIG9mIHRoaXMgRGF0ZVRpbWUuIFRoZSBJbnRsIHN5c3RlbSBtYXkgY2hvb3NlIG5vdCB0byBob25vciB0aGlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZUNhbGVuZGFyKCkgLy89PiBcInRvbW9ycm93XCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoKS5zZXRMb2NhbGUoXCJlc1wiKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlKCkgLy89PiBcIlwibWHDsWFuYVwiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZUNhbGVuZGFyKHsgbG9jYWxlOiBcImZyXCIgfSkgLy89PiBcImRlbWFpblwiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKCkubWludXMoeyBkYXlzOiAyIH0pLnRvUmVsYXRpdmVDYWxlbmRhcigpIC8vPT4gXCIyIGRheXMgYWdvXCJcbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9SZWxhdGl2ZUNhbGVuZGFyID0gZnVuY3Rpb24gdG9SZWxhdGl2ZUNhbGVuZGFyKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBkaWZmUmVsYXRpdmUob3B0aW9ucy5iYXNlIHx8IERhdGVUaW1lLmZyb21PYmplY3Qoe1xuICAgICAgem9uZTogdGhpcy56b25lXG4gICAgfSksIHRoaXMsIE9iamVjdC5hc3NpZ24ob3B0aW9ucywge1xuICAgICAgbnVtZXJpYzogXCJhdXRvXCIsXG4gICAgICB1bml0czogW1wieWVhcnNcIiwgXCJtb250aHNcIiwgXCJkYXlzXCJdLFxuICAgICAgY2FsZW5kYXJ5OiB0cnVlXG4gICAgfSkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG1pbiBvZiBzZXZlcmFsIGRhdGUgdGltZXNcbiAgICogQHBhcmFtIHsuLi5EYXRlVGltZX0gZGF0ZVRpbWVzIC0gdGhlIERhdGVUaW1lcyBmcm9tIHdoaWNoIHRvIGNob29zZSB0aGUgbWluaW11bVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX0gdGhlIG1pbiBEYXRlVGltZSwgb3IgdW5kZWZpbmVkIGlmIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50XG4gICAqL1xuICA7XG5cbiAgRGF0ZVRpbWUubWluID0gZnVuY3Rpb24gbWluKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBkYXRlVGltZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBkYXRlVGltZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaWYgKCFkYXRlVGltZXMuZXZlcnkoRGF0ZVRpbWUuaXNEYXRlVGltZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm1pbiByZXF1aXJlcyBhbGwgYXJndW1lbnRzIGJlIERhdGVUaW1lc1wiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmVzdEJ5KGRhdGVUaW1lcywgZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBpLnZhbHVlT2YoKTtcbiAgICB9LCBNYXRoLm1pbik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWF4IG9mIHNldmVyYWwgZGF0ZSB0aW1lc1xuICAgKiBAcGFyYW0gey4uLkRhdGVUaW1lfSBkYXRlVGltZXMgLSB0aGUgRGF0ZVRpbWVzIGZyb20gd2hpY2ggdG8gY2hvb3NlIHRoZSBtYXhpbXVtXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfSB0aGUgbWF4IERhdGVUaW1lLCBvciB1bmRlZmluZWQgaWYgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRcbiAgICovXG4gIDtcblxuICBEYXRlVGltZS5tYXggPSBmdW5jdGlvbiBtYXgoKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBkYXRlVGltZXMgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGRhdGVUaW1lc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIGlmICghZGF0ZVRpbWVzLmV2ZXJ5KERhdGVUaW1lLmlzRGF0ZVRpbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJtYXggcmVxdWlyZXMgYWxsIGFyZ3VtZW50cyBiZSBEYXRlVGltZXNcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJlc3RCeShkYXRlVGltZXMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gaS52YWx1ZU9mKCk7XG4gICAgfSwgTWF0aC5tYXgpO1xuICB9IC8vIE1JU0NcblxuICAvKipcbiAgICogRXhwbGFpbiBob3cgYSBzdHJpbmcgd291bGQgYmUgcGFyc2VkIGJ5IGZyb21Gb3JtYXQoKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgdGhlIHN0cmluZyBpcyBleHBlY3RlZCB0byBiZSBpbiAoc2VlIGRlc2NyaXB0aW9uKVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdGFrZW4gYnkgZnJvbUZvcm1hdCgpXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIDtcblxuICBEYXRlVGltZS5mcm9tRm9ybWF0RXhwbGFpbiA9IGZ1bmN0aW9uIGZyb21Gb3JtYXRFeHBsYWluKHRleHQsIGZtdCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgICBfb3B0aW9ucyRsb2NhbGUgPSBfb3B0aW9ucy5sb2NhbGUsXG4gICAgICAgIGxvY2FsZSA9IF9vcHRpb25zJGxvY2FsZSA9PT0gdm9pZCAwID8gbnVsbCA6IF9vcHRpb25zJGxvY2FsZSxcbiAgICAgICAgX29wdGlvbnMkbnVtYmVyaW5nU3lzID0gX29wdGlvbnMubnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBudW1iZXJpbmdTeXN0ZW0gPSBfb3B0aW9ucyRudW1iZXJpbmdTeXMgPT09IHZvaWQgMCA/IG51bGwgOiBfb3B0aW9ucyRudW1iZXJpbmdTeXMsXG4gICAgICAgIGxvY2FsZVRvVXNlID0gTG9jYWxlLmZyb21PcHRzKHtcbiAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgbnVtYmVyaW5nU3lzdGVtOiBudW1iZXJpbmdTeXN0ZW0sXG4gICAgICBkZWZhdWx0VG9FTjogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBleHBsYWluRnJvbVRva2Vucyhsb2NhbGVUb1VzZSwgdGV4dCwgZm10KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGZyb21Gb3JtYXRFeHBsYWluIGluc3RlYWRcbiAgICovXG4gIDtcblxuICBEYXRlVGltZS5mcm9tU3RyaW5nRXhwbGFpbiA9IGZ1bmN0aW9uIGZyb21TdHJpbmdFeHBsYWluKHRleHQsIGZtdCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbUZvcm1hdEV4cGxhaW4odGV4dCwgZm10LCBvcHRpb25zKTtcbiAgfSAvLyBGT1JNQVQgUFJFU0VUU1xuXG4gIC8qKlxuICAgKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlIDEwLzE0LzE5ODNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIDtcblxuICBfY3JlYXRlQ2xhc3MoRGF0ZVRpbWUsIFt7XG4gICAga2V5OiBcImlzVmFsaWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmludmFsaWQgPT09IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gZXJyb3IgY29kZSBpZiB0aGlzIERhdGVUaW1lIGlzIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIERhdGVUaW1lIGlzIHZhbGlkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImludmFsaWRSZWFzb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQucmVhc29uIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBEYXRlVGltZSBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgRGF0ZVRpbWUgaXMgdmFsaWRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW52YWxpZEV4cGxhbmF0aW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLmV4cGxhbmF0aW9uIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsb2NhbGUgb2YgYSBEYXRlVGltZSwgc3VjaCAnZW4tR0InLiBUaGUgbG9jYWxlIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEYXRlVGltZVxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxvY2FsZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLmxvY2FsZSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbnVtYmVyaW5nIHN5c3RlbSBvZiBhIERhdGVUaW1lLCBzdWNoICdiZW5nJy4gVGhlIG51bWJlcmluZyBzeXN0ZW0gaXMgdXNlZCB3aGVuIGZvcm1hdHRpbmcgdGhlIERhdGVUaW1lXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibnVtYmVyaW5nU3lzdGVtXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubnVtYmVyaW5nU3lzdGVtIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBvdXRwdXQgY2FsZW5kYXIgb2YgYSBEYXRlVGltZSwgc3VjaCAnaXNsYW1pYycuIFRoZSBvdXRwdXQgY2FsZW5kYXIgaXMgdXNlZCB3aGVuIGZvcm1hdHRpbmcgdGhlIERhdGVUaW1lXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib3V0cHV0Q2FsZW5kYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmxvYy5vdXRwdXRDYWxlbmRhciA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdGltZSB6b25lIGFzc29jaWF0ZWQgd2l0aCB0aGlzIERhdGVUaW1lLlxuICAgICAqIEB0eXBlIHtab25lfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiem9uZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3pvbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgdGltZSB6b25lLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ6b25lTmFtZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuem9uZS5uYW1lIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB5ZWFyXG4gICAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLnllYXIgLy89PiAyMDE3XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInllYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMueWVhciA6IE5hTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBxdWFydGVyXG4gICAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLnF1YXJ0ZXIgLy89PiAyXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInF1YXJ0ZXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBNYXRoLmNlaWwodGhpcy5jLm1vbnRoIC8gMykgOiBOYU47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbW9udGggKDEtMTIpLlxuICAgICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5tb250aCAvLz0+IDVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMubW9udGggOiBOYU47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGF5IG9mIHRoZSBtb250aCAoMS0zMGlzaCkuXG4gICAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLmRheSAvLz0+IDI1XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRheVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5kYXkgOiBOYU47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaG91ciBvZiB0aGUgZGF5ICgwLTIzKS5cbiAgICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSkuaG91ciAvLz0+IDlcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaG91clwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5ob3VyIDogTmFOO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG1pbnV0ZSBvZiB0aGUgaG91ciAoMC01OSkuXG4gICAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUsIDksIDMwKS5taW51dGUgLy89PiAzMFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtaW51dGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMubWludXRlIDogTmFOO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHNlY29uZCBvZiB0aGUgbWludXRlICgwLTU5KS5cbiAgICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSwgMzAsIDUyKS5zZWNvbmQgLy89PiA1MlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZWNvbmRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMuc2Vjb25kIDogTmFOO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQgKDAtOTk5KS5cbiAgICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSwgMzAsIDUyLCA2NTQpLm1pbGxpc2Vjb25kIC8vPT4gNjU0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1pbGxpc2Vjb25kXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLm1pbGxpc2Vjb25kIDogTmFOO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHdlZWsgeWVhclxuICAgICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDExLCAzMSkud2Vla1llYXIgLy89PiAyMDE1XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndlZWtZZWFyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gcG9zc2libHlDYWNoZWRXZWVrRGF0YSh0aGlzKS53ZWVrWWVhciA6IE5hTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB3ZWVrIG51bWJlciBvZiB0aGUgd2VlayB5ZWFyICgxLTUyaXNoKS5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAgICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkud2Vla051bWJlciAvLz0+IDIxXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndlZWtOdW1iZXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKHRoaXMpLndlZWtOdW1iZXIgOiBOYU47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAqIDEgaXMgTW9uZGF5IGFuZCA3IGlzIFN1bmRheVxuICAgICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDExLCAzMSkud2Vla2RheSAvLz0+IDRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2Vla2RheVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHBvc3NpYmx5Q2FjaGVkV2Vla0RhdGEodGhpcykud2Vla2RheSA6IE5hTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBvcmRpbmFsIChtZWFuaW5nIHRoZSBkYXkgb2YgdGhlIHllYXIpXG4gICAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLm9yZGluYWwgLy89PiAxNDVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfERhdGVUaW1lfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib3JkaW5hbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IGdyZWdvcmlhblRvT3JkaW5hbCh0aGlzLmMpLm9yZGluYWwgOiBOYU47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgc2hvcnQgbW9udGggbmFtZSwgc3VjaCBhcyAnT2N0Jy5cbiAgICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAxMCwgMzApLm1vbnRoU2hvcnQgLy89PiBPY3RcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhTaG9ydFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEluZm8ubW9udGhzKFwic2hvcnRcIiwge1xuICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlXG4gICAgICB9KVt0aGlzLm1vbnRoIC0gMV0gOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGh1bWFuIHJlYWRhYmxlIGxvbmcgbW9udGggbmFtZSwgc3VjaCBhcyAnT2N0b2JlcicuXG4gICAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMTAsIDMwKS5tb250aExvbmcgLy89PiBPY3RvYmVyXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1vbnRoTG9uZ1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEluZm8ubW9udGhzKFwibG9uZ1wiLCB7XG4gICAgICAgIGxvY2FsZTogdGhpcy5sb2NhbGVcbiAgICAgIH0pW3RoaXMubW9udGggLSAxXSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgc2hvcnQgd2Vla2RheSwgc3VjaCBhcyAnTW9uJy5cbiAgICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAxMCwgMzApLndlZWtkYXlTaG9ydCAvLz0+IE1vblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3ZWVrZGF5U2hvcnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLndlZWtkYXlzKFwic2hvcnRcIiwge1xuICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlXG4gICAgICB9KVt0aGlzLndlZWtkYXkgLSAxXSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgbG9uZyB3ZWVrZGF5LCBzdWNoIGFzICdNb25kYXknLlxuICAgICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDEwLCAzMCkud2Vla2RheUxvbmcgLy89PiBNb25kYXlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2Vla2RheUxvbmdcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLndlZWtkYXlzKFwibG9uZ1wiLCB7XG4gICAgICAgIGxvY2FsZTogdGhpcy5sb2NhbGVcbiAgICAgIH0pW3RoaXMud2Vla2RheSAtIDFdIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBVVEMgb2Zmc2V0IG9mIHRoaXMgRGF0ZVRpbWUgaW4gbWludXRlc1xuICAgICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKCkub2Zmc2V0IC8vPT4gLTI0MFxuICAgICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLm9mZnNldCAvLz0+IDBcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib2Zmc2V0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gK3RoaXMubyA6IE5hTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzaG9ydCBodW1hbiBuYW1lIGZvciB0aGUgem9uZSdzIGN1cnJlbnQgb2Zmc2V0LCBmb3IgZXhhbXBsZSBcIkVTVFwiIG9yIFwiRURUXCIuXG4gICAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9mZnNldE5hbWVTaG9ydFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKHRoaXMuaXNWYWxpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy56b25lLm9mZnNldE5hbWUodGhpcy50cywge1xuICAgICAgICAgIGZvcm1hdDogXCJzaG9ydFwiLFxuICAgICAgICAgIGxvY2FsZTogdGhpcy5sb2NhbGVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsb25nIGh1bWFuIG5hbWUgZm9yIHRoZSB6b25lJ3MgY3VycmVudCBvZmZzZXQsIGZvciBleGFtcGxlIFwiRWFzdGVybiBTdGFuZGFyZCBUaW1lXCIgb3IgXCJFYXN0ZXJuIERheWxpZ2h0IFRpbWVcIi5cbiAgICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib2Zmc2V0TmFtZUxvbmdcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICh0aGlzLmlzVmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuem9uZS5vZmZzZXROYW1lKHRoaXMudHMsIHtcbiAgICAgICAgICBmb3JtYXQ6IFwibG9uZ1wiLFxuICAgICAgICAgIGxvY2FsZTogdGhpcy5sb2NhbGVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHdoZXRoZXIgdGhpcyB6b25lJ3Mgb2Zmc2V0IGV2ZXIgY2hhbmdlcywgYXMgaW4gYSBEU1QuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc09mZnNldEZpeGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy56b25lLnVuaXZlcnNhbCA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB3aGV0aGVyIHRoZSBEYXRlVGltZSBpcyBpbiBhIERTVC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzSW5EU1RcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICh0aGlzLmlzT2Zmc2V0Rml4ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0ID4gdGhpcy5zZXQoe1xuICAgICAgICAgIG1vbnRoOiAxXG4gICAgICAgIH0pLm9mZnNldCB8fCB0aGlzLm9mZnNldCA+IHRoaXMuc2V0KHtcbiAgICAgICAgICBtb250aDogNVxuICAgICAgICB9KS5vZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIERhdGVUaW1lIGlzIGluIGEgbGVhcCB5ZWFyLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE2KS5pc0luTGVhcFllYXIgLy89PiB0cnVlXG4gICAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxMykuaXNJbkxlYXBZZWFyIC8vPT4gZmFsc2VcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzSW5MZWFwWWVhclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRheXMgaW4gdGhpcyBEYXRlVGltZSdzIG1vbnRoXG4gICAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNiwgMikuZGF5c0luTW9udGggLy89PiAyOVxuICAgICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYsIDMpLmRheXNJbk1vbnRoIC8vPT4gMzFcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5c0luTW9udGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIsIHRoaXMubW9udGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGlzIERhdGVUaW1lJ3MgeWVhclxuICAgICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYpLmRheXNJblllYXIgLy89PiAzNjZcbiAgICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDEzKS5kYXlzSW5ZZWFyIC8vPT4gMzY1XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRheXNJblllYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBkYXlzSW5ZZWFyKHRoaXMueWVhcikgOiBOYU47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB3ZWVrcyBpbiB0aGlzIERhdGVUaW1lJ3MgeWVhclxuICAgICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMDQpLndlZWtzSW5XZWVrWWVhciAvLz0+IDUzXG4gICAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxMykud2Vla3NJbldlZWtZZWFyIC8vPT4gNTJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2Vla3NJbldlZWtZZWFyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gd2Vla3NJbldlZWtZZWFyKHRoaXMud2Vla1llYXIpIDogTmFOO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcIkRBVEVfU0hPUlRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBEQVRFX1NIT1JUO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3QgMTQsIDE5ODMnXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIkRBVEVfTUVEXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gREFURV9NRUQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayB0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ0ZyaSwgT2N0IDE0LCAxOTgzJ1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJEQVRFX01FRF9XSVRIX1dFRUtEQVlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBEQVRFX01FRF9XSVRIX1dFRUtEQVk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayB0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdG9iZXIgMTQsIDE5ODMnXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIkRBVEVfRlVMTFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIERBVEVfRlVMTDtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnVHVlc2RheSwgT2N0b2JlciAxNCwgMTk4MydcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiREFURV9IVUdFXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gREFURV9IVUdFO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJUSU1FX1NJTVBMRVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFRJTUVfU0lNUExFO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJUSU1FX1dJVEhfU0VDT05EU1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFRJTUVfV0lUSF9TRUNPTkRTO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBBTSBFRFQnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiVElNRV9XSVRIX1NIT1JUX09GRlNFVFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFRJTUVfV0lUSF9TSE9SVF9PRkZTRVQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayB0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJUSU1FX1dJVEhfTE9OR19PRkZTRVRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBUSU1FX1dJVEhfTE9OR19PRkZTRVQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayB0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwJywgYWx3YXlzIDI0LWhvdXIuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIlRJTUVfMjRfU0lNUExFXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gVElNRV8yNF9TSU1QTEU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayB0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzJywgYWx3YXlzIDI0LWhvdXIuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIlRJTUVfMjRfV0lUSF9TRUNPTkRTXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gVElNRV8yNF9XSVRIX1NFQ09ORFM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayB0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEVEVCcsIGFsd2F5cyAyNC1ob3VyLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJUSU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVDtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgRWFzdGVybiBEYXlsaWdodCBUaW1lJywgYWx3YXlzIDI0LWhvdXIuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIlRJTUVfMjRfV0lUSF9MT05HX09GRlNFVFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFRJTUVfMjRfV0lUSF9MT05HX09GRlNFVDtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMTAvMTQvMTk4MywgOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJEQVRFVElNRV9TSE9SVFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIERBVEVUSU1FX1NIT1JUO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcxMC8xNC8xOTgzLCA5OjMwOjMzIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIkRBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EU1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIERBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUztcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0IDE0LCAxOTgzLCA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIkRBVEVUSU1FX01FRFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIERBVEVUSU1FX01FRDtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0IDE0LCAxOTgzLCA5OjMwOjMzIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIkRBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBEQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdGcmksIDE0IE9jdCAxOTgzLCA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIkRBVEVUSU1FX01FRF9XSVRIX1dFRUtEQVlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBEQVRFVElNRV9NRURfV0lUSF9XRUVLREFZO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3RvYmVyIDE0LCAxOTgzLCA5OjMwIEFNIEVEVCcuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJEQVRFVElNRV9GVUxMXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gREFURVRJTUVfRlVMTDtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0b2JlciAxNCwgMTk4MywgOTozMDozMyBBTSBFRFQnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBEQVRFVElNRV9GVUxMX1dJVEhfU0VDT05EUztcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpZGF5LCBPY3RvYmVyIDE0LCAxOTgzLCA5OjMwIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJEQVRFVElNRV9IVUdFXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gREFURVRJTUVfSFVHRTtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpZGF5LCBPY3RvYmVyIDE0LCAxOTgzLCA5OjMwOjMzIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJEQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EU1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIERBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEYXRlVGltZTtcbn0oKTtcbmZ1bmN0aW9uIGZyaWVuZGx5RGF0ZVRpbWUoZGF0ZVRpbWVpc2gpIHtcbiAgaWYgKERhdGVUaW1lLmlzRGF0ZVRpbWUoZGF0ZVRpbWVpc2gpKSB7XG4gICAgcmV0dXJuIGRhdGVUaW1laXNoO1xuICB9IGVsc2UgaWYgKGRhdGVUaW1laXNoICYmIGRhdGVUaW1laXNoLnZhbHVlT2YgJiYgaXNOdW1iZXIoZGF0ZVRpbWVpc2gudmFsdWVPZigpKSkge1xuICAgIHJldHVybiBEYXRlVGltZS5mcm9tSlNEYXRlKGRhdGVUaW1laXNoKTtcbiAgfSBlbHNlIGlmIChkYXRlVGltZWlzaCAmJiB0eXBlb2YgZGF0ZVRpbWVpc2ggPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbU9iamVjdChkYXRlVGltZWlzaCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiVW5rbm93biBkYXRldGltZSBhcmd1bWVudDogXCIgKyBkYXRlVGltZWlzaCArIFwiLCBvZiB0eXBlIFwiICsgdHlwZW9mIGRhdGVUaW1laXNoKTtcbiAgfVxufVxuXG5leHBvcnRzLkRhdGVUaW1lID0gRGF0ZVRpbWU7XG5leHBvcnRzLkR1cmF0aW9uID0gRHVyYXRpb247XG5leHBvcnRzLkZpeGVkT2Zmc2V0Wm9uZSA9IEZpeGVkT2Zmc2V0Wm9uZTtcbmV4cG9ydHMuSUFOQVpvbmUgPSBJQU5BWm9uZTtcbmV4cG9ydHMuSW5mbyA9IEluZm87XG5leHBvcnRzLkludGVydmFsID0gSW50ZXJ2YWw7XG5leHBvcnRzLkludmFsaWRab25lID0gSW52YWxpZFpvbmU7XG5leHBvcnRzLkxvY2FsWm9uZSA9IExvY2FsWm9uZTtcbmV4cG9ydHMuU2V0dGluZ3MgPSBTZXR0aW5ncztcbmV4cG9ydHMuWm9uZSA9IFpvbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sdXhvbi5qcy5tYXBcbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBnbG9iYWwsIGRlZmluZSwgU3lzdGVtLCBSZWZsZWN0LCBQcm9taXNlICovXHJcbnZhciBfX2V4dGVuZHM7XHJcbnZhciBfX2Fzc2lnbjtcclxudmFyIF9fcmVzdDtcclxudmFyIF9fZGVjb3JhdGU7XHJcbnZhciBfX3BhcmFtO1xyXG52YXIgX19tZXRhZGF0YTtcclxudmFyIF9fYXdhaXRlcjtcclxudmFyIF9fZ2VuZXJhdG9yO1xyXG52YXIgX19leHBvcnRTdGFyO1xyXG52YXIgX192YWx1ZXM7XHJcbnZhciBfX3JlYWQ7XHJcbnZhciBfX3NwcmVhZDtcclxudmFyIF9fc3ByZWFkQXJyYXlzO1xyXG52YXIgX19zcHJlYWRBcnJheTtcclxudmFyIF9fYXdhaXQ7XHJcbnZhciBfX2FzeW5jR2VuZXJhdG9yO1xyXG52YXIgX19hc3luY0RlbGVnYXRvcjtcclxudmFyIF9fYXN5bmNWYWx1ZXM7XHJcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdDtcclxudmFyIF9faW1wb3J0U3RhcjtcclxudmFyIF9faW1wb3J0RGVmYXVsdDtcclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQ7XHJcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0O1xyXG52YXIgX19jcmVhdGVCaW5kaW5nO1xyXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIHZhciByb290ID0gdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHR5cGVvZiB0aGlzID09PSBcIm9iamVjdFwiID8gdGhpcyA6IHt9O1xyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFwidHNsaWJcIiwgW1wiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKGV4cG9ydHMpIHsgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihleHBvcnRzKSkpOyB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihtb2R1bGUuZXhwb3J0cykpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlRXhwb3J0ZXIoZXhwb3J0cywgcHJldmlvdXMpIHtcclxuICAgICAgICBpZiAoZXhwb3J0cyAhPT0gcm9vdCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGlkLCB2KSB7IHJldHVybiBleHBvcnRzW2lkXSA9IHByZXZpb3VzID8gcHJldmlvdXMoaWQsIHYpIDogdjsgfTtcclxuICAgIH1cclxufSlcclxuKGZ1bmN0aW9uIChleHBvcnRlcikge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuXHJcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcblxyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3Jlc3QgPSBmdW5jdGlvbiAocywgZSkge1xyXG4gICAgICAgIHZhciB0ID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZGVjb3JhdGUgPSBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgICAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgICAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3BhcmFtID0gZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX21ldGFkYXRhID0gZnVuY3Rpb24gKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxuICAgIH07XHJcblxyXG4gICAgX19hd2FpdGVyID0gZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZ2VuZXJhdG9yID0gZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgICAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgX19leHBvcnRTdGFyID0gZnVuY3Rpb24obSwgbykge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIF9fY3JlYXRlQmluZGluZyhvLCBtLCBwKTtcclxuICAgIH07XHJcblxyXG4gICAgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG4gICAgfSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgICAgIG9bazJdID0gbVtrXTtcclxuICAgIH0pO1xyXG5cclxuICAgIF9fdmFsdWVzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3JlYWQgPSBmdW5jdGlvbiAobywgbikge1xyXG4gICAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgICAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xyXG4gICAgX19zcHJlYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xyXG4gICAgX19zcHJlYWRBcnJheXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3NwcmVhZEFycmF5ID0gZnVuY3Rpb24gKHRvLCBmcm9tKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXHJcbiAgICAgICAgICAgIHRvW2pdID0gZnJvbVtpXTtcclxuICAgICAgICByZXR1cm4gdG87XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXdhaXQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jR2VuZXJhdG9yID0gZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgICAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgIH1cclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY0RlbGVnYXRvciA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgdmFyIGksIHA7XHJcbiAgICAgICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNWYWx1ZXMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgICAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19tYWtlVGVtcGxhdGVPYmplY3QgPSBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcclxuICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgICAgIHJldHVybiBjb29rZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbiAgICB9KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbiAgICB9O1xyXG5cclxuICAgIF9faW1wb3J0U3RhciA9IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2ltcG9ydERlZmF1bHQgPSBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICAgICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbiAgICB9O1xyXG5cclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSBmdW5jdGlvbiAocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcclxuICAgICAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcclxuICAgIH07XHJcblxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9IGZ1bmN0aW9uIChyZWNlaXZlciwgcHJpdmF0ZU1hcCwgdmFsdWUpIHtcclxuICAgICAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJpdmF0ZU1hcC5zZXQocmVjZWl2ZXIsIHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydGVyKFwiX19leHRlbmRzXCIsIF9fZXh0ZW5kcyk7XHJcbiAgICBleHBvcnRlcihcIl9fYXNzaWduXCIsIF9fYXNzaWduKTtcclxuICAgIGV4cG9ydGVyKFwiX19yZXN0XCIsIF9fcmVzdCk7XHJcbiAgICBleHBvcnRlcihcIl9fZGVjb3JhdGVcIiwgX19kZWNvcmF0ZSk7XHJcbiAgICBleHBvcnRlcihcIl9fcGFyYW1cIiwgX19wYXJhbSk7XHJcbiAgICBleHBvcnRlcihcIl9fbWV0YWRhdGFcIiwgX19tZXRhZGF0YSk7XHJcbiAgICBleHBvcnRlcihcIl9fYXdhaXRlclwiLCBfX2F3YWl0ZXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2dlbmVyYXRvclwiLCBfX2dlbmVyYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fZXhwb3J0U3RhclwiLCBfX2V4cG9ydFN0YXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2NyZWF0ZUJpbmRpbmdcIiwgX19jcmVhdGVCaW5kaW5nKTtcclxuICAgIGV4cG9ydGVyKFwiX192YWx1ZXNcIiwgX192YWx1ZXMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3JlYWRcIiwgX19yZWFkKTtcclxuICAgIGV4cG9ydGVyKFwiX19zcHJlYWRcIiwgX19zcHJlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3NwcmVhZEFycmF5c1wiLCBfX3NwcmVhZEFycmF5cyk7XHJcbiAgICBleHBvcnRlcihcIl9fc3ByZWFkQXJyYXlcIiwgX19zcHJlYWRBcnJheSk7XHJcbiAgICBleHBvcnRlcihcIl9fYXdhaXRcIiwgX19hd2FpdCk7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNHZW5lcmF0b3JcIiwgX19hc3luY0dlbmVyYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNEZWxlZ2F0b3JcIiwgX19hc3luY0RlbGVnYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNWYWx1ZXNcIiwgX19hc3luY1ZhbHVlcyk7XHJcbiAgICBleHBvcnRlcihcIl9fbWFrZVRlbXBsYXRlT2JqZWN0XCIsIF9fbWFrZVRlbXBsYXRlT2JqZWN0KTtcclxuICAgIGV4cG9ydGVyKFwiX19pbXBvcnRTdGFyXCIsIF9faW1wb3J0U3Rhcik7XHJcbiAgICBleHBvcnRlcihcIl9faW1wb3J0RGVmYXVsdFwiLCBfX2ltcG9ydERlZmF1bHQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0XCIsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0XCIsIF9fY2xhc3NQcml2YXRlRmllbGRTZXQpO1xyXG59KTtcclxuIl19
